<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">

<meta name="google-site-verification" content="jgw73iXouBAJcOuff0yi9vdSNDecBSOUXacsHJszpmo" />
<meta name="baidu-site-verification" content="xyf9WD2vvl" />











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/apple-icon-57x57.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_body":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="002. Add Two NumbersDescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. A">
<meta name="keywords" content="算法刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题(Medium)">
<meta property="og:url" content="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-2/index.html">
<meta property="og:site_name" content="从零开始的BLOG">
<meta property="og:description" content="002. Add Two NumbersDescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. A">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1ft6j20hd08kzki.jpg">
<meta property="og:image" content="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1afaj20ge08dwep.jpg">
<meta property="og:image" content="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1khnj20ie06b3yh.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw0kh84zz9j20gh085dg5.jpg">
<meta property="og:updated_time" content="2018-11-26T00:17:48.308Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode算法题(Medium)">
<meta name="twitter:description" content="002. Add Two NumbersDescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. A">
<meta name="twitter:image" content="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg">






  <link rel="canonical" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>LeetCode算法题(Medium) | 从零开始的BLOG</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?21a4899cc63d3c11a3d90ac58074a19c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">194</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-计算机视觉">
    <a href="/categories/计算机视觉/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tripadvisor"></i> <br />计算机视觉</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-深度学习">
    <a href="/categories/深度学习/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-drupal"></i> <br />深度学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-caffe2">
    <a href="/categories/Caffe2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />Caffe2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-pytorch">
    <a href="/categories/PyTorch/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-free-code-camp"></i> <br />PyTorch</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">
    <a href="/categories/Cpp/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />C++</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-python">
    <a href="/categories/Python/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-product-hunt"></i> <br />Python</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-linux">
    <a href="/categories/Linux/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-linux"></i> <br />Linux</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-项目">
    <a href="/categories/项目/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-connectdevelop"></i> <br />项目</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-cuda">
    <a href="/categories/CUDA/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-braille"></i> <br />CUDA</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-面试">
    <a href="/categories/面试/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-address-card"></i> <br />面试</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-其它">
    <a href="/categories/其它/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />其它</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">34</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />站内搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="站内搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/hellozhaozheng" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZeroZone">
      <meta itemprop="description" content="并不是什么厉害的地方<br>只是一个安静的学习角落">
      <meta itemprop="image" content="/images/avatar_zz.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode算法题(Medium)
              
            
          </h1>
        

        <div class="post-meta">
	
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-02 08:54:58" itemprop="dateCreated datePublished" datetime="2018-10-02T08:54:58+08:00">2018-10-02</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">115k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:45</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="002-Add-Two-Numbers"><a href="#002-Add-Two-Numbers" class="headerlink" title="002. Add Two Numbers"></a>002. Add Two Numbers</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
<h2 id="解法一-顺序相加-注意进位"><a href="#解法一-顺序相加-注意进位" class="headerlink" title="解法一: 顺序相加, 注意进位"></a>解法一: 顺序相加, 注意进位</h2><p>从链表的第一个节点开始, 将两个节点的值和进位位想加, 如果大于10, 则当前结果节点的值对10取余, 同时将进位位置1, 如果小于10, 则直接赋值给当前结果节点, 同时将进位位置0.</p>
<p>特别注意l1和l2的长度问题, 当二者节点遇到nullptr时, 将较长的剩余部分重新赋给l1, 并继续判断</p>
<p>最后, 需要注意是否有进位位, 如果有, 则要申请一个新节点, 并将其置为1</p>
<p>时间复杂度: $O(\max(m,n))$</p>
<p>空间复杂度: $O(1)$  (这种做法会破坏原有链的结构)</p>
<p>空间复杂度: $O(\max(m,n))$  (这种做法需要额外申请空间, 但不会破坏原有链的结构)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//创建指向最终结果的头指针</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>)  head-&gt;next = l1; <span class="comment">// 虽然题目指明为非空链表, 但是最好还是做一下判断</span></span><br><span class="line">        <span class="keyword">else</span> head-&gt;next = l2;</span><br><span class="line">        ListNode* pre=head; <span class="comment">// pre用于保存l1的上一个指针</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            l1-&gt;val = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next; l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>)&#123; <span class="comment">// 此时说明l2比l1长, 用l1的上一个指针指向当前l2剩余的部分,</span></span><br><span class="line">            l1 = pre;</span><br><span class="line">            l1-&gt;next =  l2;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>)&#123;  <span class="comment">// 此时l1为剩余(l1或l2) 的部分,  只需要考虑是否有进位即可</span></span><br><span class="line">            l1-&gt;val = l1-&gt;val + carry;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;  <span class="comment">// 如果没有进位, 一定要将此处置0, 否则会引起错误</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;  <span class="comment">// 对应 999 + 001 的特殊情况,  此时进位会不断传递, 最终数字位数加1, 最高位为1</span></span><br><span class="line">            ListNode* newnode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            l1 = pre;</span><br><span class="line">            l1-&gt;next = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>What if the the digits in the linked list are stored in non-reversed order? For example:</p>
<p>$(3 \to 4 \to 2) + (4 \to 6 \to 5) = 8 \to 0 \to 7 (3→4→2)+(4→6→5)=8→0→7$</p>
<p>思路:</p>
<p>先将链表转置 , 再用上面的方法求解</p>
<p>转置时间复杂度: $O(n)$<br>转置空间复杂度: $O(1)$</p>
<h1 id="003-Longest-Substring-Without-Repeating-Characters"><a href="#003-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="003. Longest Substring Without Repeating Characters"></a>003. Longest Substring Without Repeating Characters</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1:</p>
<p>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3.<br>Example 2:</p>
<p>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.<br>Example 3:</p>
<p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<h2 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一:暴力"></a>解法一:暴力</h2><p>时间复杂度: $O(n^3)$ 对于每一个字符, 子串的添加以及查重过程时间复杂度为 $O(n^2)$ , 总共n个字符, 所以为 $O(n^3)$</p>
<p>时间复杂度: $O(min(n,m))$ 需要将当前子串存在起来以便查询是否相等, n为字符串length, m为字符集size</p>
<h2 id="解法二-前后两个指示变量"><a href="#解法二-前后两个指示变量" class="headerlink" title="解法二: 前后两个指示变量"></a>解法二: 前后两个指示变量</h2><p>思路: 首先构造一个哈希表, 用来存储当前子串中出现的字符, 这样, 新来的字符可以直接查询哈希表来判断字符是否存在, 构建哈希表空间复杂度为 <script type="math/tex">O(min(n,m))</script> (m为字符集合的大小,一般为26(字母), 128(ASCII), 256(ASCII))</p>
<p>然后, 使用两个指示变量, 分别指向当前未重复子串的首字符, 和超尾字符, 进行如下几个判断:</p>
<ul>
<li>如果超尾字符与当前子串中的字符不重复, 那么将超尾字符加入到当前子串中,并将length加1</li>
<li>如果超尾字符与当前子串中的字符重复, 利用哈希表查的重复字符的所在位置, 将当前子串的首字符直接跳向该重复字符的下一个位置( <strong>这样可以保证只遍历一遍</strong> ), 并将包括重复字符在内的之前所有字符都从哈希表中删除(之前的字符不再可能组成更长的子串了), 同时将超尾字符加入, length赋予新值: 超尾位置-重复位置-1;</li>
<li>判断首字符与超尾字符是否相等, 如果相等, 将超尾字符加1, 并将length置为1</li>
<li>看当前length是否比maxlength大, 并重复以上过程,直到超尾字符超出size</li>
</ul>
<p>时间复杂度: $O(n)$<br>空间复杂度: $O(min(n,m))$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; ch_exists;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        ch_exists.insert(&#123;s[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>,j = <span class="number">1</span> ; j &lt; s.size() ; )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ch_exists.count(s[j]) == <span class="number">0</span> )&#123; <span class="comment">// j对应的字母未重复, length增加</span></span><br><span class="line">                length++;</span><br><span class="line">                ch_exists.insert(&#123;s[j], j&#125;);</span><br><span class="line"></span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// j对应的字母重复, 将i置于重复字母的下一个(因为之前都都不可能产生更长的未重复子串了)</span></span><br><span class="line">                <span class="keyword">int</span> index = ch_exists[s[j]];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= index; k++)</span><br><span class="line">                    ch_exists.erase(s[k]);</span><br><span class="line">                i=index + <span class="number">1</span>;</span><br><span class="line">                ch_exists.insert(&#123;s[i], i&#125;);</span><br><span class="line">                length = j - index - <span class="number">1</span>;                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i==j)&#123; <span class="comment">//这里如果写在开头, j++之后有可能超过size, 导致有问题,</span></span><br><span class="line">                <span class="comment">//所以写在后面, 以便在for循环中检查j是否超过size</span></span><br><span class="line">                j++;</span><br><span class="line">                length = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(length &gt; max_length)</span><br><span class="line">                max_length = length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二的另一种写法"><a href="#解法二的另一种写法" class="headerlink" title="解法二的另一种写法"></a>解法二的另一种写法</h2><p>该写法核心思路与上面的一样, 所以时间复杂度和空间复杂度也一样, 唯一不同的是hash表, 前面的会将i与重复字符之间的都删除, 这里不删除, 利用max控制, 使i永远不会倒退</p>
<p><strong>这里写法更加简洁, 应值得学习</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; s_hash;      </span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ,j=<span class="number">0</span> ; j&lt; s.size() ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_hash.count(s[j]))&#123;</span><br><span class="line">                i = max(i,s_hash[s[j]]+<span class="number">1</span>); <span class="comment">//如果遇到重复的, 就将当前的i指向重复的下一个</span></span><br><span class="line">                <span class="comment">// (这里用max的原因是, 没有删除当前i到重复字符之间的其他字符, 这些字符</span></span><br><span class="line">                <span class="comment">//  后续还可能被检测到,  所以这里只取max的, 也就是i不会倒退)</span></span><br><span class="line">                s_hash.erase(s[j]); <span class="comment">// 将重复的删除, 以便赋予新的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            s_hash.insert(&#123;s[j], j&#125;);</span><br><span class="line">            max_length = max_length &gt; (j-i+<span class="number">1</span>) ? max_length : (j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="005-Longest-Palindromic-Substring-最大回文子串"><a href="#005-Longest-Palindromic-Substring-最大回文子串" class="headerlink" title="005. Longest Palindromic Substring(最大回文子串)"></a>005. Longest Palindromic Substring(最大回文子串)</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:</p>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.<br>Example 2:</p>
<p>Input: “cbbd”<br>Output: “bb”</p>
<h2 id="解法一：最长公共子串"><a href="#解法一：最长公共子串" class="headerlink" title="解法一：最长公共子串"></a>解法一：最长公共子串</h2><p>$O(n^2)$</p>
<p>$O(n)$</p>
<h2 id="解法二：-穷举"><a href="#解法二：-穷举" class="headerlink" title="解法二： 穷举"></a>解法二： 穷举</h2><p>$O(n^3)$</p>
<p>$O(1)$</p>
<h2 id="解法三：-动态规划"><a href="#解法三：-动态规划" class="headerlink" title="解法三： 动态规划"></a>解法三： 动态规划</h2><p>？</p>
<h2 id="解法三：-扩展中心法"><a href="#解法三：-扩展中心法" class="headerlink" title="解法三： 扩展中心法"></a>解法三： 扩展中心法</h2><p>以每一个字符为中心， 向两边扩展， 将当前能够扩展的长度 len 和最大扩展长度 max_len 作比较, 记录较大者, 同时记录较大者的所对应的重心字符的下标 max_index. 最后, 根据最大扩展的长度max_len 和中心字符的下标 max_index 计算最大回文子串的开始位置和总长度</p>
<p>此处注意, 回文子串有奇偶两种情况, 可采用以下举措之一解决:</p>
<ul>
<li>分别检查奇数和偶数的情况</li>
<li>向字符内插入特殊符号 ‘#’, 这样不管偶数奇数, 都可以当做奇数处理, 缺点是占用了额外的 $O(n)$ 空间</li>
</ul>
<p>时间复杂度: $O(n^2)$</p>
<p>空间复杂度: $O(1)$ 或者 $O(n)$</p>
<p>注意: 既然已经使用了空间复杂度为 $O(n)$ 的方法, 实际上更应该将其该写成马拉车算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(1)$</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> left=i, right = i;  <span class="comment">//通过left和right , 是的对奇偶的分别处理更方便</span></span><br><span class="line">            <span class="keyword">while</span>( left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len1 = right-left<span class="number">-1</span>; <span class="comment">// 注意, 这里一定是-1, 而不是+1</span></span><br><span class="line"></span><br><span class="line">            left=i;</span><br><span class="line">            right=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len2 = right-left<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;max_len)&#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                start = i- (len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(n)$</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>*  cs = <span class="keyword">new</span> <span class="keyword">char</span>[s.size() * <span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        cs[<span class="number">0</span>]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size() ; i++)&#123; <span class="comment">//插入 '#'</span></span><br><span class="line">            cs[i*<span class="number">2</span>+<span class="number">1</span>] = s[i];</span><br><span class="line">            cs[i*<span class="number">2</span>+<span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size()*<span class="number">2</span>+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>; <span class="comment">//记录当前扩展长度len</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i-j&gt;=<span class="number">0</span> &amp;&amp; i+j&lt;s.size()*<span class="number">2</span>+<span class="number">1</span> ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cs[i-j] == cs[i+j])&#123; <span class="comment">//两边字符若相等, 则len长度增1</span></span><br><span class="line">                    len++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; max_len)&#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = (max_index - max_len)/<span class="number">2</span>;  <span class="comment">//根据maxlen和index 计算回文子串开始坐标</span></span><br><span class="line">        <span class="keyword">int</span> len = max_len;</span><br><span class="line">        <span class="keyword">delete</span> cs;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法五-马拉车-Manacher-算法"><a href="#解法五-马拉车-Manacher-算法" class="headerlink" title="解法五: 马拉车(Manacher) 算法"></a>解法五: 马拉车(Manacher) 算法</h2><p>时间复杂度: $O(n)$<br>空间复杂度: $O(n)$</p>
<p>There is even an O(n)O(n) algorithm called Manacher’s algorithm, explained here in detail. However, it is a non-trivial algorithm, and no one expects you to come up with this algorithm in a 45 minutes coding session. But, please go ahead and understand it, I promise it will be a lot of fun</p>
<p>马拉车算法的核心思想还是从中心扩展发出发, 不过他必须使用 ‘#’ 字符先对原始字符串插入, 如下所示:</p>
<p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg" alt=""></p>
<p>接下来, 在每一次for循环当中, 都需要保存这么几个值(命名是个人习惯, 可以用其他名字代替):</p>
<ul>
<li>P: P为最大右边界下标值, 对应的是所有已检测的回文子串中, 右边界下标最大的那个</li>
<li>P_center: 该值是P对应的回文子串的中心下标</li>
<li>max_len: 对应当前最大回文子串的半径(aba的半径为1, a的半径为0)</li>
<li>max_index: 对应当前最大回文子串的中心下标</li>
</ul>
<p>然后, 还需要构建一个和插入’#’后的字符串长度相关的数组<code>p_len</code>, 里面存放着对应位置的回文串半径, 用以后续的计算, 这一步是关键, 有了这个数组 ,才能实现利用之前计算结果</p>
<p>接下来, 遍历 “新字符串”(即插入’#’之后的字符串) 的每一个字符, 设当前下标为 i, 则有如下情况, 分别处理:</p>
<ul>
<li>P&gt;i, 说明 i 在 P 的范围内, 可以利用前面的计算结果</li>
<li>P&lt;=i, 说明i不在 P 的范围内, 无法利用前面的计算结果, 只能逐个判断</li>
</ul>
<p>对上面两种情况具体分析如下:</p>
<p>第一种情况: P&gt;i</p>
<p>找到i相对于 P_center 的对称位置，设为j，那么如果Len[j]&lt;P-i, 如下图所示:</p>
<p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1ft6j20hd08kzki.jpg" alt=""></p>
<p> 则以i为中心的回文串的长度至少和以j为中心的回文串一样 , 即Len [i]&gt;=Len[j] , 因此可以直接从Len[j]+1开始判断回文</p>
<p>如果Len[j]&gt;=P-i, 如下图所示:</p>
<p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1afaj20ge08dwep.jpg" alt=""></p>
<p>由对称性，说明以i为中心的回文串可能会延伸到P之外，而大于P的部分我们还没有进行匹配，所以要从P+1位置开始一个一个进行匹配，直到发生失配</p>
<p>第二种情况: P&lt;=i</p>
<p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1khnj20ie06b3yh.jpg" alt=""></p>
<p>如果i比P还要大，说明对于中点为i的回文串还一点都没有匹配，这个时候，就只能老老实实地一个一个匹配了</p>
<p>在这一次循环完成之前, 更新上面提及的四个变量</p>
<p>循环结束后, 根据 max_index 和 max_len 的值返回最长回文子串</p>
<p>时间复杂度分析:</p>
<p>对于每一个字符, 由于如果之间比较过, 那么就可以利用之前比较的结果直接判断, 所以每个字符都只进行了一次比较, 故而时间复杂度为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cs_size = s.size()*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* cs = <span class="keyword">new</span> <span class="keyword">char</span>[cs_size];</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size(); i++)&#123;</span><br><span class="line">            cs[i*<span class="number">2</span> + <span class="number">1</span>] = s[i];</span><br><span class="line">            cs[i*<span class="number">2</span> + <span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> P = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> P_center = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>* p_len = <span class="keyword">new</span> <span class="keyword">int</span>[cs_size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;cs_size; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i &lt; P)&#123; <span class="comment">// 如果i&lt;P, 说明可以复用前面的计算结果</span></span><br><span class="line">                <span class="keyword">int</span> j = P_center*<span class="number">2</span> - i; <span class="comment">// j对i关于P_center的对称点</span></span><br><span class="line">                <span class="keyword">if</span>(P-i &gt; p_len[j])&#123; <span class="comment">// 如果i与P之间的距离比 j 的回文串长度还大,</span></span><br><span class="line">                    <span class="comment">//说明可以直接从p_len[j] + 1开始比较, 之前的子串一定是回文串</span></span><br><span class="line">                    <span class="keyword">int</span> k = p_len[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果距离没有p_len[j] + 1大, 则从超出P的部分开始比较</span></span><br><span class="line">                    <span class="keyword">int</span> k = P - i;</span><br><span class="line">                    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果i不在P范围内, 则必须从1开始逐个比较, 无法利用之前的计算结果</span></span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p_len[i] &gt; max_len)&#123;</span><br><span class="line">                max_len = p_len[i];</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+p_len[i] &gt; P)&#123;</span><br><span class="line">                P = i+p_len[i];</span><br><span class="line">                P_center = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> cs;</span><br><span class="line">        <span class="keyword">delete</span> p_len;</span><br><span class="line">        <span class="keyword">int</span> start = (max_index - max_len)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len = max_len;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="008"><a href="#008" class="headerlink" title="008."></a>008.</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>此题时间复杂度为 $O(n)$ , 重点考察是否考虑的全面, 主要有以下几种情况, 缺一不可:</p>
<ul>
<li>+123 dd   // 返回123</li>
<li>+123d   // 返回123</li>
<li>d-123  // 返回0</li>
<li>-123+ //返回-123</li>
<li>-123+4 // 返回-123</li>
<li>323123423423423 // 返回INT_MAX</li>
<li>-1231238923894234 // 返回INT_MIN</li>
<li>1234-5 // 返回1234</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_first = <span class="literal">true</span>; <span class="comment">//记录当前非数字字符是否是第一个非空格字符, 如果是, 返回0</span></span><br><span class="line">        <span class="keyword">bool</span> has_sign = <span class="literal">false</span>; <span class="comment">// 记录正负号的出现次数, 出现多于1次的, 返回0</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;  <span class="comment">//记录当前的int值, 要出现int范围, 返回对应的INT</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;str.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span> &amp;&amp; is_first) <span class="keyword">continue</span>; <span class="comment">// 空格, 且没有出现任何非空格字符(如出现了, 则空格也会跟着变成循环停止的标志)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( !has_sign &amp;&amp; (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) )&#123; <span class="comment">// 判断符号</span></span><br><span class="line">                has_sign = <span class="literal">true</span>;</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                sign = str[i]==<span class="string">'+'</span> ? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt;= <span class="string">'9'</span> &amp;&amp; str[i] &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">                has_sign = <span class="literal">true</span>;</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                res = res*<span class="number">10</span> + <span class="keyword">int</span>(str[i] - <span class="string">'0'</span>) * sign; <span class="comment">// 数字累加, 注意这里使用了sign, 因此无需在后面判断正负, 直接加就可以</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> INT_MAX; <span class="comment">// 超限</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(is_first)&#123;  <span class="comment">//首字符为非法字符, 返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="011-Container-With-Most-Water"><a href="#011-Container-With-Most-Water" class="headerlink" title="011. Container With Most Water"></a>011. Container With Most Water</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<p>The below vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw0kh84zz9j20gh085dg5.jpg" alt=""></p>
<h2 id="解法一-暴力-1"><a href="#解法一-暴力-1" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p>时间复杂度: $O(n^2)$</p>
<p>用max_area标记当前最大容器的取值, 然后两个for循环遍历所有容器的可能取值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max_area &lt; min( height[i],height[j] ) * (j-i))&#123;</span><br><span class="line">                    max_area = min( height[i],height[j] ) * (j-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-用两个指针"><a href="#解法二-用两个指针" class="headerlink" title="解法二: 用两个指针"></a>解法二: 用两个指针</h2><p>时间复杂度: $O(n)$</p>
<p>分别用两个指针指向数组的第一个元素和最后一个元素, 并计算当前的area, 然后移动指针元素值较小的一方, 移动过程中更新max_area的值</p>
<p>原理:</p>
<p>首先假设容器可以具有最大长度的宽, 也就是分别指向首尾元素,  这时候 , 我们想查看是否还有比当前最大容积更大的容器,  那么, 我们必须维持较高的垂直边不动, 而将较低的垂直边移动, 因为只有这样, 我们才 <strong>有可能</strong> (注意不是一定)获得比当前容积更大的容器, 这个时候虽然宽变小了, 但是高度却可能增加(因为新增的边有可能大于当前较低边的高).  如果移动较高的边, 那么新增的边由于受到当前较低边的作用, 只有可能减小容器的面积</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = min( height[low], height[high] ) * (high-low);</span><br><span class="line">            <span class="keyword">if</span>(max_area &lt; area)&#123;</span><br><span class="line">                max_area = area;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[low] &lt; height[high])</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="015-3Sum"><a href="#015-3Sum" class="headerlink" title="015. 3Sum"></a>015. 3Sum</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-固定一个数-按照two-sum的方式来解"><a href="#解法一-固定一个数-按照two-sum的方式来解" class="headerlink" title="解法一: 固定一个数, 按照two sum的方式来解"></a>解法一: 固定一个数, 按照two sum的方式来解</h2><p>因为不能包含重复的元祖, 因此不能直接固定然后用two sum 的方式求解, 首先要对数组进行排序, 然后从第一个开始逐个判断, 期间要去除重复的元组</p>
<p>时间复杂度: $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[low] != nums[(low+high)/<span class="number">2</span>])&#123; <span class="comment">// 注意这里用异或交换的陷阱</span></span><br><span class="line">            nums[low] = nums[low] + nums[(low+high)/<span class="number">2</span>];</span><br><span class="line">            nums[(low+high)/<span class="number">2</span>] = nums[low] - nums[(low+high)/<span class="number">2</span>];</span><br><span class="line">            nums[low] = nums[low] - nums[(low+high)/<span class="number">2</span>];      </span><br><span class="line">        &#125; <span class="comment">// 主要是将中将的数字和首位交换, 个人觉得可有可无, 因为时间复杂度是一样的</span></span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&lt;=nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&gt;=nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low&lt;mid ) quickSort(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) quickSort(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//剪枝, 如果当前数字为正, 那么后面就不可能再有符合条件的三元组, 可以提前退出</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] ) <span class="keyword">continue</span>; <span class="comment">//去除重复, 遇到除第一个外相同的三元组最小的数字, 则跳过</span></span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="keyword">if</span>(low&gt;i+<span class="number">1</span> &amp;&amp; nums[low] == nums[low<span class="number">-1</span>])&#123; <span class="comment">// 仍然是去除重复,</span></span><br><span class="line">                    low++; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[low] + nums[i] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;<span class="number">0</span>) high--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) low++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp&#123;nums[low], nums[i], nums[high]&#125;;</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                    low++;  <span class="comment">// 这一点千万别漏了, 要继续判断, 因为以当前数字开始的三元组可能不止一个</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更好的写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">2</span>)<span class="keyword">return</span> result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; a == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> j = i + <span class="number">1</span>, k = nums.size() - <span class="number">1</span>; j &lt; k;) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="keyword">int</span> c = nums[k];</span><br><span class="line">                <span class="keyword">int</span> value = a + b + c;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">                    result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;a, b, c&#125;));</span><br><span class="line">                    <span class="keyword">while</span> (j&lt;k &amp;&amp; b == nums[++j]); <span class="comment">// 主要是这里的写法很优雅, 其他地方和上面差不多</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp;c == nums[--k]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="017-Letter-Combinations-of-a-Phone-Number"><a href="#017-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="017. Letter Combinations of a Phone Number"></a>017. Letter Combinations of a Phone Number</h1><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h3><p>时间复杂度: $O(n*4^n)$</p>
<p>空间复杂度: $O(4^n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_tracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; digit_letters, <span class="built_in">string</span>&amp; tmp,<span class="built_in">string</span> digits, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.size())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;digit_letters[digits[index]-<span class="string">'0'</span>].size(); i++)&#123;</span><br><span class="line">                tmp.push_back(digit_letters[digits[index]-<span class="string">'0'</span>][i]);</span><br><span class="line">                back_tracking(res, digit_letters, tmp, digits, index+<span class="number">1</span>);</span><br><span class="line">                tmp.pop_back();<span class="comment">// 移除当前末尾元素, 以便可以加下一个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() &lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//res.push_back(""); //对res向量初始化,以便开始, 如果不初始化, 则size为0,后面的循环无法进行</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digit_letters&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,</span><br><span class="line">                      <span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">        back_tracking(res, digit_letters, tmp, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二-非递归"><a href="#解法二-非递归" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h3><p>时间复杂度: $O(n*4^n)$</p>
<p>空间复杂度: $O(4^n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() &lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(<span class="string">""</span>); <span class="comment">//对res向量初始化,以便开始, 如果不初始化, 则size为0,后面的循环无法进行</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digit_letters&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,</span><br><span class="line">                                          <span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;digits.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = digits[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(digit_letters[num] == <span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp; <span class="comment">// 申请一个临时vector, 用于存放加上当前数字字符的string集合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; digit_letters[num].size(); k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l =<span class="number">0</span>; l &lt; res.size(); l++)&#123;</span><br><span class="line">                    tmp.push_back(res[l]+digit_letters[num][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.swap(tmp); <span class="comment">// 将res于tmp交换, swap仅仅是改变指针, 比'='更快, 因为'='包含了复制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="解法一-利用reduce实现"><a href="#解法一-利用reduce实现" class="headerlink" title="解法一: 利用reduce实现"></a>解法一: 利用reduce实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> digits==<span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        digit_letters = &#123;<span class="string">'0'</span>:<span class="string">""</span>, <span class="string">'1'</span>:<span class="string">""</span>, <span class="string">'2'</span>:<span class="string">"abc"</span>,</span><br><span class="line">                        <span class="string">'3'</span>:<span class="string">"def"</span>, <span class="string">'4'</span>:<span class="string">"ghi"</span>, <span class="string">'5'</span>:<span class="string">"jkl"</span>,</span><br><span class="line">                        <span class="string">'6'</span>:<span class="string">"mno"</span>, <span class="string">'7'</span>:<span class="string">"pqrs"</span>, <span class="string">'8'</span>:<span class="string">"tuv"</span>, <span class="string">'9'</span>:<span class="string">"wxyz"</span>&#125;</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="comment"># 在python3中, reduce()函数已经从全局命名空间移除, 现在存在于functools模块中,使用时需要导入</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> res,digit:[x+y <span class="keyword">for</span> x <span class="keyword">in</span> res <span class="keyword">for</span> y <span class="keyword">in</span> digit_letters[digit]], digits, [<span class="string">""</span>])</span><br></pre></td></tr></table></figure>
<h1 id="019-Remove-Nth-Node-From-End-of-List"><a href="#019-Remove-Nth-Node-From-End-of-List" class="headerlink" title="019. Remove Nth Node From End of List"></a>019. Remove Nth Node From End of List</h1><h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p>
<h2 id="解法一-遍历两次"><a href="#解法一-遍历两次" class="headerlink" title="解法一: 遍历两次"></a>解法一: 遍历两次</h2><p>第一次遍历求出链表长度, 第二次遍历在对应位置删除节点</p>
<h2 id="只遍历一次"><a href="#只遍历一次" class="headerlink" title="只遍历一次"></a>只遍历一次</h2><p>时间复杂度: $O(n)$ 且只遍历一次</p>
<p>空间复杂度: $O(1)$</p>
<p>维护两个指针, 两指针之间的距离刚好相差n, 当第二个指针到达链表尾部时, 第一个指针刚好指向倒数第n个节点, 直接删除该节点即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">//链表为空, 或者n&lt;=0时, 直接返回head</span></span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(second == <span class="literal">nullptr</span>)&#123; <span class="comment">//对于 n&gt;=链表长度时的特殊判断和处理</span></span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是有一种写法, 新申请了一个节点空间, 用于指向head节点, 可以使代码看起来更容易理解, 对边界条件的判断也更加方便</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">//链表为空, 或者n&lt;=0时, 直接返回head</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* first = dummy;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(second == <span class="literal">nullptr</span>) <span class="keyword">return</span> dummy-&gt;next;<span class="comment">// n超出了链表的长度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="022-Generate-Parentheses"><a href="#022-Generate-Parentheses" class="headerlink" title="022. Generate Parentheses"></a>022. Generate Parentheses</h1><h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-暴力-2"><a href="#解法一-暴力-2" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p>先求出所有可能性, 然后验证每一种可能性是否正确</p>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><p>有关递归的时间空间复杂度分析起来都不太容易, 这里只上答案(//TODO 具体怎么来没搞懂)</p>
<p>时间复杂度: $O(\frac{4^n}{\sqrt n}$</p>
<p>空间复杂度: $O(\frac{4^n}{\sqrt n}$ 以及 $O(n)$ 的空间来存储组合序列</p>
<p>考虑合法括号组合的规律: 必须首先出现左括号, 然后才能出现右括号, 如果当前的string里面的右括号数量大于左括号数量, 那么就一定会出现<code>)(</code>这种不匹配的情况.</p>
<p>核心思路: 从头开始构建组合, 每次接入一个字符, 接入的字符只有两种可能性, 即左括号或者右括号, 而一旦接入的字符使得当前字符中右括号数量大于左括号, 就会变得不合法组合,其它均为合法. 根据此性质, 进行如下递归:</p>
<p>维护两个变量left_rest, right_rest分别代表 <strong>剩余</strong> 可以添加的括号的 <strong>数量</strong>. 采用递归算法, 每次添加一个 ‘(‘ 或者一个 ‘)’, 添加时需要考虑下面几种情况:</p>
<ul>
<li>为了保证当前string内左括号数量多于右括号数量, left_rest一定要小于right_rest</li>
<li>如果<code>left_rest = right_rest = 0</code>, 则说明此时没有可以添加的括号了,</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="built_in">string</span> out, <span class="keyword">int</span> left_rest, <span class="keyword">int</span> right_rest)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if(left_rest &gt; right_rest) return;</span></span><br><span class="line">        <span class="keyword">if</span>(left_rest == <span class="number">0</span> &amp;&amp; right_rest ==<span class="number">0</span>) res.push_back(out);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left_rest&gt;<span class="number">0</span>) helper(res, out+<span class="string">'('</span>, left_rest<span class="number">-1</span>, right_rest);</span><br><span class="line">            <span class="keyword">if</span>(right_rest&gt;<span class="number">0</span> &amp;&amp; right_rest &gt; left_rest) helper(res, out+<span class="string">')'</span>, left_rest, right_rest<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-用栈来模拟递归"><a href="#解法三-用栈来模拟递归" class="headerlink" title="解法三: 用栈来模拟递归"></a>解法三: 用栈来模拟递归</h2><p>首先是最厚的括号包裹状态，即一开始左边是连续的左括号，右边是连续的右括号，然后执行以下逻辑：<br>1、右括号不能比左括号多；<br>2、弹出右括号，直到遇到第一个左括号，如果左括号改成右括号仍然合法，则把它改成右括号；否则，左括号继续弹出；<br>3、改完之后一个劲加左括号，直到所有可以用的左括号都加完为止。<br>4、循环一直执行到不能弹出括号为止, 即直到栈为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> par_s;</span><br><span class="line">        <span class="keyword">int</span> left_rest = n, right_rest = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意, 这里如果把'left_rest--' 写在while判断里</span></span><br><span class="line">        <span class="comment">//会导致循环结束后的left_rest值为-1, 后面的同理</span></span><br><span class="line">        <span class="comment">//while(left_rest--) par_s.push_back('(');</span></span><br><span class="line">        <span class="keyword">while</span>(left_rest)&#123;</span><br><span class="line">            par_s.push_back(<span class="string">'('</span>);</span><br><span class="line">            left_rest--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right_rest) &#123;</span><br><span class="line">            par_s.push_back(<span class="string">')'</span>);</span><br><span class="line">            right_rest--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(par_s);</span><br><span class="line">        <span class="keyword">while</span>(par_s.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur_c = par_s.back(); par_s.pop_back();</span><br><span class="line">            <span class="keyword">if</span>(cur_c == <span class="string">')'</span>)&#123;</span><br><span class="line">                right_rest++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left_rest++;</span><br><span class="line">            <span class="keyword">if</span>(left_rest &lt; right_rest)&#123;</span><br><span class="line">                par_s.push_back(<span class="string">')'</span>);</span><br><span class="line">                right_rest--;</span><br><span class="line">                <span class="keyword">while</span>(left_rest)&#123;</span><br><span class="line">                    par_s.push_back(<span class="string">'('</span>);</span><br><span class="line">                    left_rest--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(right_rest) &#123;</span><br><span class="line">                    par_s.push_back(<span class="string">')'</span>);</span><br><span class="line">                    right_rest--;</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(par_s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="029-Divide-Two-Integers"><a href="#029-Divide-Two-Integers" class="headerlink" title="029. Divide Two Integers"></a>029. Divide Two Integers</h1><h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-循环加法"><a href="#解法一-循环加法" class="headerlink" title="解法一: 循环加法"></a>解法一: 循环加法</h2><p><strong>时间复杂度:</strong> $O(dividend)$</p>
<p>这种方法很容易时间超限: 当被除数很大(INT_MAX), 除数很小(1), 则需要循环INT_MAX次才能完成计算.</p>
<h2 id="解法二-左移法"><a href="#解法二-左移法" class="headerlink" title="解法二: 左移法"></a>解法二: 左移法</h2><p><strong>时间复杂度:</strong> $O(log(dividend))$</p>
<p>对除数进行左移, 相当于每次乘以2, 直到左移后大于被除数, 用被除数减去左移后的数字, 记录左移对应除数的倍数, 然后再次将从除数开始左移, 直到被除数小于除数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">0</span> || (dividend==INT_MIN&amp;&amp;divisor==<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend&lt;<span class="number">0</span>) ^ (divisor&lt;<span class="number">0</span>)) ? <span class="number">-1</span>:<span class="number">1</span>;<span class="comment">// 用异或来获取符号</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> did = <span class="built_in">labs</span>(dividend); <span class="comment">// long与int在有些环境中字节中一样, 所以最好用long long</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dis = <span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">while</span>(did &gt;= dis)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> temp = dis, multiple = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( did &gt;= temp&lt;&lt;<span class="number">1</span> )&#123;</span><br><span class="line">                temp = temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                multiple = multiple&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            did -= temp;</span><br><span class="line">            res+= multiple;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-这道题如果不允许使用long-或者long-long-怎么解"><a href="#扩展-这道题如果不允许使用long-或者long-long-怎么解" class="headerlink" title="扩展: 这道题如果不允许使用long 或者long long 怎么解?"></a>扩展: 这道题如果不允许使用long 或者long long 怎么解?</h2><h1 id="033-Search-in-Rotated-Sorted-Array"><a href="#033-Search-in-Rotated-Sorted-Array" class="headerlink" title="033. Search in Rotated Sorted Array"></a>033. Search in Rotated Sorted Array</h1><h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>Example 1:</p>
<p>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4<br>Example 2:</p>
<p>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</p>
<h2 id="解法一-二分查找"><a href="#解法一-二分查找" class="headerlink" title="解法一: 二分查找"></a>解法一: 二分查找</h2><p>对于数组[4,5,6,7,0,1,2], 可以将其看成是两段: [4,5,6,7] 和 [0,1,2], 可以看出, 前一段中的任意一个数字都大于后一段中的数字, 于是, 令low=0, high=size()-1, 进行二分查找, 其中 mid 对应的数字要么落在前半段(<code>nums[low] &lt;= nums[mid]</code>), 要么落在后半段.</p>
<p>如果落在的前半段, 则看 target 的值是否在 low与mid之间. 是则 <code>high = mid-1</code>, 否则 <code>low = mid+1</code></p>
<p>反之, 如果落在后半段, 则看 <code>target</code> 的值是否在 <code>mid</code> 与 <code>high</code> 之间, 是则 <code>low=mid+1</code> , 否则<code>high = mid-1</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        //数组前半段的数字永远大于后半段的数字</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123; //当low==high时, mid=low=high, 如果不等于target, 则之后会退出循环</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] &lt;= nums[mid])&#123; //说明当前mid落在数组的前半段(), 这里等于号必须带, 否则会漏解</span><br><span class="line">                //判断target是否在low与mid之间, 这里low需要带等于号,</span><br><span class="line">                //因为target有可能=nums[low], mid无需带等于号</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; // 只有当nums[low]完全小于nums[mid]时, mid才落在后半段</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high])</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-二分查找"><a href="#解法二-二分查找" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p>该方法同样是二分查找, 只不过与上面有一点不同, 对于数组<code>nums</code>=[4,5,6,7,0,1,2]来说, 如果 <code>target &lt; nums[0]</code>, 说明 <code>target</code> 位于数组的后半段, 那么可以将数组看做是<code>nums</code>=[INT_MIN,INT_MIN,INT_MIN,INT_MIN,0,1,2] , 这样一来, 就变成了最常规的有序数组, 反之, 如果 <code>target</code> 位于数组的前半段, 那么可以将数组看做是<code>nums</code>=[4,5,6,7,INT_MAX,INT_MAX,INT_MAX].</p>
<p>注意, 这里并不会改变数组内部的值, 我们只是利用一个临时变量<code>num</code>来代替当前的nums[mid]的值, 然后利用 <code>num</code> 与 <code>target</code> 比较进行二分查找.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            int num;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>])&#123; //target在后半段, 所以将前半段都看做INT_MIN</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>])  num = nums[mid]; // nums[mid]在后半段</span><br><span class="line">                <span class="keyword">else</span> num = INT_MIN; // nums[mid]在前半段,</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; //target在前半段, 所以将后半段都看作是INT_MAX</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) num = INT_MAX;  // nums[mid]在后半段</span><br><span class="line">                <span class="keyword">else</span> num = nums[mid]; // nums[mid]在前半段</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; num) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="034-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#034-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="034. Find First and Last Position of Element in Sorted Array"></a>034. Find First and Last Position of Element in Sorted Array</h1><h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>Example 1:</p>
<p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]<br>Example 2:</p>
<p>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>时间复杂度: $O(logn)$<br>空间复杂度: $O(1)$</p>
<p>先用常规的二分查找找到target, 然后分别用二分查找找到最左边的target和最右边的target下标.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;int&gt; res&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        int mid=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123; //正常的二分查找, 先找到target</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid==<span class="number">-1</span> || nums[mid] != target) <span class="keyword">return</span> res; // 数组为空或者数组内没有target</span><br><span class="line">        //以mid为中心, 分别查找下标最小的target和下标最大的target</span><br><span class="line">        int llow=low, lhigh=mid; // 左边的二分查找low,high初始化</span><br><span class="line">        int rlow=mid, rhigh=high; // 右边的二分查找low,high初始化</span><br><span class="line">        <span class="keyword">while</span>(llow&lt;=lhigh)&#123;</span><br><span class="line">            int mid = (llow+lhigh)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==llow || nums[mid<span class="number">-1</span>] != target)&#123; //关键: 只有当等于target并且左边没有元素或者左边元素不等于target时, 当前mid才是最左边的target</span><br><span class="line">                    res[<span class="number">0</span>] = mid; <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    lhigh = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                llow = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lhigh = mid<span class="number">-1</span>;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rlow&lt;=rhigh)&#123;</span><br><span class="line">            int mid = (rlow+rhigh)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==rhigh || nums[mid+<span class="number">1</span>] != target)&#123; //同理, 找最右边的target</span><br><span class="line">                    res[<span class="number">1</span>] = mid; <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    rlow = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                rlow = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rhigh = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-二分查找-1"><a href="#解法二-二分查找-1" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p>同样是二分查找, 更加精炼, 先找到最左边的target, 然后以最左边为low, 开始找最右边的target, 需要注意的是不能在<code>nums[mid] == target</code>时就退出循环.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;int&gt; res&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>; //偏向左边, 很重要, 否则会死循环</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid; //注意, 这里不是mid<span class="number">-1</span>, 因为现在是在找最左边的target, 故不能在=target时退出, 因此也不能直接令high=mid<span class="number">-1</span>, 否则会丢失mid=target的情况</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span> || nums[low] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>]=low;</span><br><span class="line">        high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            int mid = (low+high+<span class="number">1</span>)/<span class="number">2</span>; //使mid偏向右边, 这很重要</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>]=high;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="036-Valid-Sudoku"><a href="#036-Valid-Sudoku" class="headerlink" title="036 Valid Sudoku"></a>036 Valid Sudoku</h1><p>验证一个矩阵是否是数独数据 (注意, 验证和)</p>
<h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<p>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
<h2 id="解法一-利用flag数组存储判断矩阵"><a href="#解法一-利用flag数组存储判断矩阵" class="headerlink" title="解法一: 利用flag数组存储判断矩阵"></a>解法一: 利用flag数组存储判断矩阵</h2><p><strong>时间复杂度:</strong> $O(9^2)$</p>
<p><strong>空间复杂度:</strong> $O(3*9^2)$  虽然要申请三个二维数组, 但都是常数级.</p>
<p>用三个 9×9 大小的矩阵, 分别储存每一行上, 每一列上, 每一个子块上1-9数字是否出现.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        // 下面三个矩阵分别存储了 行上<span class="number">1</span><span class="number">-9</span>是否出现, 列上<span class="number">1</span><span class="number">-9</span>是否出现, sub-box上<span class="number">1</span><span class="number">-9</span>是否出现的bool值</span><br><span class="line">        // 如果row_flag[<span class="number">1</span>][<span class="number">3</span>] 为真, 则说明第<span class="number">1</span>行(从第<span class="number">0</span>行算起)上已经具有数字<span class="number">4</span>(数字比下标大<span class="number">1</span>)了</span><br><span class="line">        bool row_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;, col_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;, sub_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span> ; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>; // 如果为 <span class="string">'.'</span> 则可以直接跳过此次判断</span><br><span class="line">                int num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>; //这里<span class="number">-1</span>主要是为了能够直接将num作为下标使用</span><br><span class="line">                int k = i/<span class="number">3</span>*<span class="number">3</span> + j/<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(row_flag[i][num] || col_flag[j][num] || sub_flag[k][num])</span><br><span class="line">                    <span class="keyword">return</span> false;</span><br><span class="line">                row_flag[i][num]=col_flag[j][num]=sub_flag[k][num]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="046-Permutations"><a href="#046-Permutations" class="headerlink" title="046 Permutations"></a>046 Permutations</h1><p>全排列, 注意是distict的数字, 故而不需要进行重复检查</p>
<h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of distinct integers, return all possible permutations.</p>
<p>Example:</p>
<p>Input: [1,2,3]<br>Output:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h2 id="解法一-递归-1"><a href="#解法一-递归-1" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(A^n_n)$ , 每一种情况都是 $O(1)$ , 共有 $O(A^n_n)$ 种情况. (对吗?)</p>
<p>用一个变量pos指向nums的第一个位置, 然后将pos与后面所有位置上的数字交换(包括自己), 最终会得到n种可能性, 这n种可能性就是出现在第一位置上的所有可能字符的情况集合, 然后将第一位固定, 并将pos指向下一位, 此时问题转换成了n-1个字符的全排列, 按照这种想法一致递归下去, 就可以找到所有位置上的所有组合情况(用pos==nums.size()判断)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute_helper(res, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">            res.push_back(nums);  <span class="comment">// 当pos走到最后时, 说明一种情况诞生, 将其添加到res中</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt;nums.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[pos], nums[i]);</span><br><span class="line">                permute_helper(res, pos+<span class="number">1</span>, nums);</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[pos], nums[i]); <span class="comment">// 能够去掉这句话的前提是对res内的字符串进行重复检查, 具体可看牛客分析</span></span><br><span class="line">                <span class="comment">//在面对含有重复字符的情况时, 最好加上这句话</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n^3)$<br><strong>空间复杂度:</strong> $O(A_n^n)$ 全排列的size</p>
<p>对于n个数的全排列问题, 可以想象成已经获得了n-1个数的全排列, 然后将第n个数插入到n-1个数的n个空位上( 如将3插入到12的空位上分别为: 312,132,123).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tmp_res(<span class="built_in">std</span>::move(res)); <span class="comment">// move之后, res内部会自动被清空, 而且move的效率较高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;tmp_res.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=tmp_res[<span class="number">0</span>].size(); k++)&#123; <span class="comment">// 注意这里是&lt;=, 因为还要往尾部插</span></span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(tmp_res[j]);</span><br><span class="line">                    tmp.insert(tmp.begin()+k, num[i]);</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-利用C-的内置函数"><a href="#解法三-利用C-的内置函数" class="headerlink" title="解法三: 利用C++的内置函数"></a>解法三: 利用C++的内置函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        sort(num.begin(), num.end());</span><br><span class="line">        ans.push_back(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">std</span>::next_permutation(num.begin(), num.end()))</span><br><span class="line">            ans.push_back(num);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="048-Rotate-Image"><a href="#048-Rotate-Image" class="headerlink" title="048. Rotate Image"></a>048. Rotate Image</h1><p>将二维矩阵顺时针旋转90度.</p>
<h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Note:</p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<p>Example 1:</p>
<p>Given input matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>Example 2:</p>
<p>Given input matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>],</p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<h2 id="解法一-逆置-转置"><a href="#解法一-逆置-转置" class="headerlink" title="解法一: 逆置+转置"></a>解法一: 逆置+转置</h2><p>对行向量使用逆置, 然后对整个矩阵转置</p>
<p>clockwise rotate<br>first reverse up to down, then swap the symmetry<br>1 2 3     7 8 9     7 4 1<br>4 5 6  =&gt; 4 5 6  =&gt; 8 5 2<br>7 8 9     1 2 3     9 6 3</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::reverse(matrix.begin(), matrix.end()); <span class="comment">//逆置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;matrix[i].size();j++) <span class="comment">// 转置, 注意j=i+1</span></span><br><span class="line">                <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-转置-列向量逆置"><a href="#解法二-转置-列向量逆置" class="headerlink" title="解法二: 转置+列向量逆置"></a>解法二: 转置+列向量逆置</h2><p>先求转置, 再对行向量逆置:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;matrix[i].size();j++)</span><br><span class="line">                <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;vec_i : matrix) <span class="built_in">std</span>::reverse(vec_i.begin(), vec_i.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="补充-逆时针旋转90度"><a href="#补充-逆时针旋转90度" class="headerlink" title="补充: 逆时针旋转90度"></a>补充: 逆时针旋转90度</h2><p>对列向量使用逆置(reverse), 然后对矩阵使用转置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;vec_i:matrix) <span class="built_in">std</span>::swap(vec_i.begin(), vec_i.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; i&lt;matrix[i].size(); j++)</span><br><span class="line">        <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="049-Group-Anagrams"><a href="#049-Group-Anagrams" class="headerlink" title="049. Group Anagrams"></a>049. Group Anagrams</h1><p>找到具有相同字符的各个字符串, 并按字符分组输出</p>
<h2 id="Description-15"><a href="#Description-15" class="headerlink" title="Description"></a>Description</h2><p>Given an array of strings, group anagrams together.</p>
<p>Example:</p>
<p>Input: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Output:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:</p>
<p>All inputs will be in lowercase.<br>The order of your output does not matter.</p>
<h2 id="解法一-哈希表-sort"><a href="#解法一-哈希表-sort" class="headerlink" title="解法一: 哈希表+sort"></a>解法一: 哈希表+sort</h2><p>用哈希表来存, 键为有序的字符序列, 值为string数组, 里面存着各个与有序字符序列包含字符相同的其他序列</p>
<p><strong>时间复杂度:</strong> $O(nmlogm)$ , 其中, n为输入字符串数组的长度, m为每个字符串的长度, 对于n个字符串, 要进行n次哈希表的插入, 同时每次插入时, 需要对字符串进行排序, 排序复杂度为 $O(mlogm)$.</p>
<p><strong>空间复杂度:</strong> $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> str_value = str;</span><br><span class="line">            <span class="built_in">std</span>::sort(str.begin(), str.end());</span><br><span class="line">            res_map[str].push_back(str_value); <span class="comment">//key 为字母有序string, value为含有这些字母的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_map)</span><br><span class="line">            res_vec.push_back(str.second); <span class="comment">//将map中的所有的string转移到vec返回结果中</span></span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-哈希表-不使用sort"><a href="#解法二-哈希表-不使用sort" class="headerlink" title="解法二: 哈希表(不使用sort)"></a>解法二: 哈希表(不使用sort)</h2><p><strong>时间复杂度:</strong> $O(nm)$ , 其中, n为string个数, m为每个string的字母数.</p>
<p>由于上面的解法二需要使用排序, 故而时间上不够优化, 因此, 这里我们可以设计新的键来代替sort, 基本思想是对26个字母, 分别赋予一个素数值, 然后, 计算键的时候, 将对应字母的素数相乘即可, 这样一来, 每一种字符串的key都是唯一的(因为最终的乘积可以唯一的表示成素数相乘的序列).</p>
<p><strong>空间复杂度:</strong> $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> primer[<span class="number">26</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> ,<span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum_id</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">            sum * = primer[(<span class="keyword">int</span>)(c-<span class="string">'a'</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">            res_map[get_sum_id(str)].push_back(str); <span class="comment">//key 为字母有序string, value为含有这些字母的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_map)</span><br><span class="line">            res_vec.push_back(str.second); <span class="comment">//将map中的所有的string转移到vec返回结果中</span></span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="050-Pow-x-n"><a href="#050-Pow-x-n" class="headerlink" title="050. Pow(x, n)"></a>050. Pow(x, n)</h1><p>实现幂乘操作</p>
<h2 id="Descriptin"><a href="#Descriptin" class="headerlink" title="Descriptin"></a>Descriptin</h2><p>Implement pow(x, n), which calculates x raised to the power n (x^n).</p>
<p>Example 1:</p>
<p>Input: 2.00000, 10<br>Output: 1024.00000<br>Example 2:</p>
<p>Input: 2.10000, 3<br>Output: 9.26100<br>Example 3:</p>
<p>Input: 2.00000, -2<br>Output: 0.25000<br>Explanation: 2-2 = 1/22 = 1/4 = 0.25<br>Note:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n is a 32-bit signed integer, within the range $[−2^{31}, 2^{31} − 1]$</p>
<h2 id="解法一-递归-2"><a href="#解法一-递归-2" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>当n为偶数时: $x^n = x^{n/2} \times x^{n/2}$<br>当n为奇数时: $x^n = x\times x^{n/2} \times x^{n/2}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">return</span> (un%<span class="number">2</span>==<span class="number">0</span>) ? myPow(x*x, un/<span class="number">2</span>) : x*myPow(x*x, un/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-非递归-1"><a href="#解法二-非递归-1" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>n要么为偶数, 要么为奇数, 就算为奇数, 也可以拆分成 $x\times x^{n-1}$ 的形式, 对于偶数n, 可以写成 $x^{n/2} \times x{n/2}$ 的形式, 对于 $x^{n/2}$, 可以继续按奇数偶数进行拆分. 举例来说, 对于x=2, n=10 , 可以写成 $2^{10} = 2^{5} \times 2^{5}$ 对于 $2^5$ , 可以写成, $2 \times 2^2 \times 2^2$, 可以看出, x每次与自身相乘后, n的次数就会变成原来二分之一, 这样, 可以用循环实现幂乘的操作, 如下所示.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">double</span> res =<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(un&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(un%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                res * = x;</span><br><span class="line">            &#125;</span><br><span class="line">            x * =x;</span><br><span class="line">            un /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="054-Spiral-Matrix"><a href="#054-Spiral-Matrix" class="headerlink" title="054. Spiral Matrix"></a>054. Spiral Matrix</h1><p>以顺时针螺旋顺序返回矩阵元素, 顺时针打印矩阵</p>
<h2 id="Description-16"><a href="#Description-16" class="headerlink" title="Description"></a>Description</h2><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>Example 1:</p>
<p>Input:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>Output: [1,2,3,6,9,8,7,4,5]<br>Example 2:</p>
<p>Input:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>Output: [1,2,3,4,8,12,11,10,9,5,6,7]</p>
<h2 id="解法-按层次输出-由外而内"><a href="#解法-按层次输出-由外而内" class="headerlink" title="解法: 按层次输出(由外而内)"></a>解法: 按层次输出(由外而内)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>输出形式如下(按层次编码, 以4×6的矩阵为例), 需要注意边界控制条件:</p>
<script type="math/tex; mode=display">\begin{matrix} 1_{top}&1_{top}&1_{top}&1_{top}&1_{top}&1_{top} \\ 1_{left}&2_{top}&2_{top}&2_{top}&2_{top}&1_{right} \\ 1_{left}&2_{bottom}&2_{bottom}&2_{bottom}&2_{bottom}&1_{right} \\ 1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}  \end{matrix}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size() ==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row_layer = (matrix.size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> col_layer = (matrix[<span class="number">0</span>].size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> layer = min( row_layer, col_layer); <span class="comment">// 计算总共的层数</span></span><br><span class="line">        <span class="keyword">int</span> cur_layer =<span class="number">0</span>; <span class="comment">// 用于记录当前所处哪一层</span></span><br><span class="line">        <span class="keyword">int</span> len_row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> len_col = matrix[<span class="number">0</span>].size(); <span class="comment">//分别为行和列的size</span></span><br><span class="line">        <span class="keyword">while</span>(cur_layer &lt; layer)&#123;</span><br><span class="line">            <span class="comment">//top 输出上边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =cur_layer; j&lt;len_col-cur_layer; j++)</span><br><span class="line">                res.push_back(matrix[cur_layer][j]);</span><br><span class="line">            <span class="comment">//right 输出右边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_layer+<span class="number">1</span>; i&lt;len_row<span class="number">-1</span>-cur_layer; i++)</span><br><span class="line">                res.push_back(matrix[i][len_col - <span class="number">1</span> - cur_layer]);</span><br><span class="line">            <span class="comment">//bottom  输出下边, 这里注意为了防止重复输出, 需要确保上边和下边的行数不同,即:</span></span><br><span class="line">            <span class="comment">// cur_layer!=len_row-1-cur_layer</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= len_col - <span class="number">1</span> -cur_layer; cur_layer!=len_row<span class="number">-1</span>-cur_layer &amp;&amp; j &gt;=cur_layer  ;j--)</span><br><span class="line">                res.push_back(matrix[len_row - <span class="number">1</span> -cur_layer][j]);</span><br><span class="line">            <span class="comment">//left 输出左边, 同样, 要确保左边和右边的列数不同, 即: cur_layer!=len_col-1-cur_layer</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = len_row<span class="number">-2</span>-cur_layer; cur_layer!=len_col<span class="number">-1</span>-cur_layer &amp;&amp; i&gt;cur_layer; i--)</span><br><span class="line">                res.push_back(matrix[i][cur_layer]);</span><br><span class="line">            cur_layer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="055-Jump-Game"><a href="#055-Jump-Game" class="headerlink" title="055. Jump Game"></a>055. Jump Game</h1><p>数组的数字为最大的跳跃步数, 根据数组判断是否能跳到最后一位上</p>
<h2 id="Description-17"><a href="#Description-17" class="headerlink" title="Description"></a>Description</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>Example 1:</p>
<p>Input: [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Example 2:</p>
<p>Input: [3,2,1,0,4]<br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum<br>             jump length is 0, which makes it impossible to reach the last index.</p>
<h2 id="解法一-回溯"><a href="#解法一-回溯" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong> $O(2^n)$  总共有 $2^n$ 种跳法来跳到最后一个位置上(对于任意一个位置, 有经过和不经过两个种可能性)<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>试遍所有的可能性, 正常来说会超时, 并且也肯定不是最佳答案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(position == final_position) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(position+nums[position], final_position);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = position+<span class="number">1</span>; i&lt;=furthest; i++)&#123;</span><br><span class="line">            <span class="comment">//这里有个小小的优化, 就是令i从最大步长开始, i--, 这种优化虽然最坏情况时一样的</span></span><br><span class="line">            <span class="comment">//但在实际使用中, 会比从position+1开始要快一点(但是依然超时)</span></span><br><span class="line">            <span class="keyword">if</span>(helper(nums, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-top-down-动态规划-递归"><a href="#解法二-top-down-动态规划-递归" class="headerlink" title="解法二: top-down 动态规划(递归)"></a>解法二: top-down 动态规划(递归)</h2><p><strong>时间复杂度:</strong> $O(n^2)$ , 对于每个点来说, 都是要找到下一个<code>good_position</code>, 则需要进行 $(O)$ 的查找, 又因为总共有 $O(n)$个元素, 所以复杂度为 $O(n^2)$.<br><strong>空间复杂度:</strong> $O(2n)$, 递归需要 $O(n)$ , <code>memo</code>需要 $O(n)$.</p>
<p>设计一个数组, 用来记录当前下标对应位置是否可又达到终点, 如果能, 则该位置为<code>good position</code>, 如果不能, 则为<code>bad position</code>, 刚开始的时候都是<code>unknown position</code>(除了最后一个位置为<code>good</code>).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>&#123;</span>GOOD, BAD, UNKNOWN&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Status&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            memo.push_back(Status::UNKNOWN);</span><br><span class="line">        memo.push_back(Status::GOOD);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, memo, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;Status&gt; &amp;memo, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[position] != Status::UNKNOWN) <span class="keyword">return</span> memo[position]==Status::GOOD ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(position+nums[position], final_position);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = furthest; i&gt;position; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper(nums, memo, i))&#123;</span><br><span class="line">                memo[position] = Status::GOOD; <span class="comment">//注意是position, 不是i</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[position] = Status::BAD;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-down-top-动态规划-非递归"><a href="#解法三-down-top-动态规划-非递归" class="headerlink" title="解法三: down-top 动态规划(非递归)"></a>解法三: down-top 动态规划(非递归)</h2><p><strong>时间复杂度:</strong> $O(n^2)$ , 对于每个点来说, 都是要找到下一个<code>good_position</code>, 则需要进行 $(O)$ 的查找, 又因为总共有 $O(n)$个元素, 所以复杂度为 $O(n^2)$.<br><strong>空间复杂度:</strong> $O(n)$, 无需递归 , 只需要<code>memo</code>, $O(n)$.</p>
<p>动态规划的非递归版本.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>&#123;</span>GOOD, BAD, UNKNOWN&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums.size() ==0) return false;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Status&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            memo.push_back(Status::UNKNOWN);</span><br><span class="line">        memo.push_back(Status::GOOD);</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(i+nums[i], final_position);</span><br><span class="line">            <span class="comment">//for(int j = i+1; j&lt;=furthest; j++)&#123;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = furthest; j&gt;i;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(memo[j] == Status::GOOD)&#123; <span class="comment">// 只要有一个GOOD, 当前i位置就为GOOD, 而无需考虑BAD的情况</span></span><br><span class="line">                    memo[i] = memo[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>] == Status::GOOD ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-贪心"><a href="#解法四-贪心" class="headerlink" title="解法四: 贪心"></a>解法四: 贪心</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>由上面的down-top递归可以看出, 当前下标位置的点是否为good点, 实际上只取决于当前点是否能够达到右边坐标中(从右往左走)最左边的good(可以看上面的break语句), 如果能够达到, 则当前点一定为good点, 因此, 我们只需要用一个变量<code>left_most_good</code>来维护当前点右边的最左good点下标即可, 无需任何其他空间和操作.(速度极快)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left_most_good = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+nums[i] &gt;= left_most_good)&#123;</span><br><span class="line">                left_most_good = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left_most_good==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种贪心的形式:</strong> 记录当前能够达到的最大位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> reach=<span class="number">0</span>; i&lt;nums.size() &amp;&amp; i&lt;=reach; i++ )</span><br><span class="line">            reach = max(i+nums[i], reach);</span><br><span class="line">        <span class="keyword">return</span> i==nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="056-Merge-Intervals"><a href="#056-Merge-Intervals" class="headerlink" title="056. Merge Intervals"></a>056. Merge Intervals</h1><p>融合区间</p>
<h2 id="Description-18"><a href="#Description-18" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>Example 1:</p>
<p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].<br>Example 2:</p>
<p>Input: [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considerred overlapping.</p>
<h2 id="解法一-sort-O-n"><a href="#解法一-sort-O-n" class="headerlink" title="解法一: sort+O(n)"></a>解法一: sort+O(n)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 主要是排序<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>最简单的实现方法, 先按照interval.start用sort排序, 排好序以后, 能够融合的interval都会聚到一起, 这个时候, 因为start是呈递增的, 只需要看end的大小关系就可以.</p>
<p>最简单的实现方法就是sort之后, 通过额外申请空间来存储融合后的interval, 最后返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iv : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.back().end &lt; iv.start) res.push_back(iv);</span><br><span class="line">            <span class="keyword">else</span> res.back().end = <span class="built_in">std</span>::max(res.back().end, iv.end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-sort-O-1"><a href="#解法二-sort-O-1" class="headerlink" title="解法二: sort+O(1)"></a>解法二: sort+O(1)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$ , 主要是排序<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>上面的方法在逻辑上不够好, 因为既然已经申请了额外的内存来存储放回结果, 说明我们不希望改变原vector内部的数据, 但是sort之后, 数据顺序已经被破坏了, 既然已经破坏了, 那最好就是直接使用原地融合的办法, 来减少内存的开销<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="comment">//vector&lt;Interval&gt; res; 既然决定使用sort, 就说明已经改变了intervals, 此时不应该在额外申请空间, 而应该进行原地融合.</span></span><br><span class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        <span class="keyword">auto</span> cur_iv = intervals.begin();</span><br><span class="line">        <span class="keyword">auto</span> next_iv = intervals.begin()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; next_iv!=intervals.end(); next_iv++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (*cur_iv).end &lt; (*next_iv).start )&#123;</span><br><span class="line">                cur_iv++;</span><br><span class="line">                (*cur_iv) = (*next_iv);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                (*cur_iv).end = <span class="built_in">std</span>::max( (*cur_iv).end, (*next_iv).end );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.erase(cur_iv+<span class="number">1</span>, intervals.end());</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-不使用sort"><a href="#解法三-不使用sort" class="headerlink" title="解法三: 不使用sort"></a>解法三: 不使用sort</h2><p>有时, 我们要求不能改变原向量intervals的内容, 此时, 就不能使用sort (除非牺牲大量空间留副本,但单肯定不推荐).</p>
<p>//TODO, 未细看, 但时间复杂度应该会高于 O(nlogn)<br><a href="https://leetcode.com/problems/merge-intervals/discuss/153979/Elegant-c++-solutions.-One-without-modifying-intervals-and-one-inplace" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/discuss/153979/Elegant-c++-solutions.-One-without-modifying-intervals-and-one-inplace</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Without modifying intervals</span><br><span class="line">Since we can't sort interval, we want to instead ensure our destination <span class="built_in">vector</span> is sorted. A insertion sort is required then. Insertion should be done as follows;</span><br><span class="line"></span><br><span class="line">Find first destination interval that ends after the incoming interval starts. Called it</span><br><span class="line">If no such interval is found <span class="keyword">or</span> the incoming interval end is less than found intervals start then we can just insert <span class="keyword">and</span> be done.</span><br><span class="line">Otherwise there must be an overlap, but it could be more than one. Do another search, <span class="keyword">this</span> time <span class="keyword">for</span> the first interval whose start is greater than incoming interval end. Called last</span><br><span class="line">Everything from [it, last) can be merged together with incoming interval into a single interval</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Interval&gt; ret;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">std</span>::lower_bound(ret.begin(), ret.end(), interval.start, [](<span class="keyword">const</span> Interval&amp; l, <span class="keyword">int</span> r) &#123; <span class="keyword">return</span> l.end &lt; r; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it == ret.end() || interval.end &lt; it-&gt;start)</span><br><span class="line">          <span class="comment">// No overlap, insert as is</span></span><br><span class="line">          ret.insert(it, interval);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// There is an overlap, there might be more, so find the upper bound too</span></span><br><span class="line">          it-&gt;start = <span class="built_in">std</span>::min(it-&gt;start, interval.start);</span><br><span class="line">          <span class="keyword">auto</span> last = <span class="built_in">std</span>::upper_bound(it, ret.end(), interval.end, [](<span class="keyword">int</span> l, <span class="keyword">const</span> Interval&amp; r) &#123; <span class="keyword">return</span> l &lt; r.start; &#125;);</span><br><span class="line">          it-&gt;end = <span class="built_in">std</span>::max((last - <span class="number">1</span>)-&gt;end, interval.end);</span><br><span class="line">          ret.erase(it + <span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="062-Unique-Paths"><a href="#062-Unique-Paths" class="headerlink" title="062. Unique Paths"></a>062. Unique Paths</h1><h2 id="Description-19"><a href="#Description-19" class="headerlink" title="Description"></a>Description</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<h2 id="解法一-DP"><a href="#解法一-DP" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(mn)$<br><strong>空间复杂度:</strong> $O(mn)$</p>
<p>这是一道经典的DP问题, 当机器人处于某一点时, 它只能从上面或者左边到达该点, 因此很容易得出<code>path[i][j] = path[i-1][j] + path[i][j-1];</code>, 其中 <code>path[i][j]</code>指到达 $(i,j)$ 点的可能路径数量.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span> ; j&lt;n; j++)&#123;</span><br><span class="line">                path[i][j] = path[i<span class="number">-1</span>][j] + path[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-优化的DP"><a href="#解法二-优化的DP" class="headerlink" title="解法二: 优化的DP"></a>解法二: 优化的DP</h2><p><strong>时间复杂度:</strong> $O(mn)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>通过分析指导, 当前点的可能路径数量只与上面点和左边点的值有关, 在上面的方法中, 我们用一个 $m\times n$ 的数组来存储当前点上面和左边的值, 实际上, 我们只需要用一行数组就可以完成这个功能, 首先, 求出第一行的所有点的值, 这里只会用每个点左边的值,  然后, 对于第二行的第一个点来说, 它只会用到上面的值, 也就是第一行的第一个值, 因此可以通过行数组直接得到, 然后, 对于第二行的第二个值, 它可以从第二行的第一个值, 以及第二行的第二个值得到, 这些值都是已知的, 所以可以直接求的, 由于在求得以后, 我们就再也不需要第一行的第二个值了, 所以我们可以用这个存储空间来存储第二行的第二个值, 如此递归执行, 我们只需要 $O(n)$ 的空间即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                path[j] = path[j] + path[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-排列组合-最优"><a href="#解法三-排列组合-最优" class="headerlink" title="解法三: 排列组合(最优)"></a>解法三: 排列组合(最优)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>实际上, 仔细分析该问题, 可以把该问题看成是一个典型的排列组合问题. 首先, 将机器人向右走记为 1, 将机器人向下走记为 0. 题目问有多少种不同的走法, 实际上就是在问1/0序列的不同排列有多少种, 并且, 1/0 的长度必须为 $(m -1 + n - 1)$. 因此, 这个问题可以看做是从 $(m-1+n-1)$ 个空槽位上选择 $(m-1)$ 个槽位, 将其置为1, 并将剩余的 $n-1$ 个槽位置为0, 故而就是组合问题: $C_{m-1+n-1}^{m-1}$ . 又因为 $C_{m-1+n-1}^{m-1} = C_{m-1+n-1}^{n-1}$ , 所以为了防止溢出, 我们可以选择小的进行计算</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long res = <span class="number">1</span>; //需要注意的是, 由于下面的计算操作是会有先乘一个数, 再初以一个数的操作, 因此很有可能乘完后超过int上限, 所以需要声明为long整型</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i&lt; std::min(m,n); i++)&#123;</span><br><span class="line">            res = res * (m<span class="number">-1</span>+n<span class="number">-1</span> - i+<span class="number">1</span>) / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="073-Set-Matrix-Zeroes"><a href="#073-Set-Matrix-Zeroes" class="headerlink" title="073. Set Matrix Zeroes"></a>073. Set Matrix Zeroes</h1><h2 id="Description-20"><a href="#Description-20" class="headerlink" title="Description"></a>Description</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.</p>
<p>Example 1:</p>
<p>Input:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>Output:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br>Example 2:</p>
<p>Input:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>Output:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]<br>Follow up:</p>
<p>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p>
<h2 id="解法一-穷举"><a href="#解法一-穷举" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(nm)$</p>
<p>记录所有出现0的位置, 然后根据这些位置坐标将对应的行和列上的值置为0.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    rows.push_back(i);</span><br><span class="line">                    cols.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:rows)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:cols)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-穷举-减少空间复杂度"><a href="#解法二-穷举-减少空间复杂度" class="headerlink" title="解法二: 穷举(减少空间复杂度)"></a>解法二: 穷举(减少空间复杂度)</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(n+m)$</p>
<p>上面在记录位置坐标时没有进行重复检查, 实际上, 对于已经记录过的行或列, 可以不用再记录, 此时, 空间复杂度可以降为 $O(m+n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 记录行或列坐标之前先进行重复检查</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">std</span>::count(rows.begin(), rows.end(), i)==<span class="number">0</span>) rows.push_back(i);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">std</span>::count(cols.begin(), cols.end(), j)==<span class="number">0</span>) cols.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:rows)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:cols)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-穷举-空间复杂度-O-1"><a href="#解法三-穷举-空间复杂度-O-1" class="headerlink" title="解法三: 穷举(空间复杂度 $O(1)$ )"></a>解法三: 穷举(空间复杂度 $O(1)$ )</h2><p><strong>时间复杂度:</strong> $O(nm\times (m+n))$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>遍历矩阵时, 如果遇到 $(i,j)$ 上的值为0, 那么就将对应的行和列上的所有非0值全部置为一个矩阵范围外的值NAN(解答里面用的是-100000, 实际上这种解法存在问题, 因为理论上矩阵中的元素可以是表示范围内的任何值).</p>
<p>之后将所有的NAN值置为0, 就可以完成置0任务, 并且没有使用额外的空间. 由于每次找到一个0时, 都要遍历这个位置上的行和列, 因此时间复杂度较高</p>
<h2 id="解法四-用第一行和第一列记录"><a href="#解法四-用第一行和第一列记录" class="headerlink" title="解法四: 用第一行和第一列记录"></a>解法四: 用第一行和第一列记录</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>用第一行和第一列的值记录是否应该将对应的行和列置为0, 此时由于第一行和第一列被用作了标记数组, 因此第一行和第一列的0不能用来判断是否应该置为全0, 所以需要额外设置两个变量记录.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> is_row=<span class="literal">false</span>, is_col = <span class="literal">false</span>; <span class="comment">// 用第一行和第一列的值来做标记, 因此需要额外的记录第一行和第一列本身是有应该全0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) is_row=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>) is_col=<span class="literal">true</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_row)&#123; <span class="comment">//需要特别判断第一行和第一列是否应该置为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;matrix[<span class="number">0</span>].size();j++)  matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_col)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; matrix.size(); i++) matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="075-Sort-Colors"><a href="#075-Sort-Colors" class="headerlink" title="075. Sort Colors"></a>075. Sort Colors</h1><p>对0,1,2 (颜色: RGB) 进行排序</p>
<h2 id="Description-21"><a href="#Description-21" class="headerlink" title="Description"></a>Description</h2><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note: You are not suppose to use the library’s sort function for this problem.</p>
<p>Example:</p>
<p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p>
<p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p>
<h2 id="解法一-两次遍历"><a href="#解法一-两次遍历" class="headerlink" title="解法一: 两次遍历"></a>解法一: 两次遍历</h2><p><strong>时间复杂度: $O(n)$</strong><br><strong>空间复杂度: $O(1)$</strong></p>
<p>第一次遍历统计0,1,2的个数, 第二次遍历根据0,1,2的个数覆盖数组原有值</p>
<h2 id="解法二-一次遍历"><a href="#解法二-一次遍历" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> 大于 $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>设置mid, low, high三个指示变量, 如果mid==0, 则将其与low交换, 如果mid==2, 则将其与high交换, 直到mid&gt;high为止.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, mid=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(mid&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[mid], nums[high--]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[mid++], nums[low++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mid++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="078-Subsets"><a href="#078-Subsets" class="headerlink" title="078. Subsets"></a>078. Subsets</h1><p>返回给定数字序列的子集, 序列中每个元素都不同(这是一个很重要的条件!!)</p>
<h2 id="Description-22"><a href="#Description-22" class="headerlink" title="Description"></a>Description</h2><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:</p>
<p>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<h2 id="解法一-迭代直接求出子集"><a href="#解法一-迭代直接求出子集" class="headerlink" title="解法一: 迭代直接求出子集"></a>解法一: 迭代直接求出子集</h2><p><strong>时间复杂度:</strong> $O(2^n)$ , 对于任意一个元素, 有包含和不包含两种情况<br><strong>空间复杂度:</strong> $O(2^n)$</p>
<p><strong>由于序列中的每个元素都不同</strong>, 因此, 对于任意一个元素, 只需要将其添加都前面序列所组成的子集的每一个子序列的末尾即可, 无需考虑是否包含重复元素的情况.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res &#123;vector&lt;int&gt;&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(auto n : nums)&#123;</span><br><span class="line">            int len = res.size();</span><br><span class="line">            <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                vector&lt;int&gt; sub_item = res[i]; // c++中, =为复制赋值, move函数为移动赋值</span><br><span class="line">                sub_item.push_back(n);</span><br><span class="line">                res.push_back(sub_item);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-回溯"><a href="#解法二-回溯" class="headerlink" title="解法二: 回溯"></a>解法二: 回溯</h2><p><a href="https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning</a>)<br>回溯法可以解决一系列相关问题, 先看Subsets的求解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item;</span><br><span class="line">        back_track(res, sub_item, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        res.push_back(sub_item);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            sub_item.push_back(nums[i]);</span><br><span class="line">            back_track(res, sub_item, i+<span class="number">1</span>, nums);</span><br><span class="line">            sub_item.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>其他问题:</strong></p>
<p>Subsets II (contains duplicates) : <a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets-ii/</a><br>悠悠  11:05:53<br>Permutations : <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><br>悠悠  11:06:01<br>Permutations II (contains duplicates) : <a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a><br>悠悠  11:06:09<br>Combination Sum : <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/</a><br>悠悠  11:06:16<br>Combination Sum II (can’t reuse same element) : <a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-ii/</a><br>悠悠  11:06:23<br>Palindrome Partitioning : <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p>
<h2 id="解法三-bit控制"><a href="#解法三-bit控制" class="headerlink" title="解法三: bit控制"></a>解法三: bit控制</h2><p><strong>时间复杂度:</strong> $O(n\times 2^n)$ , 最慢的方法.<br><strong>空间复杂度:</strong> $O(2^n)$<br>因为对于任意一个数只有两种可能性, 出现在子序列中, 或者不出现在子序列中, 因此对于长度为 n 的(无相同元素的)序列来说, 共有 $2^n$ 个子序列, 我们先为这些子序列申请空间, 然后根据位操作(刚好有0,1两种情况)来决定对应位置上的字符出现还是不出现.</p>
<p>在实现时, 观察到, 第一个元素每隔两个子序列出现一次, 第二个元素每隔四个子序列出现两次, 第三个元素每隔八个子序列出现四次…</p>
<p>依次类推, 我们可以根据当前元素的位置来决定当前元素是否出现(间隔的前一半出现, 后一半不出现)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len_subsets = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>,nums.size());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(len_subsets, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len_subsets; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;&gt;i &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res[j].push_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="079-Word-Search"><a href="#079-Word-Search" class="headerlink" title="079. Word Search"></a>079. Word Search</h1><p>判断指定单词是否存在于字符数组中(可以通过上下左右邻接字符相连的才算是一个单词)</p>
<h2 id="Description-23"><a href="#Description-23" class="headerlink" title="Description"></a>Description</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>Example:</p>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.</p>
<h2 id="解法一-dfs-回溯"><a href="#解法一-dfs-回溯" class="headerlink" title="解法一: dfs+回溯"></a>解法一: dfs+回溯</h2><p><strong>时间复杂度:</strong> 暴力<br><strong>空间复杂度:</strong> $O(1)$ , 回溯时, 用<code>#</code>来记录已经遍历过的点, 无需申请额外空间来记录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word, <span class="keyword">int</span> start, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> cur_c = board[x][y];</span><br><span class="line">        <span class="keyword">if</span>(cur_c != word[start]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == word.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[x][y]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">bool</span> res=<span class="literal">false</span>, b_down=<span class="literal">false</span>, b_left=<span class="literal">false</span>, b_right=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>) res = dfs(board, word, start+<span class="number">1</span>, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; x&lt;board.size()<span class="number">-1</span>) res = dfs(board, word, start+<span class="number">1</span>, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; y&gt;<span class="number">0</span>) res = dfs(board, word, start+<span class="number">1</span>, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; y&lt;board[<span class="number">0</span>].size()<span class="number">-1</span>) res = dfs(board, word, start+<span class="number">1</span>, x, y+<span class="number">1</span>);</span><br><span class="line">        board[x][y]=cur_c;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="091-Decode-Ways"><a href="#091-Decode-Ways" class="headerlink" title="091. Decode Ways"></a>091. Decode Ways</h1><h2 id="Description-24"><a href="#Description-24" class="headerlink" title="Description"></a>Description</h2><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p>
<p>Example 1:</p>
<p>Input: “12”<br>Output: 2<br>Explanation: It could be decoded as “AB” (1 2) or “L” (12).<br>Example 2:</p>
<p>Input: “226”<br>Output: 3<br>Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).</p>
<h2 id="解法一-最优-DP-constant-space"><a href="#解法一-最优-DP-constant-space" class="headerlink" title="解法一(最优): DP constant space"></a>解法一(最优): DP constant space</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><strong>存在问题:</strong> 下面的程序在面对测例:230001或230时, 输出的不是0. 但是仍然能通过OJ, 需要注意.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || s.front()==<span class="string">"0"</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 注意, 不能用s.front() == "0"</span></span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>, f2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>) f1=<span class="number">0</span>; <span class="comment">//注意, 不能用s[i] == "0"</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span> || (s[i<span class="number">-1</span>]==<span class="string">'2'</span> &amp;&amp; s[i]&lt;=<span class="string">'6'</span>))&#123;</span><br><span class="line">                f1 = f1+f2; <span class="comment">// 令f1为前i-1字符的可能组合+前i-2字符的可能组合</span></span><br><span class="line">                f2 = f1-f2; <span class="comment">// 令f2为前i-1字符的可能组合, 也就是对于下一个i来说的前i-2的可能组合</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f2 = f1; <span class="comment">// 如果当前字符不能与前一个字符组合, 则当前字符f1不变, 而f2有变为下一个i的前i-2的可能组合, 即让新f2等于旧的f1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归-1"><a href="#解法二-递归-1" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><p><strong>时间复杂度:</strong> $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> recurve(<span class="number">0</span>,s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurve</span><span class="params">(<span class="keyword">int</span> pos, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==s.size()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[pos]==<span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp_res = recurve(pos+<span class="number">1</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;s.size()<span class="number">-1</span> &amp;&amp; (s[pos]==<span class="string">'1'</span> || (s[pos]==<span class="string">'2'</span>&amp;&amp;s[pos+<span class="number">1</span>]&lt;=<span class="string">'6'</span>))) tmp_res += recurve(pos+<span class="number">2</span>, s);</span><br><span class="line">        <span class="keyword">return</span> tmp_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="094-Binary-Tree-Inorder-Traversal"><a href="#094-Binary-Tree-Inorder-Traversal" class="headerlink" title="094. Binary Tree Inorder Traversal"></a>094. Binary Tree Inorder Traversal</h1><p>中序遍历二叉树</p>
<h2 id="Description-25"><a href="#Description-25" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>Example:</p>
<p>Input: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3</p>
<p>Output: [1,3,2]<br>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="解法一-递归-3"><a href="#解法一-递归-3" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>/**</p>
<ul>
<li>Definition for a binary tree node.</li>
<li>struct TreeNode {</li>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
<li>};<br><em>/<br>class Solution {<br>public:<br> vector<int> inorderTraversal(TreeNode</int></em> root) {<pre><code> vector&lt;int&gt; res;
 if(root==nullptr) return res;
 inorder(root, res);
 return res;
</code></pre> }<br> void inorder(TreeNode* root, vector<int> &amp;res){<pre><code> if(root-&gt;left!=nullptr) inorder(root-&gt;left, res);
 res.push_back(root-&gt;val);
 if(root-&gt;right!=nullptr) inorder(root-&gt;right, res);
</code></pre> }<br>};</int></li>
</ul>
<h2 id="解法二-非递归-2"><a href="#解法二-非递归-2" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>标准的中序非递归遍历算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s_tree;</span><br><span class="line">        <span class="keyword">while</span>(!s_tree.empty() || root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s_tree.push(root);</span><br><span class="line">                root= root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s_tree.empty())&#123;</span><br><span class="line">                root = s_tree.top(); s_tree.pop();</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="098-Validate-Binary-Search-Tree"><a href="#098-Validate-Binary-Search-Tree" class="headerlink" title="098. Validate Binary Search Tree"></a>098. Validate Binary Search Tree</h1><h2 id="Description-26"><a href="#Description-26" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:</p>
<p>Input:<br>    2<br>   / \<br>  1   3<br>Output: true<br>Example 2:</p>
<pre><code>5
</code></pre><p>   / \<br>  1   4<br>     / \<br>    3   6<br>Output: false<br>Explanation: The input is: [5,1,4,null,null,3,6]. The root node’s value<br>             is 5 but its right child’s value is 4.</p>
<h2 id="解法一-递归-4"><a href="#解法一-递归-4" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>用一个指针来指向当前节点在顺序上的前一个节点, 判断是否为BST</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre_node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> isBST(root, pre_node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBST</span><span class="params">(TreeNode* root, TreeNode * &amp;pre_node)</span></span>&#123; <span class="comment">// 注意!!! 要维持递归时的pred_node, 因此必须使用 * &amp;, 否则每次的pre_node = root;实际上只是改变了pred_node的副本</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBST(root-&gt;left, pre_node) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre_node!=<span class="literal">nullptr</span> &amp;&amp; pre_node-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre_node = root;</span><br><span class="line">        <span class="keyword">if</span>(isBST(root-&gt;right, pre_node)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>典型错误解法:</strong> 只考虑了左子树根节点值要小于当前节点值, 没有考虑应该是左子树所有的节点都应该小于当前节点的值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input</span></span><br><span class="line"><span class="comment">[10,5,15,null,null,6,20]</span></span><br><span class="line"><span class="comment">Output</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">Expected</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> b=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            b = isValidBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="literal">false</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right-&gt;val &lt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            b = isValidBST(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><p>按层次输出二叉树节点的值(每层的值要分开)</p>
<h2 id="Description-27"><a href="#Description-27" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-层次遍历"><a href="#解法一-层次遍历" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$ , 每个节点遍历一次<br><strong>空间复杂度:</strong> $O(n)$ , 存储了n个节点的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode * cur_node;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; layer;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                layer.push_back(cur_node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h1><p>按之字形打印二叉树</p>
<h2 id="Description-28"><a href="#Description-28" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
<h2 id="解法一：利用reverse"><a href="#解法一：利用reverse" class="headerlink" title="解法一：利用reverse"></a>解法一：利用reverse</h2><p>时间复杂度为 $O(n^2)$  空间复杂度为 $O(n)$</p>
<p>然后每次访问节点时，都判断当前节点的层数，如果为奇数层，则将该层直接push back到结果向量中，如果为偶数，则将该层数据进行reverse后再push back到结果向量中。通过while里面内置for循环，来保证每次for循环都会将一整层的节点放进队列中，无需额外的数组来存储depth信息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        <span class="keyword">bool</span> even = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//将vec声明在内部，省去每次的clear操作，clear操作需要对vector进行遍历，并将每个元素置为null？</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> size = que.size(); <span class="comment">//当前存的节点数目就是这一层所有的节点，之前层的到已经被取出, 并且这一层的子节点还没有开始入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123; <span class="comment">//将该层所有节点的子节点入队列，同时当到达该层最后一个节点时终止</span></span><br><span class="line">                TreeNode* tmp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(even) <span class="comment">//根据奇偶标识判断是否需要reverse</span></span><br><span class="line">                <span class="built_in">std</span>::reverse(vec.begin(), vec.end());</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            even = !even;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-最优-不用reverse"><a href="#解法二-最优-不用reverse" class="headerlink" title="解法二: 最优(不用reverse)"></a>解法二: 最优(不用reverse)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>在解法二中, 复杂度高的原因是因每次遇到偶数层的时候都要进行 reverse, 实际上, 当我们知道了该层的节点个数以后, 我们可以直接开辟一个指定大小的 vector, 然后根据下标随机访问来填入该层的节点值, 这样一来就不用进行 reverse, 并且空间复杂度与解法二相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">bool</span> is_odd = <span class="literal">true</span>;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer(layer_len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(is_odd==<span class="literal">true</span>)</span><br><span class="line">                    cur_layer[i] = cur_node-&gt;val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur_layer[layer_len<span class="number">-1</span>-i ] = cur_node-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(cur_layer);</span><br><span class="line">            is_odd = !is_odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h1><p>令每个节点中的 <code>next</code> 指针指向它的右兄弟, 如果没有右兄弟, 那么就置为 <code>nullptr</code>, <strong>注意, 题目给定的树是满二叉树</strong></p>
<h2 id="Description-29"><a href="#Description-29" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree</p>
<p>struct TreeLinkNode {<br>  TreeLinkNode <em> left;<br>  TreeLinkNode </em> right;<br>  TreeLinkNode * next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>Recursive approach is fine, implicit stack space does not count as extra space for this problem.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>Example:</p>
<p>Given the following perfect binary tree,</p>
<pre><code> 1
</code></pre><p>   /  \<br>  2    3<br> / \  / \<br>4  5  6  7<br>After calling your function, the tree should look like:</p>
<pre><code> 1 -&gt; NULL
</code></pre><p>   /  \<br>  2 -&gt; 3 -&gt; NULL<br> / \  / \<br>4-&gt;5-&gt;6-&gt;7 -&gt; NULL</p>
<h2 id="解法一-层次遍历-1"><a href="#解法一-层次遍历-1" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>显而易见可以用层次遍历, 只需额外设置一个节点指针来维护当前节点的前一个节点(左兄弟节点).</p>
<p><strong>但是</strong>, 题目中要求只能使用 $O(n)$ 的空间, 因此该解法不是最优解.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeLinkNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeLinkNode * pre, * cur;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_len = q.size();</span><br><span class="line">            pre = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len; i++)&#123;</span><br><span class="line">                cur = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pre-&gt;next = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = cur;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>) q.push(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-利用-next-指针的特性"><a href="#解法二-利用-next-指针的特性" class="headerlink" title="解法二: 利用 next 指针的特性"></a>解法二: 利用 <code>next</code> 指针的特性</h2><p><strong>时间复杂度:</strong> $O(n)$, 每个节点都要访问一次(仅访问一次)<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><strong>由于是满二叉树</strong>, 因此我们可以轻易的利用<code>next</code>指针自身的特性来实现层次遍历.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode* cur_first = root;</span><br><span class="line">        <span class="keyword">while</span>(cur_first-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeLinkNode* cur_node = cur_first;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(cur_node != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                cur_node-&gt;left-&gt;next = cur_node-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">                    cur_node-&gt;right-&gt;next = cur_node-&gt;next-&gt;left;</span><br><span class="line">                cur_node = cur_node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_first = cur_first-&gt;left;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127. Word Ladder"></a>127. Word Ladder</h1><p>实际上是图的BFS(广度优先搜索)</p>
<h2 id="Description-30"><a href="#Description-30" class="headerlink" title="Description"></a>Description</h2><p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:</p>
<p>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.<br>Example 1:</p>
<p>Input:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>Output: 5</p>
<p>Explanation: As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.<br>Example 2:</p>
<p>Input:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p>
<p>Output: 0</p>
<p>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p>
<h2 id="解法一-BFS"><a href="#解法一-BFS" class="headerlink" title="解法一: BFS"></a>解法一: BFS</h2><p><strong>时间复杂度:</strong> $O(nl)$, 其中, l 为单词的长度, 因为广度优先遍历会对每个节点遍历一次, 而每个节点计算邻居时, 需要对 l 个字母进行替换(替换26种, 常数级别), 另外, unordered_set 的 find 复杂度也为常数.<br><strong>空间复杂度:</strong> $O(n)$ 需要额外借助队列进行广度优先遍历, 另外还使用了 <code>unordered_set</code> 来存储单词表</p>
<p>我们可以将此题看做是图的广度优先搜索, 首先, 以 beginWord 为图的起始节点, 然后, 那些所有与 beginWord 只有一个字母不相同的单词都可以看做是 beginWord 的邻居节点, 依次类推, 直到找到一个单词, 与 endWord 相同为止, 此时, 返回当前 endWord 与 beginWord 的距离. (距离的记录方式和二叉树层次遍历时的方式差不多, 都是利用当前队列中的元素大小来控制<code>深度</code>的).</p>
<p>需要注意的地方有以下几点:</p>
<ul>
<li>这里的图和树不太一样, 这里图没有链表指针来指示, 因此, 在每次将某一个单词入队列以后, 都需要在单词列表中删除掉这个单词(或者额外设置标记也行), 以防止重复搜索</li>
<li>题目给的是没有重复单词的单词表, 因此推荐使用 set 结构来进行删除 (erase) 操作, vector 结构的删除 (erase) 操作的时间复杂度较高.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : wordList)</span><br><span class="line">            word_dict.insert(word);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; to_visit;</span><br><span class="line">        word_dict.erase(beginWord);</span><br><span class="line">        to_visit.push(beginWord);</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!to_visit.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = to_visit.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> word = to_visit.front(); to_visit.pop();</span><br><span class="line">                <span class="keyword">if</span>(word == endWord) <span class="keyword">return</span> dist;</span><br><span class="line">                add_next_word(word, word_dict, to_visit);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_next_word</span><span class="params">(<span class="built_in">string</span> &amp;word, <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;word_dict, <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;to_visit)</span></span>&#123;</span><br><span class="line">       <span class="comment">// word_dict.erase(word);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> letter = word[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">26</span>; k++)&#123;</span><br><span class="line">                word[i] = <span class="string">'a'</span>+k;</span><br><span class="line">                <span class="keyword">if</span>(word_dict.find(word) != word_dict.end())&#123;</span><br><span class="line">                    to_visit.push(word);</span><br><span class="line">                    word_dict.erase(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word[i] = letter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130. Surrounded Regions"></a>130. Surrounded Regions</h1><p>类似于围棋, 将被包裹住(4连通)的字符 <code>O</code> 全部转换成字符 <code>X</code>.</p>
<h2 id="Descriptioin"><a href="#Descriptioin" class="headerlink" title="Descriptioin"></a>Descriptioin</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>Example:</p>
<p>X X X X<br>X O O X<br>X X O X<br>X O X X<br>After running your function, the board should be:</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X<br>Explanation:</p>
<p>Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h2 id="解法一-递归-5"><a href="#解法一-递归-5" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, n 为 <code>board</code> 中的元素个数<br><strong>空间复杂度:</strong> $O(n)$, 递归深度优先遍历的递归次数最坏情况下为 n 次.</p>
<p>根据题目的要求, 我们可以从 <code>board</code> 的四个边界开始, 每遇到一次 <code>O</code> 就执行深度优先遍历, 将其相邻的所有 <code>O</code> 都变成另一个字符(如 <code>#</code>). 然后, 在顺序遍历整个 <code>board</code>, 将 <code>board</code> 中所有的 <code>O</code> 变成 <code>X</code>, 将所有的 <code>#</code> 变成 <code>O</code>, 即得解.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//上边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=board[i].size()<span class="number">-1</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//右边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=board.size()<span class="number">-1</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//下边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//左边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'#'</span>) board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span></span>&#123;</span><br><span class="line">        board[i][j]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==<span class="string">'O'</span>) dfs_helper(i<span class="number">-1</span>, j, board);        </span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==<span class="string">'O'</span>) dfs_helper(i, j<span class="number">-1</span>, board);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j]==<span class="string">'O'</span>) dfs_helper(i+<span class="number">1</span>, j, board);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;board[i].size()<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>]==<span class="string">'O'</span>) dfs_helper(i, j+<span class="number">1</span>, board); <span class="comment">//注意是 j&lt;board[i].size()-1, 不是 board.size()-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-1"><a href="#解法二-迭代-1" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, n 为 <code>board</code> 中的元素个数<br><strong>空间复杂度:</strong> $O(n)$, 额外申请队列的大小为 n</p>
<p>思想和解法一相同, 不过采用 BFS 迭代实现, 利用一个队列来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//上边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=board[i].size()<span class="number">-1</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//右边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=board.size()<span class="number">-1</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//下边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//左边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'#'</span>) board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs_helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; bfs_q;</span><br><span class="line">        <span class="keyword">int</span> len = board[i].size();</span><br><span class="line">        bfs_q.push(i*len +j);</span><br><span class="line">        board[i][j]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">while</span>(!bfs_q.empty())&#123;</span><br><span class="line">            i = bfs_q.front()/len; j = bfs_q.front()%len; bfs_q.pop();           </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==<span class="string">'O'</span>)&#123;  board[i<span class="number">-1</span>][j]=<span class="string">'#'</span>;bfs_q.push( (i<span class="number">-1</span>)*len+j); &#125;  <span class="comment">//注意这里一定要更改了字符以后再存入队列, 负责可能引起字符重复入队列, 最终内存超限</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==<span class="string">'O'</span>) &#123; board[i][j<span class="number">-1</span>]=<span class="string">'#'</span>; bfs_q.push( i*len+j<span class="number">-1</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j]==<span class="string">'O'</span>) &#123;  board[i+<span class="number">1</span>][j]=<span class="string">'#'</span>; bfs_q.push( (i+<span class="number">1</span>)*len + j );&#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;board[i].size()<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>]==<span class="string">'O'</span>) &#123;  board[i][j+<span class="number">1</span>]=<span class="string">'#'</span>; bfs_q.push( i*len + j+<span class="number">1</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h1><p>划分回文子串</p>
<h2 id="Description-31"><a href="#Description-31" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-回溯-验证回文子串"><a href="#解法一-回溯-验证回文子串" class="headerlink" title="解法一: 回溯+验证回文子串"></a>解法一: 回溯+验证回文子串</h2><p><strong>时间复杂度:</strong> $O(n\times 2^n)$, 其中, 可能的 partition 情况最多有 $2^n$ 种, 而对于每一种都要进行复杂度为 $O(n)$ 的回文子串检查<br><strong>空间复杂度:</strong> $O(n\times 2^n)$ ? 数组 <code>res</code> 的大小最坏情况下可达 $(n\times 2^n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; part_res;</span><br><span class="line">        dfs(s, <span class="number">0</span>, part_res, res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;part_res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.push_back(part_res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_palin(start, i, s))&#123;</span><br><span class="line">                part_res.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                dfs(s, i+<span class="number">1</span>, part_res, res);</span><br><span class="line">                part_res.pop_back();</span><br><span class="line"></span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_palin</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;end--;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-回溯-DP"><a href="#解法二-回溯-DP" class="headerlink" title="解法二: 回溯+DP"></a>解法二: 回溯+DP</h2><p><strong>时间复杂度:</strong> $O(2^n)$, 利用 DP 建立一个 $n\times n$ 的 bool 数组, 其中 <code>dp[i][j]</code> 代表字符串从第 i 个字符开始, 到第 j 个字符组成的子串是否为回文串. 因此, 检查回文串时无需执行 $O(n)$ 的检查.<br><strong>空间复杂度:</strong> $O(n\times 2^n + n^2)$, 需要额外的数组空间来实现 DP.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; part_res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=j; i++)&#123; <span class="comment">// 注意这两个for循环的顺序和控制条件, dp算法一定要保证在计算当前元素时, 之前的元素已经计算完成并且存入到了数组当中, 否则建立出的dp数组会出现漏解</span></span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j] &amp;&amp; (j-i&lt;=<span class="number">2</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="literal">true</span>))</span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(s, <span class="number">0</span>, part_res, res, dp);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;part_res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;dp )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.push_back(part_res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[start][i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                part_res.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                dfs(s, i+<span class="number">1</span>, part_res, res, dp);</span><br><span class="line">                part_res.pop_back();</span><br><span class="line"></span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_palin</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;end--;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. Gas Station</h1><p>加油站问题, 根据油量和消耗量判断是否能走完一圈</p>
<h2 id="Description-32"><a href="#Description-32" class="headerlink" title="Description"></a>Description</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p>Note:</p>
<p>If there exists a solution, it is guaranteed to be unique.<br>Both input arrays are non-empty and have the same length.<br>Each element in the input arrays is a non-negative integer.<br>Example 1:</p>
<p>Input:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p>
<p>Output: 3</p>
<p>Explanation:<br>Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 4. Your tank = 4 - 1 + 5 = 8<br>Travel to station 0. Your tank = 8 - 2 + 1 = 7<br>Travel to station 1. Your tank = 7 - 3 + 2 = 6<br>Travel to station 2. Your tank = 6 - 4 + 3 = 5<br>Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.<br>Therefore, return 3 as the starting index.<br>Example 2:</p>
<p>Input:<br>gas  = [2,3,4]<br>cost = [3,4,3]</p>
<p>Output: -1</p>
<p>Explanation:<br>You can’t start at station 0 or 1, as there is not enough gas to travel to the next station.<br>Let’s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 0. Your tank = 4 - 3 + 2 = 3<br>Travel to station 1. Your tank = 3 - 3 + 3 = 3<br>You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.<br>Therefore, you can’t travel around the circuit once no matter where you start.</p>
<h2 id="解法-最优"><a href="#解法-最优" class="headerlink" title="解法: 最优"></a>解法: 最优</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>首先要知道, 如果总油量大于总消耗量, 那么就一定存在一个起始点, 使得可以走完全程. 因此, 设置两个变量 <code>total_left</code> 和 <code>cur_left</code>, 前者存储从0点开始的总的剩余量, 后者存储从起点 <code>start</code> 开始的剩余量. 当 <code>cur_left&lt;=0</code> 时, 说明从 <code>start</code> 开始一直到当前位置之间的任何一个加油站都不能够成为起点, 因此将 <code>start</code> 置为下一个位置, 重新开始, 并令 <code>cur_left=0</code>. 在遍历完所有加油站以后, 如果总的剩余量不小于0, 则此时 <code>start</code> 所指的位置就一定是解.(由题意知, 该解是唯一解).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total_left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gas.size(); i++)&#123;</span><br><span class="line">            total_left += gas[i]-cost[i];</span><br><span class="line">            cur_left += gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(cur_left&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">                cur_left=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total_left &lt; <span class="number">0</span> ? <span class="number">-1</span>:start;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h1><p>复杂链表的复制, 复制带有随机指针的链表</p>
<h2 id="Description-33"><a href="#Description-33" class="headerlink" title="Description"></a>Description</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h2 id="解法一-复制-拆分"><a href="#解法一-复制-拆分" class="headerlink" title="解法一: 复制+拆分"></a>解法一: 复制+拆分</h2><p><strong>时间复杂度:</strong> $O(n)$,  遍历三次链表<br><strong>空间复杂度:</strong> $O(1)$, 不包括复制链表占用的空间</p>
<p>先将每个节点复制到对应节点的后面, 然后给随机指针进行赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode *cur_node = head; RandomListNode *copy_node;</span><br><span class="line">        <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            copy_node = <span class="keyword">new</span> RandomListNode(cur_node-&gt;label);</span><br><span class="line">            copy_node-&gt;next = cur_node-&gt;next;</span><br><span class="line">            cur_node-&gt;next = copy_node;</span><br><span class="line">            cur_node = cur_node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_node = head;</span><br><span class="line">        <span class="keyword">while</span>(cur_node != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            copy_node = cur_node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;random!=<span class="literal">nullptr</span>)</span><br><span class="line">                copy_node-&gt;random = cur_node-&gt;random-&gt;next;</span><br><span class="line">            cur_node = cur_node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_node = head;</span><br><span class="line">        copy_node = head-&gt;next;</span><br><span class="line">        RandomListNode *copy_head = copy_node;</span><br><span class="line">        <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur_node-&gt;next = copy_node-&gt;next;</span><br><span class="line">            cur_node = cur_node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(cur_node==<span class="literal">nullptr</span>) <span class="keyword">break</span>; <span class="comment">// 一定不要忘了尾部的空指针判断, 不要想空指针进行赋值操作.</span></span><br><span class="line">            copy_node-&gt;next = cur_node-&gt;next;</span><br><span class="line">            copy_node = copy_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-一次遍历-1"><a href="#解法二-一次遍历-1" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 需要申请链表长度的哈希表</p>
<p>利用一个哈希表来存储已经访问过的节点, 哈希表的键值为: <code>{cur_node, copy_node}</code>, 其中, <code>cur_node</code> 代表旧链表中的节点, <code>copy_node</code> 代表新链表中的节点. 顺序遍历旧链表, 对于旧链表中的每一个节点, 查看其 <code>next</code> 节点是否存在于哈希表 <code>visit</code> 中, 如果存在, 则将 <code>copy_node</code> 的 <code>next</code> 指针指向该节点(键)对应的复制节点(值). 对于 <code>random</code> 指针也是同理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode *cur_node = head;</span><br><span class="line">        RandomListNode *copy_node = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; visit;  <span class="comment">// key: old_node, value: copy_node</span></span><br><span class="line">        visit.insert(&#123;cur_node, copy_node&#125;); <span class="comment">//注意不要少了花括号</span></span><br><span class="line">        <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">            RandomListNode *next_node=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;next==<span class="literal">nullptr</span>) copy_node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visit.find(cur_node-&gt;next)==visit.end())&#123;</span><br><span class="line">                next_node = <span class="keyword">new</span> RandomListNode(cur_node-&gt;next-&gt;label);</span><br><span class="line">                copy_node-&gt;next = next_node;</span><br><span class="line">                visit.insert(&#123;cur_node-&gt;next, next_node&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                copy_node-&gt;next = visit[cur_node-&gt;next];</span><br><span class="line"></span><br><span class="line">            RandomListNode *random_node=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;random==<span class="literal">nullptr</span>) copy_node-&gt;random = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visit.find(cur_node-&gt;random) == visit.end())&#123;</span><br><span class="line">                random_node = <span class="keyword">new</span> RandomListNode(cur_node-&gt;random-&gt;label);</span><br><span class="line">                copy_node-&gt;random = random_node;</span><br><span class="line">                visit.insert(&#123;cur_node-&gt;random, random_node&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                copy_node-&gt;random = visit[cur_node-&gt;random];</span><br><span class="line"></span><br><span class="line">            cur_node = cur_node-&gt;next;</span><br><span class="line">            copy_node = copy_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visit[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-递归"><a href="#解法三-递归" class="headerlink" title="解法三: 递归"></a>解法三: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 除了哈希表所占空间外, 递归还需额外空间, 但是可以近似看做是 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; visit;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit.find(head)!=visit.end())</span><br><span class="line">            <span class="keyword">return</span> visit[head];</span><br><span class="line">        RandomListNode *node = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line"></span><br><span class="line">        visit.insert(&#123;head, node&#125;);</span><br><span class="line">        node-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">        node-&gt;random = copyRandomList(head-&gt;random);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a>139. Word Break</h1><p>判断字符串是否可以划分成字典里面的单词</p>
<h2 id="Description-34"><a href="#Description-34" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<p>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.<br>Example 1:</p>
<p>Input: s = “leetcode”, wordDict = [“leet”, “code”]<br>Output: true<br>Explanation: Return true because “leetcode” can be segmented as “leet code”.<br>Example 2:</p>
<p>Input: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>Output: true<br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”.<br>             Note that you are allowed to reuse a dictionary word.<br>Example 3:</p>
<p>Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output: false</p>
<h2 id="解法一-回溯-1"><a href="#解法一-回溯-1" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong> 超时<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  纯回溯实现, 复杂度很高, 很容易超时</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">return</span> helper(s,<span class="number">-1</span>,word_dict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> seg, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;word_dict)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seg==s.size()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=seg+<span class="number">1</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            temp+=s[i];</span><br><span class="line">            <span class="keyword">if</span>(word_dict.find(temp) != word_dict.end() &amp;&amp; helper(s, i, word_dict)==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP"><a href="#解法二-DP" class="headerlink" title="解法二: DP"></a>解法二: DP</h2><p><strong>时间复杂度:</strong> $O(n^2)$, $n$ 为字符串的长度<br><strong>空间复杂度:</strong> $O(n)$, dp 数组额外空间, unordered_set 额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&lt;<span class="number">0</span> || dp[j<span class="number">-1</span>]==<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="built_in">string</span> temp = s.substr(j, i-j+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(word_dict.find(temp) != word_dict.end())&#123;</span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// break to next i</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-DP"><a href="#解法三-DP" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为字符串的长度, $m$ 为字典的 size<br><strong>空间复杂度:</strong> $O(n)$, dp 数组额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;wordDict.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=wordDict[j].size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> len = wordDict[j].size();</span><br><span class="line">                    <span class="built_in">string</span> temp= s.substr(i-len+<span class="number">1</span>, len);                    </span><br><span class="line">                    <span class="keyword">if</span>(temp == wordDict[j] &amp;&amp; ((i-len)&lt;<span class="number">0</span> || dp[i-len]==<span class="literal">true</span>))<span class="comment">// 这里注意, .size() 返回的类型并不是int, 如果使用i-wordDict[j].size() &lt;0, 就会造成runtime error, 正确做法是进行强制的类型转换, 或者用一个int变量代表之.</span></span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h1><p>对链表进行排序, 要求时间复杂度为 $O(nlogn)$, 空间复杂度为常数</p>
<h2 id="Description-35"><a href="#Description-35" class="headerlink" title="Description"></a>Description</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p>Example 1:</p>
<p>Input: 4-&gt;2-&gt;1-&gt;3<br>Output: 1-&gt;2-&gt;3-&gt;4<br>Example 2:</p>
<p>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<h2 id="解法一-递归-6"><a href="#解法一-递归-6" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(logn)$</p>
<p>首先对于链表的排序最先想到的就是归并排序, 因为题目的要求是空间复杂度为常数, 因为不能使用递归实现(递归会占用额外空间), 但是, 递归是一种很好理解的排序方法, 因此, 这里我们先给链表归并排序的递归实现.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head; <span class="comment">//链表中至少应有两个元素, 否则不能进行融合, 会产生运行时错误</span></span><br><span class="line">        ListNode *slow=head, *fast=head, *pre=head; <span class="comment">// 两指针, 找到最中间的元素, 用slow指向</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 将前后两个链断开</span></span><br><span class="line"></span><br><span class="line">        ListNode* sort1 = sortList(head); <span class="comment">// 将前一半排序</span></span><br><span class="line">        ListNode* sort2 = sortList(slow); <span class="comment">// 将后一半排序</span></span><br><span class="line">        <span class="keyword">return</span> merge_sort(sort1, sort2); <span class="comment">// 融合两个有序链表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge_sort</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>) cur-&gt;next = l2; <span class="comment">// 将最后的一个非空元素加入排序链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-2"><a href="#解法二-迭代-2" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>接下来, 我们考虑如何实现归并排序的迭代算法, 代码如下:</p>
<p>TODO</p>
<h1 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a>150. Evaluate Reverse Polish Notation</h1><p>计算逆波兰表达式</p>
<h2 id="Description-36"><a href="#Description-36" class="headerlink" title="Description"></a>Description</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Note:</p>
<p>Division between two integers should truncate toward zero.<br>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.<br>Example 1:</p>
<p>Input: [“2”, “1”, “+”, “3”, “<em>“]<br>Output: 9<br>Explanation: ((2 + 1) </em> 3) = 9<br>Example 2:</p>
<p>Input: [“4”, “13”, “5”, “/“, “+”]<br>Output: 6<br>Explanation: (4 + (13 / 5)) = 6<br>Example 3:</p>
<p>Input: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>Output: 22<br>Explanation:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p>
<h2 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 需要一个额外的栈来存储中间结果</p>
<p>用栈来实现, 从到开始扫描字符串vector, 如果当前字符串不为运算符, 则直接入栈, 如果为运算符 , 则取栈顶两个元素进行运算然后将计算结果入栈. 最终, 栈中只剩一个结果值</p>
<p>需要注意的是: 首先要确保输入的逆波兰表达式是没有问题的, 其次还有要进行零除判断, 这几点本题没有考查, 但仍需注意</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;  polish;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> token : tokens)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="keyword">if</span>(token.back()==<span class="string">'+'</span> || token.back()==<span class="string">'-'</span> || token.back()==<span class="string">'*'</span> || token.back()==<span class="string">'/'</span>)&#123; <span class="comment">// 用back的原因是数字有可能是 -13 这种形式</span></span><br><span class="line">                b = polish.top(); polish.pop();</span><br><span class="line">                a = polish.top(); polish.pop();</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">switch</span>(token.back())&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: c=a+b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: c=a-b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>: c=a*b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>: c= (b==<span class="number">0</span>) ? <span class="number">0</span> : a/b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: c = c=<span class="built_in">std</span>::stoi(token);</span><br><span class="line">            &#125;</span><br><span class="line">            polish.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> polish.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-栈-异常"><a href="#解法二-栈-异常" class="headerlink" title="解法二: 栈+异常"></a>解法二: 栈+异常</h2><p>解法与上面相同, 不同借助了异常, 显得更加简洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rpn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;tokens.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                rpn.push(stoi(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (exception e)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = rpn.top(); rpn.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = rpn.top(); rpn.pop();</span><br><span class="line">                <span class="keyword">switch</span>(tokens[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: rpn.push(num2+num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: rpn.push(num2-num1);<span class="keyword">break</span>;</span><br><span class="line">                    case '* ': rpn.push(num2*num1);break;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: rpn.push(num2/num1);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rpn.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> rpn.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-栈-lambda"><a href="#解法三-栈-lambda" class="headerlink" title="解法三: 栈+lambda"></a>解法三: 栈+lambda</h2><p><strong>思路与解法一一直, 另一种写法:</strong> 借助哈希表和lambda表达式, 使程序更加整洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; op_map=&#123;</span><br><span class="line">            &#123;<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;&#125;, <span class="comment">//注意要用双引号, 因为token是stirng类型, 而不是char类型</span></span><br><span class="line">            &#123;<span class="string">"-"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a-b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a*b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"/"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> (b==<span class="number">0</span>) ? <span class="number">0</span> : a/b;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;  polish;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!op_map.count(token))</span><br><span class="line">                polish.push(<span class="built_in">std</span>::stoi(token));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> b = polish.top(); polish.pop();</span><br><span class="line">                <span class="keyword">int</span> a = polish.top(); polish.pop();</span><br><span class="line">                polish.push(op_map[token](a, b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> polish.top();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a>152. Maximum Product Subarray</h1><p>求连续子序列的最大乘积</p>
<h2 id="Description-37"><a href="#Description-37" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:</p>
<p>Input: [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.<br>Example 2:</p>
<p>Input: [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p>
<h2 id="解法一-递归-7"><a href="#解法一-递归-7" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(n)$, 递归 $n$ 次</p>
<p>这道题和连续子序列的最大和比较相似, 但是更难一些, 我们需要考虑负负得正这种情况, 因此, 我们不仅仅要维护最大值, 还要维护最小值. 考虑利用递归的方法来实现, 假设我们现在已经知道了以第 <code>i-1</code> 个数为结尾的连续子序列的最大乘积值<code>max</code>和最小乘积值<code>min</code>, 那么如果数组中新来一个数 <code>nums[i]</code>, 则以第 <code>i</code> 个数为结尾的连续子序列的最大乘积就一定是<code>max * nums[i]</code>, <code>min*nums[i]</code>, <code>nums[i]</code>之中的最大者, 最小值为这三者的最小者. 由于我们还不知道最终的连续子序列是以第几个字符为结尾的, 因此我们利用一个变量<code>res</code>来维护当前找到的最大的子序列乘积, 并且随着循环的进行不断更新这个值, 最终, <code>res</code>的值就是我们要求的解, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        helper(nums, nums.size()<span class="number">-1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; helper(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index, <span class="keyword">int</span> &amp;res)&#123; <span class="comment">//注意这里要设置一个引用res来不断更新最大值</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) <span class="keyword">return</span> make_pair(nums[<span class="number">0</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; max_min = helper(nums, index<span class="number">-1</span>, res);</span><br><span class="line">        <span class="keyword">int</span> a = max_min.first * nums[index];</span><br><span class="line">        <span class="keyword">int</span> b = max_min.second * nums[index];</span><br><span class="line">        <span class="keyword">int</span> c = nums[index];</span><br><span class="line">        max_min.first = max(a, max(b,c));</span><br><span class="line">        max_min.second = min(a, min(b,c));</span><br><span class="line">        res = max(res, max_min.first);</span><br><span class="line">        <span class="keyword">return</span> max_min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP-迭代"><a href="#解法二-DP-迭代" class="headerlink" title="解法二: DP 迭代"></a>解法二: DP 迭代</h2><p>上面的递归写法, 可以转换成DP迭代, 为此需要两个dp数组, 一个用来保存以第i个元素为结尾的连续子序列的最大值, 另一个保存最小值. 代码如下:</p>
<p><strong>写法一: new数组</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> *dp_max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()]();</span><br><span class="line">        <span class="keyword">int</span> *dp_min = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()]();</span><br><span class="line">        dp_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp_min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = dp_max[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> b = dp_min[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> c = nums[i];</span><br><span class="line">            dp_max[i] = max(a, max(b,c));</span><br><span class="line">            dp_min[i] = min(a, min(b,c));</span><br><span class="line">            res = max(res, dp_max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] dp_max;</span><br><span class="line">        <span class="keyword">delete</span>[] dp_min;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二: vector数组:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CCclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp_max(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp_min(nums.size(), <span class="number">0</span>);</span><br><span class="line">        dp_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp_min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = dp_max[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> b = dp_min[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> c = nums[i];</span><br><span class="line">            dp_max[i] = max(a, max(b,c));</span><br><span class="line">            dp_min[i] = min(a, min(b,c));</span><br><span class="line">            res = max(res, dp_max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a>162. Find Peak Element</h1><h2 id="Description-局部最大值"><a href="#Description-局部最大值" class="headerlink" title="Description: 局部最大值"></a>Description: 局部最大值</h2><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that nums[-1] = nums[n] = -∞.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1]<br>Output: 2<br>Explanation: 3 is a peak element and your function should return the index number 2.<br>Example 2:</p>
<p>Input: nums = [1,2,1,3,5,6,4]<br>Output: 1 or 5<br>Explanation: Your function can return either index number 1 where the peak element is 2,<br>             or index number 5 where the peak element is 6.</p>
<h2 id="解法一-O-n-复杂度"><a href="#解法一-O-n-复杂度" class="headerlink" title="解法一: $O(n)$ 复杂度"></a>解法一: $O(n)$ 复杂度</h2><p>$O(n)$ 的时间复杂度, 不合符题目要求, 仅仅记录一下.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">1</span> || nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.size()<span class="number">-2</span>] &lt; nums[nums.size()<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-O-logn-复杂度"><a href="#解法二-O-logn-复杂度" class="headerlink" title="解法二: $O(logn)$ 复杂度"></a>解法二: $O(logn)$ 复杂度</h2><p>二分查找, 分为以下几种情况:</p>
<ul>
<li>If num[i-1] &lt; num[i] &gt; num[i+1], then num[i] is peak</li>
<li>If num[i-1] &lt; num[i] &lt; num[i+1], then num[i+1…n-1] must contains a peak</li>
<li>If num[i-1] &gt; num[i] &gt; num[i+1], then num[0…i-1] must contains a peak</li>
<li>If num[i-1] &gt; num[i] &lt; num[i+1], then both sides have peak</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.size()<span class="number">-1</span>;        </span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high<span class="number">-1</span>)&#123; <span class="comment">//避免low和high相邻, 使得mid-1或mid+1可能非法</span></span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid<span class="number">-1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>]) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low]&gt;nums[high] ? low : high; <span class="comment">// 当low或high相邻时, 即为两端时的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="166-Fraction-to-Recurring-Decimal"><a href="#166-Fraction-to-Recurring-Decimal" class="headerlink" title="166. Fraction to Recurring Decimal"></a>166. Fraction to Recurring Decimal</h1><h2 id="Description-无限循环小数"><a href="#Description-无限循环小数" class="headerlink" title="Description: 无限循环小数"></a>Description: 无限循环小数</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>Example 1:</p>
<p>Input: numerator = 1, denominator = 2<br>Output: “0.5”<br>Example 2:</p>
<p>Input: numerator = 2, denominator = 1<br>Output: “2”<br>Example 3:</p>
<p>Input: numerator = 2, denominator = 3<br>Output: “0.(6)”</p>
<h2 id="解法一-用余数作为哈希表的key"><a href="#解法一-用余数作为哈希表的key" class="headerlink" title="解法一: 用余数作为哈希表的key"></a>解法一: 用余数作为哈希表的key</h2><p><strong>时间复杂度:</strong> $O(logn)$, 每次都会乘以10再取余数<br><strong>空间复杂度:</strong> $O(logn)$, 余数的哈希表</p>
<p>首先, 获取最终浮点数的符号和整数部分, 此处由于可能出现分子为<code>-2147483648</code>, 而分母为<code>-1</code>的情况, 为此, 建议使用<code>long</code>长整型来避免溢出.<br>在计算小数部分时, 将余数作为<code>key</code>, 小数当前位置作为<code>value</code>存入哈希表中, 然后将余数乘以10, 再计算当前小数位的值, 并将取余得到新的余数.<br>题目指明浮点数是无限循环小数, 则如果小数部分没有循环, 那么一定会出现余数为0的情况, 此时, 返回当前的<code>res</code>即可. 如果小数存在循环, 那么循环一定出现在余数相同的时刻, 此时, 将添加后扩号, 并根据哈希表中的<code>value</code>添加前括号.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numerator == <span class="number">0</span> || denominator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span>(numerator&lt;<span class="number">0</span> ^ denominator&lt;<span class="number">0</span>) res+=<span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> numer = (numerator &lt; <span class="number">0</span>) ? (<span class="keyword">long</span>)(numerator)*<span class="number">-1</span> : (<span class="keyword">long</span>)numerator; <span class="comment">// 注意, 不能写成 (long)(numerator*-1)</span></span><br><span class="line">        <span class="keyword">long</span> denom = (denominator &lt; <span class="number">0</span>) ? (<span class="keyword">long</span>)(denominator)*<span class="number">-1</span> : (<span class="keyword">long</span>)denominator;</span><br><span class="line">        <span class="keyword">long</span> integral = numer/denom;</span><br><span class="line">        res += <span class="built_in">std</span>::to_string(integral); <span class="comment">// 添加整数部分</span></span><br><span class="line">        <span class="keyword">long</span> rmd = numer % denom;</span><br><span class="line">        <span class="keyword">if</span>(rmd!=<span class="number">0</span>)</span><br><span class="line">            res += <span class="string">"."</span>; <span class="comment">// 存在小数</span></span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; hash;</span><br><span class="line">        <span class="keyword">while</span>(rmd!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.find(rmd) != hash.end())&#123; <span class="comment">// 判断余数</span></span><br><span class="line">                res.insert(hash[rmd], <span class="string">"("</span>);</span><br><span class="line">                res += <span class="string">")"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[rmd] = res.size();</span><br><span class="line">            rmd = rmd*<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">long</span> quotient = rmd/denom;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(quotient);</span><br><span class="line">            rmd = rmd%denom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="179-Largest-Number"><a href="#179-Largest-Number" class="headerlink" title="179. Largest Number"></a>179. Largest Number</h1><h2 id="Description-排列数字使其字符串形式的数字为最大"><a href="#Description-排列数字使其字符串形式的数字为最大" class="headerlink" title="Description: 排列数字使其字符串形式的数字为最大"></a>Description: 排列数字使其字符串形式的数字为最大</h2><p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>Example 1:</p>
<p>Input: [10,2]<br>Output: “210”<br>Example 2:</p>
<p>Input: [3,30,34,5,9]<br>Output: “9534330”</p>
<h2 id="解法一-构造比较函数-快排排序"><a href="#解法一-构造比较函数-快排排序" class="headerlink" title="解法一: 构造比较函数, 快排排序"></a>解法一: 构造比较函数, 快排排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 快排时间复杂度<br><strong>空间复杂度:</strong> $O(logn)$, 快排空间复杂度, <strong>如果使用其他排序算法, 可将空间复杂度降为 $O(1)$</strong></p>
<p>我们可以构造一个新的比较函数来决定两个元素的先后关系, 对于任意两个元素 <code>a</code> 和 <code>b</code>, 首先将其转换成字符串形式 <code>s_a</code> 和 <code>s_b</code>, 我们知道, 若整形 a&gt;b, 则一定有 <code>s_a</code> &gt; <code>s_b</code>, 因此我们可以比较 <code>s_a+s_b</code> 和 <code>s_b+s_a</code> 的大小关系, 根据题目要求, 我们要进行递减排序. 得到比较函数以后, 利用快排排序即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        q_sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);        </span><br><span class="line">        <span class="keyword">if</span>(nums.size()!=<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>; <span class="comment">// 对于输入[0, 0, 0] 应该返回 "0", 而不是"000", 必须要放在排序后, nums[0] == 0 说明所有元素均为0</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">str_geq</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s_a = <span class="built_in">std</span>::to_string(a);</span><br><span class="line">        <span class="built_in">string</span> s_b = <span class="built_in">std</span>::to_string(b);</span><br><span class="line">        <span class="keyword">if</span>(s_a+s_b &gt;= s_b+s_a) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//注意是递减排序, 所以为 &gt;=</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; str_geq(P, nums[high])) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; str_geq(nums[low], P)) low++;</span><br><span class="line">            nums[high] = nums[low];                  </span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, low, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;low) q_sort(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) q_sort(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-利用-STL-sort-函数"><a href="#解法二-利用-STL-sort-函数" class="headerlink" title="解法二: 利用 STL sort() 函数"></a>解法二: 利用 STL sort() 函数</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 快排时间复杂度<br><strong>空间复杂度:</strong> $O(logn)$, 快排空间复杂度, <strong>如果使用其他排序算法, 可将空间复杂度降为 $O(1)$</strong></p>
<p>思路与解法一一致, 只不过省略了排序算法的实现, 使用了 STL 的 <code>sort</code> 函数.</p>
<p><strong>需要注意, 在 C++ STL 的 sort 函数中, bool 返回真的时候, 必须是绝对大于或者绝对小于, 对于等于的情况, 只能返回 false</strong>(因为当返回 true 时, 元素会继续下一个, 这样对于极端情况, 如所有元素都一样时, 会出现越界, 从而导致段错误)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">str_geq</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">    <span class="built_in">string</span> s_a = <span class="built_in">std</span>::to_string(a);</span><br><span class="line">    <span class="built_in">string</span> s_b = <span class="built_in">std</span>::to_string(b);</span><br><span class="line">    <span class="keyword">if</span>(s_a+s_b &gt; s_b+s_a) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这里用 &gt;= 会产生运行时错误, 用 &gt; 则可以通过, 为什么?</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end(), str_geq);     </span><br><span class="line">        <span class="keyword">if</span>(nums.size()!=<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>; <span class="comment">// 对于输入[0, 0, 0] 应该返回 "0", 而不是"000", 必须要放在排序后, nums[0] == 0 说明所有元素均为0</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(num);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法刷题/" rel="tag"><i class="fa fa-tag"></i> 算法刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/z_post/面试-Cpp面试总结/" rel="prev" title="C++面试总结">
                <i class="fa fa-chevron-left"></i> C++面试总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/z_post/面试-算法刷题-LeetCode-1/" rel="next" title="LeetCode算法题(Easy)">
                LeetCode算法题(Easy) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar_zz.png"
                alt="ZeroZone" />
            
              <p class="site-author-name" itemprop="name">ZeroZone</p>
              <p class="site-description motion-element" itemprop="description">并不是什么厉害的地方<br>只是一个安静的学习角落</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">194</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hellozhaozheng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hellozhaozheng@foxmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/ksws0292756" title="CSDN博客" target="_blank">CSDN博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#002-Add-Two-Numbers"><span class="nav-text">002. Add Two Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序相加-注意进位"><span class="nav-text">解法一: 顺序相加, 注意进位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题"><span class="nav-text">扩展问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#003-Longest-Substring-Without-Repeating-Characters"><span class="nav-text">003. Longest Substring Without Repeating Characters</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-1"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力"><span class="nav-text">解法一:暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-前后两个指示变量"><span class="nav-text">解法二: 前后两个指示变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二的另一种写法"><span class="nav-text">解法二的另一种写法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#005-Longest-Palindromic-Substring-最大回文子串"><span class="nav-text">005. Longest Palindromic Substring(最大回文子串)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-2"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：最长公共子串"><span class="nav-text">解法一：最长公共子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：-穷举"><span class="nav-text">解法二： 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：-动态规划"><span class="nav-text">解法三： 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：-扩展中心法"><span class="nav-text">解法三： 扩展中心法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法五-马拉车-Manacher-算法"><span class="nav-text">解法五: 马拉车(Manacher) 算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#008"><span class="nav-text">008.</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-3"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一"><span class="nav-text">解法一:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#011-Container-With-Most-Water"><span class="nav-text">011. Container With Most Water</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-4"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-1"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-用两个指针"><span class="nav-text">解法二: 用两个指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#015-3Sum"><span class="nav-text">015. 3Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-5"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-固定一个数-按照two-sum的方式来解"><span class="nav-text">解法一: 固定一个数, 按照two sum的方式来解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#017-Letter-Combinations-of-a-Phone-Number"><span class="nav-text">017. Letter Combinations of a Phone Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-6"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C"><span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一-递归"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法二-非递归"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python"><span class="nav-text">Python</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一-利用reduce实现"><span class="nav-text">解法一: 利用reduce实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#019-Remove-Nth-Node-From-End-of-List"><span class="nav-text">019. Remove Nth Node From End of List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-7"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历两次"><span class="nav-text">解法一: 遍历两次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只遍历一次"><span class="nav-text">只遍历一次</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#022-Generate-Parentheses"><span class="nav-text">022. Generate Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-8"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-2"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归"><span class="nav-text">解法二: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-用栈来模拟递归"><span class="nav-text">解法三: 用栈来模拟递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#029-Divide-Two-Integers"><span class="nav-text">029. Divide Two Integers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-9"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-循环加法"><span class="nav-text">解法一: 循环加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-左移法"><span class="nav-text">解法二: 左移法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展-这道题如果不允许使用long-或者long-long-怎么解"><span class="nav-text">扩展: 这道题如果不允许使用long 或者long long 怎么解?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#033-Search-in-Rotated-Sorted-Array"><span class="nav-text">033. Search in Rotated Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-10"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-二分查找"><span class="nav-text">解法一: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-二分查找"><span class="nav-text">解法二: 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#034-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="nav-text">034. Find First and Last Position of Element in Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-11"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-1"><span class="nav-text">解法一:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-二分查找-1"><span class="nav-text">解法二: 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#036-Valid-Sudoku"><span class="nav-text">036 Valid Sudoku</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-12"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-利用flag数组存储判断矩阵"><span class="nav-text">解法一: 利用flag数组存储判断矩阵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#046-Permutations"><span class="nav-text">046 Permutations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-13"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-1"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代"><span class="nav-text">解法二: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-利用C-的内置函数"><span class="nav-text">解法三: 利用C++的内置函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#048-Rotate-Image"><span class="nav-text">048. Rotate Image</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-14"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-逆置-转置"><span class="nav-text">解法一: 逆置+转置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-转置-列向量逆置"><span class="nav-text">解法二: 转置+列向量逆置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充-逆时针旋转90度"><span class="nav-text">补充: 逆时针旋转90度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#049-Group-Anagrams"><span class="nav-text">049. Group Anagrams</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-15"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-sort"><span class="nav-text">解法一: 哈希表+sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表-不使用sort"><span class="nav-text">解法二: 哈希表(不使用sort)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#050-Pow-x-n"><span class="nav-text">050. Pow(x, n)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Descriptin"><span class="nav-text">Descriptin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-2"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归-1"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#054-Spiral-Matrix"><span class="nav-text">054. Spiral Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-16"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-按层次输出-由外而内"><span class="nav-text">解法: 按层次输出(由外而内)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#055-Jump-Game"><span class="nav-text">055. Jump Game</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-17"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯"><span class="nav-text">解法一: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-top-down-动态规划-递归"><span class="nav-text">解法二: top-down 动态规划(递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-down-top-动态规划-非递归"><span class="nav-text">解法三: down-top 动态规划(非递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-贪心"><span class="nav-text">解法四: 贪心</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#056-Merge-Intervals"><span class="nav-text">056. Merge Intervals</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-18"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-sort-O-n"><span class="nav-text">解法一: sort+O(n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-sort-O-1"><span class="nav-text">解法二: sort+O(1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-不使用sort"><span class="nav-text">解法三: 不使用sort</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#062-Unique-Paths"><span class="nav-text">062. Unique Paths</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-19"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP"><span class="nav-text">解法一: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-优化的DP"><span class="nav-text">解法二: 优化的DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-排列组合-最优"><span class="nav-text">解法三: 排列组合(最优)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#073-Set-Matrix-Zeroes"><span class="nav-text">073. Set Matrix Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-20"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-穷举-减少空间复杂度"><span class="nav-text">解法二: 穷举(减少空间复杂度)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-穷举-空间复杂度-O-1"><span class="nav-text">解法三: 穷举(空间复杂度 $O(1)$ )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-用第一行和第一列记录"><span class="nav-text">解法四: 用第一行和第一列记录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#075-Sort-Colors"><span class="nav-text">075. Sort Colors</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-21"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-两次遍历"><span class="nav-text">解法一: 两次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历"><span class="nav-text">解法二: 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#078-Subsets"><span class="nav-text">078. Subsets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-22"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代直接求出子集"><span class="nav-text">解法一: 迭代直接求出子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯"><span class="nav-text">解法二: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-bit控制"><span class="nav-text">解法三: bit控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#079-Word-Search"><span class="nav-text">079. Word Search</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-23"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-dfs-回溯"><span class="nav-text">解法一: dfs+回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#091-Decode-Ways"><span class="nav-text">091. Decode Ways</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-24"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-最优-DP-constant-space"><span class="nav-text">解法一(最优): DP constant space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归-1"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#094-Binary-Tree-Inorder-Traversal"><span class="nav-text">094. Binary Tree Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-25"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-3"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归-2"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#098-Validate-Binary-Search-Tree"><span class="nav-text">098. Validate Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-26"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-4"><span class="nav-text">解法一: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal"><span class="nav-text">102. Binary Tree Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-27"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历"><span class="nav-text">解法一: 层次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-Binary-Tree-Zigzag-Level-Order-Traversal"><span class="nav-text">103. Binary Tree Zigzag Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-28"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：利用reverse"><span class="nav-text">解法一：利用reverse</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-最优-不用reverse"><span class="nav-text">解法二: 最优(不用reverse)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node"><span class="nav-text">116. Populating Next Right Pointers in Each Node</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-29"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历-1"><span class="nav-text">解法一: 层次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用-next-指针的特性"><span class="nav-text">解法二: 利用 next 指针的特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#127-Word-Ladder"><span class="nav-text">127. Word Ladder</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-30"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-BFS"><span class="nav-text">解法一: BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#130-Surrounded-Regions"><span class="nav-text">130. Surrounded Regions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Descriptioin"><span class="nav-text">Descriptioin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-5"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-1"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#131-Palindrome-Partitioning"><span class="nav-text">131. Palindrome Partitioning</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-31"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯-验证回文子串"><span class="nav-text">解法一: 回溯+验证回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯-DP"><span class="nav-text">解法二: 回溯+DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#134-Gas-Station"><span class="nav-text">134. Gas Station</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-32"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-最优"><span class="nav-text">解法: 最优</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#138-Copy-List-with-Random-Pointer"><span class="nav-text">138. Copy List with Random Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-33"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-复制-拆分"><span class="nav-text">解法一: 复制+拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历-1"><span class="nav-text">解法二: 一次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-递归"><span class="nav-text">解法三: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#139-Word-Break"><span class="nav-text">139. Word Break</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-34"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯-1"><span class="nav-text">解法一: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP"><span class="nav-text">解法二: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP"><span class="nav-text">解法三: DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#148-Sort-List"><span class="nav-text">148. Sort List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-35"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-6"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-2"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#150-Evaluate-Reverse-Polish-Notation"><span class="nav-text">150. Evaluate Reverse Polish Notation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-36"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈"><span class="nav-text">解法一: 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-栈-异常"><span class="nav-text">解法二: 栈+异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-栈-lambda"><span class="nav-text">解法三: 栈+lambda</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-text">152. Maximum Product Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-37"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-7"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP-迭代"><span class="nav-text">解法二: DP 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#162-Find-Peak-Element"><span class="nav-text">162. Find Peak Element</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-局部最大值"><span class="nav-text">Description: 局部最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-O-n-复杂度"><span class="nav-text">解法一: $O(n)$ 复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-O-logn-复杂度"><span class="nav-text">解法二: $O(logn)$ 复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#166-Fraction-to-Recurring-Decimal"><span class="nav-text">166. Fraction to Recurring Decimal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-无限循环小数"><span class="nav-text">Description: 无限循环小数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用余数作为哈希表的key"><span class="nav-text">解法一: 用余数作为哈希表的key</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#179-Largest-Number"><span class="nav-text">179. Largest Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-排列数字使其字符串形式的数字为最大"><span class="nav-text">Description: 排列数字使其字符串形式的数字为最大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-构造比较函数-快排排序"><span class="nav-text">解法一: 构造比较函数, 快排排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用-STL-sort-函数"><span class="nav-text">解法二: 利用 STL sort() 函数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroZone</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">986k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">14:57</span>
  
</div>










  <div class="footer-custom">勤练带来力量</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
