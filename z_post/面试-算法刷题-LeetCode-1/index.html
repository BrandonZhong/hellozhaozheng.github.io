<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">

<meta name="google-site-verification" content="jgw73iXouBAJcOuff0yi9vdSNDecBSOUXacsHJszpmo" />
<meta name="baidu-site-verification" content="xyf9WD2vvl" />











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/apple-icon-57x57.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_body":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="001. Two Sum题目描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may no">
<meta name="keywords" content="算法刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题(Easy)">
<meta property="og:url" content="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-1/index.html">
<meta property="og:site_name" content="从零开始的BLOG">
<meta property="og:description" content="001. Two Sum题目描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may no">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://wx1.sinaimg.cn/large/d7b90c85ly1fxlbg7qyk9j21cs0nwq4u.jpg">
<meta property="og:image" content="http://wx3.sinaimg.cn/large/d7b90c85ly1fxngsjxjyag20cd0a9q6x.gif">
<meta property="og:updated_time" content="2018-12-02T03:39:03.323Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode算法题(Easy)">
<meta name="twitter:description" content="001. Two Sum题目描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may no">
<meta name="twitter:image" content="https://wx1.sinaimg.cn/large/d7b90c85ly1fxlbg7qyk9j21cs0nwq4u.jpg">






  <link rel="canonical" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-1/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>LeetCode算法题(Easy) | 从零开始的BLOG</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?21a4899cc63d3c11a3d90ac58074a19c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">207</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-计算机视觉">
    <a href="/categories/计算机视觉/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tripadvisor"></i> <br />计算机视觉</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-深度学习">
    <a href="/categories/深度学习/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-drupal"></i> <br />深度学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-caffe2">
    <a href="/categories/Caffe2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />Caffe2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-pytorch">
    <a href="/categories/PyTorch/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-free-code-camp"></i> <br />PyTorch</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">
    <a href="/categories/Cpp/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />C++</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-python">
    <a href="/categories/Python/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-product-hunt"></i> <br />Python</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-linux">
    <a href="/categories/Linux/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-linux"></i> <br />Linux</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-项目">
    <a href="/categories/项目/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-connectdevelop"></i> <br />项目</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-cuda">
    <a href="/categories/CUDA/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-braille"></i> <br />CUDA</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-面试">
    <a href="/categories/面试/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-address-card"></i> <br />面试</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-其它">
    <a href="/categories/其它/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />其它</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">34</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />站内搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="站内搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/hellozhaozheng" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZeroZone">
      <meta itemprop="description" content="并不是什么厉害的地方<br>只是一个安静的学习角落">
      <meta itemprop="image" content="/images/avatar_zz.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode算法题(Easy)
              
            
          </h1>
        

        <div class="post-meta">
	
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-01 08:32:03" itemprop="dateCreated datePublished" datetime="2018-10-01T08:32:03+08:00">2018-10-01</time>
            

            
          </span>

	  
  	    <span class="post-updated">
    		&nbsp; | &nbsp; 更新于
    		<time itemprop="dateUpdated" datetime="2018-12-02T11:39:03+08:00" content="2018-12-02">
      		  2018-12-02
    		</time>
  	  </span>
	  

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">60k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">54 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="001-Two-Sum"><a href="#001-Two-Sum" class="headerlink" title="001. Two Sum"></a>001. Two Sum</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<h2 id="解法一-穷举"><a href="#解法一-穷举" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p>时间复杂度: $O(n^2)$<br>空间复杂度: $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;nums.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res =&#123;i,j&#125;;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-哈希表-两次遍历"><a href="#解法二-哈希表-两次遍历" class="headerlink" title="解法二 : 哈希表, 两次遍历"></a>解法二 : 哈希表, 两次遍历</h2><p>这里要特别注意: 同一个元素不能使用两次, 但是数组中的元素是可以重复的, 重复的元素看作是两个元素. hash表中最终存储的将会是重复元素的最后一个下标, 因此, 在进行比较时, 使用 <code>i!= nums_map[target-nums[i]]</code> 来判断它们是否为同一个元素, 而不能使用<code>nums_map[nums[i]] != nums_map[target-nums[i]]</code></p>
<p>时间复杂度: $O(n)$  遍历两次<br>空间复杂度: $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            nums_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_map.count(target-nums[i]) == <span class="number">1</span> &amp;&amp; i!= nums_map[target-nums[i]])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i, nums_map[target-nums[i]]&#125;; <span class="comment">//这里一定要用i,而不能用nums_map[nums[i]] , 上面也同理</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-哈希表-一次遍历"><a href="#解法三-哈希表-一次遍历" class="headerlink" title="解法三: 哈希表 一次遍历"></a>解法三: 哈希表 一次遍历</h2><p>事实上, 可以将hash表的插入和查找对应元素的操作放在 一个循环里, 这样就只需要进行一次遍历</p>
<p>时间复杂度: $O(n)$  遍历一次<br>空间复杂度: $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_map.count(target-nums[i]) == <span class="number">1</span> &amp;&amp; i!= nums_map[target-nums[i]])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i, nums_map[target-nums[i]]&#125;;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            nums_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>How would you approach the problem if the input array is very large (but limited range) and cannot fit in the memory ? This is a follow-up question for this problem.</p>
<h1 id="007"><a href="#007" class="headerlink" title="007."></a>007.</h1><h2 id="解法一-取余数"><a href="#解法一-取余数" class="headerlink" title="解法一: 取余数"></a>解法一: 取余数</h2><p>这道题本身不难, 只要不断对x的绝对值取余数, 就可以得到反转的整数, 但是, 该题的核心考察点在于边界条件的判断, 稍不注意, 很容易漏解(如果不进行边界判断, 即使写出了解决方法, 面试官也很不满意)</p>
<ul>
<li>x为0</li>
<li>x反转后的值,超过了int型数据的表示范围, 检查方法是先用long存储, 然后看</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> abs_x = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="keyword">int</span> sign_x = x&gt;<span class="number">0</span>? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>; <span class="comment">// 为了看int是否越界,特意将res声明为long型</span></span><br><span class="line">        <span class="keyword">while</span>( abs_x!=<span class="number">0</span> )&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + abs_x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX || res &lt; INT_MIN) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//这一句就是最主要的考察点,看int是否越界</span></span><br><span class="line">            abs_x = abs_x/<span class="number">10</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sign_x ==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>-res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="013-Roman-to-Integer"><a href="#013-Roman-to-Integer" class="headerlink" title="013. Roman to Integer"></a>013. Roman to Integer</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p>Example 1:</p>
<p>Input: “III”<br>Output: 3<br>Example 2:</p>
<p>Input: “IV”<br>Output: 4<br>Example 3:</p>
<p>Input: “IX”<br>Output: 9<br>Example 4:</p>
<p>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.<br>Example 5:</p>
<p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
<h2 id="解法一-顺序扫描"><a href="#解法一-顺序扫描" class="headerlink" title="解法一: 顺序扫描"></a>解法一: 顺序扫描</h2><p>时间复杂度: $O(n)$</p>
<p>顺序扫描, 如果当前字符比下一个字符小, 说明是 ‘4’ 或 ‘9’ 的情况, 用下一个字符的值减去当前字符的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; roman_char;</span><br><span class="line">        roman_char[<span class="string">'I'</span>] = <span class="number">1</span>;</span><br><span class="line">        roman_char[<span class="string">'V'</span>] = <span class="number">5</span>;</span><br><span class="line">        roman_char[<span class="string">'X'</span>] = <span class="number">10</span>;</span><br><span class="line">        roman_char[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        roman_char[<span class="string">'C'</span>] = <span class="number">100</span>;</span><br><span class="line">        roman_char[<span class="string">'D'</span>] = <span class="number">500</span>;</span><br><span class="line">        roman_char[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size() ; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( i&lt;s.size()<span class="number">-1</span> &amp;&amp; roman_char[s[i]] &lt; roman_char[s[i+<span class="number">1</span>]])&#123;</span><br><span class="line">                res += roman_char[s[i+<span class="number">1</span>]]-roman_char[s[i]];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += roman_char[s[i]];       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题-异常检测"><a href="#扩展问题-异常检测" class="headerlink" title="扩展问题: 异常检测"></a>扩展问题: 异常检测</h2><p>上面的解法虽然可以通过OJ, 但是此题还需要进行特别的异常诊断, 即要能够判断出当前输入的罗马输出是否合法! 如 “IVIV” 就是典型的不合法输入, 对于此输入, 上面的程序会输出 , 这显然不正确</p>
<h1 id="014"><a href="#014" class="headerlink" title="014."></a>014.</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-顺序比较"><a href="#解法一-顺序比较" class="headerlink" title="解法一: 顺序比较"></a>解法一: 顺序比较</h2><p>顺序比较所有字符串的值, 直到遇到第一次不相等的位置, 然后输出前面的公共前缀, 需要额外注意处理以下几种特殊情况:<br>输入</p>
<ul>
<li>输入为: [] 或 [“”]  应该直接返回””</li>
<li>输入为: [“abc”]   应该直接返回”abc”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() ==<span class="number">0</span> || strs[<span class="number">0</span>]==<span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() ==<span class="number">1</span> ) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;strs.size(); k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[k][i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,i);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="020-Valid-Parentheses"><a href="#020-Valid-Parentheses" class="headerlink" title="020. Valid Parentheses"></a>020. Valid Parentheses</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<p>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</p>
<p>Example 1:</p>
<p>Input: “()”<br>Output: true<br>Example 2:</p>
<p>Input: “()[]{}”<br>Output: true<br>Example 3:</p>
<p>Input: “(]”<br>Output: false<br>Example 4:</p>
<p>Input: “([)]”<br>Output: false<br>Example 5:</p>
<p>Input: “{[]}”<br>Output: true</p>
<h2 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p>时间复杂度: $O(n)$<br>空间复杂度: $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s_brack;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) c=<span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">']'</span>) c=<span class="string">'['</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'&#125;'</span>) c=<span class="string">'&#123;'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!s_brack.empty() &amp;&amp; c ==  s_brack.top()) s_brack.pop();</span><br><span class="line">            <span class="keyword">else</span> s_brack.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s_brack.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="021-Merge-Two-Sorted-Lists"><a href="#021-Merge-Two-Sorted-Lists" class="headerlink" title="021. Merge Two Sorted Lists"></a>021. Merge Two Sorted Lists</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<h2 id="解法一-遍历融合"><a href="#解法一-遍历融合" class="headerlink" title="解法一: 遍历融合"></a>解法一: 遍历融合</h2><p>时间复杂度: $O(min(m,n))$</p>
<p>空间复杂度: $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur= cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面开关头结点的过程过于复杂, 可以用<code>dummy</code>指针简化这个过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="026-Remove-Duplicates-from-Sorted-Array"><a href="#026-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="026. Remove Duplicates from Sorted Array"></a>026. Remove Duplicates from Sorted Array</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>遍历,  两种写法, 后者相当精简</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> same = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == same)&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                same = nums[i];</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = !nums.empty();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; nums[length<span class="number">-1</span>])</span><br><span class="line">                nums[length++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a>28. Implement strStr()</h1><p>模式匹配, 判断是否为子串</p>
<h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:</p>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2<br>Example 2:</p>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1<br>Clarification:</p>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p>
<h2 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><h2 id="解法二-KMP"><a href="#解法二-KMP" class="headerlink" title="解法二: KMP"></a>解法二: KMP</h2><p>求解next数组: 求解某个位置 $k$ 的next数组值是一个循环的过程, 需要不断检查以 <strong>位置 $k-1$ 的next值</strong> 为下标的元素的 <strong>下一位元素</strong> 与 <strong>当前位置 $k$ 元素</strong> 是否相等, 如果相等, 则 <strong>next[k] = next[k-1]+1</strong>, 如果不相等, 则</p>
<h1 id="038-Count-and-Say"><a href="#038-Count-and-Say" class="headerlink" title="038. Count and Say"></a>038. Count and Say</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</li>
</ol>
<p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<h2 id="解法一-依次查看上一次的数字"><a href="#解法一-依次查看上一次的数字" class="headerlink" title="解法一: 依次查看上一次的数字"></a>解法一: 依次查看上一次的数字</h2><p><strong>时间复杂度:</strong> $O(nm)$  m为数字字符串的长度<br><strong>空间复杂度:</strong> $O(m)$</p>
<p>每次根据上一次的数字更新当前的数字字符串, 如此迭代直到达到指定次数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string res=<span class="string">""</span>;</span><br><span class="line">        string temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) res=<span class="string">"1"</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp =<span class="string">""</span>;</span><br><span class="line">                char cur=res[<span class="number">0</span>];</span><br><span class="line">                int count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(int k=<span class="number">0</span>; k &lt; res.size(); k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>( cur == res[k])</span><br><span class="line">                        count++;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        temp = temp + (to_string(count));</span><br><span class="line">                        temp.push_back(cur);</span><br><span class="line">                        cur = res[k];</span><br><span class="line">                        count = <span class="number">1</span>; //重新计数, 当前已经有一个cur了, 所以是<span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp + (to_string(count)); // 由于最后的一部分相同字符串没有加进来, 所以这里额外加一下</span><br><span class="line">                temp.push_back(cur);</span><br><span class="line">                res.swap(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="053-Maximum-Subarray"><a href="#053-Maximum-Subarray" class="headerlink" title="053. Maximum Subarray"></a>053. Maximum Subarray</h1><p>连续子数组的最大和</p>
<h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:</p>
<p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p>
<p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h2 id="解法-记录当前最大值"><a href="#解法-记录当前最大值" class="headerlink" title="解法: 记录当前最大值"></a>解法: 记录当前最大值</h2><p><strong>时间复杂度:</strong> $O(n)$<br>根据数组性质，设置两个变量，一个记录当前的最大值，一个记录当前的子序列之和。首先，如果当前子序列之和为负，那么就是说，从当前位置开始的子序列，比从之前位置开始的子序列大，那么就可以不考虑从之前位置开始的子序列，之前累计的和也被抛弃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum = INT_MIN;  <span class="comment">//数组有可能全负, 所以不能赋值为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; max_sum) max_sum = num; <span class="comment">//主要是为了预防数组中全是负数的情况</span></span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span>(sum!=<span class="number">0</span> &amp;&amp; sum&gt;max_sum) max_sum = sum; <span class="comment">// sum!=0 , 为了预防数组全负时, 0一定大于sum, 造成的错解</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt;<span class="number">0</span>) sum =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong> (貌似用max要比用if语句判断快一点???)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            max_sum = max(max_sum, num);</span><br><span class="line">            sum += num;</span><br><span class="line">            max_sum = max(max_sum, sum);</span><br><span class="line">            sum = max(sum, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="066-Plus-One"><a href="#066-Plus-One" class="headerlink" title="066. Plus One"></a>066. Plus One</h1><p>数组代表一个整数, 模拟整数的加法</p>
<h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.<br>Example 2:</p>
<p>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p>
<h2 id="解法一-直接模拟"><a href="#解法一-直接模拟" class="headerlink" title="解法一: 直接模拟"></a>解法一: 直接模拟</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, last_i = digits.size()<span class="number">-1</span>;</span><br><span class="line">        digits[last_i] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits[last_i] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            digits[last_i] = <span class="number">0</span>;</span><br><span class="line">            carry=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = last_i<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; carry ; i--)&#123;</span><br><span class="line">            digits[i] += carry;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &gt; <span class="number">9</span>)</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-不使用加法-更快更简单-击败100"><a href="#解法二-不使用加法-更快更简单-击败100" class="headerlink" title="解法二: 不使用加法(更快更简单, 击败100%)"></a>解法二: 不使用加法(更快更简单, 击败100%)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;   <span class="comment">//未考虑前缀0的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[i] ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="069-Sqrt-x"><a href="#069-Sqrt-x" class="headerlink" title="069. Sqrt(x)"></a>069. Sqrt(x)</h1><p>实现开方算法</p>
<h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p>Example 1:</p>
<p>Input: 4<br>Output: 2<br>Example 2:</p>
<p>Input: 8<br>Output: 2<br>Explanation: The square root of 8 is 2.82842…, and since<br>             the decimal part is truncated, 2 is returned.</p>
<h2 id="解法一-二分法"><a href="#解法一-二分法" class="headerlink" title="解法一: 二分法"></a>解法一: 二分法</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> low=<span class="number">0</span>, high=x;</span><br><span class="line">        <span class="keyword">double</span> res = high;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(res*res - x) &gt; <span class="number">0.000001</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(res*res &gt; x)&#123;</span><br><span class="line">                high = res;</span><br><span class="line">                res = (low+high)/<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = res;</span><br><span class="line">                res = (low+high)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-牛顿迭代法"><a href="#解法二-牛顿迭代法" class="headerlink" title="解法二: 牛顿迭代法"></a>解法二: 牛顿迭代法</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>相当于求解 $f(res)=res^2 - x = 0$ 中 $res$ 的解. 则对于任意一点 $(res, f(res))$, 都有切线方程:</p>
<script type="math/tex; mode=display">f(res) - 0 = f'(res)(res-res')</script><p>其中, $res’$ 是该直线与 $x$ 轴的交点. 令新的 $res$ 为该值, 就可以不断逼近 $f(res)$ 的零点, $res’$ 的值为:</p>
<script type="math/tex; mode=display">res' = res- \frac{f(res)}{f'(res)} = res- \frac{res^2-x}{2\times res} = \frac{res^2 + x}{2\times res}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = x;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(res*res - x) &gt; <span class="number">0.000001</span> )&#123;</span><br><span class="line">            res = (res*res+x) / (<span class="number">2</span>*res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-按位检索"><a href="#解法三-按位检索" class="headerlink" title="解法三: 按位检索"></a>解法三: 按位检索</h2><p><strong>时间复杂度:</strong> $O(1)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>由于本题要返回的是整数, 而上面的两种方法都是针对double类型的精确开根方法, 时间复杂度为 $O(logn)$, 实际上, 当只需要返回整数时, 我们可以按整数的位进行检索, 而整数总共只有32位(传入的x位int型, 所以开根后不可能超过int), 因此时间复杂度只有 $O(32)$ , 也就是 $O(1)$.</p>
<p><strong>注意:</strong> 由于该方法是首先找到比 x 大的那一位, 因此有可能超过int上限, 所以要换成long整型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( <span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;h) * <span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;h) &lt;= x) h++;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">1</span>&lt;&lt;(h<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>( b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (res+b) * (res+b) &lt;= x)</span><br><span class="line">                res += b;</span><br><span class="line">            b = b/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="070-Climbing-Stairs"><a href="#070-Climbing-Stairs" class="headerlink" title="070. Climbing Stairs"></a>070. Climbing Stairs</h1><p>实际上就是斐波那契数列, 更具体分析可看牛客的跳台阶</p>
<h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<p>Example 1:</p>
<p>Input: 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps<br>Example 2:</li>
</ol>
<p>Input: 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.</p>
<ol>
<li>1 step + 1 step + 1 step</li>
<li>1 step + 2 steps</li>
<li>2 steps + 1 step</li>
</ol>
<h2 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n2;</span><br><span class="line">            n2 = n1+n2;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="088-Merge-Sorted-Array"><a href="#088-Merge-Sorted-Array" class="headerlink" title="088. Merge Sorted Array"></a>088. Merge Sorted Array</h1><p>融合两个有序数组, 其中第一个数组的元素长度为n, 第二个为m, 题目假设第一个数组的空间为n+m.</p>
<h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-后移-插入融合"><a href="#解法一-后移-插入融合" class="headerlink" title="解法一: 后移+插入融合"></a>解法一: 后移+插入融合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =n+m<span class="number">-1</span>; i&gt;=n; i--)</span><br><span class="line">            nums1[i]=nums1[i-n];</span><br><span class="line">        <span class="comment">//for(int i =n; i&lt;n+m; i++) 注意, 这样写是有问题的, 例如对于 [1,2,3,4,0], 这种情况, 从前往后的复制方法会造成元素覆盖</span></span><br><span class="line">          <span class="comment">//  nums1[i]=nums1[i-n];</span></span><br><span class="line">        <span class="keyword">int</span> i =n, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n+m &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                k++; i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                k++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n+m)</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)</span><br><span class="line">            nums1[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><p>判断一个二叉树是否为对称的.(与自身镜像相等)</p>
<h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>
<pre><code>1
</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>But the following [1,2,2,null,3,null,3] is not:<br>    1<br>   / \<br>  2   2<br>   \   \<br>   3    3<br>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<h2 id="解法一-递归-1"><a href="#解法一-递归-1" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$ , 遍历了整个树中的每个节点一次<br><strong>空间复杂度:</strong> $O(n)$ , 调用递归的次数与树的高度有关, 在最差的情况下, 树的高度为n.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymHelper(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymHelper</span><span class="params">(TreeNode* subRoot1, TreeNode* subRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span> &amp;&amp; subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span> || subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1-&gt;val != subRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> b1 = isSymHelper(subRoot1-&gt;left, subRoot2-&gt;right);</span><br><span class="line">        <span class="keyword">bool</span> b2 = isSymHelper(subRoot1-&gt;right, subRoot2-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> b1&amp;&amp;b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-1"><a href="#解法二-迭代-1" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$ , 遍历了整个树中的每个节点一次<br><strong>空间复杂度:</strong> $O(n)$ , 层次遍历创建了两个队列, 其大小总和刚好为n. (有一种说法是: 层次遍历我们最多只会同时保存两层的节点数, 而最后一层的节点数最多为 $logn$, 所以空间复杂度实际上是 $O(logn)$ (常数项被约掉), 这种说法对吗??)</p>
<p>层次遍历, 注意不应该左子树和右子树做非空检查, 因此判断是否对称时, 需要包含节点为空的情况.(因为不需要知道当前的深度, 所以也不用维护深度信息)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q1;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.push(root-&gt;left);</span><br><span class="line">        q2.push(root-&gt;right);</span><br><span class="line">        TreeNode * cur1, * cur2;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">            cur1 = q1.front(); q1.pop();</span><br><span class="line">            cur2 = q2.front(); q2.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur1==<span class="literal">nullptr</span> &amp;&amp; cur2 ==<span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur1==<span class="literal">nullptr</span> || cur2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;val != cur2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q1.push(cur1-&gt;left); q1.push(cur1-&gt;right);</span><br><span class="line">            q2.push(cur2-&gt;right); q2.push(cur2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><p>求二叉树的最大深度(树的深度)</p>
<h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given binary tree [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its depth = 3.</p>
<h2 id="解法一-层次遍历"><a href="#解法一-层次遍历" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_len = q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#</p>
<p>根据 <strong>有序数组</strong> 构造平衡二叉搜索树(不唯一, 只要符合规则即可)</p>
<h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:</p>
<p>Given the sorted array: [-10,-3,0,5,9],</p>
<p>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</p>
<pre><code>  0
 / \
</code></pre><p>   -3   9<br>   /   /<br> -10  5</p>
<h2 id="解法一-递归构造"><a href="#解法一-递归构造" class="headerlink" title="解法一: 递归构造"></a>解法一: 递归构造</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 递归了n次(每个节点都被访问了一次)</p>
<p>由于题目给的条件是 <strong>有序数组</strong> , 因此大大降低了了构造难度, 可以每次将数组的中间位置作为根节点, 然后分别将两边的数组作为一个新的子数组进行构造, 无需考虑插入新节点引起的二叉搜索树不平衡的问题.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> construct_BST(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct_BST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = construct_BST(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = construct_BST(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-2"><a href="#解法二-迭代-2" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, 只不过需要遍历两次树的size<br><strong>空间复杂度:</strong> $O(n)$, 层次遍历的队列和中根遍历的栈</p>
<p>先用层次遍历构造一个完全二叉树(以却确保树是平衡的), 然后在利用中根遍历对树中的每个元素进行赋值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tree_len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(tree_len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        q.push(root); tree_len--;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">int</span> layer_len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tree_len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            layer_len *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len &amp;&amp; tree_len&gt;<span class="number">0</span>; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                TreeNode* left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                cur_node-&gt;left = left;</span><br><span class="line">                q.push(cur_node-&gt;left); tree_len--;</span><br><span class="line">                <span class="keyword">if</span>(tree_len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    TreeNode *right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                    cur_node-&gt;right = right;</span><br><span class="line">                    q.push(cur_node-&gt;right); tree_len--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        cur_node = root;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.push(cur_node);</span><br><span class="line">                cur_node = cur_node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                cur_node = s.top(); s.pop();</span><br><span class="line">                cur_node-&gt;val =nums[i++];</span><br><span class="line">                cur_node = cur_node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="解法三-迭代-只中根遍历一次"><a href="#解法三-迭代-只中根遍历一次" class="headerlink" title="解法三: 迭代(只中根遍历一次)"></a>解法三: 迭代(只中根遍历一次)</h1><p>【链接】Loading…<br><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution</a></p>
<h1 id="111-minimum-depth-of-binary-tree"><a href="#111-minimum-depth-of-binary-tree" class="headerlink" title="111. minimum depth of binary tree"></a>111. minimum depth of binary tree</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="　题目描述"></a>　题目描述</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given binary tree [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>层次优先遍历,遇到的首个叶子结点(左右子树为空)即为最短的深度</p>
<p>注意:</p>
<p>利用while内嵌for循环的方式, 可以省去对每个结点depth的维护, 只需要每次进入for循环之前, depth++即可(因为一个for循环会将当前层所有的结点都入队列, for循环结束后, 意味着进入了下一层, 所以depth++即可)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int run(TreeNode *root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q_node;</span><br><span class="line">        if(root==nullptr) return 0;</span><br><span class="line">        q_node.push(root);</span><br><span class="line">        int depth = 0;</span><br><span class="line">        while(!q_node.empty())&#123;</span><br><span class="line">            const int size = q_node.size();</span><br><span class="line">            depth++;</span><br><span class="line">            for(int i = 0; i&lt; size; i++)&#123;</span><br><span class="line">                TreeNode* node = q_node.front(); q_node.pop();</span><br><span class="line">                if(node-&gt;left!=nullptr) q_node.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right!=nullptr) q_node.push(node-&gt;right);</span><br><span class="line">                if(node-&gt;left==nullptr &amp;&amp; node-&gt;right == nullptr) return depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二(递归):"></a>解法二(递归):</h2><p>让当前结点为空, 则当前结点深度为0, 若当前结点左子树为空, 则当前结点深度等于左子树深度, 反之 ,等于右子树深度. 若当前结点左右子树均不为空, 则当前结点的 <strong>最小深度</strong> 等于左右子树深度 <strong>较小者</strong> 加1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right ==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> depth1=run(root-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> depth2=run(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> depth1&lt;depth2 ? depth1+<span class="number">1</span> : depth2+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a>118. Pascal’s Triangle</h1><p>Pascal 三角形</p>
<h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.</p>
<p>Example:</p>
<p>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<h2 id="解法一-按照三角形的性质进行赋值"><a href="#解法一-按照三角形的性质进行赋值" class="headerlink" title="解法一: 按照三角形的性质进行赋值"></a>解法一: 按照三角形的性质进行赋值</h2><p>赋值时, 每一行的两端都是1, 无需重复赋值, 注意控制好边界条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;numRows; i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(i+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)&#123; <span class="comment">// 两边默认为1, 无需重复赋值</span></span><br><span class="line">                temp[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>]+res[i<span class="number">-1</span>][j];<span class="comment">// i和j的值只有在大于1时才会进入循环, 所以无需担心i-1或j-1&lt;0</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h1><p>获取最大的股票利润</p>
<h2 id="Description-15"><a href="#Description-15" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:</p>
<p>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.<br>Example 2:</p>
<p>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<h2 id="解法一-穷举-1"><a href="#解法一-穷举-1" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p>计算所有可能性, $O(n^2)$</p>
<h2 id="解法二-一次遍历"><a href="#解法二-一次遍历" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>维护两个变量 <code>min_price</code> 和 <code>max_profit</code>, 每次检查元素, 一方面如果当前价格更低, 则更改 <code>min_price</code> 变量, 另一方面如果当前利润超过 <code>max_profit</code>, 则更新之.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Vclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_price=prices[<span class="number">0</span>], max_profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= min_price)&#123;</span><br><span class="line">                min_price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-min_price &gt; max_profit) max_profit = prices[i]-min_price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_price=prices[<span class="number">0</span>], max_profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= min_price)&#123;</span><br><span class="line">                min_price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-min_price &gt; max_profit) max_profit = prices[i]-min_price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h1><p>可以多次交易, 统计最大利润和</p>
<h2 id="Description-16"><a href="#Description-16" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:</p>
<p>Input: [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.<br>Example 2:</p>
<p>Input: [1,2,3,4,5]<br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.<br>Example 3:</p>
<p>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<h2 id="解法一-用变量维护最低价格"><a href="#解法一-用变量维护最低价格" class="headerlink" title="解法一: 用变量维护最低价格"></a>解法一: 用变量维护最低价格</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>寻找递增序列, 一旦出现递减的情况, 则说明应该及时卖出, 并将 <code>min_price</code> 重新赋值. 因为最后一个元素后面没有值来判断是否递减, 因此需要对最后一个元素进行单独判断<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum_profit = <span class="number">0</span>, pre_price=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; pre_price)&#123; <span class="comment">//如果小于之前的price, 则说明此时应该卖出</span></span><br><span class="line">                sum_profit += pre_price-min_price; <span class="comment">//计算卖出利润</span></span><br><span class="line">                min_price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            pre_price = prices[i];</span><br><span class="line">            <span class="keyword">if</span>(i==prices.size()<span class="number">-1</span> &amp;&amp; prices[i] &gt; min_price) <span class="comment">//到了最后一个元素, 查看是否应该卖出</span></span><br><span class="line">                sum_profit += prices[i] - min_price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-每两个相邻数字当做一次交易"><a href="#解法二-每两个相邻数字当做一次交易" class="headerlink" title="解法二: 每两个相邻数字当做一次交易"></a>解法二: 每两个相邻数字当做一次交易</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>实际上和解法一本质相同, 只不过在累加利润上有一点小区别.<br>该解法是将每两个相邻数字看做是一次交易, 如果后者大于前者, 说明应该执行交易, 并累加交易所的利润.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>]) sum_profit += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125 Valid Palindrome"></a>125 Valid Palindrome</h1><p>判断是否为回文子串</p>
<h2 id="Description-17"><a href="#Description-17" class="headerlink" title="Description"></a>Description</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p>
<p>Example 1:</p>
<p>Input: “A man, a plan, a canal: Panama”<br>Output: true<br>Example 2:</p>
<p>Input: “race a car”<br>Output: false</p>
<h2 id="解法一-前后两个指示变量-向中间遍历判断"><a href="#解法一-前后两个指示变量-向中间遍历判断" class="headerlink" title="解法一: 前后两个指示变量, 向中间遍历判断"></a>解法一: 前后两个指示变量, 向中间遍历判断</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(1)$, 只额外用了两个变量</p>
<p>需要注意的是将大小写字母转换成同大写或者同小写的形式再进行判断</p>
<p><strong>写法一:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.size()<span class="number">-1</span>; i&lt;j; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_alphanumeric(s[i]) == <span class="literal">false</span>)&#123;</span><br><span class="line">                i++; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is_alphanumeric(s[j]) == <span class="literal">false</span>)&#123;</span><br><span class="line">                j--; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">tolower</span>(s[i]) != <span class="built_in">std</span>::<span class="built_in">tolower</span>(s[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++; j--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_alphanumeric</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span> &amp;&amp; c&lt;=<span class="string">'z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'A'</span> &amp;&amp; c&lt;=<span class="string">'Z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.size()<span class="number">-1</span>; i&lt;=j;i++,j-- )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.size() &amp;&amp; is_alphanumeric(s[i]) == <span class="literal">false</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; is_alphanumeric(s[j]) == <span class="literal">false</span>) j--;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">tolower</span>(s[i]) != <span class="built_in">std</span>::<span class="built_in">tolower</span>(s[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_alphanumeric</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span> &amp;&amp; c&lt;=<span class="string">'z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'A'</span> &amp;&amp; c&lt;=<span class="string">'Z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h1><p>数组中有一个数字出现了1次(奇数次), 其他均出现了2次(偶数次), 找到出现1次(奇数次)的数字.</p>
<h2 id="Description-18"><a href="#Description-18" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<p>Input: [2,2,1]<br>Output: 1<br>Example 2:</p>
<p>Input: [4,1,2,1,2]<br>Output: 4</p>
<h2 id="解法一-哈希"><a href="#解法一-哈希" class="headerlink" title="解法一: 哈希"></a>解法一: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 哈希表额外空间</p>
<p>遍历数组, 对于每一个数, 如果当前的数存在于hash表中, 则将表中哈希删除, 如果不存在, 则添加到哈希表中, 最终, 哈希表中存在的值就是只出现一次的值</p>
<h2 id="解法二-数学公式"><a href="#解法二-数学公式" class="headerlink" title="解法二: 数学公式"></a>解法二: 数学公式</h2><p><script type="math/tex">2\times (a + b + c) - (a+b+a+b+c) = c</script>.</p>
<p>将数组中的元素转换为 <code>set</code>(无重复元素), 然后利用上面的公式纠结<br><strong>时间复杂度:</strong> $O(n + n)=O(n)$, 转换为 <code>set</code> 需要 $O(n), 公式求解遍历也需要 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$. <code>set</code> 所占额外空间</p>
<h2 id="解法三-异或"><a href="#解法三-异或" class="headerlink" title="解法三: 异或"></a>解法三: 异或</h2><p>任何数和0异或不变, 和自身异或变为0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>其他更多扩展问题可看牛客第40题.</strong></p>
<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><h2 id="Description-19"><a href="#Description-19" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="解法一-Floyd-Cycle-Floyd-判圈算法"><a href="#解法一-Floyd-Cycle-Floyd-判圈算法" class="headerlink" title="解法一: Floyd Cycle(Floyd 判圈算法)"></a>解法一: Floyd Cycle(Floyd 判圈算法)</h2><p><strong>时间复杂度:</strong> $O(n+k)$, 可以认为是$O(n)$,  $n$ 为链表长度, $k$ 为环长<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>从头结点开始，slow每次走一步，fast每次走两步，那么只要有环，slow和fast就一定会在环中的某个节点处相遇，如果无环，则fast一定先到达空指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow=head, *fast=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; slow != fast)&#123;</span><br><span class="line">            slow= slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多扩展见牛客第55题, 链表中环的入口节点</p>
<h1 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a>155. Min Stack</h1><p>获取栈中最小的元素</p>
<h2 id="Description-20"><a href="#Description-20" class="headerlink" title="Description"></a>Description</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) — Push element x onto stack.<br>pop() — Removes the element on top of the stack.<br>top() — Get the top element.<br>getMin() — Retrieve the minimum element in the stack.<br>Example:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   —&gt; Returns -3.<br>minStack.pop();<br>minStack.top();      —&gt; Returns 0.<br>minStack.getMin();   —&gt; Returns -2.</p>
<h2 id="解法一-两个栈"><a href="#解法一-两个栈" class="headerlink" title="解法一: 两个栈"></a>解法一: 两个栈</h2><p><strong>时间复杂度:</strong> $O(1)$<br><strong>空间复杂度:</strong> $O(n)$, 两个栈</p>
<p>申请两个栈, 一个栈正常操作, 另一个栈只有当当前元素小于或等于栈顶元素时才入栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">    MinStack()&#123;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty() || x &lt;= s2.top()) s2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top() == s2.top()) s2.pop();</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>两个链表的第一个公共节点</p>
<h2 id="Description-21"><a href="#Description-21" class="headerlink" title="Description"></a>Description</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p>
<p>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><p><strong>时间复杂度:</strong> $O(m+n)$, 遍历两个链表<br><strong>空间复杂度:</strong> $O(m+n)$, 两个栈</p>
<p>分析公共子节点的特点，首先，是单向链表，因此，从第一个公共子节点开始，后面的都是一样的，所以最好是能从链表的最后一项还是比较。但由于是单向链表，因此只能从头访问，从能访问最后的节点。 <strong>就像是先进先出一样</strong>  因此，考虑用两个辅助栈来帮助实现～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s2;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead1; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s1.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead2; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s2.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* firstCN = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.top() == s2.top())&#123;</span><br><span class="line">                firstCN = s1.top();</span><br><span class="line">                s1.pop();</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="解法二-常数空间复杂度"><a href="#解法二-常数空间复杂度" class="headerlink" title="解法二: 常数空间复杂度"></a>解法二: 常数空间复杂度</h1><p><strong>时间复杂度:</strong> $O(m+n)$, 遍历两次<br><strong>空间复杂度:</strong> $O(1)$, 不使用额外空间</p>
<p>首先遍历得到两个链表的长度, 然后先让长链表前进长度差个节点, 接着两个链表共同向前遍历, 当相遇时即为第一个公共节点.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA;</span><br><span class="line">        <span class="keyword">while</span>(curA !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode *curB = headB;</span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = lenA-lenB;</span><br><span class="line">            curA = headA;</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                curA = curA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curB = headB;</span><br><span class="line">            <span class="keyword">while</span>(curA!=<span class="literal">nullptr</span> &amp;&amp; curB!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curA == curB) <span class="keyword">return</span> curA;</span><br><span class="line">                curA = curA-&gt;next;</span><br><span class="line">                curB = curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = lenB-lenA;</span><br><span class="line">            curB = headB;</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                curB = curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = headA;</span><br><span class="line">            <span class="keyword">while</span>(curA!=<span class="literal">nullptr</span> &amp;&amp; curB!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curA == curB) <span class="keyword">return</span> curA;</span><br><span class="line">                curA = curA-&gt;next;</span><br><span class="line">                curB = curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169 Majority Element"></a>169 Majority Element</h1><h2 id="Description-找出数组中超过一半的数字"><a href="#Description-找出数组中超过一半的数字" class="headerlink" title="Description: 找出数组中超过一半的数字"></a>Description: 找出数组中超过一半的数字</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: 3<br>Example 2:</p>
<p>Input: [2,2,1,1,1,2,2]<br>Output: 2</p>
<p><strong>题目中指明了该数字一定存在, 所以无需进行count检查, 如果该数字有可能不存在, 则根据情况需要进行 $O(n)$ 复杂度的count检查(即检查当前的数字是否出现了大于 n/2 次).</strong></p>
<h2 id="解法一-排序"><a href="#解法一-排序" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先排序, 然后取中间元素, 即为 majority element.<br>(如有需要可进行count检查, $O(n)$)</p>
<h2 id="解法二-哈希"><a href="#解法二-哈希" class="headerlink" title="解法二: 哈希"></a>解法二: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>每个元素的值为哈希的 key, 每个元素出现的次数为哈希的 value, 如果某个 key 的 value 大于 n/2, 则该元素即为 majority element.<br>哈希法记录的元素的出现次数, 所以无需进行 count 检查.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt; <span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            hash[num]++;</span><br><span class="line">            <span class="keyword">if</span>(hash[num] &gt; nums.size()/<span class="number">2</span>) <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-同增异减"><a href="#解法三-同增异减" class="headerlink" title="解法三: 同增异减"></a>解法三: 同增异减</h2><p>如果数组中存在这样一个数，那么这个数的出现次数一定大于其他所有数的出现次数总和，因此，设置两个变量，一个 cur_num 用来存储当前数组中的可能解，另一个 count 为统计差值. 即每遇到一个和可能解相同的元素, 就 count++, 否则, count—. 如果 count=0, 则说明当前的可能解已经注定不是最终的解, 则令新的元素为可能解.<br>最终, 对可能解进行 $O(n)$ 的 count 检查, 判断是否存在 majority element (题目假设一定存在, 所以可以不做此检查).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_num = nums[<span class="number">0</span>]<span class="number">-1</span>; <span class="comment">//确保cur_num不和第一个数相等</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == cur_num)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur_num = num;</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_num;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-随机"><a href="#解法四-随机" class="headerlink" title="解法四: 随机"></a>解法四: 随机</h2><p>如果确定数组中存在 majority element 的话, 则我们可以从数组中随机选取一个元素, 并判断这个元素是否为 majority element.  这种解法依赖于统计学的概率知识, 实际的时间复杂度与数组的组成规律有关.</p>
<h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a>171. Excel Sheet Column Number</h1><h2 id="Description-Excel列表数字"><a href="#Description-Excel列表数字" class="headerlink" title="Description: Excel列表数字"></a>Description: Excel列表数字</h2><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28
...
</code></pre><p>Example 1:</p>
<p>Input: “A”<br>Output: 1<br>Example 2:</p>
<p>Input: “AB”<br>Output: 28<br>Example 3:</p>
<p>Input: “ZY”<br>Output: 701</p>
<h2 id="解法一-遍历字符串"><a href="#解法一-遍历字符串" class="headerlink" title="解法一: 遍历字符串"></a>解法一: 遍历字符串</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            res += res*<span class="number">25</span> + <span class="keyword">int</span>(c-<span class="string">'A'</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="172-Factorial-Trailing-Zeroes"><a href="#172-Factorial-Trailing-Zeroes" class="headerlink" title="172. Factorial Trailing Zeroes"></a>172. Factorial Trailing Zeroes</h1><h2 id="Description-阶乘的尾部含有0的个数"><a href="#Description-阶乘的尾部含有0的个数" class="headerlink" title="Description: 阶乘的尾部含有0的个数"></a>Description: 阶乘的尾部含有0的个数</h2><h2 id="解法一-统计5的个数"><a href="#解法一-统计5的个数" class="headerlink" title="解法一: 统计5的个数"></a>解法一: 统计5的个数</h2><p><strong>首先, 求出阶乘值在取余求0个数的方法肯定不可以, 阶乘会轻松溢出(n=13时就已经 int 溢出了)</strong></p>
<p><strong>时间复杂度:</strong> $O(logn)$, 以5位基数<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>因为尾部的0只可能来自于 $2\times 5$ 这样的数, 对于 $n$ 的阶乘 $1\times 2\times 3\times, …, n$ 来说, $2$ 一定是充足的, 所以我们只需要统计 $5$ 的个数就可以.<br>统计时, 每个5个数字会出现一次5, 每隔25个数字会额外出现一次5, 每个125个数字又会额外出现一次5…, 如此循环下去, 最终5的个数就是尾部0的个数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i =<span class="number">5</span>; n/i &gt;<span class="number">0</span>; i*=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="comment">//注意这里的i的字节数一定要大于n, 因为n有可能为INT_MAX, 而 n/i &gt;0 时, i必须&gt;n</span></span><br><span class="line">            res += n/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-另一个角度"><a href="#解法二-另一个角度" class="headerlink" title="解法二: 另一个角度"></a>解法二: 另一个角度</h2><p><strong>时间复杂度:</strong> $O(logn)$, 以5位基数<br><strong>空间复杂度:</strong> $O(1)$ (迭代), $O(logn)$ (递归需额外空间)</p>
<p>核心思想是相同的, 同样是统计5的出现个数, 只不过这里我们是先求出 n 中 5 的倍数, 然后再求 n/5 中 5 的倍数, 实际上这里就是相当于求 n 中 25 的倍数. 因此, 和解法一是相同的, 只不过解法二因为是通过减小 n, 而不是增大 i (5,25,125,..)的方式来统计 5 个数, 因此解法二有个好处就是可以不使用 <code>long</code> 类型的变量, 下面分别是该方法的递归实现和迭代实现.</p>
<p><strong>递归:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt; <span class="number">5</span> ? <span class="number">0</span> : n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>迭代:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">            res += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189. Rotate Array"></a>189. Rotate Array</h1><h2 id="Description-循环右移数组"><a href="#Description-循环右移数组" class="headerlink" title="Description: 循环右移数组"></a>Description: 循环右移数组</h2><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,4,5,6,7] and k = 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]</p>
<p>Example 2:</p>
<p>Input: [-1,-100,3,99] and k = 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]</p>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<h2 id="解法一-暴力-1"><a href="#解法一-暴力-1" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p><strong>时间复杂度:</strong> $O(nk)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>所有的数字每次移动一步, 攻移动 k 次. 超时</p>
<h2 id="解法二-使用额外数组"><a href="#解法二-使用额外数组" class="headerlink" title="解法二: 使用额外数组"></a>解法二: 使用额外数组</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>申请一个长度相等的数组, 复制原数组中的 $i$ 号元素到新数组中的 $i+k$ 号位置.</p>
<h2 id="解法三-循环置换"><a href="#解法三-循环置换" class="headerlink" title="解法三: 循环置换"></a>解法三: 循环置换</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>每次直接将元素放置在正确的位置, 放置前, 需要用一个临时变量将被放置的元素保存起来以防止覆盖, 然后将临时变量的元素再直接放到正确的位置, 循环进行, 知道临时变量指向了最开始的变量, 然后再继续从下一个元素开始这个过程. 在代码中设置一个 <code>count</code> 变量, 用来统计放置的次数, 当次数等于数组长度时, 说明已经完成移动.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>; count&lt;nums.size(); start++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_pos = start;</span><br><span class="line">            <span class="keyword">int</span> cur_val = nums[start];</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> next_pos = (cur_pos + k) % nums.size();</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next_pos];</span><br><span class="line">                nums[next_pos] = cur_val;</span><br><span class="line">                cur_pos = next_pos;</span><br><span class="line">                cur_val = temp;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(start!=cur_pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-reverse"><a href="#解法四-reverse" class="headerlink" title="解法四: reverse"></a>解法四: reverse</h2><p><strong>时间复杂度:</strong> $O(n)$, 调用扫除 reverse 函数<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.begin(), nums.end()-k);</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.end()-k, nums.end());</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="190"><a href="#190" class="headerlink" title="190."></a>190.</h1><h2 id="Description-按位逆置"><a href="#Description-按位逆置" class="headerlink" title="Description: 按位逆置"></a>Description: 按位逆置</h2><p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>Example:</p>
<p>Input: 43261596<br>Output: 964176192<br>Explanation: 43261596 represented in binary as 00000010100101000001111010011100,<br>             return 964176192 represented in binary as 00111001011110000010100101000000.<br>Follow up:<br>If this function is called many times, how would you optimize it?</p>
<h2 id="解法一-按位进行32次操作"><a href="#解法一-按位进行32次操作" class="headerlink" title="解法一: 按位进行32次操作"></a>解法一: 按位进行32次操作</h2><p>每次取 <code>n</code> 的最后一位, 如果为 1, 则令<code>res</code>左移一位并加一, 如果为0, 则只左移一位. 进行32次(<code>n</code>的32位).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> res= <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>) | ((n&gt;&gt;i)&amp;<span class="number">1</span>); <span class="comment">//res = (res&lt;&lt;1) | (n&amp;1); n = (n&gt;&gt;1);            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-按位二分进行5次操作"><a href="#解法二-按位二分进行5次操作" class="headerlink" title="解法二: 按位二分进行5次操作"></a>解法二: 按位二分进行5次操作</h2><p>先将前16位和后16位交换(利用位移和位操作实现)<br>然后再将16位中的前8位和后8位交换<br>然后再将8位中的前4位和后4位交换<br>然后再将4位中的前2位和后2位交换<br>最后将2位中的前1位和后1位交换.</p>
<p>上述交换全部采用位操作实现, 因此, 速度上有所优化.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        n = (n&gt;&gt;<span class="number">16</span>) | (n&lt;&lt;<span class="number">16</span>);</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xff00ff00</span>)&gt;&gt;<span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>)&lt;&lt;<span class="number">8</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xf0f0f0f0</span>)&gt;&gt;<span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>)&lt;&lt;<span class="number">4</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xcccccccc</span>)&gt;&gt;<span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>)&lt;&lt;<span class="number">2</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xaaaaaaaa</span>)&gt;&gt;<span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>)&lt;&lt;<span class="number">1</span>) );</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a>191. Number of 1 Bits</h1><h2 id="Description-统计二进制中1的个数"><a href="#Description-统计二进制中1的个数" class="headerlink" title="Description: 统计二进制中1的个数"></a>Description: 统计二进制中1的个数</h2><p>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight).</p>
<p>Example 1:</p>
<p>Input: 11<br>Output: 3<br>Explanation: Integer 11 has binary representation 00000000000000000000000000001011<br>Example 2:</p>
<p>Input: 128<br>Output: 1<br>Explanation: Integer 128 has binary representation 00000000000000000000000010000000</p>
<h2 id="解法一-逐位统计"><a href="#解法一-逐位统计" class="headerlink" title="解法一: 逐位统计"></a>解法一: 逐位统计</h2><p><strong>时间复杂度:</strong> $O(1)$, 循环32次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>查看每一位上的二进制是否为1, 若为1, 则<code>count++</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (n &amp; (<span class="number">1</span>&lt;&lt;i)) != <span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-和-n-1-按位与"><a href="#解法二-和-n-1-按位与" class="headerlink" title="解法二: 和 $n-1$ 按位与"></a>解法二: 和 $n-1$ 按位与</h2><p><strong>时间复杂度:</strong> $O(1)$, 循环次数为二进制中1的个数.<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><img src="https://wx1.sinaimg.cn/large/d7b90c85ly1fxlbg7qyk9j21cs0nwq4u.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h1><h2 id="Description-房屋小偷获取最大收益"><a href="#Description-房屋小偷获取最大收益" class="headerlink" title="Description: 房屋小偷获取最大收益"></a>Description: 房屋小偷获取最大收益</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,1]<br>Output: 4<br>Explanation:<br>Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>Total amount you can rob = 1 + 3 = 4.<br>Example 2:</p>
<p>Input: [2,7,9,3,1]<br>Output: 12<br>Explanation:<br>Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>Total amount you can rob = 2 + 9 + 1 = 12.</p>
<h2 id="解法一-DP"><a href="#解法一-DP" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>依据 DP 的思想, 对于一个任意价格的房子, 我们有两种选择: 偷或不偷. 如果选择不偷, 那么前 $(i+1)$ 个房子的最大收益, 就应该是前 $i$ 个房子的最大收益(偷或者不偷第 $i$ 个房子收益中的较大者), 如果选择偷, 那么就不能偷第 $i$ 个房子.<br>根据上面的描述, 我们可以维护两个变量 <code>cur_rob</code> 和 <code>cur_nrob</code>, 前者代表偷第 $i$ 个房子的收益, 后者代表不偷第 $i$ 个房子的收益, 则最大收益就应该为二者中的较大者. 详细代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_rob=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_nrob=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cur_nrob;</span><br><span class="line">            cur_nrob = <span class="built_in">std</span>::max(cur_rob, cur_nrob);            </span><br><span class="line">            cur_rob = temp+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(cur_rob, cur_nrob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-根据房屋的编号奇偶性"><a href="#解法二-根据房屋的编号奇偶性" class="headerlink" title="解法二: 根据房屋的编号奇偶性"></a>解法二: 根据房屋的编号奇偶性</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>因为偷取的房屋不能相邻, 因此我们可以维护两个变量, <code>even</code> 是前偶数个房屋的最大收益, <code>odd</code> 是前奇数个房屋的最大收益, 对于任意的一个新来的房屋, 如果该新房屋的编号为奇数, 那么它的最大收益就是 <code>odd+new</code> 和 <code>even</code> 当中的较大者(因为不能相邻, 所以只能令 <code>odd+new</code>). 对于偶数的情况同理. 最终返回 <code>odd</code> 和 <code>even</code> 的较大者.(因为有可能包含最后一个元素, 也有可能不包含) 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> odd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> even=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) even = <span class="built_in">std</span>::max(odd, even+nums[i]);</span><br><span class="line">            <span class="keyword">else</span> odd = <span class="built_in">std</span>::max(odd+nums[i], even);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a>202. Happy Number</h1><h2 id="Description-判断一个数字是否是-Happer-Number"><a href="#Description-判断一个数字是否是-Happer-Number" class="headerlink" title="Description: 判断一个数字是否是 Happer Number"></a>Description: 判断一个数字是否是 Happer Number</h2><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example:</p>
<p>Input: 19<br>Output: true<br>Explanation:<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<h2 id="解法一-模拟计算过程"><a href="#解法一-模拟计算过程" class="headerlink" title="解法一: 模拟计算过程"></a>解法一: 模拟计算过程</h2><p><strong>时间复杂度:</strong> $O(logn)$, 基数为10<br><strong>空间复杂度:</strong> 未知, 取决于无序集合的size.</p>
<p>按照题目中的逻辑, 模拟整个计算过程, 如果出现1, 则返回 <code>true</code>, 如果出现循环(即在集合中发现已存在元素), 则返回 <code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span> &amp;&amp; num_set.find(n)==num_set.end())&#123;</span><br><span class="line">            num_set.insert(n);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">                n = n/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-Floyd-判圈算法"><a href="#解法二-Floyd-判圈算法" class="headerlink" title="解法二: Floyd 判圈算法"></a>解法二: Floyd 判圈算法</h2><p><strong>时间复杂度:</strong> $O(logn)$, 时间复杂度不变<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>利用 Floyd 判圈算法维护两个变量 <code>slow</code> 和 <code>fast</code>, <code>fast</code> 每次都比 <code>flow</code> 多走一步, 那么, 当 <code>fast==1</code> 时, 说明应该返回 <code>true</code>, 当 <code>slow==fast</code> 时, 说明存在循环, 应该返回 <code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=n, fast=n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = digitSquareSum(slow);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(fast!=<span class="number">1</span> &amp;&amp; slow!=fast);</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            temp += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204. Count Primes"></a>204. Count Primes</h1><h2 id="Description-素数的个数"><a href="#Description-素数的个数" class="headerlink" title="Description: 素数的个数"></a>Description: 素数的个数</h2><p>Count the number of prime numbers less than a non-negative number, n.</p>
<p>Example:</p>
<p>Input: 10<br>Output: 4<br>Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</p>
<h2 id="解法一-填充非素数"><a href="#解法一-填充非素数" class="headerlink" title="解法一: 填充非素数"></a>解法一: 填充非素数</h2><p><strong>时间复杂度:</strong> $O(n)$, 至多遍历两次 $n$ 大小的数组, 可优化为只遍历一次.<br><strong>空间复杂度:</strong> $O(n)$, 申请了 $n$ 大小的一维布尔数组来标识是否为负数</p>
<p><img src="http://wx3.sinaimg.cn/large/d7b90c85ly1fxngsjxjyag20cd0a9q6x.gif" alt=""></p>
<p>如上图, 我们从 $2\times 2$ 开始填充, 将所有能与2相乘切乘积小于 $n$ 的数对应下标置为 <code>false</code>, 然后从 $3\times 3$ 开始填充(注意不是从 $3\times 2$, 因为这样会与前面的 $2\times 3$ 重复), 接着从 $4\times 4$ 开始填充, 因此, 填充的开始位置最大为 $\sqrt{n}$. 另外需要注意的是, 0 和 1 均不是素数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> div_n = <span class="built_in">sqrt</span>(n)+<span class="number">1</span>; <span class="comment">// 注意这里是开根号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_primes(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;div_n; i++)&#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;n; j+=i)&#123;</span><br><span class="line">                is_primes[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res_count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> primes : is_primes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(primes==<span class="literal">true</span>) res_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_count<span class="number">-2</span>; <span class="comment">//去掉0和1的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优化1: 因为任何一个合数都可以拆分成素数的乘积, 因此我们只在当前元素为素数的时候才开始填充, 例如, 对于4, 我们不填充16, 20, ..等数字, 因为这些数字在开始元素为2的时候已经填充过了. 因此, 可以避免这些重复填充, 减少迭代次数, 代码如下(多加了一条<code>if</code>语句).</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> div_n = <span class="built_in">sqrt</span>(n)+<span class="number">1</span>; <span class="comment">// 注意这里是开根号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_primes(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;div_n; i++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(is_primes[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;n; j+=i)&#123;</span><br><span class="line">                    is_primes[j]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::count(is_primes.begin(), is_primes.end(), <span class="literal">true</span>)<span class="number">-2</span>; <span class="comment">//去掉0和1的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优化2: 只遍历一次.</strong> 令<code>res_count</code>为总的数字个数, 每次找到一个合数时, 令<code>res_count--</code>, 这样就无需二次遍历数组. 但是使用这种优化的条件是必须确保不能有重复填充的情况, 否则会多计数合数的个数, 导致素数的个数少计数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> div_n = <span class="built_in">sqrt</span>(n)+<span class="number">1</span>; <span class="comment">// 注意这里是开根号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_primes(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> res_count = n<span class="number">-2</span>;<span class="comment">//去掉0和1的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;div_n; i++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(is_primes[i])&#123;<span class="comment">//确保不从合数开始填充</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;n; j+=i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(is_primes[j])&#123;<span class="comment">//确保没有重复填充</span></span><br><span class="line">                        is_primes[j]=<span class="literal">false</span>;</span><br><span class="line">                        res_count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><h2 id="Description-逆置链表"><a href="#Description-逆置链表" class="headerlink" title="Description: 逆置链表"></a>Description: 逆置链表</h2><p>Reverse a singly linked list.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h2 id="解法一-迭代"><a href="#解法一-迭代" class="headerlink" title="解法一: 迭代"></a>解法一: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次链表<br><strong>空间复杂度:</strong> $O(1)$, 借助3个复制指针完成逆置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* next = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归-1"><a href="#解法二-递归-1" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 迭代需要占用 $O(n)$ 大小的栈空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *P = reverseList(head-&gt;next); <span class="comment">//令下一个开始的节点逆置, 返回新链表的头结点</span></span><br><span class="line">        head-&gt;next-&gt;next = head; <span class="comment">// 将当前节点逆置</span></span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>; <span class="comment">// 将当前节点的下一个置空, 主要是处理新的尾节点, 其他节点的next会在递归中正确赋值</span></span><br><span class="line">        <span class="keyword">return</span> P; <span class="comment">//返回新的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a>217. Contains Duplicate</h1><h2 id="Description-判断数组中是否有重复元素"><a href="#Description-判断数组中是否有重复元素" class="headerlink" title="Description: 判断数组中是否有重复元素"></a>Description: 判断数组中是否有重复元素</h2><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,1]<br>Output: true<br>Example 2:</p>
<p>Input: [1,2,3,4]<br>Output: false<br>Example 3:</p>
<p>Input: [1,1,1,3,3,4,3,2,4,2]<br>Output: true</p>
<h2 id="解法一-暴力-2"><a href="#解法一-暴力-2" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 暴力求解, 双重循环<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>时间超限, 无法通过 OJ</p>
<h2 id="解法二-排序-遍历"><a href="#解法二-排序-遍历" class="headerlink" title="解法二: 排序+遍历"></a>解法二: 排序+遍历</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 先排序, 然后遍历看是否有相邻元素相等, 即 $O(nlogn + n)$, 也就是 $O(nlogn)$.<br><strong>空间复杂度:</strong> $O(1)$, 基于不同的排序算法决定, 使用堆排序则为 $O(1)$.</p>
<h2 id="解法三-unordered-set-哈希"><a href="#解法三-unordered-set-哈希" class="headerlink" title="解法三: unordered_set(哈希)"></a>解法三: unordered_set(哈希)</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一遍数组, 在 unordered_set 中查询的复杂度为常数<br><strong>空间复杂度:</strong> $O(n)$, unordered_set占用额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_set.find(num) == nums_set.end())</span><br><span class="line">                nums_set.insert(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h1><h2 id="Description-回文链表判断"><a href="#Description-回文链表判断" class="headerlink" title="Description: 回文链表判断"></a>Description: 回文链表判断</h2><p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
<h2 id="解法一-借助辅助数组"><a href="#解法一-借助辅助数组" class="headerlink" title="解法一: 借助辅助数组"></a>解法一: 借助辅助数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 两次遍历<br><strong>空间复杂度:</strong> $O(n)$, 额外数组</p>
<p>最简单的做法就是遍历链表, 将其转换成一个可随机访问的数组, 然后进行回文串的判断.</p>
<h2 id="解法二-不借助辅助数组"><a href="#解法二-不借助辅助数组" class="headerlink" title="解法二: 不借助辅助数组"></a>解法二: 不借助辅助数组</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法刷题/" rel="tag"><i class="fa fa-tag"></i> 算法刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/z_post/面试-算法刷题-LeetCode-2/" rel="prev" title="LeetCode算法题(Medium)">
                <i class="fa fa-chevron-left"></i> LeetCode算法题(Medium)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/z_post/深度学习-机器学习经典算法之SVM深入解析/" rel="next" title="机器学习经典算法之SVM深入解析">
                机器学习经典算法之SVM深入解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar_zz.png"
                alt="ZeroZone" />
            
              <p class="site-author-name" itemprop="name">ZeroZone</p>
              <p class="site-description motion-element" itemprop="description">并不是什么厉害的地方<br>只是一个安静的学习角落</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">207</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hellozhaozheng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hellozhaozheng@foxmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/ksws0292756" title="CSDN博客" target="_blank">CSDN博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#001-Two-Sum"><span class="nav-text">001. Two Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表-两次遍历"><span class="nav-text">解法二 : 哈希表, 两次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-哈希表-一次遍历"><span class="nav-text">解法三: 哈希表 一次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题"><span class="nav-text">扩展问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#007"><span class="nav-text">007.</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-取余数"><span class="nav-text">解法一: 取余数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#013-Roman-to-Integer"><span class="nav-text">013. Roman to Integer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序扫描"><span class="nav-text">解法一: 顺序扫描</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题-异常检测"><span class="nav-text">扩展问题: 异常检测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#014"><span class="nav-text">014.</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-1"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序比较"><span class="nav-text">解法一: 顺序比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#020-Valid-Parentheses"><span class="nav-text">020. Valid Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-2"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈"><span class="nav-text">解法一: 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#021-Merge-Two-Sorted-Lists"><span class="nav-text">021. Merge Two Sorted Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-3"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历融合"><span class="nav-text">解法一: 遍历融合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#026-Remove-Duplicates-from-Sorted-Array"><span class="nav-text">026. Remove Duplicates from Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-4"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一"><span class="nav-text">解法一:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-Implement-strStr"><span class="nav-text">28. Implement strStr()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#description"><span class="nav-text">description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-KMP"><span class="nav-text">解法二: KMP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#038-Count-and-Say"><span class="nav-text">038. Count and Say</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-5"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-依次查看上一次的数字"><span class="nav-text">解法一: 依次查看上一次的数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#053-Maximum-Subarray"><span class="nav-text">053. Maximum Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-6"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-记录当前最大值"><span class="nav-text">解法: 记录当前最大值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#066-Plus-One"><span class="nav-text">066. Plus One</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-7"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-直接模拟"><span class="nav-text">解法一: 直接模拟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-不使用加法-更快更简单-击败100"><span class="nav-text">解法二: 不使用加法(更快更简单, 击败100%)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#069-Sqrt-x"><span class="nav-text">069. Sqrt(x)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-8"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-二分法"><span class="nav-text">解法一: 二分法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-牛顿迭代法"><span class="nav-text">解法二: 牛顿迭代法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-按位检索"><span class="nav-text">解法三: 按位检索</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#070-Climbing-Stairs"><span class="nav-text">070. Climbing Stairs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-9"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#088-Merge-Sorted-Array"><span class="nav-text">088. Merge Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-10"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-后移-插入融合"><span class="nav-text">解法一: 后移+插入融合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-Symmetric-Tree"><span class="nav-text">101. Symmetric Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-11"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-1"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-1"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="nav-text">104. Maximum Depth of Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-12"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历"><span class="nav-text">解法一: 层次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-13"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归构造"><span class="nav-text">解法一: 递归构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-2"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解法三-迭代-只中根遍历一次"><span class="nav-text">解法三: 迭代(只中根遍历一次)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#111-minimum-depth-of-binary-tree"><span class="nav-text">111. minimum depth of binary tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-1"><span class="nav-text">　题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-1"><span class="nav-text">解法一:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归"><span class="nav-text">解法二(递归):</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-Pascal’s-Triangle"><span class="nav-text">118. Pascal’s Triangle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-14"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-按照三角形的性质进行赋值"><span class="nav-text">解法一: 按照三角形的性质进行赋值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-text">121. Best Time to Buy and Sell Stock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-15"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举-1"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历"><span class="nav-text">解法二: 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-text">122. Best Time to Buy and Sell Stock II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-16"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用变量维护最低价格"><span class="nav-text">解法一: 用变量维护最低价格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-每两个相邻数字当做一次交易"><span class="nav-text">解法二: 每两个相邻数字当做一次交易</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-Valid-Palindrome"><span class="nav-text">125 Valid Palindrome</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-17"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-前后两个指示变量-向中间遍历判断"><span class="nav-text">解法一: 前后两个指示变量, 向中间遍历判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-Single-Number"><span class="nav-text">136. Single Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-18"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希"><span class="nav-text">解法一: 哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-数学公式"><span class="nav-text">解法二: 数学公式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-异或"><span class="nav-text">解法三: 异或</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-Linked-List-Cycle"><span class="nav-text">141. Linked List Cycle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-19"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-Floyd-Cycle-Floyd-判圈算法"><span class="nav-text">解法一: Floyd Cycle(Floyd 判圈算法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-Min-Stack"><span class="nav-text">155. Min Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-20"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-两个栈"><span class="nav-text">解法一: 两个栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="nav-text">160. Intersection of Two Linked Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-21"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：栈"><span class="nav-text">解法一：栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解法二-常数空间复杂度"><span class="nav-text">解法二: 常数空间复杂度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-Majority-Element"><span class="nav-text">169 Majority Element</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出数组中超过一半的数字"><span class="nav-text">Description: 找出数组中超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希"><span class="nav-text">解法二: 哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-同增异减"><span class="nav-text">解法三: 同增异减</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-随机"><span class="nav-text">解法四: 随机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel-Sheet-Column-Number"><span class="nav-text">171. Excel Sheet Column Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-Excel列表数字"><span class="nav-text">Description: Excel列表数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历字符串"><span class="nav-text">解法一: 遍历字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#172-Factorial-Trailing-Zeroes"><span class="nav-text">172. Factorial Trailing Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-阶乘的尾部含有0的个数"><span class="nav-text">Description: 阶乘的尾部含有0的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-统计5的个数"><span class="nav-text">解法一: 统计5的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-另一个角度"><span class="nav-text">解法二: 另一个角度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-Rotate-Array"><span class="nav-text">189. Rotate Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-循环右移数组"><span class="nav-text">Description: 循环右移数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-1"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-使用额外数组"><span class="nav-text">解法二: 使用额外数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-循环置换"><span class="nav-text">解法三: 循环置换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-reverse"><span class="nav-text">解法四: reverse</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#190"><span class="nav-text">190.</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-按位逆置"><span class="nav-text">Description: 按位逆置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-按位进行32次操作"><span class="nav-text">解法一: 按位进行32次操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-按位二分进行5次操作"><span class="nav-text">解法二: 按位二分进行5次操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#191-Number-of-1-Bits"><span class="nav-text">191. Number of 1 Bits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-统计二进制中1的个数"><span class="nav-text">Description: 统计二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-逐位统计"><span class="nav-text">解法一: 逐位统计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-和-n-1-按位与"><span class="nav-text">解法二: 和 $n-1$ 按位与</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#198-House-Robber"><span class="nav-text">198. House Robber</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-房屋小偷获取最大收益"><span class="nav-text">Description: 房屋小偷获取最大收益</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP"><span class="nav-text">解法一: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-根据房屋的编号奇偶性"><span class="nav-text">解法二: 根据房屋的编号奇偶性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#202-Happy-Number"><span class="nav-text">202. Happy Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断一个数字是否是-Happer-Number"><span class="nav-text">Description: 判断一个数字是否是 Happer Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-模拟计算过程"><span class="nav-text">解法一: 模拟计算过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-Floyd-判圈算法"><span class="nav-text">解法二: Floyd 判圈算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#204-Count-Primes"><span class="nav-text">204. Count Primes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-素数的个数"><span class="nav-text">Description: 素数的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-填充非素数"><span class="nav-text">解法一: 填充非素数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-Reverse-Linked-List"><span class="nav-text">206. Reverse Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-逆置链表"><span class="nav-text">Description: 逆置链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代"><span class="nav-text">解法一: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归-1"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#217-Contains-Duplicate"><span class="nav-text">217. Contains Duplicate</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断数组中是否有重复元素"><span class="nav-text">Description: 判断数组中是否有重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-2"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-排序-遍历"><span class="nav-text">解法二: 排序+遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-unordered-set-哈希"><span class="nav-text">解法三: unordered_set(哈希)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#234-Palindrome-Linked-List"><span class="nav-text">234. Palindrome Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-回文链表判断"><span class="nav-text">Description: 回文链表判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-借助辅助数组"><span class="nav-text">解法一: 借助辅助数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-不借助辅助数组"><span class="nav-text">解法二: 不借助辅助数组</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroZone</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">1.1m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">16:17</span>
  
</div>










  <div class="footer-custom">勤练带来力量</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
