<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">

<meta name="google-site-verification" content="jgw73iXouBAJcOuff0yi9vdSNDecBSOUXacsHJszpmo" />
<meta name="baidu-site-verification" content="xyf9WD2vvl" />











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/apple-icon-57x57.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_body":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1. 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 2. 替换空格3.从尾到头打印链表4.重建二叉树5.用两个栈实现队列6.旋转数组的最小数字7.斐波那契数列8.跳台阶9.变态跳台阶10.矩形覆盖11.二进制中1的个数12.数值的">
<meta name="keywords" content="算法刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="《剑指offer》">
<meta property="og:url" content="https://hellozhaozheng.github.io/z_post/面试-算法刷题-剑指offer/index.html">
<meta property="og:site_name" content="从零开始的BLOG">
<meta property="og:description" content="1. 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 2. 替换空格3.从尾到头打印链表4.重建二叉树5.用两个栈实现队列6.旋转数组的最小数字7.斐波那契数列8.跳台阶9.变态跳台阶10.矩形覆盖11.二进制中1的个数12.数值的">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-10-12T23:39:33.047Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《剑指offer》">
<meta name="twitter:description" content="1. 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 2. 替换空格3.从尾到头打印链表4.重建二叉树5.用两个栈实现队列6.旋转数组的最小数字7.斐波那契数列8.跳台阶9.变态跳台阶10.矩形覆盖11.二进制中1的个数12.数值的">






  <link rel="canonical" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-剑指offer/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>《剑指offer》 | 从零开始的BLOG</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?21a4899cc63d3c11a3d90ac58074a19c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">131</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-计算机视觉">
    <a href="/categories/计算机视觉/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tripadvisor"></i> <br />计算机视觉</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-深度学习">
    <a href="/categories/深度学习/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-drupal"></i> <br />深度学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">
    <a href="/categories/Cpp/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />C++</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-python">
    <a href="/categories/Python/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-product-hunt"></i> <br />Python</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-linux">
    <a href="/categories/Linux/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-linux"></i> <br />Linux</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-caffe2">
    <a href="/categories/Caffe2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />Caffe2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-项目">
    <a href="/categories/项目/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-connectdevelop"></i> <br />项目</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-cuda">
    <a href="/categories/CUDA/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-braille"></i> <br />CUDA</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-面试">
    <a href="/categories/面试/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-address-card"></i> <br />面试</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-其它">
    <a href="/categories/其它/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />其它</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">25</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-life">
    <a href="/life/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-child"></i> <br />生活杂记</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />站内搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="站内搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/hellozhaozheng" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-剑指offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZeroZone">
      <meta itemprop="description" content="并不是什么厉害的地方<br>只是一个安静的学习角落">
      <meta itemprop="image" content="/images/avatar_zz.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《剑指offer》
              
            
          </h1>
        

        <div class="post-meta">
	
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-26 07:48:58" itemprop="dateCreated datePublished" datetime="2018-08-26T07:48:58+08:00">2018-08-26</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">76k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:09</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p>
<h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h1><h1 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h1><h1 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a>4.重建二叉树</h1><h1 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h1><h1 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h1><h1 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.斐波那契数列</h1><h1 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h1><h1 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h1><h1 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h1><h1 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h1><h1 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h1><h1 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h1><h1 id="14-链表中倒数第k个节点"><a href="#14-链表中倒数第k个节点" class="headerlink" title="14.链表中倒数第k个节点"></a>14.链表中倒数第k个节点</h1><h1 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h1><h1 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h1><h1 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h1><h1 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h1><h1 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h1><h1 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h1><h1 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h1><h1 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h1><h1 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h1><h1 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h1><h1 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>链表的复制不同于其他复制，在进行链表复制时，必须创建新的节点，同时，不能通过<code>newnode-&gt;next = oldnode-next</code>对新节点进行赋值，这是因为这样赋值会使新链表指向旧链表的节点，造成混乱。</p>
<h2 id="正确解题思路："><a href="#正确解题思路：" class="headerlink" title="正确解题思路："></a>正确解题思路：</h2><ul>
<li>先对原链表中的每一个节点进行复制，将复制的节点插入到原节点之后，比如原链表是<code>A-&gt;B-&gt;C</code>，则复制后应该变成<code>A-&gt;A1-&gt;B-&gt;B1-&gt;C-&gt;C1</code>。</li>
<li>再按照原始链表中随机指针的指向，对新节点的随机指针进行赋值。</li>
<li>将链表拆分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//少考虑这种情况会发生段错误</span></span><br><span class="line">        RandomListNode* curnode = pHead;</span><br><span class="line">        <span class="comment">//C++允许在声明结构变量时省略关键字struct，但是C不允许</span></span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* clonenode = <span class="keyword">new</span> RandomListNode(curnode-&gt;label);</span><br><span class="line">            clonenode-&gt;next = curnode-&gt;next;</span><br><span class="line">            curnode-&gt;next = clonenode;</span><br><span class="line">            curnode = clonenode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curnode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curnode-&gt;random!=<span class="literal">NULL</span>)&#123;  <span class="comment">//少考虑这种情况会不满足个别用例</span></span><br><span class="line">                curnode-&gt;next-&gt;random = curnode-&gt;random-&gt;next;</span><br><span class="line">                curnode = curnode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curnode-&gt;next-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">                curnode = curnode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curnode = pHead;</span><br><span class="line">        RandomListNode* newhead = pHead-&gt;next;</span><br><span class="line">        RandomListNode* newcur = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newcur-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                curnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curnode-&gt;next = newcur-&gt;next;</span><br><span class="line">            newcur-&gt;next = newcur-&gt;next-&gt;next;</span><br><span class="line">            curnode = curnode-&gt;next;</span><br><span class="line">            newcur = newcur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中结点指针的指向。</p>
<h2 id="解法一：自己的思路"><a href="#解法一：自己的思路" class="headerlink" title="解法一：自己的思路"></a>解法一：自己的思路</h2><p>后序遍历，递归实现，首先将左子树全部变成有序的，然后将右子树全部变成有序的。由于在返回时，返回的是左右子树的根节点，因此，在将当前根节点与左右子树拼接时，需要移动到左子树的最后一个元素上（最大），与当前根节点的left拼接。对于右子树，要移动到右子树的第一个元素上（最小），与当前根节点的right拼接。</p>
<p>这里有一个需要注意的地方，以下两种声明方式，指针一定要初始化之后才能使用，会使代码结果表现不同，前者超时，后者通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* pre=<span class="literal">nullptr</span>,* next=<span class="literal">nullptr</span>;</span><br><span class="line">TreeNode* pre,* next;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = recurve(pRootOfTree);</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recurve</span><span class="params">(TreeNode* pRootOfTree)</span></span>&#123;</span><br><span class="line">        TreeNode* pre=<span class="literal">nullptr</span>,* next=<span class="literal">nullptr</span>; <span class="comment">// 这里，如果没有指定nullptr，则程序会超时！！！</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>!=pRootOfTree-&gt;left)</span><br><span class="line">            pre = recurve(pRootOfTree-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>!=pRootOfTree-&gt;right)</span><br><span class="line">            next = recurve(pRootOfTree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                pre=pre-&gt;right;</span><br><span class="line">            pRootOfTree-&gt;left = pre;</span><br><span class="line">            pre-&gt;right = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(next-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                next = next-&gt;left;</span><br><span class="line">            pRootOfTree-&gt;right = next;</span><br><span class="line">            next-&gt;left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：中序遍历，递归实现"><a href="#解法二：中序遍历，递归实现" class="headerlink" title="解法二：中序遍历，递归实现"></a>解法二：中序遍历，递归实现</h2><p>由于对搜索二叉树来说，中序遍历的结果就是有序的，因此，只需要通过维护一个prenode指针来标记当前节点的上一个节点即可完成双向有序链表。</p>
<p>注意，这里有一个非常关键的点，那就是<code>TreeNode*&amp; prenode</code>，如果少了<code>&amp;</code>引用标识，则结果错误！具体原因看文章关于<code>*&amp;</code>和<code>*</code>的联系和区别。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* prenode = <span class="literal">nullptr</span>;</span><br><span class="line">        recurve(pRootOfTree,prenode);</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurve</span><span class="params">(TreeNode* root, TreeNode*&amp; prenode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurve(root-&gt;left,prenode);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = prenode;</span><br><span class="line">        <span class="keyword">if</span>(prenode!=<span class="literal">nullptr</span>) prenode-&gt;right = root;</span><br><span class="line">        prenode = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurve(root-&gt;right,prenode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三：中序遍历，非递归实现"><a href="#解法三：中序遍历，非递归实现" class="headerlink" title="解法三：中序遍历，非递归实现"></a>解法三：中序遍历，非递归实现</h2><p>基于中序遍历的非递归方法，思路与解法二一致。</p>
<p><del><strong>但是这里有个疑问，为什么使用下面的代码会发生段错误。</strong></del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(pRootOfTree-&gt;left!=nullptr)</span><br><span class="line">    pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">return pRootOfTree;</span><br><span class="line"></span><br><span class="line">发生段错误的原因主要是因为没有对pRootOfTree进行空指针检查,</span><br><span class="line">就直接使用了该指针的成员变量, 访问了本不存在的内存, 从而造成</span><br><span class="line">了段错误, 修改方法是在程序前加上空指针检查</span><br></pre></td></tr></table></figure></p>
<p>以下代码额外设置了一个指针指向第一个节点，以避免使用上面代码带来的段错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S_node;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        TreeNode* P = pRootOfTree;</span><br><span class="line">        <span class="comment">// TreeNode* node = pRootOfTree; 进行了空指针检查, 所以不用再使用这个指针了, 下面也是同理</span></span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>||!S_node.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                S_node.push(P);</span><br><span class="line">                P = P-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!S_node.empty())&#123;</span><br><span class="line">                P = S_node.top();</span><br><span class="line">                P-&gt;left = pre;</span><br><span class="line">                <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pre-&gt;right = P;</span><br><span class="line">                &#125;<span class="comment">//else</span></span><br><span class="line">                    <span class="comment">//node = P;</span></span><br><span class="line">                pre = P;</span><br><span class="line">                S_node.pop();</span><br><span class="line">                P = P-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">        <span class="comment">//return node;</span></span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27.字符串的排列"></a>27.字符串的排列</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a，b，c所能排列出来的所有字符串abc，acb，bac，cab和cab。</p>
<h2 id="思路（没想到）："><a href="#思路（没想到）：" class="headerlink" title="思路（没想到）："></a>思路（没想到）：</h2><p>将一个字符串看成两个部分，前一部分为首位字母，剩下的是后一部分。通过将首位字母与后一部分的所有字符交换（包括跟自己交换），可以得到第一个位置的所有可能情况。然后，再将剩下的部分看作是一个新的字符串，同样将剩余部分分成两部分，其中，第一部分是剩余部分的首位。如此，可以按照递归进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bool my_sort(string s1, string s2)&#123; return s1&lt;s2;&#125;;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v_string;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>) <span class="keyword">return</span> v_string;</span><br><span class="line">        PermutationHelp(v_string, <span class="number">0</span>, str);</span><br><span class="line">        <span class="built_in">std</span>::sort(v_string.begin(), v_string.end());</span><br><span class="line">        <span class="keyword">return</span> v_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PermutationHelp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v_string, <span class="keyword">int</span> pos, <span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="comment">/* if(pos == 0 )&#123;</span></span><br><span class="line"><span class="comment">            v_string.push_back(str);</span></span><br><span class="line"><span class="comment">            PermutationHelp(v_string, pos+1, str);</span></span><br><span class="line"><span class="comment">        &#125; * /</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //这里i=pos而不是pos+1的原因是：如果用pos+1,会导致丟解，即自己与自己交换的那种情况没有继续向下递归</span></span><br><span class="line"><span class="comment">        for(int i=pos; i&lt;str.length(); i++)&#123;</span></span><br><span class="line"><span class="comment">            std::swap(str.at(pos), str.at(i));</span></span><br><span class="line"><span class="comment">            if(std::count(v_string.begin(), v_string.end(), str) == 0)</span></span><br><span class="line"><span class="comment">                v_string.push_back(str);</span></span><br><span class="line"><span class="comment">            PermutationHelp(v_string, pos+1, str);</span></span><br><span class="line"><span class="comment">            //std::swap(str.at(pos), str.at(i));</span></span><br><span class="line"><span class="comment">            //注释本行的原因是因为，这里，由于，我们只需要将后面的n-1中字符依次置换到首位，因此，无须在置换后进行还原再置换，直接进行置换即可</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure>
<h1 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28.数组中出现次数超过一半的数字"></a>28.数组中出现次数超过一半的数字</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为-nlog-n-。"><a href="#思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为-nlog-n-。" class="headerlink" title="思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为 $nlog(n)$ 。"></a>思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为 $nlog(n)$ 。</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bool mysort(int a, int b) &#123;return a&lt;b;&#125;</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counts;</span><br><span class="line">            <span class="built_in">std</span>::sort(numbers.begin(), numbers.end());</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">std</span>::count(numbers.begin(), numbers.end(), numbers.at((<span class="keyword">int</span>)numbers.size()/<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (n &gt; numbers.size()/<span class="number">2</span>) <span class="keyword">return</span> numbers.at((<span class="keyword">int</span>)numbers.size()/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>根据快排的思想，由于该数字一定在数组的中间位置，那么可以借助Partition来实现，随机选一个数字进行Partition，如果返回的mid索引最终停在N/2处，那么该索引对应的数字就有可能是答案，此时，只需统计该数字的出现次数即可。</p>
<p>该方法的时间复杂度是 $O(n)$ ，因为只会执行一边的Partition，并不会执行另一边。</p>
<p>需要注意，具体在代码中看</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mysort</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a&lt;b;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = Partition(numbers, low, high);</span><br><span class="line">        <span class="keyword">while</span>(mid != numbers.size()/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; numbers.size()/<span class="number">2</span>)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                mid = Partition(numbers, low, high);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                mid = Partition(numbers,low, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">std</span>::count(numbers.begin(), numbers.end(), numbers.at(mid)) &gt; numbers.size()/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> numbers.at(mid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = numbers.at(low);</span><br><span class="line">        <span class="keyword">int</span> mid = low;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; p &lt; numbers.at(high)) high--;</span><br><span class="line">		<span class="comment">//这里如果p用的是&lt;,则需要下面的low++逻辑，否则，会陷入死循环，如果用的是&lt;=，则在返回时，会返回首个元素的坐标</span></span><br><span class="line">            numbers.at(low) = numbers.at(high);</span><br><span class="line">            <span class="keyword">if</span>(low!=high) low++;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; p &gt; numbers.at(low)) low++;</span><br><span class="line">            numbers.at(high) = numbers.at(low);</span><br><span class="line">            <span class="keyword">if</span>(low!=high) high--;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.at(low) = p;</span><br><span class="line">        <span class="keyword">if</span>(low == high) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="思路三："><a href="#思路三：" class="headerlink" title="思路三："></a>思路三：</h2><p> 如果数组中存在这样一个数，那么这个数的出现次数一定大于其他所有数的出现次数总和，因此，设置两个变量，一个number用来存储数组中的第一个数，另一个num置为1,如果下一个数与number数相同，则num加一，否则减1,如果num被减为0,那么number转而存储下一个数，同时将num置为1。</p>
<p>这样，如果存在这个数，最终这个数一定为number，且num大于1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        int number = numbers.at(0);</span><br><span class="line">        int num = 1;</span><br><span class="line">        for(vector&lt;int&gt;::iterator iter = numbers.begin()+1; iter != numbers.end(); iter++)&#123;</span><br><span class="line">            if(num == 0)&#123; //这里与下面的区别之一是，一定要放在for训练内部的前面</span><br><span class="line">                number = *(iter-1); //区别之二这里如果使用iter-1,则无须在最后做count检查</span><br><span class="line">                num = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(number == *iter) num++;</span><br><span class="line">            else num--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(num &gt;= 1) return number; //这里，num只需要&gt;=1 即可，仔细想一想这是为什么，为啥用了iter-1,就不用检查count。</span><br><span class="line">        else return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        int number = numbers.at(0);</span><br><span class="line">        int num = 1;</span><br><span class="line">        for(vector&lt;int&gt;::iterator iter = numbers.begin(); iter != numbers.end(); iter++)&#123;</span><br><span class="line">            if(number == *iter) num++;</span><br><span class="line">            else num--;</span><br><span class="line">            if(num == 0)&#123;</span><br><span class="line">                number = *iter;</span><br><span class="line">                num = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count(numbers.begin(), numbers.end(), number) &gt; numbers.size()/2) return number;</span><br><span class="line">        //由于上面用的是iter，所以最终的num为1的数，只是有可能是我们要得数字，因此，需要进行检查。</span><br><span class="line">        else return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入n个整数，找出最小的K个数，例如输入4,5,1,6,2,7,3,8，则输出1,2,3,4。</p>
<p>一定要考虑边界情况：</p>
<ul>
<li>数组为空</li>
<li>k大于数组size</li>
<li>k小于0</li>
</ul>
<h2 id="思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为-nlog-n-n-。-快排"><a href="#思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为-nlog-n-n-。-快排" class="headerlink" title="思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为 $nlog(n) + n$ 。 快排"></a>思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为 $nlog(n) + n$ 。 快排</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; k_input;</span><br><span class="line">        if(k &gt; input.size() || input.size()&lt;=0) return k_input;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = input.size()-1;</span><br><span class="line">        quickSort(input, low, high);</span><br><span class="line">        //vector&lt;int&gt; k_input(&amp;input.at(0), &amp;input.at(k-1));</span><br><span class="line">        for(int i=0; i&lt;k; i++) k_input.push_back(input.at(i));</span><br><span class="line">        return k_input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void quickSort(vector&lt;int&gt;&amp; input, int low, int high)&#123;</span><br><span class="line">        int mid = Partition(input, low, high);</span><br><span class="line"></span><br><span class="line">        if(mid&lt;high)    quickSort(input, mid+1, high);</span><br><span class="line">        if(mid&gt;low)    quickSort(input, low, mid-1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Partition(vector&lt;int&gt;&amp; input, int low, int high)&#123;</span><br><span class="line">        int p = input[low];</span><br><span class="line">        while(low&lt;high)&#123;</span><br><span class="line">            while(low&lt;high &amp;&amp; p&lt;=input[high]) high--;</span><br><span class="line">            input[low] = input[high];</span><br><span class="line">            while(low&lt;high &amp;&amp; p&gt;=input[low]) low++;</span><br><span class="line">            input[high] = input[low];</span><br><span class="line">        &#125;</span><br><span class="line">        input[low] = p;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="思路二：遍历整个数组，将当前元素与k-input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k-input。时间复杂度-O-nk-。（该思想与冒泡排序思想类似）。"><a href="#思路二：遍历整个数组，将当前元素与k-input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k-input。时间复杂度-O-nk-。（该思想与冒泡排序思想类似）。" class="headerlink" title="思路二：遍历整个数组，将当前元素与k_input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k_input。时间复杂度 $O(nk)$ 。（该思想与冒泡排序思想类似）。"></a>思路二：遍历整个数组，将当前元素与k_input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k_input。时间复杂度 $O(nk)$ 。（该思想与冒泡排序思想类似）。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; k_input;</span><br><span class="line">        if(k&gt;input.size() || input.size()&lt;=0) return k_input;</span><br><span class="line">        k_input.push_back(input.at(0));</span><br><span class="line">        for(auto iter = input.begin()+1; iter!=input.end(); iter++)&#123;</span><br><span class="line">            for(int i =0 ;i&lt;k; i++)&#123;</span><br><span class="line">                if(i == k_input.size())&#123;</span><br><span class="line">                    k_input.push_back(*iter);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if(*iter &lt; k_input.at(i))&#123;</span><br><span class="line">                    k_input.insert(k_input.begin()+i, *iter);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(k_input.size() &gt; k) k_input.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return k_input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-大顶堆"><a href="#解法三-大顶堆" class="headerlink" title="解法三: 大顶堆"></a>解法三: 大顶堆</h2><p>遍历数组, 维护一个大顶堆, 每遇到一个比堆顶小的数, 就将其插入大顶堆 (如果是找最大的k个数, 就用小顶堆)</p>
<p>时间复杂度: $nlogk$</p>
<h2 id="解法四-快速选择算法"><a href="#解法四-快速选择算法" class="headerlink" title="解法四: 快速选择算法"></a>解法四: 快速选择算法</h2><p><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/02.01.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/02.01.html</a></p>
<h1 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h2 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h2><p>穷举遍历，时间复杂度 $O(n^2)$ 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int max=array.at(0);</span><br><span class="line">        for(auto iter=array.begin(); iter!=array.end(); iter++)&#123;</span><br><span class="line">            //if(*iter &gt; 0)&#123;</span><br><span class="line">                int temp = 0;</span><br><span class="line">                for(auto it = iter; it!=array.end(); it++)&#123;</span><br><span class="line">                    temp += *it;</span><br><span class="line">                    if(temp &gt; max)</span><br><span class="line">                        max = temp;</span><br><span class="line">                //&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>$O(n)$ 的方法，根据数组性质，设置两个变量，一个记录当前的最大值，一个记录当前的子序列之和。首先，如果当前子序列之和为负，那么就是说，从当前位置开始的子序列，比从之前位置开始的子序列大，那么就可以不考虑从之前位置开始的子序列，之前累计的和也被抛弃。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="built_in">array</span>.at(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> s = <span class="built_in">array</span>.at(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">array</span>.begin()+<span class="number">1</span>; iter!=<span class="built_in">array</span>.end(); iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                s = * iter;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s += * iter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( max &lt; s)&#123;</span><br><span class="line">                max = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h2><p>动态规划。与解法二的思路异曲同工，核心思想可有下述公式表示。 $f(i)代表以第i个数字结尾的子数组的连续最大和$</p>
<script type="math/tex; mode=display">f(x)=
\begin{cases}
pData[i]& {i=0 或者f(i-1)\le 0} \\
f(i-1)+pData[i]& {i\ne 0 并且 f(i-1) > 0}
\end{cases}</script><p>上面的形式是递归的，通常情况下都用递归的方式来分析动态规划问题，但最终都会基于循环去编码。  上述公式对应的非递归形式就是思路二的代码。</p>
<p>递归写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int max = array.at(0);</span><br><span class="line">        f(array, array.size()-1, max);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int f(vector&lt;int&gt;&amp; array, int i, int&amp; max)&#123;</span><br><span class="line">        if(i==0) return array.at(0);</span><br><span class="line">        int f1  = f(array, i-1, max);</span><br><span class="line">        if(f1&lt;0)</span><br><span class="line">            f1 = array.at(i);</span><br><span class="line">        else&#123;</span><br><span class="line">            f1 = f1+ array.at(i);</span><br><span class="line">        &#125;</span><br><span class="line">        if(f1&gt; max) max =f1;</span><br><span class="line">        return f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="31-整数中1出现的次数（从1到整数n中1出现的次数）"><a href="#31-整数中1出现的次数（从1到整数n中1出现的次数）" class="headerlink" title="31.整数中1出现的次数（从1到整数n中1出现的次数）"></a>31.整数中1出现的次数（从1到整数n中1出现的次数）</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h2 id="解法一：-1"><a href="#解法一：-1" class="headerlink" title="解法一："></a>解法一：</h2><p>直接借助C++函数，先将int转换成string，然后count计算string里面‘1’的个数。（这种方法可能面试不会满意，可以提一下，不过肯定有其他方法）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count_1 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="built_in">std</span>::to_string(i);</span><br><span class="line">            count_1 += <span class="built_in">std</span>::count(str.begin(), str.end(), <span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count_1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：-1"><a href="#解法二：-1" class="headerlink" title="解法二："></a>解法二：</h2><p>对每个数字进行除和求余的运算，得到每个数字中1的个数，然后将个数相加。 该方法的复杂度为 $O(nlogn)$ ，该种思想过于直接，时间复杂度较高，属于次等方案。（注意：这里的log底数按理说是10 ，但说大O记法是不考虑常数的，所以直接表示成log就可以）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i1 = has1(i);</span><br><span class="line">            <span class="keyword">if</span>(i1)</span><br><span class="line">                count+=i1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">has1</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三：-1"><a href="#解法三：-1" class="headerlink" title="解法三："></a>解法三：</h2><p>设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上为1的情况有多少种进行分析</p>
<p>根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</p>
<p>当i表示百位，且百位对应的数&gt;=2时,如n=31456,i=100，则a=314,b=56，此时百位为1的情况有a/10+1=32（最高两位0~31，百位为1,共32种），每一种都包含100个连续的点，即共有(a%10+1) * 100种情况百位为1</p>
<p>当i表示百位，且百位对应的数为1时，如n=31156， i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)种情况是包含100个连续点，当最高两位为31（即a=311），本次只对应部分情况00~56，共b+1种，所有点加起来共有（a%10*100）+(b+1)种情况可以是百位为1</p>
<p>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的情况有a/10=31种（最高两位0~30）</p>
<p>综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，当百位为1时，有(a%10==1)种，另外需要增加部分情况b+1种</p>
<p>之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;=n; i*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = n/i;</span><br><span class="line">            <span class="keyword">int</span> b = n%i;</span><br><span class="line">            count+=(a+<span class="number">8</span>)/<span class="number">10</span>*i+(<span class="keyword">int</span>)(a%<span class="number">10</span>==<span class="number">1</span>)*(b+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h2><p>剑指offer的递归方法，没看懂，感觉好像有错误？</p>
<h1 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h2 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h2><ol>
<li>找出一个新的排序规则，同时要证明这个排序规则是有效的</li>
<li>看到将两个int整数拼接在一起，就应该想到大数问题</li>
</ol>
<h2 id="解法一：-2"><a href="#解法一：-2" class="headerlink" title="解法一："></a>解法一：</h2><p>主要考虑如何制定一个合理的判断规则：</p>
<p><strong>比较两个字符串s1, s2大小的时候，先将它们拼接起来，比较s1+s2,和s2+s1那个大，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面。</strong></p>
<p>基于上面的规则，首先将<code>vector&lt;int&gt;</code>转换成对应的<code>vector&lt;string&gt;</code>，然后直接利用快排进行排序，最后将排好序的字符串向量拼接输出。</p>
<p>时间复杂度为主要在排序，因此为 $O(nlogn)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=numbers.begin(); it!=numbers.end(); it++)&#123;</span><br><span class="line">            str_numbers.push_back(<span class="built_in">std</span>::to_string(*it));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        quickSort(str_numbers, low, high);</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = str_numbers.begin(); it != str_numbers.end(); it++)&#123;</span><br><span class="line">            s+=*it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; str_numbers, <span class="keyword">int</span> low , <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = Partition(str_numbers, low, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) quickSort(str_numbers,mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;low) quickSort(str_numbers, low, mid<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; str_numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> p = str_numbers.at(low);</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="built_in">string</span> s1= p + str_numbers.at(high);</span><br><span class="line">            <span class="built_in">string</span> s2= str_numbers.at(high) + p;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; s1.compare(s2) &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                high--;</span><br><span class="line">                s1 = p + str_numbers.at(high);</span><br><span class="line">                s2 = str_numbers.at(high) + p;</span><br><span class="line">            &#125;</span><br><span class="line">            str_numbers.at(low) = str_numbers.at(high);</span><br><span class="line">            <span class="keyword">if</span>(high&gt;low) low++;</span><br><span class="line"></span><br><span class="line">            s1 = p + str_numbers.at(low);</span><br><span class="line">            s2 = str_numbers.at(low) + p;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; s1.compare(s2) &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                s1 = p + str_numbers.at(low);</span><br><span class="line">                s2 = str_numbers.at(low) + p;</span><br><span class="line">            &#125;</span><br><span class="line">            str_numbers.at(high) = str_numbers.at(low);</span><br><span class="line">            <span class="keyword">if</span>(high&gt;low) high--;</span><br><span class="line">        &#125;</span><br><span class="line">        str_numbers.at(low) = p;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h1><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数</p>
<h2 id="解法一：-3"><a href="#解法一：-3" class="headerlink" title="解法一："></a>解法一：</h2><p>最简单的方法，就是对所有整数进行判断，该方法很容易超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ugly=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">            <span class="keyword">if</span>(IsUgly(num))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                ugly = num;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsUgly</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            num /=<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：-2"><a href="#解法二：-2" class="headerlink" title="解法二："></a>解法二：</h2><p>用空间换时间，用一个数组将之前的丑数都存起来，然后，在判断下一个丑数时，不用对逐个整数判断，而只是与丑数和2,3,5的乘积进行判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用指针时，一定要千万注意，指针会改变指向地址的值，使得其他指向该地址的指针，其指向的值也跟着变！</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>* UglyArray = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        UglyArray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt; index; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> *Ugly2 = UglyArray;</span><br><span class="line">            <span class="keyword">int</span> *Ugly3 = UglyArray;</span><br><span class="line">            <span class="keyword">int</span> *Ugly5 = UglyArray;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly2 * <span class="number">2</span> &lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly2++;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly3 * <span class="number">3</span> &lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly3++;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly5 * <span class="number">5</span>&lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly5++;</span><br><span class="line">            UglyArray[i] = Min(*Ugly2 *<span class="number">2</span>, *Ugly3 *<span class="number">3</span>, *Ugly5 *<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = UglyArray[index<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">delete</span>[] UglyArray;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b,<span class="keyword">const</span> <span class="keyword">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a&lt;b? a:b;</span><br><span class="line">        <span class="keyword">return</span> x&lt;c? x:c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="34-第一次只出现一次的字符"><a href="#34-第一次只出现一次的字符" class="headerlink" title="34.第一次只出现一次的字符"></a>34.第一次只出现一次的字符</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）</p>
<h2 id="解法一（自想）"><a href="#解法一（自想）" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>每遇到一个字符，判断其是否是第一次出现，则将它存在一个vector once里面，如果不是，则判断该字符是否在另一个vector more里面，如果没在，则该once中的该字符转移到mul里面，接着判断下一个字符。最终，输出once里面的首个元素。</p>
<p>该方法时间复杂度为 $O(n^2)$，并不令人满意。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; once_char;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; mul_char;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isfirst = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = once_char.begin(); it!=once_char.end(); it++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[*it] == str[i])&#123;</span><br><span class="line">                    isfirst = <span class="literal">false</span>;</span><br><span class="line">                    once_char.erase(it);</span><br><span class="line">                    mul_char.push_back(str[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isfirst)&#123;</span><br><span class="line">                <span class="keyword">auto</span> mul_it = find(mul_char.begin(), mul_char.end(), str[i]);</span><br><span class="line">                <span class="keyword">if</span>(mul_it != mul_char.end())</span><br><span class="line">                    isfirst = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isfirst)&#123;</span><br><span class="line">                once_char.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(once_char.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> once_char.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：牛客"><a href="#解法二：牛客" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>借助哈希表，时间复杂度为 $O(n)$。哈希表的构造可以用256大小的数组实现，字符对应的int值可作为哈希表的索引，表内的内容存储了该字符出现的次数。总共需要遍历两次字符串，第一次更新数组内字符出现的次数，第二次找到首个出现次数为1的字符。空间复杂度为 $O(1)$ （256是常数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash_map[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">            hash_map[i] = <span class="number">0</span>; <span class="comment">//若少了初始化数组，则通不过，经过验证，数组默认内部不是0,而是随机数？</span></span><br><span class="line">       <span class="comment">//有一种更标准初始化为0的方法，无需显式while循环：int hash_map[256]= &#123;0&#125;;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            hash_map[<span class="keyword">int</span>(str[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash_map[<span class="keyword">int</span>(str[i])] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>输入描述:</p>
<p>题目保证输入的数组中没有的相同的数字</p>
<p>数据范围：</p>
<pre><code>对于%50的数据,size&lt;=10^4

对于%75的数据,size&lt;=10^5

对于%100的数据,size&lt;=2*10^5
</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>仔细思考，这道题的P的数量会非常大，对于长度为n的数组，其P值最大可为 $\frac{n(n-1)}{2}$ 个。根据体重给出的数据，n最大可为 $2\times 10^5$ ，因此，P最大为 $\frac{2\times 10^5\times(2\times10^5 -1)}{2} \approx 2\times 10^{10}$,因此，使用int类型的数据时，有可能超过限制。所以，要使用long！</p>
<h2 id="解法一（自）"><a href="#解法一（自）" class="headerlink" title="解法一（自）"></a>解法一（自）</h2><p>  暴力求解，时间复杂度 $O(n^2)$ ，这样做肯定不行</p>
<h2 id="解法二（剑指）"><a href="#解法二（剑指）" class="headerlink" title="解法二（剑指）"></a>解法二（剑指）</h2><h3 id="这里需要注意的几点："><a href="#这里需要注意的几点：" class="headerlink" title="这里需要注意的几点："></a>这里需要注意的几点：</h3><ol>
<li>初始化是，将data数据复制到temp中，然后在递归时，将data和temp数组交换传递，可以不用在数组融合时，将temp中的数据复制到data中， 减少计算次数</li>
<li>数组融合时使用的while循环，条件均为 $&lt;=$ 或  $&gt;=$。</li>
<li>每次得到P的一部分时，都进行取余数，可保证P的值不会过大。（但还是要用long型整数）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp= data;</span><br><span class="line">      <span class="comment">//int P=0;</span></span><br><span class="line">      <span class="keyword">long</span> P = mergeSort(data,temp, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> P%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (last - first)/<span class="number">2</span>;</span><br><span class="line">      mid += first;</span><br><span class="line">      <span class="keyword">long</span> inv1=<span class="number">0</span>,inv2=<span class="number">0</span>,inv=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(first&lt; last)&#123;</span><br><span class="line">        <span class="comment">//这里，首先temp和data相同，因此对于mergeSort来说，可以顺序颠倒</span></span><br><span class="line">        <span class="comment">//此时相当于把temp当前真实数组，而data当作了缓存空间</span></span><br><span class="line">        <span class="comment">//经过mergeSort后，data里面数据就是分别排好序的</span></span><br><span class="line">        <span class="comment">//所以传向mergeArray时，要把data放前面，把temp放后面</span></span><br><span class="line">          inv1 = mergeSort(temp, data, first, mid);</span><br><span class="line">          inv2 = mergeSort(temp, data, mid+<span class="number">1</span>, last);</span><br><span class="line">          inv = mergeArray(data, temp, first, mid, mid+<span class="number">1</span>, last);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (inv1+inv2+inv)%<span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">mergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">int</span> inv = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> t = last2;</span><br><span class="line">      <span class="keyword">int</span> i = last1;</span><br><span class="line">      <span class="keyword">int</span> j = last2;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=first1 &amp;&amp; j&gt;=first2)&#123;</span><br><span class="line">          <span class="keyword">if</span>(data.at(i) &gt; data.at(j))&#123;</span><br><span class="line">              temp.at(t) = data.at(i);</span><br><span class="line">              inv += j-first2+<span class="number">1</span>;;</span><br><span class="line">              i--;</span><br><span class="line">              t--;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              temp.at(t) = data.at(j);</span><br><span class="line">              j--;</span><br><span class="line">              t--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=first1)&#123;</span><br><span class="line">          temp.at(t) = data.at(i);</span><br><span class="line">          t--;</span><br><span class="line">          i--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;=first2)&#123;</span><br><span class="line">          temp.at(t) = data.at(j);</span><br><span class="line">          j--;</span><br><span class="line">          t--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> inv%<span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="36-两个链表的第一个公共节点"><a href="#36-两个链表的第一个公共节点" class="headerlink" title="36.两个链表的第一个公共节点"></a>36.两个链表的第一个公共节点</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p>
<h2 id="解法一：-4"><a href="#解法一：-4" class="headerlink" title="解法一："></a>解法一：</h2><p>分析公共子节点的特点，首先，是单向链表，因此，从第一个公共子节点开始，后面的都是一样的，所以最好是能从链表的最后一项还是比较。但由于是单向链表，因此只能从头访问，从能访问最后的节点。 <strong>就像是先进先出一样</strong>  因此，考虑用两个辅助栈来帮助实现～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s2;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead1; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s1.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead2; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s2.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* firstCN = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.top() == s2.top())&#123;</span><br><span class="line">                firstCN = s1.top();</span><br><span class="line">                s1.pop();</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="解法一（自想）-1"><a href="#解法一（自想）-1" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>先利用二分查找找到该数字的下标，然后统计该数字左右两边的相等数的个数，虽然二分查找的时间复杂度为$O(logn)$，但是在对该数左右两边查看相等数个数时，时间复杂度为 $O(n)$，因此，最终的时间复杂度应为 $O(n)$ 。 （这样的复杂度不会让面试官满意）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = index<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;data.size() &amp;&amp; data.at(index) == k)&#123;</span><br><span class="line">                index++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; data.at(i) == k)&#123;</span><br><span class="line">                i--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.at(first) == num) <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearch(data, num ,first, mid);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearch(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：牛客-1"><a href="#解法二：牛客-1" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>分析上面的方法，时间复杂度高的主要原因来自于最后的顺序检索。设想一下，如果知道目标数字出现的第一个位置和最后一个位置，是否就不用再进行顺序检索了？  于是，可以将二分查找算法改成分别查找目标数字的首次出现位置和末次出现位置。也就是说，如果mid上的数字等于num，同时mid-1（mid&gt;0）上的数字不等于num，则mid为首次出现位置，否则，首次出现位置就应该还在前半段，同理，末次出现位置也是相似的道理。</p>
<p>结合以上讨论，将二分查找分成两个函数，分别找首次和末次位置，这样时间复杂度就是 $O(logn)$，无需进行顺序查找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> index1 = binarySearchFirst(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> index2 = binarySearchLast(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(index1 == <span class="number">-1</span> || index2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> index2-index1+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first &gt; last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> || data.at(mid<span class="number">-1</span>) != num)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> binarySearchFirst(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearchFirst(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearchFirst(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first &gt; last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==last || data.at(mid+<span class="number">1</span>)!=num)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> binarySearchLast(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearchLast(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearchLast(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="解法一（自想）-2"><a href="#解法一（自想）-2" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>利用<del>BFS广度优先遍历</del>（错了，树没有广度遍历，这个应该叫层次遍历），结合一个专门存储当前节点所处深度的队列实现，最终的树深度，就应该等于<del>广度优先遍</del>层次遍历历最后一个访问节点所处的深度。（因为这肯定是最后一层，也就是最深的一层）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; BFSqueue;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; depth;</span><br><span class="line">        <span class="keyword">if</span>(pRoot!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            depth.push(<span class="number">1</span>);</span><br><span class="line">            BFSqueue.push(pRoot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tree_depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!BFSqueue.empty())&#123;</span><br><span class="line">            TreeNode* curNode = BFSqueue.front();</span><br><span class="line">            <span class="keyword">int</span> cur_depth = depth.front();</span><br><span class="line">            depth.pop();</span><br><span class="line">            BFSqueue.pop();</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                BFSqueue.push(curNode-&gt;left);</span><br><span class="line">                depth.push(cur_depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                BFSqueue.push(curNode-&gt;right);</span><br><span class="line">                depth.push(cur_depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            tree_depth = cur_depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：牛客-2"><a href="#解法二：牛客-2" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>二叉树中的某个节点的深度，就是其左子树深度和右子树深度较大者+1 ， 二叉树的深度就是根节点的深度，所以，利用递归的思想实现。（代码简洁，但是复杂复杂度好像和广度优先一样，都是n？ 是这样吗？）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> depth1 = <span class="number">1</span>, depth2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left!=<span class="literal">nullptr</span>) depth1 = TreeDepth(pRoot-&gt;left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;right!=<span class="literal">nullptr</span>) depth2 = TreeDepth(pRoot-&gt;right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> depth1&gt;depth2 ? depth1 : depth2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39.平衡二叉树"></a>39.平衡二叉树</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h2 id="解法一（自想）-3"><a href="#解法一（自想）-3" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>将题目看作是求左右子树的深度，如果深度差超过1,那么就不是二叉树，返回一个特殊的标识（-1），这种方法属于一边遍历，一边判断，只需要遍历每个节点一次，通过递归实现。时间复杂度为 $O(logn)$</p>
<p><strong>有一种“不太好”的方法是每遇到一个节点，就单独求一次这个节点对应的树的深度，这种做法要遍历一个节点很多次，是一种典型的不令人满意的做法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tdepth = treeDepth(pRoot);</span><br><span class="line">        <span class="keyword">if</span>(tdepth!=<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftdepth = treeDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(leftdepth == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightdepth = treeDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(rightdepth == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(leftdepth-rightdepth) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(leftdepth,rightdepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p>
<p>（暴力解法就不提了，肯定不是最优。）</p>
<h2 id="解法一：异或"><a href="#解法一：异或" class="headerlink" title="解法一：异或"></a>解法一：异或</h2><p>注：异或运算符还可以实现无中间变量的两个数字互换：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">4</span>;</span><br><span class="line">a = a^b; <span class="comment">// a = 2^4 = 6</span></span><br><span class="line">b = a^b; <span class="comment">// b = 6^4 = 2</span></span><br><span class="line">a = a^b; <span class="comment">// a = 6^2 = 4</span></span><br><span class="line"><span class="comment">//同理有</span></span><br><span class="line">a = a + b; <span class="comment">// a = 2+4 = 6</span></span><br><span class="line">a = a - b; <span class="comment">// b = 6-4 = 2</span></span><br><span class="line">a = a - b; <span class="comment">// a = 6-2 = 4</span></span><br></pre></td></tr></table></figure></p>
<p>异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。</p>
<p>（这里不限定是一次，只要是奇数次都可以）</p>
<p>本题数列中，有两个出现一次的数字，第一次先全部异或，得到的结果是两个一次数字的异或值，该值至少有一位的值为1,因此，找到这一位，然后根据这一位这数组分成两拨，如此一来，每一拨都变成了上面的简单情况。</p>
<p>（同理，如果有N个一次数字，可以通过不断分拨的方法解决）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor_result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = data.begin(); it!=data.end(); it++)&#123;</span><br><span class="line">            xor_result = xor_result ^ (*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((xor_result&amp;i) == <span class="number">0</span>)</span><br><span class="line">            i = i&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = data.at(low);</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; (data.at(high)&amp;i) != <span class="number">0</span>) high--;</span><br><span class="line">            data.at(low) = data.at(high);</span><br><span class="line">            <span class="keyword">if</span>(low&lt;high)low++; <span class="comment">//这里的判断条件一定不能少，否则low有可能超过high</span></span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; (data.at(low)&amp;i) == <span class="number">0</span>) low++;</span><br><span class="line">            data.at(high) = data.at(low);</span><br><span class="line">            <span class="keyword">if</span>(low&lt;high) high--; <span class="comment">//这里的判断条件一定不能少，否则hig有可能比low低</span></span><br><span class="line">        &#125;</span><br><span class="line">        data.at(low) = p;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((p&amp;i) != <span class="number">0</span>) mid = low;</span><br><span class="line">        <span class="keyword">else</span> mid = data.size()<span class="number">-1</span> &lt; low+<span class="number">1</span> ? data.size()<span class="number">-1</span> : low+<span class="number">1</span>;</span><br><span class="line">        *num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;mid; j++)</span><br><span class="line">            *num1 = (*num1) ^ data.at(j);</span><br><span class="line">        *num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = mid; j&lt; data.size(); j++)</span><br><span class="line">            *num2 =(*num2) ^ data.at(j);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="41-和为S的连续正数序列"><a href="#41-和为S的连续正数序列" class="headerlink" title="41.和为S的连续正数序列"></a>41.和为S的连续正数序列</h1><h2 id="解法一（自想）-4"><a href="#解法一（自想）-4" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>设置两个变量记录当前序列的start位置和end位置，判断当前序列的和:</p>
<ul>
<li>如果=sum，则存储当前序列，并将start+1,序列前进;</li>
<li>如果&gt;sum,将应减去序列中的最小值，也就是start指向位置的值，然后start+1;</li>
<li>如果&lt;sum，则应该再加上下一个值，也就是end指向的值。</li>
</ul>
<p>然后再进行上面的循环，直到start指向的位置值为sum/2,此时就已经不可能出现和为sum的连续序列了。该方法时间复杂度为$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end =start; start &lt;= sum/<span class="number">2</span> ;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp == sum)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numseq;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i&lt;end; i++)&#123;</span><br><span class="line">                    numseq.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                results.push_back(numseq);</span><br><span class="line">                tmp -=start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( tmp &gt; sum)&#123;</span><br><span class="line">                tmp -= start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                tmp += end;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42.和为S的两个数字"></a>42.和为S的两个数字</h1><h2 id="解法一（自想）-5"><a href="#解法一（自想）-5" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>设置两个变量，分别指向数组的第一个位置和最后一个位置，然后将这两个变量所指位置的值相加，分以下三种情况：</p>
<ul>
<li>=sum，判断二者乘积是否比当前最小值小，如果是，则改变最小值的持有值。 不管是否小，都将num1++</li>
<li><blockquote>
<p>sum，num2—</p>
</blockquote>
</li>
<li>&lt;sum，num++<br>循环以上三步直到num1&lt;num2。最后判断minnum1和minnum2的值，如果二者相等，说明数组里面不存在这样的数对儿，返回空vector，若不相等，则输出这两个值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"><span class="comment">//在使用容器的back()方法访问时，必须要确保容器不是空的，否则会出现段错误（访问越界）</span></span><br><span class="line">        <span class="keyword">int</span> minnum1 = <span class="built_in">array</span>.back();</span><br><span class="line">        <span class="keyword">int</span> minnum2 = <span class="built_in">array</span>.back();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num1 &lt; num2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>.at(num1)+<span class="built_in">array</span>.at(num2) == sum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>.at(num1) * <span class="built_in">array</span>.at(num2) &lt; minnum1*minnum2)&#123;</span><br><span class="line">                    minnum1 = <span class="built_in">array</span>.at(num1);</span><br><span class="line">                    minnum2 = <span class="built_in">array</span>.at(num2);</span><br><span class="line">                &#125;</span><br><span class="line">                num1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>.at(num1) + <span class="built_in">array</span>.at(num2) &gt; sum)&#123;</span><br><span class="line">                num2--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minnum1==minnum2) <span class="keyword">return</span> result;</span><br><span class="line">        result.push_back(minnum1);</span><br><span class="line">        result.push_back(minnum2);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h2 id="解法一（自想）：利用str-substr-pos-n"><a href="#解法一（自想）：利用str-substr-pos-n" class="headerlink" title="解法一（自想）：利用str.substr(pos,n)"></a>解法一（自想）：利用str.substr(pos,n)</h2><p><strong>注意：</strong></p>
<p>这道题看似简单，实则很容易考虑不全，主要需注意以下几点：</p>
<ul>
<li>n大于str.length()的情况</li>
<li>str.length()=0的情况</li>
<li>n为负数的情况（虽然这里牛客没考虑，我觉得题里没说正数，所以是有负数的可能的）</li>
</ul>
<p><strong>越是简单的题，越要注意各种情况的考虑，因为这种题的考察点就是考虑是否全面，而不是题怎么解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=str.length())  n = n % str.length();</span><br><span class="line">        res=str.substr(n);</span><br><span class="line">        res += str.substr(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）：反转"><a href="#解法二（牛客）：反转" class="headerlink" title="解法二（牛客）：反转"></a>解法二（牛客）：反转</h2><p>利用多次反转的方法，首先将字符串按照n的位置分成两部分，然后进行以下三步（abcdefg，2）：</p>
<ul>
<li>反转前一部分：ba</li>
<li>反转后一部分：gfed</li>
<li>反转整个字符串：bagfed -&gt; defgab</li>
</ul>
<p>时间复杂度也为$O(n)$</p>
<h1 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44.翻转单词顺序列"></a>44.翻转单词顺序列</h1><h2 id="解法一：-5"><a href="#解法一：-5" class="headerlink" title="解法一："></a>解法一：</h2><p>设值两个标记i，j，都从字符串的最后一位开始，如果当前字符不是空格，那么i指向下一个，直到遇到空格为止，此时，将i到j范围内字符提取出来，然后把令j=i。重复以上过程，直到i=0为止。 该解法时间复杂度为 $O(n)$ 而且只需遍历一边字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = str.length()<span class="number">-1</span>, j=str.length()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;<span class="comment">//这里注意不能用双引号,双引号代表字符串,在C++内部,""与''表示的是不同的东西</span></span><br><span class="line">                res += str.substr(i+<span class="number">1</span>,j-i);</span><br><span class="line">                res += <span class="string">" "</span>;</span><br><span class="line">                i--;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                res += str.substr(i,j-i+<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）：两次反转"><a href="#解法二（牛客）：两次反转" class="headerlink" title="解法二（牛客）：两次反转"></a>解法二（牛客）：两次反转</h2><p>首先反转整个字符串，然后以空格为间隔，反转每个单词。时间复杂度也是$O(n)$ 。</p>
<h1 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张)他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h2><p>该题目需要注意：1123 这样的顺序返回的是false</p>
<h2 id="解法一-自想"><a href="#解法一-自想" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>分析能组成顺子的数字的特征，首先，最大的数字和最小的数字他们的差一定要比numbers的size小，否则，肯定连不了顺子。比如12345和2300等。其次，如果数组中出现非0的重复数字，那么也一定不是顺子。因此，代码可以这样写：</p>
<ul>
<li>找出非0的最大值和最小值</li>
<li>在找最值的时候顺便利用最简单的hash表来存储每个数字出现的次数，hash表长度为14，key值为数字，value值为key值出现的次数，如果value出现&gt;1的情况，则直接返回false</li>
<li>做判断，如果max-min&lt; numbers.size()，则返回true，否则返回false。</li>
</ul>
<p>以上程序时间复杂度为$O(n)$ ，并且只需要遍历一次numbers。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] == <span class="number">0</span>) i++;</span><br><span class="line">        <span class="keyword">int</span> min=numbers.at(i);</span><br><span class="line">        <span class="keyword">int</span> max = numbers.at(i);</span><br><span class="line">        <span class="keyword">int</span> zeronum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">14</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.begin(); it!=numbers.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it &lt; min &amp;&amp; *it!=<span class="number">0</span>) min = *it;</span><br><span class="line">            <span class="keyword">if</span>(*it &gt; max) max = *it;</span><br><span class="line">            <span class="keyword">if</span>(*it == <span class="number">0</span>) zeronum++;</span><br><span class="line">            count[*it]++;</span><br><span class="line">            <span class="keyword">if</span>(*it != <span class="number">0</span> &amp;&amp; count[*it] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max-min &lt;= numbers.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）："><a href="#解法二（牛客）：" class="headerlink" title="解法二（牛客）："></a>解法二（牛客）：</h2><p>先排序，在统计0的个数，再用0填补空缺，时间复杂度为 $O(nlogn)$ 不如上面的方法好。</p>
<h1 id="46-圆圈中最后剩下的数：约瑟夫（Josephuse）环问题"><a href="#46-圆圈中最后剩下的数：约瑟夫（Josephuse）环问题" class="headerlink" title="46.圆圈中最后剩下的数：约瑟夫（Josephuse）环问题"></a>46.圆圈中最后剩下的数：约瑟夫（Josephuse）环问题</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>0,1,…,n-1这n个数字排成一个圆圈，从数字0开始每次删除m-1处的数字，然后从这个数字的下一位继续从0开始，删除m-1处的数字，求出圆圈里剩下的最后一个数字</p>
<h2 id="解法一（自想）：利用vector维护动态数组"><a href="#解法一（自想）：利用vector维护动态数组" class="headerlink" title="解法一（自想）：利用vector维护动态数组"></a>解法一（自想）：利用vector维护动态数组</h2><p>利用一个vector维护一个动态数组，数组内的内容是每个孩子的编号，每次要删除的节点位置，都在index+m-1处，如果index+m-1超过了数组的大小，则对数组的size求余即可。该算法是最简单的一种思路，<del>时间复杂度为：$O(n)$</del> ，vector或list在删除时，由于要将后面的元素向前挪，所以erase的时间<br>复杂度为 $O(m)$ ，因此，总的时间复杂度为$O(mn)$。</p>
<p>空间复杂度为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; children;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            children.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(children.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            index += m<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(index&lt;children.size()<span class="number">-1</span>) children.erase(children.begin()+index);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                index = index % children.size();</span><br><span class="line">                children.erase(children.begin()+index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> children.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）：经典解法，用环形链表模拟圆圈"><a href="#解法二（牛客）：经典解法，用环形链表模拟圆圈" class="headerlink" title="解法二（牛客）：经典解法，用环形链表模拟圆圈"></a>解法二（牛客）：经典解法，用环形链表模拟圆圈</h2><p>可以用<code>std::list</code>或者<code>std::vector</code>来模拟一个环形链表，由于它们本身不是循环的，因此需要记得手动实现循环逻辑（其实就是解法一）</p>
<p>如果要求不可以使用标准模板库里面的数据容器来模拟环形链表，那么可以自己设计结构体类型，实现一个循环链表。</p>
<p><del>该方法的时间复杂度为 $O(n)$</del> 这里由于链表无法进行随机访问，只能顺序访问，所以要时间复杂度应该为$O(nm)$</p>
<p>空间复杂度为$O(n)。</p>
<h2 id="解法三（牛客）："><a href="#解法三（牛客）：" class="headerlink" title="解法三（牛客）："></a>解法三（牛客）：</h2><p>分析每次删除时的数字规律，总结出以下公式，按照公式编写递归或非递归程序，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$ 。</p>
<script type="math/tex; mode=display">\begin{cases} 0 & n=1 \\  [f(n-1,m)+m]\%n & n>1 \end{cases}</script><p>思考过程：首先，如果只是去掉第ｍ个数，而下一次开始的地方仍然是从头开始的话，那么这个问题就可以很自然的用递归来解决。但是这里下一个开始的地方是下一个数，而不是第一个数，对此，可以想到将数组映射成从０开始的形式，然后在计算时再反映射回去，如此一来就可以得到上面的公式了（＋ｍ的操作就是反映射回去时添加上的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;= <span class="number">0</span> || m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) res = <span class="number">0</span>;</span><br><span class="line">            res = (res+m)%i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">递归写法</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="47-非常规法求前n项和"><a href="#47-非常规法求前n项和" class="headerlink" title="47.非常规法求前n项和"></a>47.非常规法求前n项和</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>这道题本身没有实际意义，侧重考察发散性思维和对C++相关机制的理解程度。</p>
<h2 id="解法一：构造函数"><a href="#解法一：构造函数" class="headerlink" title="解法一：构造函数"></a>解法一：构造函数</h2><p>每声明一个对象，则构造函数都被调用一次，因此，可以借助静态变量来在构造函数内部实现累加操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sum</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">        sum()&#123;i++; s+=i;&#125;;</span><br><span class="line">        ~sum()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            s = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">int</span> sum::i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum::s = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sum::<span class="built_in">set</span>();</span><br><span class="line">        sum a[n];</span><br><span class="line">        <span class="keyword">return</span> sum::s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：虚函数"><a href="#解法二：虚函数" class="headerlink" title="解法二：虚函数"></a>解法二：虚函数</h2><p>利用虚函数来模拟递归函数，可以在两个类中分别定义函数，其中一个函数充当递归函数的角色，另一个函数处理终止递归的情况，然后在两个函数里二选一。</p>
<p>这里用到了一个小trick，那就是对于整型变量n，执行<code>!!n</code>以后，可以将其转换成布尔值（0和1）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual int sum(int n)&#123;return 0;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">A* Array[2];  //这里必须为指针，否则不会进入B的sum 函数</span><br><span class="line">class B : public A&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual int sum(int n)&#123;return Array[!!n]-&gt;sum(n-1) + n;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        class A a;</span><br><span class="line">        class B b;</span><br><span class="line">        Array[0] = &amp;a;</span><br><span class="line">        Array[1] = &amp;b;</span><br><span class="line">        return Array[1]-&gt;sum(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面用了虚函数，那么使用普通的函数可以吗？答案是否定的，因为使用普通函数时，无法同时调用两个类的函数，最终只会调用A类的sum函数。</p>
<h2 id="解法三：函数指针"><a href="#解法三：函数指针" class="headerlink" title="解法三：函数指针"></a>解法三：函数指针</h2><p>同样是上面的思想，不过改为使用函数指针来实现两个函数模拟递归</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*fun[<span class="number">2</span>])</span><span class="params">(<span class="keyword">int</span> n)</span> </span>= &#123;A,B&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun[!!n](n<span class="number">-1</span>) + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四：模板类"><a href="#解法四：模板类" class="headerlink" title="解法四：模板类"></a>解法四：模板类</h2><p>使用模板类完成递归，这种方法有一个很大的缺点就是整个过程是在编译阶段完成的，因此无法使用动态的n，而必须是在编译期间就能确定的常量，另外，编译器对递归编译代码的递归深度也是有限制的，所以n不能太大。</p>
<h1 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h1><h1 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br>输入描述:</p>
<p>输入一个字符串,包括数字字母符号,可以为空</p>
<p>输出描述:</p>
<p>如果是合法的数值表达则返回该数字，否则返回0</p>
<h2 id="解法一（自想）："><a href="#解法一（自想）：" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>从头开始逐个字符遍历，每次遇到一个“数字”，就将之间的res×10，然后再加上这个数字。需要特别注意“-123”，“+123”等情况。 时间复杂度为 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            negative=<span class="literal">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'+'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; str.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                res = res*<span class="number">10</span> + (<span class="keyword">int</span>)(str[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(negative) res = <span class="number">0</span> - res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><p>上面的代码虽然已经解决了牛客的题，但是有几点是需要特别注意的！</p>
<p>首先，题目很简单，所以这道题的考察点只在于是否将所有情况都考虑到了，以下是一些可能的情况，日后再遇到一定要想起来：</p>
<ul>
<li>首先考虑如何返回错误，首先不能使用可以转换成数值类型（int，bool，char）的数据直接指明错误（比如返回0，无法得知到底是错误当时真的是0），由此，可以创建一个全局的错误变量，如果要返回错误，则返回0并且将该变量状态改变。</li>
<li>非数字类符号不全是错误输出，如：<code>+123</code>、<code>-123</code></li>
<li>只输入<code>+</code>和<code>-</code>时，要返回错误</li>
<li><code>string str==&quot;&quot;</code>时，也要返回错误</li>
<li>如果为<code>char str*</code>，则要判断指针是否为空</li>
<li>一定要考虑数值溢出情况（当转换的数字大于最大正数，小于最小负数时，会溢出）</li>
</ul>
<h1 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h2><p>对于每个数组中的数字，都到前面的数字中去寻找是否有重复的。</p>
<p>时间复杂度： $O(n^2)$  空间复杂度： $O(1)$</p>
<h2 id="解法二：哈希"><a href="#解法二：哈希" class="headerlink" title="解法二：哈希"></a>解法二：哈希</h2><p>建立长度为n的哈希表，每次遇到一个数字x，就在hash[x]增1，如果此时hash[x]变为2，那么就说明有重复。</p>
<p>时间复杂度： $O(n)$  空间复杂度： $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hash(length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; length; i++)&#123;</span><br><span class="line">            hash[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(hash[numbers[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><h1 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
<h2 id="解法一（自想）：-1"><a href="#解法一（自想）：-1" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>将乘积看成两段，前i-1项的乘积，和后n-i项的乘积，分开计算，最终合并。<br>时间复杂度： $O(n)$   空间复杂度： $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = A.begin(); it!=A.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it!=A.begin()) tmp *= *(it<span class="number">-1</span>);</span><br><span class="line">            B.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=A.size()<span class="number">-1</span>) tmp *= A.at(i+<span class="number">1</span>);</span><br><span class="line">            B.at(i) *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<h2 id="解法一：（牛客）"><a href="#解法一：（牛客）" class="headerlink" title="解法一：（牛客）"></a>解法一：（牛客）</h2><p>主要分两种情况：</p>
<ul>
<li>当前字符的下一个字符不是‘*’</li>
<li>当前字符的字一个字符是‘*’</li>
</ul>
<p>对于第一种情况：直接判断是否相等（包含‘.’的情况）</p>
<p>对于第二种情况，需要分情况讨论：</p>
<ul>
<li>当前字符与pattern当前字符不相等，则patter当前只能出现零次，调用<code>match(str, pattern+2)</code></li>
<li>当前字符与pattern字符相等（包含‘.’的情况），则pattern的选择有两种，出现零次，或者出现一次以上，这两种情况都必须考虑，否则会丢解，如（aab和a.*ab），因此，需要调用<code>match(str, pattern+2) || match(str+1, pattern)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( *str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( *str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( *(pattern+<span class="number">1</span>) != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( *str == *pattern || *str!=<span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>)  <span class="comment">//  *str的条件不能丢</span></span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( *str == *pattern || *str!=<span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>)  <span class="comment">//这里的if else组合语句是必须的，否则会在不能出现多次时，函数仍然考虑出现多次的情况，造成误解</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>) || match(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h2 id="解法一（自想）：-2"><a href="#解法一（自想）：-2" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>没有难点，考察点主要在于各种情况的考虑（以下均为false）：</p>
<ul>
<li>+</li>
<li>-</li>
<li>+12.2.2</li>
<li>12e</li>
<li>12e-</li>
<li>12E+4.3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*string == &apos;\0&apos;) return false;</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        int point_count = 0;</span><br><span class="line">        while( (*string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos;)</span><br><span class="line">             || *string == &apos;.&apos;)&#123;</span><br><span class="line">            if (*string == &apos;.&apos;) point_count++;</span><br><span class="line">            if (point_count &gt; 1) return false;</span><br><span class="line">            string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        if(*string == &apos;e&apos; || *string == &apos;E&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        while( *string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos; )</span><br><span class="line">            string++;</span><br><span class="line">        if(*string != &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h1><h2 id="解法一（牛客）：哈希表"><a href="#解法一（牛客）：哈希表" class="headerlink" title="解法一（牛客）：哈希表"></a>解法一（牛客）：哈希表</h2><p>建立一个哈希表和一个char数组（均为256大小），哈希表存储每个字符出现的次数，key为char，value为次数，数组存储所有 <strong>曾经</strong> 出现过一次的字符。</p>
<p>时间复杂度 $O(n)$  空间复杂度 $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="keyword">char</span> hash_c[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> first_c[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hash_c[ch]++;</span><br><span class="line">        <span class="keyword">if</span>(hash_c[ch] == <span class="number">1</span>)&#123;</span><br><span class="line">            *(first_c+index) = ch;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;index; i++)</span><br><span class="line">            <span class="keyword">if</span> (hash_c[*(first_c+i)] == <span class="number">1</span>) <span class="keyword">return</span> *(first_c+i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="55-链表中环的入口节点"><a href="#55-链表中环的入口节点" class="headerlink" title="55.链表中环的入口节点"></a>55.链表中环的入口节点</h1><h2 id="解法一（牛客）"><a href="#解法一（牛客）" class="headerlink" title="解法一（牛客）"></a>解法一（牛客）</h2><p>假设有环，并且环中的节点数为n，那么只要设值两个指针，一个slow指针指向头结点，另一个fast指针指向第n+1个节点，然后每次slow指针和fast指针都增1，那么肯定会在环的头部相遇（因为fast刚好比slow领先了一个环的长度）</p>
<p>因此，首先需要判断是否有环，思路是：从头结点开始，slow每次走一步，fast每次走两步，那么只要有环，slow和fast就一定会在环中的某个节点处相遇，如果无环，则fast一定先到达空指针</p>
<p>判断有环后，令fast从当前节点开始，继续往下走（每次走一步），并记录步数，最终遇到slow时的步数就是环的长度。</p>
<p>该方法时间复杂度为 $O(n)$  空间复杂度为  $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(step&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            step--;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）：-断链法"><a href="#解法二（牛客）：-断链法" class="headerlink" title="解法二（牛客）： 断链法"></a>解法二（牛客）： 断链法</h2><p>同理，先判断有环无环</p>
<p>然后记录两个指针，一个当前节点指针cur，一个相邻祖先指针pre，每经过一个节点时，都将pre指针的next置为nullptr，则当cur的next为空时，既为环的首个节点。</p>
<p>该方法的时间复杂度为O(n)，且只需遍历两次，且第二次遍历的时候正好遍历n个节点，但是缺点是会破坏链结构，补救办法是使用额外的标记来替代断链，但是这样会增加额外空间开销</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;next == pHead) <span class="keyword">return</span> pHead;  <span class="comment">//需要特别考虑只有一个节点并且自己组成环的情况</span></span><br><span class="line">        slow = pHead;</span><br><span class="line">        fast = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            slow = fast;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三：没太看懂"><a href="#解法三：没太看懂" class="headerlink" title="解法三：没太看懂"></a>解法三：没太看懂</h2><p><a href="https://blog.csdn.net/dawn_after_dark/article/details/82564271" target="_blank" rel="noopener">https://blog.csdn.net/dawn_after_dark/article/details/82564271</a><br>对应文中解法一</p>
<h1 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56.删除链表中重复的结点"></a>56.删除链表中重复的结点</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h2 id="解法一（自想）：-3"><a href="#解法一（自想）：-3" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>这道题本身比较简单，只需要维护一个pre指针和cur指针，分别指向前一个结点和当前结点，如果当前结点和下一个结点的值相等，那么就删除当前结点，最后我pre指针的next值设置为指向未重复的结点</p>
<p>但是！本题恶心了我很久，一直报段错误，主要原因是有的结点没有做空判断，就访问了结点的val或者next成员，此时如果结点是空的，那么就会报段错误，主要有以下这么几个情况：</p>
<ul>
<li>头结点本身就是重复的，这个需要删除头结点，另外判断是否重复时，还要检查头结点的下一个结点是否为空，如果为空，则不能访问其val值，否则，报段错误</li>
<li>在进行重复判断时，访问<code>cur-&gt;next-&gt;val</code>时，需要先判断<code>cur-&gt;next</code>是否为空，如果为空，则不能访问其val值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead == nullptr || pHead-&gt;next == nullptr) return pHead;</span><br><span class="line">        ListNode* newHead = new ListNode(0); //  建立一个新的结点，其next用于标识头结点，以便在头结点重复时，指向新的头结点</span><br><span class="line">        newHead-&gt;next = pHead;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        ListNode* pre = newHead;</span><br><span class="line"></span><br><span class="line">        while(cur != nullptr &amp;&amp; cur-&gt;next !=nullptr)&#123;   // 注意   这里一定必须是 &amp;&amp; ，如果是|| ，则下面有可能会访问到空结点的val，造成段错误</span><br><span class="line"></span><br><span class="line">            if(cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class="line">                ListNode* dup = cur-&gt;next;</span><br><span class="line">                while(cur-&gt;val == dup-&gt;val &amp;&amp; dup!=nullptr)&#123;  // 同理，让验证所有欲访问的结点不为空</span><br><span class="line">                    dup = dup-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = dup;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return newHead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="57-二叉树的下一个节点"><a href="#57-二叉树的下一个节点" class="headerlink" title="57.二叉树的下一个节点"></a>57.二叉树的下一个节点</h1><h1 id="58-对称的二叉树"><a href="#58-对称的二叉树" class="headerlink" title="58.对称的二叉树"></a>58.对称的二叉树</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="　题目描述"></a>　题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h2 id="解法一（牛客）：递归"><a href="#解法一（牛客）：递归" class="headerlink" title="解法一（牛客）：递归"></a>解法一（牛客）：递归</h2><p>要判断一个树是否对称，需要判断其树的左右子节点是否相等，同时还要判断左子树的右子树和右子树的左子树是否相等，以及左子树的左子树和右子树的右子树是否相等，然后如此递归解之：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymHelper(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymHelper</span><span class="params">(TreeNode* subRoot1, TreeNode* subRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> subRoot2==<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1-&gt;val != subRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> b1 = isSymHelper(subRoot1-&gt;right, subRoot2-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> b2 = isSymHelper(subRoot1-&gt;left, subRoot2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> b1&amp;&amp;b2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）：非递归"><a href="#解法二（牛客）：非递归" class="headerlink" title="解法二（牛客）：非递归"></a>解法二（牛客）：非递归</h2><p>关键还是知道怎么样才能判断一个<br>二叉树是否对称，只要采用前序、中序、后序、层次遍历等任何一种遍历方法，分为先左后右和先<br>右后左两种方法，只要两次结果相等就说明这棵树是一颗对称二叉树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//以下为层次遍历</span><br><span class="line">//与普通遍历不同的是，对于这道题，必须要把左右子树都存入到queue中，不论是否为空，因为只有这样才能将整个二叉树的结构存储起来，以便判断</span><br><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        if( nullptr==pRoot) return true;</span><br><span class="line">        q1.push(pRoot);</span><br><span class="line">        q2.push(pRoot);</span><br><span class="line">        TreeNode* cur1;</span><br><span class="line">        TreeNode* cur2;</span><br><span class="line">        while(!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">            cur1 = q1.front(); q1.pop();</span><br><span class="line">            cur2 = q2.front(); q2.pop();</span><br><span class="line">            if(cur1 == cur2 &amp;&amp; nullptr == cur1)</span><br><span class="line">                continue;</span><br><span class="line">            if(nullptr == cur1 || nullptr == cur2)</span><br><span class="line">                return false;</span><br><span class="line">            if(cur1-&gt;val != cur2-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            q1.push(cur1-&gt;left); q1.push(cur1-&gt;right);</span><br><span class="line">            q2.push(cur2-&gt;right); q2.push(cur2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三（牛客）：非递归"><a href="#解法三（牛客）：非递归" class="headerlink" title="解法三（牛客）：非递归"></a>解法三（牛客）：非递归</h2><p>=非递归算法，利用DFS和BFS===========================</p>
<p> BFS使用Queue来保存成对的节点</p>
<ol>
<li>出队的时候也是成对成对的<pre><code>       1.若都为空，继续；
        2.一个为空，返回false;
        3.不为空，比较当前值，值不等，返回false；
</code></pre><ol>
<li>确定入队顺序，每次入队都是成对成对的，如left.left， right.right ;left.rigth,right.left</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(pRoot-&gt;left); q.push(pRoot-&gt;right);</span><br><span class="line">        TreeNode* lnode; TreeNode* rnode;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            lnode = q.front(); q.pop();</span><br><span class="line">            rnode = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == lnode &amp;&amp; <span class="literal">nullptr</span> == rnode) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == lnode || <span class="literal">nullptr</span> == rnode) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(lnode-&gt;val != rnode-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            q.push(lnode-&gt;left); q.push(rnode-&gt;right);</span><br><span class="line">            q.push(lnode-&gt;right); q.push(rnode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DFS使用stack来保存成对的节点</p>
<ol>
<li>出栈的时候也是成对成对的 ，<pre><code>         1.若都为空，继续；
         2.一个为空，返回false;
         3.不为空，比较当前值，值不等，返回false；
</code></pre></li>
<li>确定入栈顺序，每次入栈都是成对成对的，如left.left， right.right ;left.rigth,right.left</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        s.push(pRoot-&gt;left);</span><br><span class="line">        s.push(pRoot-&gt;right);</span><br><span class="line">        TreeNode* lnode; TreeNode* rnode;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            rnode = s.top(); s.pop();</span><br><span class="line">            lnode = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span>( <span class="literal">nullptr</span>==lnode &amp;&amp; <span class="literal">nullptr</span> == rnode)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>( <span class="literal">nullptr</span> == lnode || <span class="literal">nullptr</span> == rnode)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(lnode-&gt;val != rnode-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(lnode-&gt;left); s.push(rnode-&gt;right);</span><br><span class="line">            s.push(lnode-&gt;right); s.push(rnode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解法一（自想）：-4"><a href="#解法一（自想）：-4" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>利用两个queue，一个用于层次遍历树节点，另一个用于存储对应节点的depth，然后每次访问节点时，都判断当前节点的层数，如果为奇数层，则将该层直接push back到结果向量中，如果为偶数，则将该层数据进行reverse后再push back到结果向量中。</p>
<p>时间复杂度为 $O(n^2)$  空间复杂度为 $O(n)$</p>
<p>需要注意的是最后一层的边界条件与其它层不同一样，需要专门判断以下，具体可以看下面的点注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q_node;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q_depth;</span><br><span class="line">        q_node.push(pRoot);</span><br><span class="line">        q_depth.push(<span class="number">1</span>);</span><br><span class="line">        TreeNode* cur; <span class="keyword">int</span> depth;</span><br><span class="line">        <span class="keyword">int</span> global_depth = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer;</span><br><span class="line">        <span class="keyword">while</span>(!q_node.empty())&#123;</span><br><span class="line">            cur = q_node.front(); q_node.pop();</span><br><span class="line">            depth = q_depth.front(); q_depth.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q_node.push(cur-&gt;left);</span><br><span class="line">                q_depth.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q_node.push(cur-&gt;right);</span><br><span class="line">                q_depth.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(depth == global_depth)&#123;</span><br><span class="line">                cur_layer.push_back(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q_node.empty())&#123;</span><br><span class="line">                  <span class="comment">// 对应最后一层的情况，当到了最后一层时，depth不会再继续增1了，</span></span><br><span class="line">                  <span class="comment">//所以不能通过global depth或depth的大小来判断是否进行pushback，</span></span><br><span class="line">                  <span class="comment">//需要通过看是否达到了最后一个节点来判断</span></span><br><span class="line">                    <span class="keyword">if</span>(global_depth % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        res.push_back(cur_layer);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        reverse(cur_layer.begin(), cur_layer.end());</span><br><span class="line">                        res.push_back(cur_layer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(global_depth % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res.push_back(cur_layer);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reverse(cur_layer.begin(), cur_layer.end());</span><br><span class="line">                    res.push_back(cur_layer);</span><br><span class="line">                &#125;</span><br><span class="line">                cur_layer.clear();</span><br><span class="line">                cur_layer.push_back(cur-&gt;val);</span><br><span class="line">                global_depth=depth;</span><br><span class="line">                <span class="keyword">if</span>(q_node.empty()) res.push_back(cur_layer);</span><br><span class="line">                <span class="comment">//这句话用于处理最后一层只有一个节点的情况，如果只有一个节点的话，</span></span><br><span class="line">                <span class="comment">//那么当前queue就为空，不会进入下一次循环，从而导致最后一层没有pushback进去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：牛客-3"><a href="#解法二：牛客-3" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>同样的思路，另一种写法，更加简洁，通过while里面内置for循环，来保证每次for循环都会将一整层的节点放进队列中，无需额外的数组来存储depth信息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/91b69814117f4e8097390d107d2efbe0</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        <span class="keyword">bool</span> even = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//将vec声明在内部，省去每次的clear操作，clear操作需要对vector进行遍历，并将每个元素置为null？</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> size = que.size(); <span class="comment">//当前存的节点数目就是这一层所有的节点，之前层的到已经被取出, 并且这一层的子节点还没有开始入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123; <span class="comment">//将该层所有节点的子节点入队列，同时当到达该层最后一个节点时终止</span></span><br><span class="line">                TreeNode* tmp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(even) <span class="comment">//根据奇偶标识判断是否需要reverse</span></span><br><span class="line">                <span class="built_in">std</span>::reverse(vec.begin(), vec.end());</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            even = !even;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h2 id="解法一（半自想）："><a href="#解法一（半自想）：" class="headerlink" title="解法一（半自想）："></a>解法一（半自想）：</h2><p>while循环加for循环，无需额外记录层数，具体看59题解法二分析</p>
<p>时间和空间复杂度为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">            <span class="keyword">if</span>(pRoot== <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; q_node;</span><br><span class="line">            q_node.push(pRoot);</span><br><span class="line">            <span class="keyword">while</span>(!q_node.empty())&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> cur_size = q_node.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cur_size; i++)&#123;</span><br><span class="line">                    TreeNode* cur_node = q_node.front(); q_node.pop();</span><br><span class="line">                    cur_layer.push_back(cur_node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) q_node.push(cur_node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) q_node.push(cur_node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(cur_layer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h1><h1 id="62-二叉搜索树的第k个节点"><a href="#62-二叉搜索树的第k个节点" class="headerlink" title="62.二叉搜索树的第k个节点"></a>62.二叉搜索树的第k个节点</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h2 id="解法一（自想）：-5"><a href="#解法一（自想）：-5" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>中根遍历，遍历到第k个节点时将其输出，如果k大于节点数量，输出nullptr, 时间复杂度 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s_node;</span><br><span class="line">        TreeNode* P =  pRoot;</span><br><span class="line">        <span class="comment">//ctor&lt;TreeNode*&gt; vec_node;</span></span><br><span class="line">        <span class="keyword">int</span> cur_k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(P!=<span class="literal">nullptr</span> || !s_node.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s_node.push(P);</span><br><span class="line">                P = P-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!s_node.empty())&#123;</span><br><span class="line">                P = s_node.top(); s_node.pop();</span><br><span class="line">                cur_k++;</span><br><span class="line">                <span class="keyword">if</span>(cur_k == k) <span class="keyword">break</span>;</span><br><span class="line">                P = P-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_k == k) <span class="keyword">return</span> P;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h1><h2 id="解法一-自想-1"><a href="#解法一-自想-1" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>插入时用vector的insert方法,按顺序插入,空间为 $O(n)$ ,时间复杂度为$O(n)$ 返回中位数时直接利用下标,时间复杂度和空间复杂度都为 $O(1)$.</p>
<p>这里关于vector的insert方法,有两个需要注意的点:</p>
<ul>
<li>it = vec.insert(it,num);  如果后序还要继续插入的话, 就必须将insert的结果重新赋值给it, 否则如果没有重新赋值而直接继续使用it的话,会导致段错误,  这里因为已经不需要继续插入了,所以可以用break直接跳出,无需赋值</li>
<li>插入时,如果num比vec里面所有的数都大, 那么会导致插入失败, 此时 ,应使用push_back将num插入到最后</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            vec.insert(vec.begin(), num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> is_insert=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=vec.begin(); it!=vec.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it &gt; num)&#123;</span><br><span class="line">                vec.insert(it,num);</span><br><span class="line">                is_insert=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!is_insert) vec.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x1 = vec.size()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> x2 = (vec.size()<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (vec[x1]+vec[x2])/<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h2><p>插入的时候不考虑排序,在查找中位数时可以使用基于Partition的方法,时间复杂度为 $O(n)$.</p>
<h2 id="解法三-AVL树"><a href="#解法三-AVL树" class="headerlink" title="解法三:AVL树"></a>解法三:AVL树</h2><p>插入时间复杂度为 $O(logn)$  找中位数时间复杂度为 $O(1)$</p>
<h2 id="解法四-牛客-用大顶堆和小顶堆"><a href="#解法四-牛客-用大顶堆和小顶堆" class="headerlink" title="解法四(牛客):用大顶堆和小顶堆"></a>解法四(牛客):用大顶堆和小顶堆</h2><p>思路:</p>
<p>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。　　因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是 O(logn)。由于只需 O(1)时间就可以得到位于堆顶的数据，因此得到中位数的时间效率是 O(1)。</p>
<p>首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过 1</p>
<p>还要保证最大堆中里的所有数据都要小于最小堆中的数据</p>
<p>当数据的总数目是偶数时，按照前面分配的规则会把新的数据插入到最小堆中。如果此时新的数据比最大堆中的一些数据要小，怎么办呢？</p>
<p>可以先把新的数据插入到最大堆中，接着把最大堆中的最大的数字拿出来插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中的所有数字都大于最大堆中的数字。 当需要把一个数据插入到最大堆中，但这个数据小于最小堆里的一些数据时，这个情形和前面类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt; &gt; q_max;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; q_min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( q_max.size()&gt; q_min.size() )&#123;</span><br><span class="line">            q_max.push(num);</span><br><span class="line">            <span class="keyword">int</span> tmp = q_max.top(); q_max.pop();</span><br><span class="line">            q_min.push(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q_min.push(num);</span><br><span class="line">            <span class="keyword">int</span> tmp = q_min.top(); q_min.pop();</span><br><span class="line">            q_max.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res;</span><br><span class="line">        <span class="keyword">if</span>(q_max.size() == q_min.size())&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = q_max.top();</span><br><span class="line">            <span class="keyword">int</span> x2 = q_min.top();</span><br><span class="line">            res = (x1+x2)/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = q_max.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>插入时间复杂度为 $O(logn)$  找中位数时间复杂度为 $O(1)$</p>
<h1 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="解法一-自想-2"><a href="#解法一-自想-2" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>用最直接的办法, 每次求出滑动窗口内的最大值, 然后存到max_res向量里面, 该方法时间复杂度为 $O(nm)$ . 空间为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max_res;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> max_res; <span class="comment">//无符号整数, 要首先考虑size为0的情况, 否则会导致下面的程序数组越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; num.size()-size+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_max;</span><br><span class="line">            <span class="comment">//if(i&lt;num.size())  tmp_max = num[i]; //这里的if语句看起来是多余的, 实际上可以帮助进行数组越界检查, 有助于快速确定bug位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt; i+size ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] &gt; tmp_max) tmp_max = num[j]; <span class="comment">// 这里同样可以进行越界检查, 有助于bug定位, bug修复后可去掉</span></span><br><span class="line">            &#125;</span><br><span class="line">            max_res.push_back(tmp_max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-讨论区"><a href="#解法二-讨论区" class="headerlink" title="解法二(讨论区):"></a>解法二(讨论区):</h2><p>使用双端队列deque, 从下标0开始, 一直到n-1, 每次进行如下步骤:</p>
<ul>
<li>当前元素是否比队列中最后一个元素大, 如果大, 说明队列元素以后也不可能再成为较大值, 直接pop, 如此循环, 直到队列为空或者遇到比当前值大的元素</li>
<li>判断队列中队首的元素是否过期(若队空则直接下一步, 无需判断), 若过期, 则pop, 否则, 不管( 只看队首, 队内的元素是否过期不影响算法, 因为就算过期后面也会将其淘汰)</li>
<li>将当前元素的下标存到队尾</li>
<li>将新的队首元素存到结果向量max_res中</li>
</ul>
<p>注意: 队列里面存的是下标,  而不是元素本身的值,  后面在提到队列的元素值时,  均是指队列中存储的下标对应的元素值.</p>
<p>时间复杂度分析: 不是 $O(n*szie)$  而是 $O(n)$ ?</p>
<p>原因:  假设队列里面的正好包含size个元素(最多就为size个), 那么这三个元素对应的值一定是递减的,  因为如果不是递减中, 在进行第一个判断时, 就会将其移除,  此时, 如果新来了一个元素, 如果该元素值小于队列中所有的值, 那么就只可能进行一次判断, 而不是循环size次, 而如果均大于队列中的值, 那么队列中的元素个数就会变成1个,  这样, 在下次进行判断时, 只会与一个元素做判断,  如果是元素值位于中间, 那么下一次做判断的元素个数也会减少一部分, 综上, 内部while循环时, 相对于普通的循环嵌套,  该种循环可以认为是常数级(虽然还是与size的大小有关, 但是总体来说,  要做的判断次数比通常的循环小).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; max_res;</span><br><span class="line">        deque&lt;int&gt; dq_index;</span><br><span class="line">        for(int i =0; i&lt; num.size(); i++)&#123;</span><br><span class="line">            while(!dq_index.empty() &amp;&amp; num[i] &gt; num[dq_index.back()] )&#123;</span><br><span class="line">                dq_index.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            if(!dq_index.empty() &amp;&amp; i-dq_index.front()&gt;= size)</span><br><span class="line">                    dq_index.pop_front();</span><br><span class="line">            dq_index.push_back(i);</span><br><span class="line">            if(i&gt;=size-1)</span><br><span class="line">                max_res.push_back(num[dq_index.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>这是一个可以用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。<br>重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。<br>　　由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个<br>字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。<br>　　由于路径不能重复进入矩阵的格子，还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的<br>格子和路径字符串中相应的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下一个字符<br>如果4个相邻的格子都没有匹配字符串中下一个的字符，表明当前路径字符串中字符在矩阵中的定位不正确，我们需要回到前一个，然后重新定位。<br>　　一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置</p>
<p><strong>本题一定要注意边界条件即特殊情况的判断:</strong></p>
<ul>
<li>当矩阵所有元素一样时(这种情况一定要注意先)</li>
<li>当矩阵只有一个元素时(这两种情况要注意, 先进入递归程序, 然后再对flag矩阵进行判断, 否则, 当子串和矩阵大小一样时, 就无法判断到下一个字符是否==’\0’了)<br>-</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str[0] == &apos;\0&apos;) return true;</span><br><span class="line"></span><br><span class="line">        int* flag_matrix = new int[rows*cols];</span><br><span class="line">        for(int i = 0; i&lt;rows; i++)&#123;</span><br><span class="line">            for(int j =0 ;j&lt;cols; j++)&#123;</span><br><span class="line">                flag_matrix[i*cols+j] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt; rows; i++)&#123;</span><br><span class="line">            for(int j = 0;j&lt; cols; j++)&#123;</span><br><span class="line">                if(matrix[i*cols+j] == str[0])&#123;</span><br><span class="line">                    bool is_path = hasPath_helper(matrix,flag_matrix,i,j, rows, cols, str, 0);</span><br><span class="line">                    if(is_path)</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delete []flag_matrix;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasPath_helper(char* matrix,int* flag_matrix, int i, int j, int rows, int cols, char* str,int x)&#123;</span><br><span class="line">        if(str[x] == &apos;\0&apos;) return true;</span><br><span class="line"></span><br><span class="line">        if(i&lt;0 || i&gt;=rows || j&lt;0 || j&gt;=cols) return false;</span><br><span class="line">        if(flag_matrix[i*cols+j] == 0 || matrix[i*cols+j] != str[x]) return false;</span><br><span class="line"></span><br><span class="line">        flag_matrix[i*cols+j] = 0;</span><br><span class="line">        bool is_path = hasPath_helper(matrix, flag_matrix, i, j-1, rows, cols, str, x+1) ||</span><br><span class="line">                       hasPath_helper(matrix, flag_matrix, i-1 , j, rows, cols, str, x+1) ||</span><br><span class="line">                       hasPath_helper(matrix, flag_matrix, i, j+1, rows, cols, str, x+1) ||</span><br><span class="line">                        hasPath_helper(matrix, flag_matrix, i+1, j, rows, cols, str, x+1);</span><br><span class="line">        flag_matrix[i*cols+j] = 1;</span><br><span class="line">        return is_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>回溯法, 如果当前节点的位数值满足要求, 那么从当前节点开始, 满足要求的格子数字应该等于” 1+左+右+上+下”, 其中方向代表这个方向上的满足要求的格子数.</p>
<p>注意每走过一次格子, 需要将flag矩阵中当前格子的标识设为”已走过(1)”,  并且, 由于此任务是统计符合条件的格子总数, 所以和一般的回溯法不同, 不能在递归结束后将该格子的标识重新复位(否则不同路径上回到同一个格子重复计数).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mc_helper(int threshold,int cur_i, int cur_j, vector&lt; vector&lt;int&gt; &gt;&amp; flag_matrix)&#123;</span><br><span class="line">        int rows = flag_matrix.size();</span><br><span class="line">        int cols = flag_matrix[0].size();</span><br><span class="line">        int cur_val = cur_i/10 + cur_i%10 + cur_j/10 + cur_j%10;</span><br><span class="line"></span><br><span class="line">        if(cur_val &gt; threshold</span><br><span class="line">           || cur_i&lt;0 || cur_i &gt;=rows || cur_j&lt;0 || cur_j&gt;=cols</span><br><span class="line">           || flag_matrix[cur_i][cur_j]) return 0;</span><br><span class="line"></span><br><span class="line">        flag_matrix[cur_i][cur_j] = 1;</span><br><span class="line">        return 1 + mc_helper(threshold, cur_i, cur_j-1, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i, cur_j+1, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i-1, cur_j, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i+1, cur_j, flag_matrix);</span><br><span class="line">        //flag_matrix[cur_i][cur_j] = 0;</span><br><span class="line">        //return cur_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int movingCount(int threshold, int rows, int cols)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(rows&lt;=0 || cols&lt;=0) return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; flag_matrix(rows, vector&lt;int&gt;(cols));</span><br><span class="line">        int count = mc_helper(threshold,0, 0, flag_matrix);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法刷题/" rel="tag"><i class="fa fa-tag"></i> 算法刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/z_post/面试-知识点梳理-编译型语言、解释型语言、静态类型语言、动态类型语言的概念与区别/" rel="prev" title="编译型语言、解释型语言、静态类型语言、动态类型语言的概念与区别">
                <i class="fa fa-chevron-left"></i> 编译型语言、解释型语言、静态类型语言、动态类型语言的概念与区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/z_post/计算机视觉-论文解读-FCN/" rel="next" title="Fully Convolutional Networks for Semantic Segmentation---ICCV">
                Fully Convolutional Networks for Semantic Segmentation---ICCV <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar_zz.png"
                alt="ZeroZone" />
            
              <p class="site-author-name" itemprop="name">ZeroZone</p>
              <p class="site-description motion-element" itemprop="description">并不是什么厉害的地方<br>只是一个安静的学习角落</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">131</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hellozhaozheng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hellozhaozheng@foxmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/ksws0292756" title="CSDN博客" target="_blank">CSDN博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-二维数组中的查找"><span class="nav-text">1. 二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-替换空格"><span class="nav-text">2. 替换空格</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-从尾到头打印链表"><span class="nav-text">3.从尾到头打印链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-重建二叉树"><span class="nav-text">4.重建二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-用两个栈实现队列"><span class="nav-text">5.用两个栈实现队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-旋转数组的最小数字"><span class="nav-text">6.旋转数组的最小数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-斐波那契数列"><span class="nav-text">7.斐波那契数列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-跳台阶"><span class="nav-text">8.跳台阶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-变态跳台阶"><span class="nav-text">9.变态跳台阶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-矩形覆盖"><span class="nav-text">10.矩形覆盖</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-二进制中1的个数"><span class="nav-text">11.二进制中1的个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-数值的整数次方"><span class="nav-text">12.数值的整数次方</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-调整数组顺序使奇数位于偶数前面"><span class="nav-text">13.调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-链表中倒数第k个节点"><span class="nav-text">14.链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-反转链表"><span class="nav-text">15.反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-合并两个排序的链表"><span class="nav-text">16.合并两个排序的链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-树的子结构"><span class="nav-text">17.树的子结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-二叉树的镜像"><span class="nav-text">18.二叉树的镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-顺时针打印矩阵"><span class="nav-text">19.顺时针打印矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-包含min函数的栈"><span class="nav-text">20.包含min函数的栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-栈的压入、弹出序列"><span class="nav-text">21.栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-从上往下打印二叉树"><span class="nav-text">22.从上往下打印二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-二叉搜索树的后序遍历序列"><span class="nav-text">23.二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-二叉树中和为某一值的路径"><span class="nav-text">24.二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-复杂链表的复制"><span class="nav-text">25.复杂链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-1"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意"><span class="nav-text">注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正确解题思路："><span class="nav-text">正确解题思路：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-二叉搜索树与双向链表"><span class="nav-text">26.二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-2"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：自己的思路"><span class="nav-text">解法一：自己的思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：中序遍历，递归实现"><span class="nav-text">解法二：中序遍历，递归实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：中序遍历，非递归实现"><span class="nav-text">解法三：中序遍历，非递归实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-字符串的排列"><span class="nav-text">27.字符串的排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-3"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路（没想到）："><span class="nav-text">思路（没想到）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-数组中出现次数超过一半的数字"><span class="nav-text">28.数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述："><span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为-nlog-n-。"><span class="nav-text">思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为 $nlog(n)$ 。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路二："><span class="nav-text">思路二：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路三："><span class="nav-text">思路三：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-最小的K个数"><span class="nav-text">29.最小的K个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述：-1"><span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为-nlog-n-n-。-快排"><span class="nav-text">思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为 $nlog(n) + n$ 。 快排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路二：遍历整个数组，将当前元素与k-input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k-input。时间复杂度-O-nk-。（该思想与冒泡排序思想类似）。"><span class="nav-text">思路二：遍历整个数组，将当前元素与k_input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k_input。时间复杂度 $O(nk)$ 。（该思想与冒泡排序思想类似）。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-大顶堆"><span class="nav-text">解法三: 大顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-快速选择算法"><span class="nav-text">解法四: 快速选择算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-连续子数组的最大和"><span class="nav-text">30.连续子数组的最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-4"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一："><span class="nav-text">解法一：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二："><span class="nav-text">解法二：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三："><span class="nav-text">解法三：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-整数中1出现的次数（从1到整数n中1出现的次数）"><span class="nav-text">31.整数中1出现的次数（从1到整数n中1出现的次数）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-5"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：-1"><span class="nav-text">解法一：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：-1"><span class="nav-text">解法二：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：-1"><span class="nav-text">解法三：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四："><span class="nav-text">解法四：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-把数组排成最小的数"><span class="nav-text">32.把数组排成最小的数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述：-2"><span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#难点："><span class="nav-text">难点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：-2"><span class="nav-text">解法一：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-丑数"><span class="nav-text">33.丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述：-3"><span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：-3"><span class="nav-text">解法一：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：-2"><span class="nav-text">解法二：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-第一次只出现一次的字符"><span class="nav-text">34.第一次只出现一次的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-6"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）"><span class="nav-text">解法一（自想）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：牛客"><span class="nav-text">解法二：牛客</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-数组中的逆序对"><span class="nav-text">35.数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-7"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意："><span class="nav-text">注意：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自）"><span class="nav-text">解法一（自）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（剑指）"><span class="nav-text">解法二（剑指）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#这里需要注意的几点："><span class="nav-text">这里需要注意的几点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-两个链表的第一个公共节点"><span class="nav-text">36.两个链表的第一个公共节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-8"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：-4"><span class="nav-text">解法一：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-数字在排序数组中出现的次数"><span class="nav-text">37.数字在排序数组中出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-9"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-1"><span class="nav-text">解法一（自想）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：牛客-1"><span class="nav-text">解法二：牛客</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-二叉树的深度"><span class="nav-text">38.二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-10"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-2"><span class="nav-text">解法一（自想）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：牛客-2"><span class="nav-text">解法二：牛客</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-平衡二叉树"><span class="nav-text">39.平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-11"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-3"><span class="nav-text">解法一（自想）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-数组中只出现一次的数字"><span class="nav-text">40.数组中只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-12"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：异或"><span class="nav-text">解法一：异或</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-和为S的连续正数序列"><span class="nav-text">41.和为S的连续正数序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-4"><span class="nav-text">解法一（自想）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-和为S的两个数字"><span class="nav-text">42.和为S的两个数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-5"><span class="nav-text">解法一（自想）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-左旋转字符串"><span class="nav-text">43.左旋转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-13"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：利用str-substr-pos-n"><span class="nav-text">解法一（自想）：利用str.substr(pos,n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：反转"><span class="nav-text">解法二（牛客）：反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-翻转单词顺序列"><span class="nav-text">44.翻转单词顺序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：-5"><span class="nav-text">解法一：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：两次反转"><span class="nav-text">解法二（牛客）：两次反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-扑克牌顺子"><span class="nav-text">45.扑克牌顺子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-14"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意-1"><span class="nav-text">注意:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-自想"><span class="nav-text">解法一(自想):</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）："><span class="nav-text">解法二（牛客）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-圆圈中最后剩下的数：约瑟夫（Josephuse）环问题"><span class="nav-text">46.圆圈中最后剩下的数：约瑟夫（Josephuse）环问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-15"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：利用vector维护动态数组"><span class="nav-text">解法一（自想）：利用vector维护动态数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：经典解法，用环形链表模拟圆圈"><span class="nav-text">解法二（牛客）：经典解法，用环形链表模拟圆圈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三（牛客）："><span class="nav-text">解法三（牛客）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47-非常规法求前n项和"><span class="nav-text">47.非常规法求前n项和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-16"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：构造函数"><span class="nav-text">解法一：构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：虚函数"><span class="nav-text">解法二：虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：函数指针"><span class="nav-text">解法三：函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四：模板类"><span class="nav-text">解法四：模板类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-不用加减乘除做加法"><span class="nav-text">48.不用加减乘除做加法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-把字符串转换成整数"><span class="nav-text">49.把字符串转换成整数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-17"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）："><span class="nav-text">解法一（自想）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意-2"><span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-数组中重复的数字"><span class="nav-text">50.数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-18"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：暴力"><span class="nav-text">解法一：暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：哈希"><span class="nav-text">解法二：哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三"><span class="nav-text">解法三</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51-构建乘积数组"><span class="nav-text">51.构建乘积数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-19"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-1"><span class="nav-text">解法一（自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52-正则表达式匹配"><span class="nav-text">52.正则表达式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-20"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：（牛客）"><span class="nav-text">解法一：（牛客）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-表示数值的字符串"><span class="nav-text">53.表示数值的字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-21"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-2"><span class="nav-text">解法一（自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-字符流中第一个不重复的字符"><span class="nav-text">54.字符流中第一个不重复的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（牛客）：哈希表"><span class="nav-text">解法一（牛客）：哈希表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-链表中环的入口节点"><span class="nav-text">55.链表中环的入口节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（牛客）"><span class="nav-text">解法一（牛客）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：-断链法"><span class="nav-text">解法二（牛客）： 断链法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：没太看懂"><span class="nav-text">解法三：没太看懂</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-删除链表中重复的结点"><span class="nav-text">56.删除链表中重复的结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-22"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-3"><span class="nav-text">解法一（自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57-二叉树的下一个节点"><span class="nav-text">57.二叉树的下一个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58-对称的二叉树"><span class="nav-text">58.对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-23"><span class="nav-text">　题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（牛客）：递归"><span class="nav-text">解法一（牛客）：递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：非递归"><span class="nav-text">解法二（牛客）：非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三（牛客）：非递归"><span class="nav-text">解法三（牛客）：非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#59-按之字形顺序打印二叉树"><span class="nav-text">59.按之字形顺序打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-24"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-4"><span class="nav-text">解法一（自想）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：牛客-3"><span class="nav-text">解法二：牛客</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#60-把二叉树打印成多行"><span class="nav-text">60.把二叉树打印成多行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-25"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（半自想）："><span class="nav-text">解法一（半自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-序列化二叉树"><span class="nav-text">61.序列化二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62-二叉搜索树的第k个节点"><span class="nav-text">62.二叉搜索树的第k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-26"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-5"><span class="nav-text">解法一（自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#63-数据流中的中位数"><span class="nav-text">63.数据流中的中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-自想-1"><span class="nav-text">解法一(自想):</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二"><span class="nav-text">解法二:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-AVL树"><span class="nav-text">解法三:AVL树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-牛客-用大顶堆和小顶堆"><span class="nav-text">解法四(牛客):用大顶堆和小顶堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64-滑动窗口的最大值"><span class="nav-text">64.滑动窗口的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-27"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-自想-2"><span class="nav-text">解法一(自想):</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-讨论区"><span class="nav-text">解法二(讨论区):</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#65-矩阵中的路径"><span class="nav-text">65.矩阵中的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-28"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一"><span class="nav-text">解法一:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-机器人的运动范围"><span class="nav-text">66.机器人的运动范围</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-29"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-1"><span class="nav-text">解法一:</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroZone</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">471k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">7:08</span>
  
</div>










  <div class="footer-custom">勤练带来力量</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
