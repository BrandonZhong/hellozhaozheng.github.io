<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>PyTorch-官方教程-DataLoadingAndProcessing</title>
      <link href="/z_post/PyTorch-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B-DataLoadingAndProcessing/"/>
      <url>/z_post/PyTorch-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B-DataLoadingAndProcessing/</url>
      
        <content type="html"><![CDATA[<p>对于一个新的机器/深度学习任务, 大量的时间都会花费在数据准备上. PyTorch提供了多种辅助工具来帮助用户更方便的处理和加载数据. 本示例主要会用到以下两个包:</p><ul><li>scikit-image: 用于读取和处理图片</li><li>pandas: 用于解析csv文件</li></ul><p>导入下面的包<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function, division</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, transform</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore warnings</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"></span><br><span class="line">plt.ion()   <span class="comment"># interactive mode</span></span><br></pre></td></tr></table></figure></p><p>本示例使用的是人脸姿态的数据集, 数据集的标注信息是由68个landmark点组成的, csv文件的格式如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image_name,part_0_x,part_0_y,part_1_x,part_1_y,part_2_x, ... ,part_67_x,part_67_y</span><br><span class="line">0805personali01.jpg,27,83,27,98, ... 84,134</span><br><span class="line">1084239450_e76e00b7e7.jpg,70,236,71,257, ... ,128,312</span><br></pre></td></tr></table></figure></p><p>利用如下代码可以快速的读取CSV文件里面的标注信息, 并且将其转换成 (N,2) 的数组形式, 其中, N 为 landmarks 点的个数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">landmarks_frame = pd.read_csv(<span class="string">'faces/face_landmarks.csv'</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">65</span></span><br><span class="line">img_name = landmarks_frame.iloc[n, <span class="number">0</span>]</span><br><span class="line">landmarks = landmarks_frame.iloc[n, <span class="number">1</span>:].as_matrix()</span><br><span class="line">landmarks = landmarks.astype(<span class="string">'float'</span>).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Image name: &#123;&#125;'</span>.format(img_name))</span><br><span class="line">print(<span class="string">'Landmarks shape: &#123;&#125;'</span>.format(landmarks.shape))</span><br><span class="line">print(<span class="string">'First 4 Landmarks: &#123;&#125;'</span>.format(landmarks[:<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>利用下面的函数可以将图像和标注文件中的点显示出来, 方便观察:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_landmarks</span><span class="params">(image, landmarks)</span>:</span></span><br><span class="line">    <span class="string">"""Show image with landmarks"""</span></span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.scatter(landmarks[:, <span class="number">0</span>], landmarks[:, <span class="number">1</span>], s=<span class="number">10</span>, marker=<span class="string">'.'</span>, c=<span class="string">'r'</span>)</span><br><span class="line">    plt.pause(<span class="number">0.001</span>)  <span class="comment"># pause a bit so that plots are updated</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">show_landmarks(io.imread(os.path.join(<span class="string">'faces/'</span>, img_name)),</span><br><span class="line">               landmarks)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><h1 id="Dataset-class"><a href="#Dataset-class" class="headerlink" title="Dataset class"></a>Dataset class</h1><p><code>torch.utils.data.Dataset</code>实际上是一个用来表示数据集的虚类, 我们可以通过集成该类来定义我们自己的数据集, 在继承时, 需要重写以下方法:</p><ul><li><code>__len__</code>: 让自定义数据集支持通过<code>len(dataset)</code>来返回dataset的size</li><li><code>__getitem__</code>: 让自定义数据集支持通过下标<code>dataset[i]</code>来获取第 $i$ 个数据样本.</li></ul><p>接下来, 尝试创建人脸姿态的自定义数据集. 我们将会在<code>__init__</code>函数中读取csv文件, 但是会将读取图片的逻辑代码写在<code>__getitem__</code>方法中. 这么做有助于提高内存使用效率, 因为我们并不需要所有的图片同时存储在内存中, 只需要在用到的时候将指定数量的图片加载到内存中即可.</p><p>我们的数据集样本将会是字典形式: <code>{&#39;image&#39;: image, &#39;landmarks&#39;:landmarks}</code>.  我们的数据集将会接受一个可选参数<code>transform</code>, 以便可以将任何需要的图片处理操作应用在数据样本上. 使用<code>transform</code>会使得代码看起来异常整洁干净.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FaceLandmarksDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, csv_file, root_dir, transform=None)</span>:</span></span><br><span class="line">        <span class="comment"># 参数:</span></span><br><span class="line">        <span class="comment"># csv_file(string): csv标签文件的路径</span></span><br><span class="line">        <span class="comment"># root_dir(string): 所有图片的文件夹路径</span></span><br><span class="line">        <span class="comment"># transform(callable, optioinal): 可选的变换操作</span></span><br><span class="line">        self.landmarks_frame = pd.read_csv(csv_file)</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.transform = transform</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.landmarks_frame)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        img_name = os.path.join(self.root_dir, self.landmarks_frame.iloc[idx, <span class="number">0</span>])</span><br><span class="line">        image = io.imread(img_name)</span><br><span class="line">        landmarks = self.landmarks.astype(<span class="string">"float"</span>).reshape(<span class="number">-1</span>,<span class="number">2</span>)</span><br><span class="line">        sample = &#123;<span class="string">"image"</span>: image, <span class="string">"landmarks"</span>:landmarks&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            sample = self.transform(sample)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sample</span><br></pre></td></tr></table></figure></p><p>接下来, 让我们对这个类进行初始化<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">face_dataset = FaceLandmarksDataset(csv_file=<span class="string">"faces/face_.csv"</span>, root_dir=<span class="string">"faces/"</span>)</span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(face_dataset)):</span><br><span class="line">    sample = face_dataset[i]</span><br><span class="line">    print(i, sample[<span class="string">"image"</span>].shape, sample[<span class="string">"landmarks"</span>])</span><br><span class="line">    ax = plt.subplot(<span class="number">1</span>,<span class="number">4</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    ax.set_title(<span class="string">"Sample"</span>)</span><br><span class="line">    ax.axis(<span class="string">"off"</span>)</span><br><span class="line">    show_landmarks(**sample)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:</span><br><span class="line">        plt.show()</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><h1 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h1><p>尝试以下三种常见的转换操作:</p><ul><li>Rescale: 改变图片的尺寸大小</li><li>RandomCrop: 对图片进行随机剪裁(数据增广技术)</li><li>ToTensor: 将numpy图片转换成tensor数据</li></ul><p>我们将会把这些操作写成可供调用的类, 而不仅仅是一个简单的函数, 这样做的主要好处是不用每次都传递transform的相关参数. 为了实现可调用的类, 我们需要实现类的 <code>__call__</code> 方法, 并且根据需要实现 <code>__init__</code> 方法. 我们可以像下面这样使用这些类:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsfm = Transform(params)</span><br><span class="line">transformed_sample = tsfm(sample)</span><br></pre></td></tr></table></figure></p><p>具体实现如下:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rescale</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output_size)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(output_size, (int, tuple))</span><br><span class="line">        self.output_size = output_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line">        image, landmarks = sample[<span class="string">"image"</span>], sample[<span class="string">"landmarks"</span>]</span><br><span class="line"></span><br><span class="line">        h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> isinstance(self.output_size, int):</span><br><span class="line">            <span class="keyword">if</span> h&gt;w:</span><br><span class="line">                new_h, new_w = self.output_size*h/w, self.out_size</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_h, new_w = self.output_size, self.output_size*w/h</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_h, new_w = self.output_size</span><br><span class="line"></span><br><span class="line">        new_h, new_w = int(new_h), int(new_w)</span><br><span class="line">        img = transform.resize(image, (new_h, new_w))</span><br><span class="line">        landmarks = landmarks*[new_w/w, new_h/h]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"image"</span>:img, <span class="string">"landmarks"</span>: landmarks&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomCrop</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Crop randomly the image in a sample.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        output_size (tuple or int): Desired output size. If int, square crop</span></span><br><span class="line"><span class="string">            is made.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output_size)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(output_size, (int, tuple))</span><br><span class="line">        <span class="keyword">if</span> isinstance(output_size, int):</span><br><span class="line">            self.output_size = (output_size, output_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> len(output_size) == <span class="number">2</span></span><br><span class="line">            self.output_size = output_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line">        image, landmarks = sample[<span class="string">'image'</span>], sample[<span class="string">'landmarks'</span>]</span><br><span class="line"></span><br><span class="line">        h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">        new_h, new_w = self.output_size</span><br><span class="line"></span><br><span class="line">        top = np.random.randint(<span class="number">0</span>, h - new_h)</span><br><span class="line">        left = np.random.randint(<span class="number">0</span>, w - new_w)</span><br><span class="line"></span><br><span class="line">        image = image[top: top + new_h,</span><br><span class="line">                      left: left + new_w]</span><br><span class="line"></span><br><span class="line">        landmarks = landmarks - [left, top]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'image'</span>: image, <span class="string">'landmarks'</span>: landmarks&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToTensor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Convert ndarrays in sample to Tensors."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line">        image, landmarks = sample[<span class="string">'image'</span>], sample[<span class="string">'landmarks'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># swap color axis because</span></span><br><span class="line">        <span class="comment"># numpy image: H x W x C</span></span><br><span class="line">        <span class="comment"># torch image: C X H X W</span></span><br><span class="line">        image = image.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'image'</span>: torch.from_numpy(image),</span><br><span class="line">                <span class="string">'landmarks'</span>: torch.from_numpy(landmarks)&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Compose-transforms"><a href="#Compose-transforms" class="headerlink" title="Compose transforms"></a>Compose transforms</h1><p>接下来, 需要将定义好的转换操作应用到具体的样本上, 我们首先将特定的操作组合在一起, 然后利用<code>torchvision.transforms.Compose</code>方法直接将操作应用到对应的图片上.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scale = Rescale(<span class="number">256</span>)</span><br><span class="line">crop = RandomCrop(<span class="number">128</span>)</span><br><span class="line">composed = transforms.Compose([Rescale(<span class="number">256</span>),</span><br><span class="line">                               RandomCrop(<span class="number">224</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply each of the above transforms on sample.</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">sample = face_dataset[<span class="number">65</span>]</span><br><span class="line"><span class="keyword">for</span> i, tsfrm <span class="keyword">in</span> enumerate([scale, crop, composed]):</span><br><span class="line">    transformed_sample = tsfrm(sample)</span><br><span class="line"></span><br><span class="line">    ax = plt.subplot(<span class="number">1</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    ax.set_title(type(tsfrm).__name__)</span><br><span class="line">    show_landmarks(**transformed_sample)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><h1 id="Iterating-through-the-dataset"><a href="#Iterating-through-the-dataset" class="headerlink" title="Iterating through the dataset"></a>Iterating through the dataset</h1><p>总结一下对数据采样的过程:</p><ul><li>从文件中读取一张图片</li><li>将transforms应用到图片上</li><li>由于transforms是随机应用的, 因此起到了一定的增广效果.</li></ul><p>可以利用 <code>for i in range</code>循环操作来对整个数据集进行transforms<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">transformed_dataset = FaceLandmarksDataset(csv_file=<span class="string">'faces/face_landmarks.csv'</span>,root_dir=<span class="string">'faces/'</span>,</span><br><span class="line">                    transform=transforms.Compose([Rescale(<span class="number">256</span>),RandomCrop(<span class="number">224</span>),ToTensor()]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(transformed_dataset)):</span><br><span class="line">    sample = transformed_dataset[i]</span><br><span class="line"></span><br><span class="line">    print(i, sample[<span class="string">'image'</span>].size(), sample[<span class="string">'landmarks'</span>].size())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><h1 id="Afterword-torchvision"><a href="#Afterword-torchvision" class="headerlink" title="Afterword: torchvision"></a>Afterword: torchvision</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, datasets</span><br><span class="line"></span><br><span class="line">data_transform = transforms.Compose([</span><br><span class="line">        transforms.RandomSizedCrop(<span class="number">224</span>),</span><br><span class="line">        transforms.RandomHorizontalFlip(),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">        std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">        ])</span><br><span class="line">hymenoptera_dataset = datasets.ImageFolder(root=<span class="string">'hymenoptera_data/train'</span>,</span><br><span class="line">                    transform=data_transform)</span><br><span class="line">dataset_loader = torch.utils.data.DataLoader(hymenoptera_dataset,</span><br><span class="line">                            batch_size=<span class="number">4</span>, shuffle=<span class="keyword">True</span>,</span><br><span class="line">                            num_workers=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DCN-ICCV 2017</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-DCN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-DCN/</url>
      
        <content type="html"><![CDATA[<p>#</p><p>#</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>卷积神经网络由于其模型内部固定的几何结构, 使得它固有的受限于模型的几何变换. 在这片文章中, 作者引入了两种新的模块来增强CNN模型的transformation modeling能力, 分别为可变形的卷积模块和可变形的RoI池化模块(deformable convolution and deformable RoI pooling). 这两个模块都是基于增强模型中的空间采样点的思想提出的. 这些新的模块可以还轻易的替换掉CNN网络中的原始部分, 并且可以轻易地进行端到端的训练. 下面, 我们将会展示在CNN网络中学习秘籍的空间形变, 有助于提升传统的视觉任务, 如物体检测, 语义分割等等.</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在视觉识别任务中, 有一个很关键的点在于怎样才能最大程度的适应物体的几何变换, 如物体尺寸, 姿态, 观察角度, 局部形变等等. 在通常情况下, 具有两种做法, 第一是建立足够的数据集来包含这些可能的形变, 以便让网络能够学习到足够的形变知识. 这一类方法的典型应用就是数据增广. 第二种方法就是使用支持形变不变性的特征表示或算法, 如SIFT(CNN具有平移不变性, 但不具有形变不变性).<br>上面的两种方法有一些明显的缺点. 首先, 就是要求对形变类型已知, 只有在这种假设成立的前提下, 才能有选择的应用最合适的数据增广方法. 第二, 即使在知道形变可能类型时, 利用人工设计特征算子依然是一个不容易的工作, 尤其适当形变类型较为复杂时. CNN虽然取得了很大成功, 但是CNN仍然面临这这两问题. 它们对物体形变的适应能力实际上大多来自于海量数据集, 大型模型, 以及一些简单的人工设计模块的支持.<br><strong>总而言之, CNN固有的优先于具有大量未知形变的任务</strong>, 这种限制来自于CNN模型本身的结构模块(不论是卷积层还是fc层, 层的参数及输出向量都是固定的). 因此, 在CNN内部, 缺少相应的内部机制来处理几何形变的问题. 举个例子来说, 在同一层卷积层中所有激活单元感受野大小都是一样的, 而这并不是high level的卷积层所期望看到的, 因为正常来说, 不同位置与物体之间的联系紧密程度是不同的. 另外, 目前大多数方法都是基于主边框进行回归预测的, 这实际上是一种次优化的方法, 尤其是对于非规则物体来说.<br>在这篇文章中, 我们提出了两个新的模块可以增强CNN对物体集合形变的适应能力. 首先是可形变卷积模块, 它将2D的偏移量添加到规则的网格采样位置中, 可以自由的形成各种形变的卷积, 如图1所示. 图中的不同的偏移量都是通过额外的卷积层从之前的特征图谱中学习到的. 因此, 可形变是以一种局部的, 密集的, 自适应的方法建立在输入特征之上的.</p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwye3au996j20sb0kfdl0.jpg" alt=""></p><p>第二部分是可形变RoI pooling. 它会将每个bin位置的offset添加到对应位置上. 同样, RoI pooling的offset也是学习得到的.<br>以上两种可形变模块都是轻量级的, 并且只引入了很少的参数和计算量, 可以很容易的替换掉标准的CNN网络中去. 产生的网络我们称之为可形变卷积网络(Deformable ConvNets).</p><h2 id="Deformable-Convolutional-Networks"><a href="#Deformable-Convolutional-Networks" class="headerlink" title="Deformable Convolutional Networks"></a>Deformable Convolutional Networks</h2><p>可形变操作的位移是2D的, 代表着不能跨通道执行, 所有的操作都是在同一的channel上执行的.</p><h3 id="Deformable-Convolution"><a href="#Deformable-Convolution" class="headerlink" title="Deformable Convolution"></a>Deformable Convolution</h3><h3 id="Deformable-RoI-Pooling"><a href="#Deformable-RoI-Pooling" class="headerlink" title="Deformable RoI Pooling"></a>Deformable RoI Pooling</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Softer-NMS-Arvix 2018</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-Arxiv2018-SofterNMS/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-Arxiv2018-SofterNMS/</url>
      
        <content type="html"><![CDATA[<p><strong>作者:</strong> Yihui He, Xiangyu Zhang, Kris Kitani, Marios Savvides<br><strong>发表:</strong><br><strong>机构:</strong> CMU &amp; Face++</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>提出了一种新的边框回归损失函数和NMS算法</strong><br>作者提出了一种 <strong>基于KL散度的边框回归损失函数</strong>, 可以同时学习到边框的形变量和位置变化量. 最终产生的位置变化量会与位置的精确度有很强的联系, 然后将其使用在本文提出的 <strong>新的NMS</strong> 算法上, 以此提高准确度.</p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在目前的目标检测模型中, NMS是十分重要的一步处理步骤. 但是, 有时候, 较精确的候选框可能并没有很高的socre, 这时候使用NMS就会导致物体位置的预测精度降低. 在这篇文章中, 作者提出了一种 <strong>新的边框回归损失函数</strong>, 可以同时学习到边框的形变量和位置变化量. 最终产生的位置变化量会与位置的精确度有很强的联系, 然后将其使用在本文提出的 <strong>新的NMS</strong> 算法上, 以此提高准确度. 在MS-COCO数据集上, 将 VGG-16 Faster RCNN的 AP 从 23.6 提高到了 29.1, 将 ResNet-50 FPN Fast RCNN 的 AP 从 36.8 提高到了 37.8 .</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前, 目标检测模型主要分为one-stage和two-stage两种, 本文主要关注two-stage模型. 本文主要关注候选区域框可能出现的以下两种问题: 第一, 当物体周围所有的dounding box都是不准确的, 如图1(a)所示. 第二, 较准确的box的score不高, 而不准确box的score较高, 如图1(b)所示. 上面两种问题都说明了box的位置和box的score不是强相关的.</p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwx9g5daq9j20k50x51kx.jpg" alt=""></p><p>收到这两种问题的启发, 本文提出使用 <strong>KL loss</strong> 来作为物体边框回归loss. 具体来说, 首先将bounding box的预测值和真实值分别建模成高斯分布和Dirac delta function(狄拉克 $\delta$ 函数). 然后, 训练模型, 以期降低来自于这两个分布的KL散度边框回归损失函数. 最后, 提出一个基于权重平均的soft NMS算法, 简言之就是当box具有较高的confidence事, 它就会得到较大的权重, 而不管它的分类score是多少.</p><h2 id="利用KL-Loss来训练边框回归模型"><a href="#利用KL-Loss来训练边框回归模型" class="headerlink" title="利用KL Loss来训练边框回归模型"></a>利用KL Loss来训练边框回归模型</h2><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwy9fjaaa9j20t50rlq61.jpg" alt=""></p><p>本文的检测模型的头部结构如图2所示. 我们的目的是估计边框的位置置信度, 具体来说, 我们的网络将会预测下面的高斯分布而不仅仅是边框回归:</p><script type="math/tex; mode=display">P_\theta (x) = \frac{1}{2\pi \sigma^2}e^{-\frac{(x-x_e)^2}{2\sigma^2}}</script><p>上式中, $x_e$ 代表预测的边框的位置期望, $\sigma$ 代表标准差. 这些值将从Fast RCNN的头部(fc7)产生, 注意, fc7使用的是绝对值激活函数(而不是ReLU), 主要目的是尽量避免大量的 $\sigma$ 值为0., 当 $\sigma \rightarrow 0$ 时, 说明网络对当前预测的边框位置期望持有很大的置信度.</p><p>同样, 真实边框也可以写成高斯函数的形式, 实际上就是如下Dirac delta 函数:</p><script type="math/tex; mode=display">P_D(x) = \delta (x - x_g)</script><p>其中, $x_g$ 是真实边框的位置.<br>我们的目标时找到使得 $P_\theta (x)$ 和 $P_D(x)$ 之间KL散度最小的参数 $\hat\theta$, 即:</p><script type="math/tex; mode=display">\hat\theta = \arg\min_{\theta} D_{KL}(P_D(x) || P_{\theta}(x))</script><p>综上, 本文的模型将使用KL散度作为边框回归损失函数 $L_{reg}$, 分类损失函数 $L_{cls}$ 维持不变(与其他模型一样)</p><script type="math/tex; mode=display">L_{reg} = D_{KL}(P_D(x) || P_{\theta}(x)) = ... = \frac{(x_g - x_e)^2}{2\sigma^2} + \frac{1}{2}log(\sigma^2) + \frac{1}{2}log(2\pi) + H(P_D(x))</script><p>如图3所示, 当预测位置 $x_e$ 不准确时, 我们就希望方差 $\sigma^2$ 越小越好, 这样一来, 损失函数 $L_{reg}$ 就会变小.</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwyaiiqvu6j20sa0qfgor.jpg" alt=""></p><p>//TODO</p><h2 id="Softer-NMS"><a href="#Softer-NMS" class="headerlink" title="Softer-NMS"></a>Softer-NMS</h2><p>在获取到预测位置的标准偏差以后, 通过平均权重将bounding boxes融合, 如下面的算法流程所示, 主要使用两行代码来修改原始的NMS算法.</p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwyan7cz2tj20t00sltsp.jpg" alt=""></p><p>首先, 使用标准的NMS或者soft NMS算法来候选框进行选择. 然后, 对于每一个box $M$, 我们计算它基于周围及自身box的权重均值的新的location. 举个例子, 对于第 $i$ 个box 的坐标 $x1$来说, 它的新坐标 $x1_i$ 计算如下:</p><script type="math/tex; mode=display">x1_i = \frac{\sum_j x1_j / \sigma^2_x1,j}{\sum_j 1/ \sigma^2_x1,j}, \text{subject to } IoU(x1_j, x1_i) > N_t</script><p>当bounding box的iou大于一定阈值 $N_t$ 时, 就会被考虑加入到权重均值当追溯去. 在这里, 我们不需要设置分类score的阈值, 因为即使是较低的socre有时它的localization socre却较高. 图4展示了在应用softerNMS以后, 我们有时候可以避免文章开头提高的两种错误情况.</p><p><img src="https://wx1.sinaimg.cn/large/d7b90c85ly1fwyb7a79nyj20ty0rbb29.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PyTorch官方教程(一)-A 60 Minute Blitz</title>
      <link href="/z_post/PyTorch-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B-60MinuteBlitz/"/>
      <url>/z_post/PyTorch-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B-60MinuteBlitz/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-PyTorch"><a href="#What-is-PyTorch" class="headerlink" title="What is PyTorch?"></a>What is PyTorch?</h1><p>一个基于Python的科学计算包, 设计目的有两点:</p><ul><li>numpy在GPUs实现上的替代品</li><li>具有高度灵活性和速度的深度学习研究平台</li></ul><h2 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h2><p>Tensors可以理解成是Numpy中的ndarrays, 只不过Tensors支持GPU加速计算.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = torch.empty(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">print(x) <span class="comment"># 输出 5×3 的未初始化的矩阵, 矩阵元素未初始化, 所以可能是浮点类型的任何职</span></span><br><span class="line"></span><br><span class="line">x = torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = torch.zeros(<span class="number">5</span>,<span class="number">4</span>,dtype=torch.long)</span><br><span class="line"></span><br><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>]) <span class="comment"># 直接用常数来初始化一个Tensor</span></span><br><span class="line"></span><br><span class="line">x.size() <span class="comment"># Tensor的size</span></span><br></pre></td></tr></table></figure><h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p>PyTorch支持多种语法实现相同的操作.</p><p><strong>加法:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">y = torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">z1 = x + y</span><br><span class="line">z2 = torch.add(x,y)</span><br><span class="line"></span><br><span class="line">z3 = torch.empty(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">torch.add(x,y,out=z3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in-place</span></span><br><span class="line">y.add_(x) <span class="comment"># _ 代表原地加法 也就是 y = y+x</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以想numpy数组一样使用tensor:</span></span><br><span class="line">print(x[:,<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Resizing, 利用torch.view来对tensor执行reshape/resize操作</span></span><br><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">z = x.view(<span class="number">-1</span>,<span class="number">8</span>) <span class="comment"># -1代表自动推断维度</span></span><br><span class="line">print(x.size(), y.size(), z.size()) <span class="comment"># torch.Size([4,4]) torch.Size([16]) torch.Size([2,8])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># item()可以获得只有一个元素的tensor的值</span></span><br><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure></p><h2 id="Tensor与Numpy-Array"><a href="#Tensor与Numpy-Array" class="headerlink" title="Tensor与Numpy Array"></a>Tensor与Numpy Array</h2><p><strong>从tensor转换成numpy数组:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">print(type(a)) <span class="comment"># &lt;class 'torch.Tensor'&gt;</span></span><br><span class="line">b = a.numpy()</span><br><span class="line">print(type(b)) <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意, 此时a和b共享内存, 即a和b指向的都是同一个数据, 也就是说, 如果改变a的值, 那么b的值也会随之改变!!</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a.add_(<span class="number">1</span>)) <span class="comment"># tensor([2., 2., 2., 2., 2])</span></span><br><span class="line">print(b) <span class="comment"># [2., 2., 2., 2., 2]</span></span><br></pre></td></tr></table></figure></p><p><strong>从numpy数组转换成tensor</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br></pre></td></tr></table></figure><p><strong>同样, a和b是共享内存的</strong></p><p>所有位于CPU上的Tensor (除了CharTensor) 都支持转换成对应的numpy数组并且再转换回来.</p><h2 id="CUDA-Tensors"><a href="#CUDA-Tensors" class="headerlink" title="CUDA Tensors"></a>CUDA Tensors</h2><p>Tensors可以利用<code>.to</code>方法移动到任何设备上去<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_avaiable():</span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>) <span class="comment"># 创建了一个cuda device对象</span></span><br><span class="line">    y = torch.ones_like(x, device=device) <span class="comment"># 直接从GPU上创建tensor</span></span><br><span class="line">    x = x.to(device) <span class="comment"># 将x移到gpu上, 也可以直接用字符串指明: x = x.to("cuda")</span></span><br><span class="line">    z = x+y</span><br><span class="line">    z.to(<span class="string">"cpu"</span>, torch.double)</span><br></pre></td></tr></table></figure></p><h1 id="Neural-Networks"><a href="#Neural-Networks" class="headerlink" title="Neural Networks"></a>Neural Networks</h1><p>可以利用<code>torch.nn</code>包来创建神经网络, <code>nn</code>依靠<code>autograd</code>来定义模型并且对其计算微分. 从<code>nn.Module</code>类派生的子类中会包含模型的layers, 子类的成员函数<code>forward(input)</code>会返回模型的运行结果.</p><p>经典的训练神经网络的过程包含以下步骤:</p><ul><li>定义具有一些可学习参数(权重)的神经网络</li><li>在数据集上创建迭代器</li><li>将数据送入到网络中处理</li><li>计算loss</li><li>对参数进行反向求导</li><li>更新参数: $weight = weight - lr*gradient$</li></ul><h2 id="定义一个简单的网络"><a href="#定义一个简单的网络" class="headerlink" title="定义一个简单的网络"></a>定义一个简单的网络</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 1 input image channel, 6 output channels, 5x5 square convolution</span></span><br><span class="line">        <span class="comment"># kernel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># an affine operation: y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># Max pooling over a (2, 2) window</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># If the size is a square you can only specify a single number</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, self.num_flat_features(x))</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure><p>输出如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Net(</span><br><span class="line">  (conv1): Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (conv2): Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (fc1): Linear(in_features=<span class="number">400</span>, out_features=<span class="number">120</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">  (fc2): Linear(in_features=<span class="number">120</span>, out_features=<span class="number">84</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">  (fc3): Linear(in_features=<span class="number">84</span>, out_features=<span class="number">10</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>当定义好模型的<code>forward()</code>函数以后, <code>backward()</code>函数就会自动利用<code>autograd</code>机制定义, 无需认为定义.</p><p>可以通过<code>net.parameters()</code>函数来获取模型中可学习的参数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params = net.parameter() <span class="comment"># params的类型为 &lt;class 'Iterator'&gt;</span></span><br><span class="line">print(len(list(params))) <span class="comment"># 具有可学习参数的层数</span></span><br><span class="line">print(list(params)[<span class="number">0</span>].size()) <span class="comment"># conv1 的参数</span></span><br></pre></td></tr></table></figure><p>根据网络结构接受的输入, 想网络中传输数据并获取计算结果<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input = torch.randn(<span class="number">1</span>,<span class="number">1</span>,<span class="number">32</span>,<span class="number">32</span>) <span class="comment"># 四个维度分别为 (N,C,H,W)</span></span><br><span class="line">out = net(input) <span class="comment"># 自动调用forward函数进行计算并返回结果</span></span><br><span class="line">print(out)  <span class="comment">#tensor([[ 0.1246, -0.0511, 0.0235, 0.1766,  -0.0359, -0.0334, 0.1161, 0.0534, 0.0282, -0.0202]], grad_fn=&lt;ThAddmmBackward&gt;)</span></span><br></pre></td></tr></table></figure></p><p>下面的代码可以清空梯度缓存并计算所有需要求导的参数的梯度<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(<span class="number">1</span>,<span class="number">10</span>)) <span class="comment"># 正如前面所说, 当定义了forward函数以后, 就会自动定义backward函数, 因此可以直接使用</span></span><br></pre></td></tr></table></figure></p><p><strong>需要注意的是, 整个<code>torch.nn</code>包只支持mini-batches, 所以对于单个样本, 也需要显示指明batch size=1, 即input第一个维度的值为1</strong></p><p>也可以对单个样本使用<code>input.unsqueeze(0)</code>来添加一个假的batch dimension.</p><h2 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h2><p>一个损失函数往往接收的是一对儿数据 <code>(output, target)</code>. 然后根据相应规则计算<code>output</code>和<code>target</code>之间相差多远, 如下所示:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output = net(input)</span><br><span class="line">target = torch.randn(<span class="number">10</span>)</span><br><span class="line">target = target.view(<span class="number">1</span>,<span class="number">-1</span>) <span class="comment"># 令target和output的shape相同.</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">print(loss) <span class="comment"># tensor(1.3638, grad_fn=&lt;MseLossBackward&gt;)</span></span><br></pre></td></tr></table></figure><p>利用<code>.grad_fn</code>属性, 可以看到关于loss的计算图:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(loss.grad_fn) <span class="comment"># 返回MseLossBackward对象</span></span><br><span class="line"><span class="comment">#input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span></span><br><span class="line"><span class="comment">#      -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span></span><br><span class="line"><span class="comment">#      -&gt; MSELoss</span></span><br><span class="line"><span class="comment">#      -&gt; loss</span></span><br></pre></td></tr></table></figure></p><p>因此, 当调用<code>loss.backward()</code>时, 就会计算出所有(<code>requires_grad=True</code>的)参数关于loss的梯度, 并且这些参数都将具有<code>.grad</code>属性来获得计算好的梯度</p><h2 id="BackProp"><a href="#BackProp" class="headerlink" title="BackProp"></a>BackProp</h2><p>再利用<code>loss.backward()</code>计算梯度之前, 需要先清空已经存在的梯度缓存(因为PyTorch是基于动态图的, 每迭代一次就会留下计算缓存, 到一下次循环时需要手动清楚缓存), 如果不清除的话, 梯度就换累加(注意不是覆盖).</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()  <span class="comment"># 清楚缓存</span></span><br><span class="line">print(net.conv1.bias.grad) <span class="comment"># tensor([0., 0., 0., 0., 0., 0.])</span></span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(net.conv1.bias.grad) <span class="comment"># tensor([ 0.0181, -0.0048, -0.0229, -0.0138, -0.0088, -0.0107])</span></span><br></pre></td></tr></table></figure><h2 id="Update-The-Weights"><a href="#Update-The-Weights" class="headerlink" title="Update The Weights"></a>Update The Weights</h2><p>最简单的更新方法是按照权重的更新公式:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(learning_rate*f.grad.data)</span><br></pre></td></tr></table></figure></p><p>当希望使用一些不同的更新方法如SGD, Adam等时, 可以利用<code>torch.optim</code>包来实现, 如下所示:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>) <span class="comment"># 创建优化器</span></span><br><span class="line">optimizer.zero_grad() <span class="comment"># 清空缓存</span></span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward() <span class="comment"># 计算梯度</span></span><br><span class="line">optimizer.step() <span class="comment"># 执行一次更新</span></span><br></pre></td></tr></table></figure></p><h1 id="Train-A-Classifier"><a href="#Train-A-Classifier" class="headerlink" title="Train A Classifier"></a>Train A Classifier</h1><h2 id="What-About-Data"><a href="#What-About-Data" class="headerlink" title="What About Data?"></a>What About Data?</h2><p>通常情况下, 在处理数据的时候可以使用标准的Python包(opencv, skimage等), 并将其载入成Numpy数组的形式, 然后可以很方便的将其转换成<code>torch.*Tensor</code>数据.</p><p>对于图像数据来说, PyTorch提供了<code>torchvision</code>包, 它包含许多常见数据集(Imagenet, CIFAR10, MNIST等等)的加载器, 同时还包含其他一些针对图片的数据转换(data transformers)函数. 对于CIFAR10来说, 它的数据集中图片尺寸为 3×32×32, 总共具有10个不同的类别. 下面就来看一下如何训练一个分类器将这10个类别进行分类.</p><h2 id="Training-An-Image-Classifier"><a href="#Training-An-Image-Classifier" class="headerlink" title="Training An Image Classifier"></a>Training An Image Classifier</h2><p>接下来主要包括以下步骤:</p><ul><li>使用<code>torchvision</code>加载并归一化CIFAR10的训练数据集和测试数据集.</li><li>定义一个卷积神经网络</li><li>定义损失函数</li><li>在traing data上训练网络</li><li>在test datauh测试网络</li></ul><p><strong>Loading and normalizing CIFAR10:</strong></p><p>导入相关的包<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br></pre></td></tr></table></figure></p><p><code>torchvision</code>的输出类型是 PILImage. 我们需要将其转换成 Tensors, 并对其进行归一化, 使其数值处于 [-1, 1] 之间.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多个transforms链接(chained)起来</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line"></span><br><span class="line">transform = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),</span><br><span class="line">     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line"></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(root=<span class="string">'./data'</span>, train=<span class="keyword">True</span>, download=<span class="keyword">True</span>, transform=transform)</span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class="number">4</span>, shuffle=<span class="keyword">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">testset = torchvision.datasets.CIFAR10(root=<span class="string">'./data'</span>, train=<span class="keyword">False</span>, download=<span class="keyword">True</span>, transform=transform)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testset, batch_size=<span class="number">4</span>, shuffle=<span class="keyword">False</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">classes = (<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>,</span><br><span class="line">           <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>)</span><br></pre></td></tr></table></figure></p><p>利用下面的代码可以查看CIFAR10中的训练图片样本:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># functions to show an image</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span><span class="params">(img)</span>:</span></span><br><span class="line">    img = img / <span class="number">2</span> + <span class="number">0.5</span>     <span class="comment"># unnormalize</span></span><br><span class="line">    npimg = img.numpy()</span><br><span class="line">    plt.imshow(np.transpose(npimg, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get some random training images</span></span><br><span class="line">dataiter = iter(trainloader)</span><br><span class="line">images, labels = dataiter.next()</span><br><span class="line"></span><br><span class="line"><span class="comment"># show images</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"><span class="comment"># print labels</span></span><br><span class="line">print(<span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure></p><p><strong>定义卷积神经网络:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(self, Net).__init__</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>) <span class="comment"># 两个max pooling的参数是一样的, 所以定义一个就行, 可以重复使用</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        x = self.pool(F.relu(self.conv1(input)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>) <span class="comment"># 第一个维度为batch size</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        output = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">net = Net()</span><br></pre></td></tr></table></figure></p><p><strong>Define a Loss function and optimizer:</strong></p><p>损失函数使用交叉熵, 优化器使用带动量的SGD<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure></p><p><strong>训练网络:</strong></p><p>训练网络的时候, 我们需要简单的在数据迭代器上进行循环操作就可以, 只需要注意不断想网络中送入新的数据即可.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># get the inputs</span></span><br><span class="line">        inputs, labels = data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2000</span> == <span class="number">1999</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            print(<span class="string">'[%d, %5d] loss: %.3f'</span> %</span><br><span class="line">                  (epoch + <span class="number">1</span>, i + <span class="number">1</span>, running_loss / <span class="number">2000</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Finished Training'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>Test the network on the test data</strong></p><p>在测试集上获取模型的准确率, 只需要利用<code>outputs = net(images)</code>即可获得预测的类别概率, 取最大者为预测的类别结果.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span><br><span class="line">        total += labels.size(<span class="number">0</span>)</span><br><span class="line">        correct += (predicted == labels).sum().item()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy of the network on the 10000 test images: %d %%'</span> % (</span><br><span class="line">    <span class="number">100</span> * correct / total))</span><br></pre></td></tr></table></figure><p>利用下面的代码可以看到每个类别的准确率:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class_correct = list(<span class="number">0.</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">class_total = list(<span class="number">0.</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predicted = torch.max(outputs, <span class="number">1</span>)</span><br><span class="line">        c = (predicted == labels).squeeze()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            label = labels[i]</span><br><span class="line">            class_correct[label] += c[i].item()</span><br><span class="line">            class_total[label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'Accuracy of %5s : %2d %%'</span> % (</span><br><span class="line">        classes[i], <span class="number">100</span> * class_correct[i] / class_total[i]))</span><br></pre></td></tr></table></figure><h2 id="Training-on-GPU"><a href="#Training-on-GPU" class="headerlink" title="Training on GPU"></a>Training on GPU</h2><p>上面的代码是在CPU上训练的, 那么如何利用PyTorch在GPU上进行训练呢? 实际上, 只需要将模型转移到GPU上即可. 首先定义一个device对象:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">print(device) <span class="comment"># 输出 cdua:0</span></span><br></pre></td></tr></table></figure></p><p>接下来, 利用<code>.to()</code>方法将模型转移到GPU上面(同时所有的参数和梯度缓存也会转移到GPU上)<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.to(device) <span class="comment"># 也可以直接写成 net.to(device), 但是这样会缺少了设备检查, 不够健壮</span></span><br></pre></td></tr></table></figure></p><p>接下来, 再向模型投喂数据之前, 就需要先将数据转移到GPU上<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputs, labels = inputs.to(device), labels.to(device)</span><br></pre></td></tr></table></figure></p><p>其余代码均与上面的训练代码相同.</p><h2 id="Training-on-multiple-GPUs"><a href="#Training-on-multiple-GPUs" class="headerlink" title="Training on multiple GPUs"></a>Training on multiple GPUs</h2><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>计算机视觉-CVPR2018-NonLocal</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2018-NonLocal/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2018-NonLocal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CoupleNet-Coupling Global Structure with Local Parts for Object Detection</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-CoupleNet/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-CoupleNet/</url>
      
        <content type="html"><![CDATA[<h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>在进行区域分类时, 同时使用了全局信息,上下文信息和局部信息综合判断</strong><br>提出了一个新颖的全卷积网络, 并称之为CoupleNet, 它可以在目标检测中结合使用全局和局部信息. 具体来说, CoupleNet会将由RPN网络产生的候选区域送入到coupling module中, 该模块包含两个分支. 第一条分支利用position-sensitive RoI pooling来捕获物体的局部信息, 另一条分支利用RoI pooling对全局上下文信息进行编码. 接着, 我们设计了不同的coupling策略和归一化方法来使用这些不同分支格子的优势.</p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>尽管R-FCN在保证检测准确度的同时, 取得了更快的检测速度, 但是position-sensitive score maps的设计依然忽略了图中的整体结构的全局信息. 为了充分利用并结合局部和全局信息, 本文提出了一个新颖的全卷积网络, 并称之为CoupleNet, 它可以在目标检测中结合使用全局和局部信息. 具体来说, CoupleNet会将由RPN网络产生的候选区域送入到coupling module中, 该模块包含两个分支. 第一条分支利用position-sensitive RoI pooling来捕获物体的局部信息, 另一条分支利用RoI pooling对全局上下文信息进行编码. 接着, 我们设计了不同的coupling策略和归一化方法来使用这些不同分支格子的优势. 最终, 本文的模型达到了SOTA.</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>典型的基于候选区域的检测算法如FasterRCNN使用了单独的网络来生成候选区域, 这使得检测速度很慢, 而R-FCN利用PSRoI pooling(position-sensitive RoI)对其进行了改进, 在保证精度的情况下获得了更快的检测速度. 但是, R-FCN网络依然没能利用到全局结构信息, 如图1所示, 当只利用局部信息时, 检测框内物体对沙发的预测概率只有0.08, 这显然是是不合理的, 而如果只利用全局信息, 也只能得到0.45的预测概率, 但是如果结合这两部分信息, 就能得到0.78的预测结果, 我们更乐意接受这个结果.</p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwuuq0z3b6j20sn0nwk3a.jpg" alt=""></p><p>本文的主要贡献有以下三点:</p><ol><li>本文提出了一个统一的全卷积网络, 可以联合地学习到目标检测任务中的局部信息, 全局信息和相关的上下文信息</li><li>本文设计了多个不同的归一化方法和coupling策略, 用以挖掘全局信息和局部信息之间的兼容性和互补性</li><li>本文的模型在三个主流数据集(VOC07,VOC12,COCO)取得了SOTA</li></ol><h2 id="CoupleNet"><a href="#CoupleNet" class="headerlink" title="CoupleNet"></a>CoupleNet</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwuvmld7psj21kw0t4agk.jpg" alt=""></p><p>CounpleNet的网络结构如图2所示, 主要包含两条不同的分支:</p><ol><li>一个局部的part-sensitive全卷积网络, 用于学习特定物体的局部信息, 记为local FCN;</li><li>一个全局的region-sensitive全卷积网络, 用于对物体整体结构的全局信息和上下文信息进行编码, 记为global FCN.<br>本文首先利用ResNet-101 (移除了最后的全局平均层和fc层)对图片进行卷积操作, 得到相应的特征图谱, 并利用RPN网络得到相应的候选区域, RPN网络与后续的CoupleNet共享特征图谱计算结果. 然后conv5上对应的候选区域会流向两个不同的分支: local FCN 和 global FC. 最后, 从 local FCN 和 gocal FCN 中得到的结果会被结合在一起, 作为最终的物体socre输出.</li></ol><h3 id="Local-FCN"><a href="#Local-FCN" class="headerlink" title="Local FCN"></a>Local FCN</h3><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwvy0czkkbj20jd0prts4.jpg" alt=""></p><p>为了在local FCN高效的捕获特定区域的信息, 本文通过利用通道数为 $k^2(C+1)$ 的 $1\times 1$ 的卷积层构建了一系列的 part=sensitive socre map, 其中 $k$ 代表我们将物体划分成 $k\times k$ 个局部部位(local parts), $C+1$ 代表类别. 因此, 对于任意一个类别, 都会有 $k^2$ 个通道, 并且每一个通道会负责物体的一个特定局部部位. 最终的类别score将由这 $k^2$ 个结果投票产生. 这里, 我们使用了 R-FCN 的 position-sentitive RoI pooling 层来提取物体的特定部位, 并且是三简单的平均池化来进行投票. 如此一来, 我们就会得到一个 $C+1$ 维度的向量, 代表着当前候选区域属于每一类的概率. 这个过程相当于是把一个对物体类别的强分类器转换成了许多弱分类器, 如此便可以起到ensemble part models的作用, 使得分类更加准确. 如图3(a)所示, 对于一个被裁剪的人像来说, 神经网络对人的全局信息无法很高的响应, 但是如果仅从局部特征角度出发, 如人的鼻子, 眼睛等, local FCN可以十分高效的捕获到这些特定区域的特征. 因此, 我们认为 local FCN 更加关注物体的内部结构和组成要素等信息, 这些信息可以高效的反映出物体的局部属性, 特别是当物体被遮挡或者整体边界不完整的情况. 但是, 对于那些具有简单空间结构以及那些包括了相当多背景区域的物体来说(如, 餐桌), 单单只靠 local FCN 很难做出鲁棒性较高的预测结构. 因此有必要加入全局结构信息来增强网络的分辨能力.</p><h3 id="Global-FCN"><a href="#Global-FCN" class="headerlink" title="Global FCN"></a>Global FCN</h3><p>对于 global FCN, 本文通过使用整体的区域级别的特征来描述物体的全局信息. 首先, 我们将一个 1024 维度的 $1\times 1$ 卷积层接在ResNet101的最后一个残差模块之后, 用于降低维度. 由于候选区域的尺寸不唯一, 因此, 本文会插入一个 RoI pooling 层来提取固定长度的特征向量作为物体的全局结构信息. 第二, 本文使用了两个卷积层(分别为 $k\times k$ 和 $1\times 1$)来更进一步的抽象物体的全局信息. 最后, $1\times 1$ 的卷积结果会被送入分类器, 分类器的输出也是一个 $C+1$ 维度的向量(与local FCN一样).</p><p>此外, 上下文信息是视觉识别任务中最基本,最重要的元素之一. 例如, 船通常是在水里的, 而不太可能是在空中的. 尽管, 在深层网络中, 较深的网络的特征图谱具有更大的感受野, 可以相对获得更多的空间上下文信息, 但是实际中深层特征图谱所包含的上下文信息要理理论上少很多. 因此, 很有必要显式的去收集物体的周围信息, 以减少错分类的可能性. 为了增强 global FCN 的特征表达能力, 本文将上下文信息引入到网络中作为一种有效的附加信息. 具体来说, 本文将物体的RoI区域扩大为原来的2倍. 然后将这两种RoI(原始的和扩大后的)通过RoIpooling后再连接在一起(concatenated), 接着送入之后的子网络.(如图2后下部分所示, 实际上, global分支可以看做是一种特殊的FasterRCNN).</p><p>由于RoI pooling操作, global FCN可以将物体区域作为物体的整体特征进行描述, 因此, 它可以轻松的处理那些完整的物体, 如图3(b)所示.</p><h3 id="Coupling-structure"><a href="#Coupling-structure" class="headerlink" title="Coupling structure"></a>Coupling structure</h3><p>为了让global FCN 和 local FCN 返回的结果在数量级上匹配, 本文对它们的输出使用了归一化操作. 主要利用了两种方案来进行归一化: L2归一化层或者 $1 \times 1$ 卷积层. 同时, 如何将local和global输出结合起来也是一个关键问题. 在本文中, 我们探究了三种不同的coupling方法: 对应位相加(element-wise sum), 对应位相乘(element-wise product), 以及对应位取最大(element-wise maximum). 实验结果表明, 使用 $1\times 1$ 卷积配合对应位相加可以取得最好的实验效果.</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>使用L2归一化效果很差(甚至比不使用归一化的结果还要差), 推测原因可能是L2归一化以后会使得score之间的gap变小, 进而造成错分类. 而使用 $1\times 1$ 卷积进行归一化时, 网络会自动学习并调节local和global归一化以后的尺寸大小.</p><p>对于coupling策略的选择, 对应位相加是一种很有效的连接方式, 在ResNet也使用了这种连接, 而对应位相乘有时候会造成梯度的不稳定, 从而导致训练难以收敛. 对应位取最大则会丢失掉更多的信息, 同时也就丢失了结合局部和全局信息的优势.</p><p>正如我们之前讨论的那样, CoupleNet在面对遮挡, 截断以及包括大量背景的目标时(如沙发,人,桌子,椅子等等), 可以表现出很强的识别能力.</p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwvy0gxc17j20s00fn0vy.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/large/d7b90c85ly1fwvy0kvkn0j21kw0g27ax.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwvy0p2vmrj21kw0iphdt.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwvy0rsfv2j20rt0e276x.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwvy0vpsavj21kw0iphdt.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwvy0yl1ujj21kw0hkn4k.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用PyTorch自己动手从零实现YOLOv3</title>
      <link href="/z_post/PyTorch-YOLOv3/"/>
      <url>/z_post/PyTorch-YOLOv3/</url>
      
        <content type="html"><![CDATA[<p>学习一个算法最好的方式就是自己尝试着去实现它! 因此, 在这片博文里面, 我会为大家讲解如何用PyTorch从零开始实现一个YOLOv3目标检测模型.</p><p>这里我们假设大家对YOLOv3的各个细节都比较熟悉, 因此就不对YOLOv3做过多介绍, 如果对YOLOv3不太懂的话, 可以再看看原文, 或者看看我写的<a href="../计算机视觉-YOLOv3-Arxiv2018">YOLOv3解析</a>.</p><p>模型实现总共会分为以下四部分:</p><ul><li>(一) 搭建YOLO模型框架</li><li>(二) 实现模型框架的前向传播过程</li><li>(三) 目标函数相关实现及NMS算法实现</li><li>(四) 设计输入输出流(input and output pipelines)</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.paperspace.com/how-to-implement-a-yolo-object-detector-in-pytorch/" target="_blank" rel="noopener">https://blog.paperspace.com/how-to-implement-a-yolo-object-detector-in-pytorch/</a></p><p>【链接】从零开始实现YOLOv3（part2）<br><a href="https://zhuanlan.zhihu.com/p/36920744" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36920744</a></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>visdom-数据可视化工具(支持PyTorch和Numpy)</title>
      <link href="/z_post/PyTorch-visdom/"/>
      <url>/z_post/PyTorch-visdom/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/32025746" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32025746</a><br>visdom 是一个灵活的可视化工具, 可用来对实时, 大量的数据进行分析, 组织, 共享等, 还可以实现 <strong>远程</strong> 数据的可视化.</p><h1 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h1>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>itertools模块-高效的迭代器操作</title>
      <link href="/z_post/Python-itertools/"/>
      <url>/z_post/Python-itertools/</url>
      
        <content type="html"><![CDATA[<p><a href="http://funhacks.net/2017/02/13/itertools/#product" target="_blank" rel="noopener">http://funhacks.net/2017/02/13/itertools/#product</a></p><p>itertools 模块提供的迭代器函数有以下几种类型:</p><ul><li>无限迭代器: 生成一个无限序列, 比如自然数序列: 1, 2, 3, 4, …</li><li>有限迭代器: 接受一个或多个序列作为参数, 进行组合, 分组, 过滤等操作</li><li>组合生成器: 序列的排列, 组合, 求序列的笛卡尔积等等</li></ul><h1 id="无线迭代器"><a href="#无线迭代器" class="headerlink" title="无线迭代器"></a>无线迭代器</h1><h1 id="优先迭代器"><a href="#优先迭代器" class="headerlink" title="优先迭代器"></a>优先迭代器</h1><h1 id="组合生成器"><a href="#组合生成器" class="headerlink" title="组合生成器"></a>组合生成器</h1><h2 id="product"><a href="#product" class="headerlink" title="product"></a><code>product</code></h2><p><code>product</code> 用于求多个可迭代对象的笛卡尔积, 它跟嵌套的 <code>for</code> 循环等价, 其一般使用形式如下:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">product(iter1, iter2, ..., iterN, [repeat=<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>其中, <code>repeat</code>是一个关键字参数, 用于指定重复生成序列的次数</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用PyTorch实现经典VGG网络</title>
      <link href="/z_post/PyTorch-VGG/"/>
      <url>/z_post/PyTorch-VGG/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SSD源码解析-模型结构</title>
      <link href="/z_post/PyTorch-SSD-%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84/"/>
      <url>/z_post/PyTorch-SSD-%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Single-Shot Refinement Neural Network for Object Detection</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-RefineDet-CVPR2018/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-RefineDet-CVPR2018/</url>
      
        <content type="html"><![CDATA[<p><strong>作者:</strong> Shifeng Zhang, Longyin Wen, Xiao Bian, Zhen Lei, Stan Z.Li<br><strong>发表:</strong> CVPR2018</p><h1 id="论文亮点"><a href="#论文亮点" class="headerlink" title="论文亮点:"></a>论文亮点:</h1><p><strong>结合了one-stage方法和two-stage方法各自的优势, 提出了一个基于single-shot的检测模型:</strong><br>模型主要包含两大模块, 分别是anchor精化模块和物体检测模块. 网络采用了类似FPN的思想, 通过 Transfer Connection Block 将特征图谱在两个模块之间传送, 不仅提升了的精度, 同时还在速度方面取得了与one-stage方案相媲美的表现</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwp44jaiyij213h0o2n1j.jpg" alt=""></p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文提出了一个基于single-shot的检测模型, 称为RefineDet, 它在精度上高于现有的two-stage方法, 同时, 可以和one-stage方法的速度相媲美. RefineDet包含两个内部连接的模块(如图1):</p><ul><li>anchor精化模块(anchor refinement module):<ol><li>过滤掉负样本的anchors, 以减少分类器的搜索空间;</li><li>对anchors的位置和size进行粗糙的调整, 以便为后续的回归网络提供更好的初始化状态.</li></ol></li><li>物体检测模块(object detection module):<ul><li>用refined anchors作为输入进行回归预测.</li><li>同时, 设计一个<code>传送连接模块(transfer connection block)</code>, 将anchor refinement module里面的特征进行传送, 以此来预测框的位置, size 和 类别标签.</li></ul></li></ul><p>由于本文使用了多任务联合损失函数, 因此可以进行端到端的训练.</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在作者看来, 目前的two-stage方法(Faster RCNN, R-FCN, FPN), 相比于One-Stage方法来说具有三个优势:</p><ul><li>具有启发式规则来处理正负样本不均衡问题</li><li>具有两个级联的物体边框回归阶段(边框更加精确)</li><li>提取了更加丰富的物体特征(anchor使得提取过程更精细)</li></ul><p>为了结合One-Stage和Two-Stage方法的优势, 同时克服他们的缺点, 本文的RefineDet设计了两个内部连接的模块: anchor refinement module(ARM) 和 object detection module(ODM).(如图1所示)</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>网络结构的整体视图如图1所示, 和SSD类似, RefineDet会基于前向传播网络预测出固定数量的bounding box和对应的类别score. 本文的网络主要包含ARM和ODM两大部分.</p><p><strong>ARM:</strong> 对经典网络结构(VGG-16, ResNet-101)进行改造, 去掉分类层, 并加上一些附属结构<br><strong>ODM:</strong> ODM由TCBs (Transfer Connection Block)和预测层(3×3 卷积层)组成, 会输出物体的类别score和相对于refined anchor box的相对位置坐标.</p><p><strong>Transfer Connection Block:</strong> 用于链接ARM和ODM, 引入TCBs的目的主要是为了将ARM中不同层的特征转换成ODM接受的形式, 这样一来,ODM和ARM就可以共享特征向量. 值得注意的是, 在ARM中, 本文仅仅对于anchor相关的特征图谱使用TCBs. 其实很像FPN的想法, 但是与它又不太一样. TCBs的结构如图2所示</p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwp6b5h1hxj20ia0iemym.jpg" alt=""></p><p><strong>Two-Step Cascaded Regression:</strong> 当前的two-stage方法仅仅依赖于一次边框回归过程, 其主要是基于在不同尺度的特征图谱上来预测不同size的物体的位置, 因此预测的精度较低, 尤其是在面对小物体时. 因此, 本文的模型采用了Two-Step Cascaded Regression. 首先, 利用ARM来调节anchor的位置和大小, 以便为后续的ODM的回归预测提供更好的anchor初始状态. 具体来说, 我们会将特征图谱进行网格划分, 然后对于每一个cell可以得到n个anchor boxes, 最开始的时候, 每一个anchor box的位置相对于它的cell来说都是固定的. 在每一个特征图谱的cell上面, 我们都会预测4个相对坐标(refined网格相对于origin网格的位移坐标). 因此, 我们可以在每一个cell上面, 产生n个refined anchors.</p><p>在获得了refined anchor boxes以后, 我们将它们传送到对应的ODM中去(不同的feature map对应不同的ODM) 来预测物体类别,边框位置和大小等信息. 互相关联的ARM和ODM具有相同的维度, 对于每一个anchor box, ODM都会生成 $c+4$ 个输出( $c$ 为物体类别数 ).  这个预测过程与SSD很相似, 但是与之不同的是本文使用了Refined anchor boxes, 从而可以获得更精确的结果.</p><p><strong>Negative Anchor Filtering:</strong> 同以往检测模型一样, 本文不希望训练过多的(容易分类的)简单样本, 同时需要减轻样本不均衡问题, 因此, 本文设计了一个 negative anchor过滤机制. 具体来说, 就是在训练阶段, 对于一个refined anchor box, 如果它的负样本概率大于一个阈值(如0.99), 那么我们就不去训练它. 这样一来, 网络只会训练 <strong>难负样本(refined hard negative anchor boxes)</strong> 以及 所有的 <strong>正样本(refined positive anchor boxes)</strong>.  同样, 在预测阶段, 对于大于阈值的负样本, 也会对其放弃检测.</p><h2 id="训练和预测-Training-and-Inference"><a href="#训练和预测-Training-and-Inference" class="headerlink" title="训练和预测(Training and Inference)"></a>训练和预测(Training and Inference)</h2><p><strong>Data Augmentatin:</strong> 采用了和SSD相同的数据增广方法</p><p><strong>Backbone Network:</strong> 使用了 VGG-16 和 ResNet-101 作为骨架网络, 分别在两个网络后面多加了一些卷积层或者残差模块, 以提取更高level的特征.</p><p><strong>Anchors Design and Matching:</strong> 为了处理不同的物体尺度问题, 本文选择了4个特征层, stride size分别为8, 16, 32 和 64.</p><p><strong>Hard Negative Mining:</strong> 采用了和SSD类似的难样例挖掘算法.</p><p><strong>Loss Function:</strong> RefineDet 的损失函数包含两部分, 即ARM的损失和ODM的损失. 对于ARM损失来说, 我们给每个anchor赋予一个二值标签(是或不是物体). 对于ODM损失来说, 它会接受refined之后的anchor, 进行更进一步的边框预测和类别预测.</p><p><strong>Optimization:</strong> “vavier”初始化用于额外增加的层(两层).</p><p><strong>Inference:</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cpp-RTTI机制</title>
      <link href="/z_post/Cpp-RTTI%E6%9C%BA%E5%88%B6/"/>
      <url>/z_post/Cpp-RTTI%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="RTTI概念"><a href="#RTTI概念" class="headerlink" title="RTTI概念"></a>RTTI概念</h1><p>RTTI (Run Time Type Identification) 即运行时类型识别, 程序能够使用基类类型的指针或引用来检查来检查这些指针或引用所指的对象的实际派生类型.</p><h1 id="RTTI机制的产生"><a href="#RTTI机制的产生" class="headerlink" title="RTTI机制的产生"></a>RTTI机制的产生</h1><p>C++ 是一种静态类型语言, 其具体类型是在编译器就确定的, 不能在运行时更改. 然而由于面向对象程序设计中多态性的要求, C++中的指针或引用, 可能指向与它实际类型不符的其他类型(子类). 有时我们需要将一个多态指针转换为其实际指针对象的类型, 此时就需要知道运行时的类型信息.</p><h1 id="typeid-和-dynamic-cast-操作符"><a href="#typeid-和-dynamic-cast-操作符" class="headerlink" title="typeid 和 dynamic_cast 操作符"></a><code>typeid</code> 和 <code>dynamic_cast</code> 操作符</h1><p>RTTI提供了两个非常有用的操作符: <code>typeid</code> 和 <code>dynamic_cast</code>.</p><ul><li><code>typeid</code>操作符: 返回指针和引用所指的实际类型</li><li><code>dynamic_cast</code>操作符: 将基类类型的指针或引用安全的转换为其派生类类型的指针或引用</li></ul><p>我们知道C++的多态性是有虚函数实现的, 对于多态性的对象, 无法在程序编译阶段确定对象的类型. 为了在运行时获得一个对象的类型, 可以使用<code>typeid</code>函数, 该函数返回一个对<code>type_info</code>类对象的引用, 要使用<code>typeid</code>时必须使用头文件<code>&lt;typeinfo&gt;</code>, 因为<code>typeid</code>是一个返回类型为<code>type_info</code>的引用, 因此, 首先看一下<code>type_info</code>类</p><h2 id="type-info-类"><a href="#type-info-类" class="headerlink" title="type_info 类"></a><code>type_info</code> 类</h2><p><strong>成员函数:</strong></p><ul><li>name(): 返回类型的名称</li><li>raw_name(): 返回名字编码(Name Mangling)算法产生的新名称.</li><li>hash_code(): 返回当前类型对应的hash值. hash值是一个可以用来标志当前类型的函数, 有点类型学生的学号, 公民的身份证号, 银行卡号等等. 不过hash值有赖于编译器的实现, 在不同的编译器下可能会有不同的整数, 但它们都能唯一的标识某个类型.</li></ul><p><strong>遗憾的是, C++标准只对<code>type_info</code>类做了很有限的规定, 不仅成员函数少, 功能弱, 而且各个平台的实现不一致. 例如最常用的<code>name()</code>函数, <code>int</code>类型和<code>Base(类)</code>类型在VC/VS下的输出结果分别是<code>int</code>和<code>class Base</code>, 而在GCC下的输出结果分别是<code>i</code>和<code>4Base</code>.</strong></p><p>C++标准规定, <code>type_info</code>类至少要有如下所示的4个public属性的成员函数, 其他的扩展函数编译器开发者可以自由发挥, 不做限制.</p><ol><li><code>const char *name() const</code>: 返回一个能表示类型名称的字符串, 但是C++标准没有规定这个字符串是什么形式的, 因此出现了不同编译器返回的字符串形式不同的情况.</li><li><code>bool before (const type_info &amp;rhs) const</code>: 判断一个类型是否位于另一个类型前面, <code>rhs</code>参数是一个<code>type_info</code>对象的引用, 但是C++标准并没有规定类型的排列规则, 不同的编译器有不同的排列规则, 程序员也可以自定义. 要特别注意的是, 这个排列顺序和继承顺序是没有关系的, 基类并不一定位于派生类的前面.</li><li><code>bool operator==(const type_info &amp;rhs) const</code>: 重载运算符<code>==</code>, 判断两个类型是否相同, <code>rhs</code>参数是一个<code>type_info</code>对象的引用</li><li><code>bool operator!=(const type_info &amp;rhs) const</code>: 重载运算符<code>!=</code>, 判断两个类型是否不同, <code>rhs</code>参数是一个<code>type_info</code>对象的引用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PyTorch官方教程-Learning PyTorch with Examples</title>
      <link href="/z_post/PyTorch-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B-Learning-PyTorch-with-Examples/"/>
      <url>/z_post/PyTorch-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B-Learning-PyTorch-with-Examples/</url>
      
        <content type="html"><![CDATA[<h1 id="用PyTorch实现一个简单的神经网络"><a href="#用PyTorch实现一个简单的神经网络" class="headerlink" title="用PyTorch实现一个简单的神经网络"></a>用PyTorch实现一个简单的神经网络</h1><p>在神经网络的实现中, 较麻烦的是梯度的计算过程, 下面利用PyTorch的自动求导来实现一个简单的神经网络(两层隐藏层)</p><p>在使用PyTorch的自动推导模块<code>autograd</code>时, 前向传播过程会被定义成一个计算图, 图中的节点时Tensors, 图中的边是一些函数, 用于根据 input Tensors 来生成 output Tensors. 比如当 <code>x</code> 是一个Tensor, 并且拥有属性<code>x.requires_grad=True</code>, 那么<code>x.grad</code>就是另一个Tensor, 它持有loss相对于<code>x</code>的梯度.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">dtype = torch.float</span><br><span class="line">device = torch.device(<span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># N为batch size, D_in为input dimension</span></span><br><span class="line"><span class="comment"># H为hidden dimension, D_out为output dimension</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建输入和输出的Tensors</span></span><br><span class="line"><span class="comment"># requires_grad的值默认为False 指明无需计算x和y的梯度</span></span><br><span class="line">x = torch.randn(N, D_in, device=device, dtype=dtype)</span><br><span class="line">y = torch.randn(N, D_in, device=device, dtype=dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化两个隐藏层的参数, 注意要将requires_grad的值设置为True</span></span><br><span class="line">w1 = torch.randn(D_in, H, device=device, dtype=dtype, requires_grad=<span class="keyword">True</span>)</span><br><span class="line">w2 = torch.randn(H, D_out, device=device, dtype=dtype, requires_grad=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    <span class="comment"># 定义前向计算过程, mm为两个矩阵相乘, clamp可以将数据限定在某一范围内, 实现relu的功能</span></span><br><span class="line">    y_pre = x.mm(w1).clamp(min=<span class="number">0</span>).mm(w2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算loss, loss.item()可以得到loss的矢量值</span></span><br><span class="line">    loss = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只需要调用一条语句, 即可计算出所有requires_grad设置为True的参数的梯度, 可以通过w1或者w2的grad属性来访问各自的梯度.</span></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 手动更新参数(面对大型网络时, 可以通过调用torch.optim.SGD来自动更新)</span></span><br><span class="line">    <span class="comment"># 将参数放在 torch.no_grad() 管理环境当中, 这是因为我们无需对grad进行跟踪, 因此, 也需要在更新完参数以后, 将grad重新置为0 , 以便下一次更新</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        w1 -= learning_rate*w1.grad</span><br><span class="line">        w2 -= learning_rate*w2.grad</span><br><span class="line"></span><br><span class="line">        w1.grad.zero_()</span><br><span class="line">        w2.grad.zero_()</span><br></pre></td></tr></table></figure><h1 id="自定义一个具有自动求导功能的PyTorch函数"><a href="#自定义一个具有自动求导功能的PyTorch函数" class="headerlink" title="自定义一个具有自动求导功能的PyTorch函数"></a>自定义一个具有自动求导功能的PyTorch函数</h1><p>在PyTorch中, 每一个具有自动求导功能的operator都由两个作用在Tensors上的函数实现, 分别是用于计算输出的 <strong>前向函数</strong> , 以及用于计算梯度的 <strong>反向函数</strong>. 因此, 我们在可以在PyTorch中通过继承父类<code>torch.autograd.Function</code>, 并实现其中的<code>forward</code> 和 <code>backward</code> 函数来定义自己的自定义</p><h1 id="PyTorch的动态计算图与TensorFlow的静态计算图"><a href="#PyTorch的动态计算图与TensorFlow的静态计算图" class="headerlink" title="PyTorch的动态计算图与TensorFlow的静态计算图"></a>PyTorch的动态计算图与TensorFlow的静态计算图</h1><h1 id="nn-模块"><a href="#nn-模块" class="headerlink" title="nn 模块"></a>nn 模块</h1><h1 id="optim-模块"><a href="#optim-模块" class="headerlink" title="optim 模块"></a>optim 模块</h1><h1 id="自定义nn-Modules"><a href="#自定义nn-Modules" class="headerlink" title="自定义nn Modules"></a>自定义nn Modules</h1><h1 id="Control-Flow-Weight-Sharing"><a href="#Control-Flow-Weight-Sharing" class="headerlink" title="Control Flow + Weight Sharing"></a>Control Flow + Weight Sharing</h1><p>在上面的例子中, 我们实现了一个非常奇怪的模型: 一个全连接的ReLU网络, 并且使用了很多的相同结构的隐藏层.</p><p>在PyTorch中, 我们可以通过for循环来重复使用同一个Module(如:全连接层), 如下所示:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicNet</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, D_in, H, D_out)</span>:</span></span><br><span class="line"></span><br><span class="line">        super(DynamicNet, self).__init__()</span><br><span class="line">        self.input_linear = torch.nn.Linear(D_in, H)</span><br><span class="line">        self.middle_linear = torch.nn.Linear(H, H)</span><br><span class="line">        self.output_linear = torch.nn.Linear(H, D_out)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在PyTorch中, 我们可以通过for循环来随机的选择中间层的层数, 使得每一次</span></span><br><span class="line"><span class="string">        执行forward函数时, 都具有不同的中间层层数. 而这些中间层因为是被重复使用的, 因而具有共享的权重参数.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        h_relu = self.input_linear(x).clamp(min=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(random.randint(<span class="number">0</span>,<span class="number">3</span>)):</span><br><span class="line">            h_relu = self.middle_linear(h_relu).clamp(min=<span class="number">0</span>)</span><br><span class="line">        y_pred = self.output_linear(h_relu)</span><br><span class="line">        <span class="keyword">return</span> y_pred;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Numpy实现一个简单的神经网络</title>
      <link href="/z_post/Python-%E7%94%A8Numpy%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/z_post/Python-%E7%94%A8Numpy%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>本示例来自于PyTorch的官网上的一个warm-up小示例, 觉得很有代表性, 所有这里单独记录一下.</p><p>对于numpy来说, 它对计算图, 深度学习, 梯度等等概念几乎是不知道的, 但是, 如果我们了解简单神经网络的具体结构, 那么我们就可以很轻易的用numpy来实现这个简单网络, 对此, 我们通常需要自己来实现前向计算和反向计算的逻辑, 下面我们来实现一个具有两层隐藏层的简单网络:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># N 为batch size, D_in 为输入维度</span></span><br><span class="line"><span class="comment"># H 为隐藏层的维度, D_out 为输出的维度</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建随机的输入和输出数据</span></span><br><span class="line">x = np.random.randn(N, D_in) <span class="comment"># N × D_in 的矩阵</span></span><br><span class="line">y = np.random.randn(N, D_out) <span class="comment"># N × D_out 的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对两个隐藏层w1,w2进行初始化</span></span><br><span class="line">w1 = np.random.randn(D_in, H)</span><br><span class="line">w2 = np.random.randn(H, D_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置学习率</span></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    <span class="comment"># 前向传播: 计算预测结果 y_pred</span></span><br><span class="line">    h = x.dot(w1) <span class="comment"># x维度为64 × 1000, w1维度为 1000 × 100, 计算完以后, h维度为 64 × 100</span></span><br><span class="line">    h_relu = np.maximum(h,<span class="number">0</span>)</span><br><span class="line">    y = h_relu.dot(w2) <span class="comment"># h_relu维度为 64×100, w2维度为100×10, y的维度为64×10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    loss = np.square(y_pred - y).sum()</span><br><span class="line">    print(t, loss)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播根据loss更新w1和w2的值</span></span><br><span class="line">    grad_y_pred = <span class="number">2.0</span>*(y_pred - y) <span class="comment"># 对y_pred求导</span></span><br><span class="line">    grad_w2 = h_relu.T.dot(grad_y_pred) <span class="comment"># 对w2求导, 微分矩阵应该与w2的size相同</span></span><br><span class="line">    grad_h_relu = grad_y_pred.dot(w2.T) <span class="comment"># 对h_relu求导</span></span><br><span class="line">    grad_h = grad_h_relu.copy()</span><br><span class="line">    grad_h[h &lt; <span class="number">0</span>] = grad_h_relu <span class="comment"># 经过relu, 将小于0的梯度归0</span></span><br><span class="line">    grad_w1 = x.T.dot(grad_h)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update weights</span></span><br><span class="line">    w1 = w1 - learning_rate * grad_w1</span><br><span class="line">    w2 = w2 - learning_rate * grad_w2</span><br></pre></td></tr></table></figure><p>在执行上述代码以后, <code>w1</code>和<code>w2</code>的值会是的预测出来的<code>pred_y</code>与<code>y</code>之间的平方损失越来越小.</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PyTorch 基础</title>
      <link href="/z_post/PyTorch-%E5%9F%BA%E7%A1%80/"/>
      <url>/z_post/PyTorch-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>PyTorch主要提供以下两大特色:</p><ul><li>支持强力GPU加速的Tensor计算能力</li><li>基于tape的具有自动微分求导能力的深度神经网络框架</li></ul><p>PyTorch 主要包含以下组成要素:</p><div class="table-container"><table><thead><tr><th>组成要素</th><th>描述说明</th></tr></thead><tbody><tr><td>torch</td><td>一个类似于numpy的tensor哭, 提供强力的GPU支持</td></tr><tr><td>torch.autograd</td><td>一个基于tape的具有自动微分求导能力的库, 可以支持几乎所有的tesnor operatioin</td></tr><tr><td>torch.nn</td><td>一个神经网络库, 与autograd深度整合, 可以提供最大限度的灵活性</td></tr><tr><td>torch.multiprocessing</td><td>Python的多线程处理, 可以提供torch Tensors之间的内存共享, 对于加载数据和Hogwild training来说十分有用</td></tr><tr><td>torch.utils</td><td>一些功能类和函数, 如DataLoader, Trainer等等</td></tr><tr><td>torch.legacy(.nn/.optim)</td><td>为了兼容性而存在的一些代码和实现</td></tr></tbody></table></div><p>Pytorch通常可以作为以下用途使用:</p><ul><li>为了使用GPUs性能的numpy替代品</li><li>可以提供强大灵活力和速度优势的深度学习平台.</li></ul><h1 id="torch-nn-MaxPool2d"><a href="#torch-nn-MaxPool2d" class="headerlink" title="torch.nn.MaxPool2d"></a>torch.nn.MaxPool2d</h1>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SSD源码解析(PyTorch版本)</title>
      <link href="/z_post/PyTorch-SSD/"/>
      <url>/z_post/PyTorch-SSD/</url>
      
        <content type="html"><![CDATA[<p>下文对SSD的PyTorch实现进行了详细解析, 项目地址: <a href="https://github.com/amdegroot/ssd.pytorch" target="_blank" rel="noopener">https://github.com/amdegroot/ssd.pytorch</a></p><h1 id="1-ssd-py-模型结构"><a href="#1-ssd-py-模型结构" class="headerlink" title="1. ssd.py 模型结构"></a>1. <code>ssd.py</code> 模型结构</h1><p>在本文件中, 定义了SSD的模型结构. 主要包含以下类和函数:</p><ul><li><code>class SSD(nn.Module)</code>: 自定义SSD网络</li><li><code>def vgg(cfg, i, batch_norm=False)</code>: 搭建vgg网络?</li><li><code>def add_extras(cfg, i, batch_norm=False)</code>: 向VGG网络添加额外的层用于feature scaling</li><li><code>def multibox(vgg, extra_layers, cfg, num_classes)</code>: 构建multibox结构?//TODO</li><li><code>def build_ssd(phase, size=300, num_classes=21)</code>: 构建模型</li></ul><h2 id="1-1-ssd-py-build-ssd-模型构建"><a href="#1-1-ssd-py-build-ssd-模型构建" class="headerlink" title="1.1 ssd.py / build_ssd(...) 模型构建"></a>1.1 <code>ssd.py / build_ssd(...)</code> 模型构建</h2><p>在其他文件通常利用<code>build_ssd(phase, size=300, num_classes=21)</code>函数来创建模型, 下面先看看该函数的具体实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssd.py</span></span><br><span class="line"></span><br><span class="line">base = &#123;</span><br><span class="line">    <span class="string">'300'</span>: [<span class="number">64</span>, <span class="number">64</span>, <span class="string">'M'</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="string">'M'</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="string">'C'</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">'M'</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>],</span><br><span class="line">    <span class="string">'500'</span>: []</span><br><span class="line">&#125;</span><br><span class="line">extras = &#123;</span><br><span class="line">    <span class="string">'300'</span>: [<span class="number">256</span>, <span class="string">'S'</span>, <span class="number">512</span>, <span class="number">128</span>, <span class="string">'S'</span>, <span class="number">256</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">128</span>, <span class="number">256</span>],</span><br><span class="line">    <span class="string">'500'</span>: []</span><br><span class="line">&#125;</span><br><span class="line">mbox = &#123;</span><br><span class="line">    <span class="string">'300'</span>: [<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">'500'</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_ssd</span><span class="params">(phase, size=<span class="number">300</span>, num_classes=<span class="number">21</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> phase != <span class="string">"test"</span> <span class="keyword">and</span> phase != <span class="string">"train"</span>: <span class="comment"># 只能是训练或者预测阶段</span></span><br><span class="line">        print(<span class="string">"ERROR: Phase: "</span> + phase + <span class="string">" not recognized"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> size != <span class="number">300</span>:</span><br><span class="line">        print(<span class="string">"ERROR: You specified size "</span> + repr(size) + <span class="string">". However, "</span>+</span><br><span class="line">                <span class="string">"currently only SSD300 is supported!"</span>) <span class="comment"># 仅仅支持300size的SSD</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    base_, extras_, head_ = multibox(vgg(base[str(size)], <span class="number">3</span>),</span><br><span class="line">                                    add_extras(extras[str(size)], <span class="number">1024</span>),</span><br><span class="line">                                    mbox[str(size)], num_classes)</span><br><span class="line">                                    )</span><br><span class="line">    <span class="keyword">return</span> SSD(phase, size, base_, extras_, head_, num_classes)</span><br></pre></td></tr></table></figure></p><p>可以看到, <code>build_ssd(...)</code>函数主要使用了<code>multibox(...)</code>函数来获取<code>base_, extras_, head_</code>, 在调用<code>multibox(...)</code>函数的同时, 还分别调用了<code>vgg(...)</code>函数, <code>add_extras(...)</code>函数, 并将其返回值作为参数. 之后, 利用这些信息初始化了SSD网络.</p><h2 id="1-2-ssd-py-multibox"><a href="#1-2-ssd-py-multibox" class="headerlink" title="1.2 ssd.py / multibox(...)"></a>1.2 <code>ssd.py / multibox(...)</code></h2><p>我们以调用顺序为依据, 先对<code>multibox(...)</code>函数的内部实现进行解析, 但是在查看<code>multibox(...)</code>函数之前, 我们首先需要看看其参数的由来, 首先是<code>vgg(...)</code>函数, 根据调用语句<code>vgg(base[str(size)], 3)</code>可以看出, 调用<code>vgg</code>时向其传入了两个参数, 分别为<code>base[str(size)]</code> 和<code>3</code>, 对应的就是<code>base[&#39;300&#39;]</code>和3.</p><h3 id="ssd-py-vgg"><a href="#ssd-py-vgg" class="headerlink" title="ssd.py / vgg(...)"></a><code>ssd.py / vgg(...)</code></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssd.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg</span><span class="params">(cfg, i, batch_norm = False)</span>:</span></span><br><span class="line">    <span class="comment"># cfg = base['300'] = [64, 64, 'M', 128, 128, 'M', 256, 256, 256, 'C', 512, 512, 512, 'M', 512, 512, 512],</span></span><br><span class="line">    <span class="comment"># i = 3</span></span><br><span class="line">    layers = []</span><br><span class="line">    in_channels = i</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> cfg:</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">'M'</span>:</span><br><span class="line">            layers += [nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">'C'</span>:</span><br><span class="line">            layers += [nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>, ceil_mode=<span class="keyword">True</span>)]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            conv2d = nn.Conv2d(in_channels=in_channels, out_channels=v, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> batch_norm:</span><br><span class="line">                layers += [conv2d, nn.BatchNorm2d(v), nn.ReLU(inplace=<span class="keyword">True</span>)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                layers += [conv2d, nn.ReLU(inplace=<span class="keyword">True</span>)]</span><br><span class="line">            in_channels = v</span><br><span class="line">        pool5 = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        conv6 = nn.Conv2d(<span class="number">512</span>, <span class="number">1024</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">6</span>, dilation=<span class="number">6</span>)</span><br><span class="line">        conv7 = nn.Con2d(<span class="number">1024</span>, <span class="number">1024</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        layers += [pool5, conv6, nn.ReLU(inplace=<span class="keyword">True</span>), conv7, nn.ReLU(inplace=<span class="keyword">True</span>)]</span><br><span class="line">        <span class="keyword">return</span> layers</span><br></pre></td></tr></table></figure><h3 id="ssd-py-add-extras"><a href="#ssd-py-add-extras" class="headerlink" title="ssd.py / add_extras(...)"></a><code>ssd.py / add_extras(...)</code></h3><p>接下来看一下 <code>add_extras(...)</code> 的内部实现, 根据调用语句<code>add_extras(extras[str(size)], 1024)</code> 可知, 该函数中参数<code>cfg = extras[&#39;300&#39;]</code>, <code>i=1024</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssd.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_extras</span><span class="params">(cfg, i, batch_norm=False)</span>:</span></span><br><span class="line">    <span class="comment"># cfg = [256, 'S', 512, 128, 'S', 256, 128, 256, 128, 256]</span></span><br><span class="line">    <span class="comment"># i = 1024</span></span><br><span class="line">    layers = []</span><br><span class="line">    in_channels = i</span><br><span class="line">    flag = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(cfg):</span><br><span class="line">        <span class="keyword">if</span> in_channels != <span class="string">'S'</span>:</span><br><span class="line">            <span class="keyword">if</span> v == <span class="string">'S'</span>: <span class="comment"># (1,3)[True] = 3, (1,3)[False] = 1</span></span><br><span class="line">                layers += [nn.Conv2d(in_channels=in_channels, out_channels=cfg[k+<span class="number">1</span>],</span><br><span class="line">                                    kernel_size=(<span class="number">1</span>, <span class="number">3</span>)[flag], stride=<span class="number">2</span>, padding=<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                layers += [nn.Conv2d(in_channels=in_channels, out_channels=v,</span><br><span class="line">                                    kernel_size=(<span class="number">1</span>, <span class="number">3</span>)[flag])]</span><br><span class="line">            flag = <span class="keyword">not</span> flag</span><br><span class="line">        in_channels = v</span><br><span class="line">    <span class="keyword">return</span> layers</span><br></pre></td></tr></table></figure></p><h3 id="ssd-py-multibox"><a href="#ssd-py-multibox" class="headerlink" title="ssd.py / multibox(...)"></a><code>ssd.py / multibox(...)</code></h3><p><code>multibox(...)</code> 总共有4个参数, 现在我们已经得到了两个参数, 分别是<code>vgg(...)</code>函数返回的<code>layers</code>, 以及<code>add_extras(...)</code>函数返回的<code>layers</code>, 后面两个参数根据调用语句可知分别为<code>mbox[str(size)]</code>(<code>mbox[&#39;300&#39;]</code>)和<code>num_classes</code>(默认为21). 下面, 看一下<code>multibox(...)</code>函数的具体内部实现:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssd.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multibox</span><span class="params">(vgg, extra_layers, cfg, num_classes)</span>:</span></span><br><span class="line">    <span class="comment"># cfg = [4, 6, 6, 6, 4, 4]</span></span><br><span class="line">    <span class="comment"># num_classes = 21</span></span><br><span class="line">    <span class="comment"># ssd总共会选择6个卷积特征图谱进行预测, 分别为, vggnet的conv4_3, 以及extras_layers的5段卷积的输出(每段由两个卷积层组成, 具体可看extras_layers的实现).</span></span><br><span class="line">    <span class="comment"># 也就是说, loc_layers 和 conf_layers 分别具有6个预测层.</span></span><br><span class="line">    loc_layers = []</span><br><span class="line">    conf_layers = []</span><br><span class="line">    vgg_source = [<span class="number">21</span>, <span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(vgg_source):</span><br><span class="line">        loc_layers += [nn.Conv2d(vgg[v].out_channels, cfg[k]*<span class="number">4</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>]</span><br><span class="line">        conf_layers += [nn.Conv2d(vgg[v].out_channels, cfg[k]*num_classes, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(extra_layers[<span class="number">1</span>::<span class="number">2</span>], <span class="number">2</span>):</span><br><span class="line">        loc_layers += [nn.Conv2d(v.out_channels, cfg[k]*<span class="number">4</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)]</span><br><span class="line">        conf_layers += [nn.Conv2d(v.out_channels, cfg[k]*num_classes, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> vgg, extra_layers, (loc_layers, conf_layers)</span><br></pre></td></tr></table></figure><h3 id="ssd-py-SSD-nn-Module"><a href="#ssd-py-SSD-nn-Module" class="headerlink" title="ssd.py / SSD(nn.Module)"></a><code>ssd.py / SSD(nn.Module)</code></h3><p>在 <code>build_ssd(...)</code> 函数的最后, 利用语句<code>return SSD(phase, size, base_, extras_, head_, num_classes)</code>调用的返回了一个<code>SSD</code>类的对象, 下面, 我们就来看一下看类的内部细节(这也是SSD模型的主要框架实现)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSD</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># SSD网络是由 VGG 网络后街 multibox 卷积层 组成的, 每一个 multibox 层会有如下分支:</span></span><br><span class="line">    <span class="comment"># - 用于class conf scores的卷积层</span></span><br><span class="line">    <span class="comment"># - 用于localization predictions的卷积层</span></span><br><span class="line">    <span class="comment"># - 与priorbox layer相关联, 产生默认的bounding box</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数:</span></span><br><span class="line">    <span class="comment"># phase: test/train</span></span><br><span class="line">    <span class="comment"># size: 输入图片的尺寸</span></span><br><span class="line">    <span class="comment"># base: VGG16的层</span></span><br><span class="line">    <span class="comment"># extras: 将输出结果送到multibox loc和conf layers的额外的层</span></span><br><span class="line">    <span class="comment"># head: "multibox head", 包含一系列的loc和conf卷积层.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, phase, size, base, extras, head, num_classes)</span>:</span></span><br><span class="line">        <span class="comment"># super(SSD, self) 首先找到 SSD 的父类, 然后把类SSD的对象转换为父类的对象</span></span><br><span class="line">        super(SSD, self).__init__()</span><br><span class="line">        self.phase = phase</span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        self.cfg = (coco, voc)[num_classes == <span class="number">21</span>]</span><br><span class="line">        self.priorbox = PriorBox(self.cfg) <span class="comment"># layers/functions/prior_box.py class PriorBox(object)</span></span><br><span class="line">        self.priors = Variable(self.priorbox.forward(), volatile=<span class="keyword">True</span>) <span class="comment"># from torch.autograd import Variable</span></span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">        self.vgg = nn.ModuleList(base)</span><br><span class="line">        self.L2Norm = L2Norm(<span class="number">512</span>,<span class="number">20</span>)  <span class="comment"># layers/modules/l2norm.py class L2Norm(nn.Module)</span></span><br><span class="line">        self.extras = nn.ModuleList(extras)</span><br><span class="line"></span><br><span class="line">        self.loc = nn.ModuleList(head[<span class="number">0</span>]) <span class="comment"># head = (loc_layers, conf_layers)</span></span><br><span class="line">        self.conf = nn.ModuleList(head[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> phase = <span class="string">"test"</span>:</span><br><span class="line">            self.softmax = nn.Softmax(dim=<span class="number">-1</span>)</span><br><span class="line">            self.detect = Detect(num_classes, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0.01</span>, <span class="number">0.45</span>) <span class="comment"># layers/functions/detection.py class Detect</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 定义forward函数, 将设计好的layers和ops应用到输入图片 x 上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 参数: x, 输入的batch 图片, Shape: [batch, 3, 300, 300]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回值: 取决于不同阶段</span></span><br><span class="line">        <span class="comment"># test: 预测的类别标签, confidence score, 以及相关的location.</span></span><br><span class="line">        <span class="comment">#       Shape: [batch, topk, 7]</span></span><br><span class="line">        <span class="comment"># train: 关于以下输出的元素组成的列表</span></span><br><span class="line">        <span class="comment">#       1: confidence layers, Shape: [batch*num_priors, num_classes]</span></span><br><span class="line">        <span class="comment">#       2: localization layers, Shape: [batch, num_priors*4]</span></span><br><span class="line">        <span class="comment">#       3: priorbox layers, Shape: [2, num_priors*4]</span></span><br><span class="line">        sources = list()</span><br><span class="line">        loc = list()</span><br><span class="line">        conf = list()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算vgg直到conv4_3的relu</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">23</span>):</span><br><span class="line">            x = self.vgg[k](x)</span><br><span class="line"></span><br><span class="line">        s = self.L2Norm(x)</span><br><span class="line">        sources.append(s) <span class="comment"># conv4_3 的特征层</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将vgg应用到fc7</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">23</span>, len(self.vgg)):</span><br><span class="line">            x = self.vgg[k](x)</span><br><span class="line">        sources.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算extras layers, 并且将结果存储到sources列表中</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(self.extras):</span><br><span class="line">            x = F.relu(v(x), inplace=<span class="keyword">True</span>) <span class="comment"># import torch.nn.functional as F</span></span><br><span class="line">            <span class="keyword">if</span> k % <span class="number">2</span> = <span class="number">1</span>: <span class="comment"># 在extras_layers, 第1,3,5,7,9的卷积层的输出会用于预测box位置和类别.</span></span><br><span class="line">                sources.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 应用multibox到source layers上, source layers中的元素均为各个用于预测的特征图谱</span></span><br><span class="line">        <span class="keyword">for</span> (x, l, c) <span class="keyword">in</span> zip(sources, self.loc, self.conf):</span><br><span class="line">            <span class="comment"># permute重新排列维度顺序, PyTorch维度的默认排列顺序为 (N, C, H, W),</span></span><br><span class="line">            <span class="comment"># 因此, 这里的排列是将其改为 $(N, H, W, C)$.</span></span><br><span class="line">            <span class="comment"># contiguous返回内存连续的tensor, 由于在执行permute或者transpose等操作之后, tensor的内存地址可能不是连续的,</span></span><br><span class="line">            <span class="comment"># 然后 view 操作是基于连续地址的, 因此, 需要调用contiguous语句.</span></span><br><span class="line">            loc.append(l(x).permute(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>).contiguous())</span><br><span class="line">            conf.append(c(x).permute(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>).contiguous())</span><br><span class="line">        <span class="comment"># cat 是 concatenate 的缩写, view返回一个新的tensor, 具有相同的数据但是不同的size, 类似于numpy的reshape</span></span><br><span class="line">        <span class="comment"># 在调用view之前, 需要先调用contiguous</span></span><br><span class="line">        loc = torch.cat([o.view(o.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="keyword">for</span> o <span class="keyword">in</span> loc], <span class="number">1</span>)</span><br><span class="line">        conf = torch.cat([o.view(o.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="keyword">for</span> o <span class="keyword">in</span> conf], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.phase == <span class="string">"test"</span>:</span><br><span class="line">            output = self.detect(</span><br><span class="line">                loc.view(loc.size(<span class="number">0</span>), <span class="number">-1</span>, <span class="number">4</span>),</span><br><span class="line">                self.softmax(conf.view(conf.size(<span class="number">0</span>), <span class="number">-1</span>, self.num_classes)),</span><br><span class="line">                self.priors.type(type(x.data))</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">if</span> self.phase == <span class="string">"train"</span>:</span><br><span class="line">            output = (</span><br><span class="line">                loc.view(loc.size(<span class="number">0</span>), <span class="number">-1</span>, <span class="number">4</span>), conf.view(conf.size(<span class="number">0</span>), <span class="number">-1</span>, self.num_classes), self.priors</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_weights</span><span class="params">(self, base_file)</span>:</span></span><br><span class="line">        other, ext = os.path.splitext(base_file)</span><br><span class="line">        <span class="keyword">if</span> ext == <span class="string">".pkl"</span> <span class="keyword">or</span> <span class="string">".pth"</span>:</span><br><span class="line">            print(<span class="string">"Loading weights into state dict..."</span>)</span><br><span class="line">            self.load_state_dict(torch.load(base_file, map_location=<span class="keyword">lambda</span> storage, loc: storage))</span><br><span class="line">            print(<span class="string">"Finished!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Sorry only .pth and .pkl files supported"</span>)</span><br></pre></td></tr></table></figure><p>在上面的模型定义中, 我们可以看到使用了几个辅助类, 分别是<code>layers/functions/prior_box.py class PriorBox(object)</code>, <code>layers/modules/l2norm.py class L2Norm(nn.Module)</code>以及 <code>layers/functions/detection.py class Detect</code>. 基本上从他们的名字就可以看出他们的用途, 详细的解析可以看后文.</p><h1 id="layers"><a href="#layers" class="headerlink" title="layers/"></a><code>layers/</code></h1><p>该文件夹的结构组成如下所示, 主要包含了一些辅助SSD模型搭建的类:</p><ul><li><code>functions/</code><ul><li><code>__init__.py</code></li><li><code>detection.py</code></li><li><code>prior_box.py</code></li></ul></li><li><code>modules/</code><ul><li><code>__init__.py</code></li><li><code>l2norm.py</code></li><li><code>multibox_loss.py</code></li></ul></li><li><code>__init__.py</code></li><li><code>box_utils.py</code></li></ul><p>根据上面的调用顺序, 首先看一下<code>prior_box.py</code>文件中的<code>PriorBox</code>类</p><h2 id="layers-functions-prior-box-py"><a href="#layers-functions-prior-box-py" class="headerlink" title="layers/functions/prior_box.py"></a><code>layers/functions/prior_box.py</code></h2><p>该类主要用于计算每一个特征图谱上网格划分后cell推荐的box.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `layers/functions/prior_box.py`</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorBox</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 所谓priorbox实际上就是网格中每一个cell推荐的box</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cfg)</span>:</span></span><br><span class="line">        <span class="comment"># 在SSD的init中, cfg=(coco, voc)[num_classes=21]</span></span><br><span class="line">        <span class="comment"># coco, voc的相关配置都来自于data/cfg.py 文件</span></span><br><span class="line">        super(PriorBox, self).__init__()</span><br><span class="line">        self.image_size = cfg[<span class="string">"min_dim"</span>]</span><br><span class="line">        self.num_priors = len(cfg[<span class="string">"aspect_ratios"</span>])</span><br><span class="line">        self.variance = cfg[<span class="string">"variance"</span>] <span class="keyword">or</span> [<span class="number">0.1</span>]</span><br><span class="line">        self.min_sizes = cfg[<span class="string">"min_sizes"</span>]</span><br><span class="line">        self.max_sizes = cfg[<span class="string">"max_sizes"</span>]</span><br><span class="line">        self.steps = cfg[<span class="string">"steps"</span>]</span><br><span class="line">        self.aspect_ratios = cfg[<span class="string">"aspect_ratios"</span>]</span><br><span class="line">        self.clip = cfg[<span class="string">"clip"</span>]</span><br><span class="line">        self.version = cfg[<span class="string">"name"</span>]</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> self.variance:</span><br><span class="line">            <span class="keyword">if</span> v &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">"Variances must be greater than 0"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self)</span>:</span></span><br><span class="line">        mean = []</span><br><span class="line">        <span class="keyword">for</span> k, f <span class="keyword">in</span> enumerate(self.feature_maps): <span class="comment"># 存放的是feature map的尺寸:38,19,10,5,3,1</span></span><br><span class="line">            <span class="comment"># from itertools import product as product</span></span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> product(range(f), repeat=<span class="number">2</span>):</span><br><span class="line">                <span class="comment"># 这里实际上可以用最普通的for循环嵌套来代替, 主要目的是产生anchor的坐标(i,j)</span></span><br><span class="line"></span><br><span class="line">                f_k = self.image_size / self.steps[k] <span class="comment"># steps=[8,16,32,64,100,300]. f_k大约为feature map的尺寸</span></span><br><span class="line"></span><br><span class="line">                cx = (j + <span class="number">0.5</span>) / f_k <span class="comment"># 求得center的坐标, 浮点类型</span></span><br><span class="line">                cy = (i + <span class="number">0.5</span>) / f_k</span><br><span class="line"></span><br><span class="line">                s_k = self.min_sizes[k]/self.image_size</span><br><span class="line">                mean += [cx, cy, s_k, s_k]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 同一个location上的不同box的尺寸(中心坐标相同)</span></span><br><span class="line">                <span class="comment"># rel size: sqrt(s_k * s_(k+1))</span></span><br><span class="line">                s_k_prime = sqrt(s_k * (self.max_sizes[k]/self.image_size))</span><br><span class="line">                mean += [cx, cy, s_k_prime, s_k_prime]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 其余的宽高比(aspect ratio)</span></span><br><span class="line">                <span class="keyword">for</span> ar <span class="keyword">in</span> self.aspect_ratios[k]:</span><br><span class="line">                    mean += [cx, cy, s_k*sqrt(ar), s_k/sqrt(ar)]</span><br><span class="line">                    mean += [cx, cy, s_k/sqrt(ar), s_k*sqrt(ar)]</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        output = torch.Tensor(mean).view(<span class="number">-1</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> self.clip:</span><br><span class="line">            output.clamp_(max=<span class="number">1</span>, min=<span class="number">0</span>) <span class="comment"># clamp_ 是clamp的原地执行版本</span></span><br><span class="line">        <span class="keyword">return</span> output <span class="comment"># 输出default box坐标(可以理解为anchor box)</span></span><br></pre></td></tr></table></figure><p>最终, ouput就是一张图片中所有的default box的坐标, 对于论文中的默认设置来说产生的box数量为:</p><script type="math/tex; mode=display">38^2 \times 4+19^2 \times 6+ 10^2 \times 6+5^2 \times 6+3^2 \times 4+1^2 \times 4 = 8732</script><h2 id="layers-functions-detection-py"><a href="#layers-functions-detection-py" class="headerlink" title="layers/functions/detection.py"></a><code>layers/functions/detection.py</code></h2><p>在SSD模型的<code>forward()</code>函数中, 使用了<code>output = self.detect(...)</code> 来进行预测, <code>class Detect</code> 类位于 <code>layers/functions/detection.py</code> 文件中, 详细解析如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from troch.autograd import Function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detect</span><span class="params">(Function)</span>:</span> <span class="comment"># 在测试阶段, detect是SSD的最后一层.(同时会使用nms算法减少重复框)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes, bkg_label, top_k, conf_thresh, nms_thresh)</span>:</span></span><br><span class="line">        self.num_classes = num</span><br><span class="line">        self.background_label = bkg_label</span><br><span class="line">        self.top_k = top_k</span><br><span class="line">        <span class="comment"># Parameters used in nms</span></span><br><span class="line">        self.nms_thresh = nms_thresh</span><br><span class="line">        <span class="keyword">if</span> nms_thresh &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"nms_threshold must be non negative"</span>)</span><br><span class="line">        self.conf_thresh = conf_thresh</span><br><span class="line">        self.variance = cfg[<span class="string">"variance"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, loc_data, conf_data, prior_data)</span>:</span></span><br><span class="line">        <span class="comment"># loc_data: 从loc layers得到的loc预测值(tensor), Shape:[batch, num_priors*4]</span></span><br><span class="line">        <span class="comment"># conf_data: 从conf layers得到的conf预测值(tensor), Shape:[batch*num_priors, num_classes]</span></span><br><span class="line">        <span class="comment"># prior_data: prior box, 也就是SSD中的default box, Shape:[1, num_priors, 4], num_priors在默认参数组合下为8732, 1代表一张图片, 4代表4个坐标</span></span><br><span class="line">        num = loc_data.size(<span class="number">0</span>) <span class="comment"># batch size</span></span><br><span class="line">        num_priors = prior_data.size(<span class="number">0</span>) <span class="comment"># one image</span></span><br><span class="line">        output = torch.zeros(num, self.num_classes, self.top_k, <span class="number">5</span>)</span><br><span class="line">        conf_preds = conf_data.view(num, num_priors, self.num_classes).transpose(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将预测结果编码成bboxes数据</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">            <span class="comment"># from ..box_utils import decode, nms</span></span><br><span class="line">            decoded_boxes = decode(loc_data[i], prior_data, self.variance)</span><br><span class="line">            <span class="comment"># for each class, perform nms</span></span><br><span class="line">            conf_scores = conf_preds[i].clone()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> cl <span class="keyword">in</span> range(<span class="number">1</span>, self.num_classes):</span><br><span class="line">                c_mask = conf_scores[cl].gt(self.conf_thresh)</span><br><span class="line">                scores = conf_scores[cl][c_mask]</span><br><span class="line">                <span class="keyword">if</span> scores.size(<span class="number">0</span>) == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">//TODO</span><br></pre></td></tr></table></figure><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>在<code>layers/modules/multibox_loss.py</code> 中定义了SSD模型的损失函数, 在SSD论文中, 损失函数具体定义如下:</p><script type="math/tex; mode=display">L_{loc}(x,l,g) = \sum_{i\in Pos}^N \sum_{m\in\{cx,cy,w,h\}} x_{ij}^k smooth_{L_1}(l_i^m - \hat g_j^m)</script><script type="math/tex; mode=display">L_{conf}(x,c) = -\sum_{i\in Pos}^N x_{ij}^p log(\hat c_i^p) - \sum_{i\in Neg} log(\hat c_i^0), 其中, \hat c_i^p = \frac{exp(c_i^p)}{\sum_p exp(c_i^p)}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># layers/modules/multibox_loss.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiBoxLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># 计算目标:</span></span><br><span class="line">    <span class="comment"># 输出那些与真实框的iou大于一定阈值的框的下标.</span></span><br><span class="line">    <span class="comment"># 根据与真实框的偏移量输出localization目标</span></span><br><span class="line">    <span class="comment"># 用难样例挖掘算法去除大量负样本(默认正负样本比例为1:3)</span></span><br><span class="line">    <span class="comment"># 目标损失:</span></span><br><span class="line">    <span class="comment"># L(x,c,l,g) = (Lconf(x,c) + αLloc(x,l,g)) / N</span></span><br><span class="line">    <span class="comment"># 参数:</span></span><br><span class="line">    <span class="comment"># c: 类别置信度(class confidences)</span></span><br><span class="line">    <span class="comment"># l: 预测的框(predicted boxes)</span></span><br><span class="line">    <span class="comment"># g: 真实框(ground truth boxes)</span></span><br><span class="line">    <span class="comment"># N: 匹配到的框的数量(number of matched default boxes)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes, overlap_thresh, prior_for_matching, bkg_label, neg_mining, neg_pos, neg_overlap, encode_target, use_gpu=True)</span>:</span></span><br><span class="line">        super(MultiBoxLoss, self).__init__()</span><br><span class="line">        self.use_gpu = use_gpu</span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">        self.variance = cfg[<span class="string">"variance"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, predictions, targets)</span>:</span></span><br><span class="line">        loc_data, conf_data, priors = predictions</span><br><span class="line">        num = loc_data.size(<span class="number">0</span>)</span><br><span class="line">        priors = priors[:loc_data.size(<span class="number">1</span>), :]</span><br><span class="line">        num_priors = (priors.size(<span class="number">0</span>))</span><br><span class="line">        num_classes = self.num_classes</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将priors(default boxes)和ground truth boxes匹配</span></span><br><span class="line">        loc_t = torch.Tensor(num, num_priors, <span class="number">4</span>)</span><br><span class="line">        conf_t = torch.LongTensor(num, num_priors)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(num):</span><br><span class="line">            truths = targets[idx][:, :<span class="number">-1</span>].data</span><br><span class="line">            labels = targets[idx][:, <span class="number">-1</span>].data</span><br><span class="line">            defaults = priors.data</span><br><span class="line">            <span class="comment"># from ..box_utils import match</span></span><br><span class="line">            match(self.threshold, truths, defaults, self.variance, labels, loc_t, conf_t, idx)</span><br><span class="line">        <span class="keyword">if</span> self.use_gpu:</span><br><span class="line">            loc_t = loc_t.cuda()</span><br><span class="line">            conf_t = conf_t.cuda()</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        loc_t = Variable(loc_t, requires_grad=<span class="keyword">False</span>)</span><br><span class="line">        conf_t = Variable(conf_t, requires_grad=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">        pos = conf_t &gt; <span class="number">0</span></span><br><span class="line">        num_pos = pos.sum(dim=<span class="number">1</span>, keepdim=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        pos_idx = pos.unsqueeze(pos.dim()).expand_as(loc_data)</span><br><span class="line">        loc_p = loc_data[pos_idx].view(<span class="number">-1</span>, <span class="number">4</span>)</span><br><span class="line">        loc_t = loc_t[pos_idx].view(<span class="number">-1</span>, <span class="number">4</span>)</span><br><span class="line">        loss_l = F.smooth_l1_loss(loc_p, loc_t, size_average=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ... TODO 未解析完</span></span><br><span class="line"></span><br><span class="line">        N = num_pos.data.sum()</span><br><span class="line">        loss_l = loss_l / N</span><br><span class="line">        loss_c = loss_c / N</span><br><span class="line">        <span class="keyword">return</span> loss_l, loss_c</span><br></pre></td></tr></table></figure><h1 id="train-py-模型训练"><a href="#train-py-模型训练" class="headerlink" title="train.py 模型训练"></a><code>train.py</code> 模型训练</h1><p>模型定义后以后, 接下来就是训练阶段, 训练代码位于<code>train.py</code>文件中, 下面对该文件代码进行解读:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2bool</span><span class="params">(v)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> v.lower() <span class="keyword">in</span> (<span class="string">"yes"</span>, <span class="string">"true"</span>, <span class="string">"t"</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">"Single Shot MultiBox Detection"</span>)</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">parser.add_argument(<span class="string">"--cuda"</span>, default=<span class="keyword">True</span>, type=str2bool,</span><br><span class="line">                    help=<span class="string">"Use CUDA to train model"</span>)</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    <span class="keyword">if</span> args.cuda:</span><br><span class="line">        torch.set_default_tensor_type(<span class="string">"torch.cuda.FloatTensor"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        torch.set_default_tensor_type(<span class="string">"torch.FloatTensor"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    torch.set_default_tensor_type(<span class="string">"torch.FloatTensor"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># 该文件中中主要的函数, 在main()中, 仅调用了该函数</span></span><br><span class="line">    <span class="keyword">if</span> args.dataset == <span class="string">"COCO"</span>:</span><br><span class="line">        <span class="keyword">if</span> args.dataset_root == VOC_ROOT:</span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">        cfg = coco <span class="comment"># coco位于config.py文件中</span></span><br><span class="line">        <span class="comment"># COCODetection类 位于coco.py文件中</span></span><br><span class="line">        <span class="comment"># SSDAugmentation类 位于utils/augmentations.py文件中</span></span><br><span class="line">        dataset = COCODetection(root=args.dataset_root,</span><br><span class="line">                                transform=SSDAugmentation(cfg[<span class="string">"min_dim"</span>], MEANS))</span><br><span class="line">    <span class="keyword">elif</span> args.dataset == <span class="string">"VOC"</span>:</span><br><span class="line">        <span class="keyword">if</span> args.dataset_root == COCO_ROOT:</span><br><span class="line">            <span class="comment">#...</span></span><br><span class="line">        cfg = voc</span><br><span class="line">        dataset = VOCDetection(root=args.dataset_root,</span><br><span class="line">                               transform=SSDAugmentation(cfg[<span class="string">"min_dim"</span>], MEANS))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.visdom:</span><br><span class="line">        <span class="keyword">import</span> visdom</span><br><span class="line">        viz = visdom.Visdom()</span><br><span class="line">    <span class="comment"># from ssd import build_ssd</span></span><br><span class="line">    ssd_net = build_ssd(<span class="string">"train"</span>, cfg[<span class="string">"min_dim"</span>], cfg[<span class="string">"num_classes"</span>])</span><br><span class="line">    net = ssd_net</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.cuda:</span><br><span class="line">        net = torch.nn.DataParallel(ssd_net)</span><br><span class="line">        <span class="comment"># import torch.backends.cudnn as cudnn</span></span><br><span class="line">        cudnn.benchmark = <span class="keyword">True</span> <span class="comment"># 大部分情况下, 这个flag可以让内置的cuDNN的auto-tuner自动寻找最适合当前配置的算法.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.resume: <span class="comment"># resume 类型为 str, 值为checkpoint state_dict file</span></span><br><span class="line">        ssd_net.load_weights(args.resume)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        vgg_weights = torch.load(args.save_folder + args.basenet)</span><br><span class="line">        ssd_net.load_state_dict(vgg_weights)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.cuda:</span><br><span class="line">        net = net.cuda() <span class="comment"># 将所有的参数都移送到GPU内存中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args.resume:</span><br><span class="line">        ssd_net.extras.apply(weights_init) <span class="comment"># 本文件的函数: def weights_init(), 对网络参数执行Xavier初始化.</span></span><br><span class="line">        ssd_net.loc.apply(weights_init)</span><br><span class="line">        ssd_net.conf.apply(weights_init)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># import torch.optim as optim</span></span><br><span class="line">    optimizer = optim.SGD(net.parameters(), lr=args.lr, momentum=args.momentum, weight_decay=args.weight_decay)</span><br><span class="line">    <span class="comment"># MultiBoxLoss类 位于layers/modules/multibox_loss.py文件中</span></span><br><span class="line">    criterion = MultiBoxLoss(cfg[<span class="string">"num_classes"</span>], <span class="number">0.5</span>, <span class="keyword">True</span>, <span class="number">0</span>, <span class="keyword">True</span>, <span class="number">3</span>, <span class="number">0.5</span>, <span class="keyword">False</span>, args.cuda)</span><br><span class="line"></span><br><span class="line">    net.train()</span><br><span class="line">    <span class="comment"># loss计数器</span></span><br><span class="line">    loc_loss = <span class="number">0</span></span><br><span class="line">    conf_loss = <span class="number">0</span></span><br><span class="line">    epoch = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    epoch_size = len(dataset) // args.batch_size</span><br><span class="line"></span><br><span class="line">    step_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.visdom:</span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># import torch.utils.data as data</span></span><br><span class="line">    data_loader = data.DataLoader(dataset, args.batch_size, num_workers=args.num_workers, shuffle=<span class="keyword">True</span>, collate_fn=detection_collate, pin_memory=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建batch迭代器</span></span><br><span class="line">    batch_iterator = iter(data_loader)</span><br><span class="line">    <span class="keyword">for</span> iteration <span class="keyword">in</span> range(args.start_iter, cfg[<span class="string">"max_iter"</span>]):</span><br><span class="line">        <span class="keyword">if</span> args.visdom <span class="keyword">and</span> iteration != <span class="number">0</span> <span class="keyword">and</span> (iteration % epoch_size==<span class="number">0</span>):</span><br><span class="line">            update_vis_plot(epoch, loc_loss, conf_loss, epoch_plot, <span class="keyword">None</span>, <span class="string">"append"</span>, epoch_size)</span><br><span class="line">            loc_loss = <span class="number">0</span></span><br><span class="line">            conf_loss = <span class="number">0</span></span><br><span class="line">            epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iteration <span class="keyword">in</span> cfg[<span class="string">"lr_steps"</span>]:</span><br><span class="line">            step_index += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 每经过固定迭代次数, 就将lr衰减1/10</span></span><br><span class="line">            adjust_learning_rate(optimizer, args.gamma, step_index)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load train data</span></span><br><span class="line">        images, targets = next(batch_iterator)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> args.cuda:</span><br><span class="line">            images = Variable(images.cuda())</span><br><span class="line">            targets = [Variable(ann.cuda(), volatile=<span class="keyword">True</span>) <span class="keyword">for</span> ann <span class="keyword">in</span> targets]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            images = Variable(images)</span><br><span class="line">            targets = [Variable(ann, valotile=<span class="keyword">True</span>) <span class="keyword">for</span> ann <span class="keyword">in</span> targets]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        out = net(images)</span><br><span class="line">        <span class="comment"># backprop</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss_l, loss_c = criterion(out, targets) <span class="comment"># criterion = MultiBoxLoss(...)</span></span><br><span class="line">        loss = loss_l + loss_c</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        loc_loss += loss_l.data[<span class="number">0</span>]</span><br><span class="line">        conf_loss += loss_c.data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iteratioin % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print(...) 每隔10次迭代就输出一次训练状态信息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> args.visdom:</span><br><span class="line">            <span class="comment"># update_vis_plot(...)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iteration != <span class="number">0</span> <span class="keyword">and</span> iteration % <span class="number">5000</span> ==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># save model</span></span><br></pre></td></tr></table></figure><h2 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjust_learning_rate</span><span class="params">(optimizer, gamma, step)</span>:</span></span><br><span class="line">    lr = args.lr * (gamma ** (step)) <span class="comment">## **为幂乘</span></span><br><span class="line">    <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">        param_group[<span class="string">"lr"</span>] = lr</span><br></pre></td></tr></table></figure><h2 id="Xavier-初始化"><a href="#Xavier-初始化" class="headerlink" title="Xavier 初始化"></a>Xavier 初始化</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tran.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xavier</span><span class="params">(param)</span>:</span></span><br><span class="line">    init.xavier_uniform(param) <span class="comment"># import torch.nn.init as init</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weights_init</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(m, nn.Conv2d): <span class="comment"># 只对卷积层初始化</span></span><br><span class="line">        xavier(m.weight.data)</span><br><span class="line">        m.bias.data.zero_()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> PyTorch </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Caffe2-SSD</title>
      <link href="/z_post/Caffe2-SSD/"/>
      <url>/z_post/Caffe2-SSD/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DSSD-Deconvolutional Single Shot Detector</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-Arxiv2017-DSSD/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-Arxiv2017-DSSD/</url>
      
        <content type="html"><![CDATA[<h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>(1) 利用反卷积模块向特征图谱中添加更多的上下文信息</strong><br>主要是对SSD的一点改进, SSD使用了不同阶段的卷积特征图谱进行目标检测, 而DSSD受到人体姿态识别任务的启发, 将这些不同阶段的卷积特征图谱通过反卷积模块连接起来, 然后再进行目标检测的预测任务.<br><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwtpkdiie6j21480trdn7.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwtrhla3r4j20mm0jxgnc.jpg" alt=""><br><strong>(2), 预测模块采用Residual模块</strong><br>这个不算是亮点, 不过也是改动之一, 基本来说就说原始的SSD是直接在特征图谱预测结果并计算损失的, 而DSSD在预测之前会先经过一个Residual模块做进一步的特征提取, 然后在进行预测.<br><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwtqpmp2rvj21cf0kejv9.jpg" alt=""></p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这篇文章最主要的贡献在于提出了一个可以将额外的上下文信息引入到现有大多数目标检测模型的方法. 为了达到这个目标, 本文首先将Resnet101 分类网络和SSD模型结合起来, 然后对SSD+Resnet101的模型进行了扩展, 添加了反卷积层, 以此引入了针对更大范围尺度的目标物上下文特征信息, 进而提高了准确率(特别是在小物体上面). <strong>这种方法在进行高度阐述时, 很容易就能讲明白, 但是在真正实现时, 却很难成功.</strong> 因此本文精心的添加了一些具有已经学习好的特征信息的阶段, 特别是在反卷积时的前向计算的连接上, 最终使得上面的方法得以起效.</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwtpkdiie6j21480trdn7.jpg" alt=""></p><h2 id="DSSD-模型"><a href="#DSSD-模型" class="headerlink" title="DSSD 模型"></a>DSSD 模型</h2><h3 id="base-network"><a href="#base-network" class="headerlink" title="base network"></a>base network</h3><p>如图1上半部分所示, SSD模型是用一个经典网络做为基础网络, 然后后接几层额外的特征层构建的. 原始的SSD采用的是VGGnet, 但是大量的工作都是用ResNet获得了更好的效果, 因此, 本文也选用ResNet-101网络作为backbone. 并且将额外的卷积层(也换成Residual模块)接在 conv5_x block后面, 同时会分别从 conv3_x, conv5_x两个卷积段预测score和offsets. <strong>个人觉得奇怪的一点是, 为什么单单把VGG换成ResNet并没有提高mAP?(VOC数据集, 前者77.5, 后者76.4) 而是在使用了其他辅助模块后才提高的</strong></p><h3 id="prediction-module"><a href="#prediction-module" class="headerlink" title="prediction module"></a>prediction module</h3><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwtqpmp2rvj21cf0kejv9.jpg" alt=""></p><p>MS-CNN指出, 提升每个任务的子网络有助于提高准确率, 根据这个原则, 我们在每一个预测层都添加了一个residual block, 如图2(c)所示. 同时也对其他形式的predictin module进行了尝试(图2,a,b,c).</p><h3 id="Deconvolutional-SSD"><a href="#Deconvolutional-SSD" class="headerlink" title="Deconvolutional SSD"></a>Deconvolutional SSD</h3><p>为了增加更多高级别的上下文信息, 文章将prediction module 移动到了一系列的反卷积层之后, 并与原始SSD的额外卷积层形成了一种非对称的沙漏结构(hourglass network, 灵感来自于一篇人体姿态检测论文), 如图1所示. 每一个卷积层的特征图谱会和之前的层一起经过一个反卷积模块(该模块细节在后面介绍), 这就相当于在特征图谱中加入了更多的上下文信息. 这里的反卷积只有很浅的几层, 作者这样设计的原因一是不想增加过多的计算时间, 二是由于迁移学习方法可以帮助更好更快的模型收敛, 同时可以获得更高的精度, 因此无需设计过深的网络. <strong>反卷积层很重要的一个点在于计算成本的增加, 除了反卷积操作本身的计算, 还体现在从之前层中添加信息时</strong></p><h3 id="Deconvolution-Module"><a href="#Deconvolution-Module" class="headerlink" title="Deconvolution Module"></a>Deconvolution Module</h3><p>为了帮助整合反卷积层和之前层的特征信息, 文章引入了一种反卷积模块, 如图3所示.</p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwtrhla3r4j20mm0jxgnc.jpg" alt=""></p><p>图3中左下角是从原始SSD中得到的特征图谱, 左上角是论文<code>Learning to refine object segment</code>中提出的反卷积层. 在当前模块中的每一个卷积层, 都使用了BN层, 在放大特征图谱时, 我们使用了学习到的反卷积层, 而不是双线性插值法. 在测试了多种conbination方法后(element-wise sum, element-wise product), 根据实验结果决定采用对应为相乘的结合方式(VOC数据集, 前者78.4, 后者78.6, 提升了0.2的mAP).</p><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p>除了一些参数设置的不同外, 训练策略基本遵循SSD.</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwtsusimmaj20o70b1dhb.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwtsvfcjkfj21kw0n911g.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwtsvsst7yj20s60ildjb.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwtsw8f5f3j21kw0gxn37.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwtswrk1sjj21kw0ji7an.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwtsx845hej21kw0q9aix.jpg" alt=""></p><p>从COCO数据集的结果来看, DSSD在小物体方面并没有提升, 而在大物体方面获得了很大的提升, 推测原因主要是因为ResNet-101在大物体的特征提取能力上, 要远强于VGGNet.<br>另外, 可以看出, 由于采用了更深的ResNet网络, 同时增加了反卷积过程, 使得FPS降低不少.(即使在测试阶段利用计算公式移除了BN层, 这个trick可以提升1.2~1.5倍的检测速度).</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11 新特性</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-Cpp11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-Cpp11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h1 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h1><h1 id="decltype-关键字"><a href="#decltype-关键字" class="headerlink" title="decltype 关键字"></a><code>decltype</code> 关键字</h1>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Cpp-整型上下限INT_MAX和INT_MIN及其运算</title>
      <link href="/z_post/Cpp-%E6%95%B4%E5%9E%8B%E4%B8%8A%E4%B8%8B%E9%99%90INT-MAX%E5%92%8CINT-MIN%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/"/>
      <url>/z_post/Cpp-%E6%95%B4%E5%9E%8B%E4%B8%8A%E4%B8%8B%E9%99%90INT-MAX%E5%92%8CINT-MIN%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="INT-MAX-INT-MIN数值大小"><a href="#INT-MAX-INT-MIN数值大小" class="headerlink" title="INT_MAX,INT_MIN数值大小"></a>INT_MAX,INT_MIN数值大小</h1><p>因为int占4字节32位，根据二进制编码的规则，INT_MAX = 2^31-1，INT_MIN= -2^31.C/C++中，所有超过该限值的数，都会出现溢出，出现warning，但是并不会出现error。如果想表示的整数超过了该限值，可以使用长整型long long 占8字节64位。</p><h1 id="关于INT-MAX-INT-MIN的运算"><a href="#关于INT-MAX-INT-MIN的运算" class="headerlink" title="关于INT_MAX INT_MIN的运算"></a>关于INT_MAX INT_MIN的运算</h1><p>由于二进制编码按原码、补码和反码的规则进行运算，所有程序中对INT_MAX和INT_MIN的运算应当格外注意，在出现溢出的时候，不遵循数学规则。</p><p>INT_MAX + 1 = INT_MIN</p><p>INT_MIN - 1 = INT_MAX</p><p><strong>abs(INT_MIN) = -INT_MIN = INT_MIN</strong></p><p><strong>另外要注意的是:</strong> INT_MAX + 1 &lt; INT_MAX， INT_MIN - 1 &gt; INT_MIN, abs(INT_MIN) &lt; 0.</p><p>虽然abs(INT_MIN) = -INT_MIN = INT_MIN, 但是可以利用unsigned int来获取最小负值的绝对值:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(INT_MIN)  <span class="comment">// un = 2147483648</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>glob模块-文件路径查找</title>
      <link href="/z_post/Python-glob/"/>
      <url>/z_post/Python-glob/</url>
      
        <content type="html"><![CDATA[<p>glob模块是Python最简单的模块之一, 内容非常少, 用它可以查找符合特定规则的文件路径名, 查找文件时只会用到三个匹配符:</p><ul><li><ul><li>: 匹配0个或多个字符</li></ul></li><li>? : 匹配单个字符</li><li>[] : 匹配指定范围内的字符, 如[0-9]匹配数字</li></ul><h1 id="glob-glob"><a href="#glob-glob" class="headerlink" title="glob.glob"></a>glob.glob</h1><p>返回所有匹配的文件路径列表, 它只有一个参数pathname, 定义了文件路径匹配的规则, 这里可以是绝对路径或者相对路径:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">pathes_list = glob.glob(<span class="string">"~/Pictures/*.jpg"</span>)</span><br><span class="line"><span class="comment"># 获取Pictures下的所有图片</span></span><br><span class="line"></span><br><span class="line">relative_pathes_list = glob.glob(<span class="string">"../*.py"</span>)</span><br><span class="line"><span class="comment"># 获取上级目录中的所有.py文件</span></span><br></pre></td></tr></table></figure></p><h1 id="glob-iglob"><a href="#glob-iglob" class="headerlink" title="glob.iglob"></a>glob.iglob</h1><p>获取一个可遍历的对象, 使用它可以逐个获取匹配的文件路径名. 与<code>glob.glob()</code>的区别是: <code>glob.glob()</code>会同时获取到所有的匹配路径, 而<code>glob.iglob()</code>一次只获取一个匹配路径.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = glob.iglob(<span class="string">"../*.py"</span>)</span><br><span class="line"><span class="keyword">print</span> f <span class="comment"># &lt;generator object iglob at 0x00B9FF80&gt;</span></span><br><span class="line"><span class="keyword">for</span> py <span class="keyword">in</span> f:</span><br><span class="line">    print(py)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>tarfile和zipfile模块-压缩解压tar归档文件</title>
      <link href="/z_post/Python-tarfile-zipfile/"/>
      <url>/z_post/Python-tarfile-zipfile/</url>
      
        <content type="html"><![CDATA[<h1 id="tarfile"><a href="#tarfile" class="headerlink" title="tarfile"></a>tarfile</h1><p>tarfile是Python自带的用于方便读取tar归档文件的模块.</p><h1 id="zipfile"><a href="#zipfile" class="headerlink" title="zipfile"></a>zipfile</h1><p>与tarfile对应的是zipfile模块, 用于处理zip压缩.</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>requests模块-HTTP客户端库</title>
      <link href="/z_post/Python-requests/"/>
      <url>/z_post/Python-requests/</url>
      
        <content type="html"><![CDATA[<p><code>requests</code> 是一个很实用的Python HTTP客户端库, 在编写爬虫和测试服务器响应数据时会经常用到, 可以说, requests 完全满足如今网络的需求.</p><h1 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CIFAR-10 (Caffe2)</title>
      <link href="/z_post/Caffe2-CIFAR-10/"/>
      <url>/z_post/Caffe2-CIFAR-10/</url>
      
        <content type="html"><![CDATA[<p>本示例主要包含以下几个主要部分:</p><ul><li>下载Cifar10数据集</li><li>将Images写入Imdbs</li><li>定义并且训练model</li><li>保存训练好的model</li><li>加载训练好的model</li><li>在testing imdb上面执行inference</li><li>继续训练以提高test accuracy</li><li>测试retrained model</li></ul><h1 id="导入必要的包"><a href="#导入必要的包" class="headerlink" title="导入必要的包"></a>导入必要的包</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> lmdb</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> imageio <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">import</span> caffe2.python.predictor.predictor_exporter <span class="keyword">as</span> pe</span><br><span class="line"><span class="keyword">from</span> caffe2.proto <span class="keyword">import</span> caffe2_pb2</span><br><span class="line"><span class="keyword">from</span> caffe2.python.predictor <span class="keyword">import</span> mobile_exporter</span><br><span class="line"><span class="keyword">from</span> caffe2.python <span class="keyword">import</span>(</span><br><span class="line">    brew,</span><br><span class="line">    core,</span><br><span class="line">    model_helper,</span><br><span class="line">    net_drawer,</span><br><span class="line">    optimizer,</span><br><span class="line">    visualize,</span><br><span class="line">    workspace</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局初始化信息 , 如果需要看到更加详细的初始化信息, 需要将caffe2_log_level参数设置为 1</span></span><br><span class="line">core.GlobalInit([<span class="string">'caffe2'</span>, <span class="string">'--caffe2_log_level=0'</span>])</span><br></pre></td></tr></table></figure><h1 id="下载并解压数据集"><a href="#下载并解压数据集" class="headerlink" title="下载并解压数据集"></a>下载并解压数据集</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="comment"># 设置下载路径相关变量</span></span><br><span class="line"><span class="comment"># data_folder为data下载并解压的地方</span></span><br><span class="line">data_folder = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'Works'</span>, <span class="string">'test'</span>, <span class="string">'caffe2'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>)</span><br><span class="line"><span class="comment"># root_folder为checkpoints文件和.pb模型定义文件存放的地方</span></span><br><span class="line">root_folder = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'Works'</span>, <span class="string">'test'</span>, <span class="string">'caffe2'</span>, <span class="string">'tutorial_files'</span>, <span class="string">'tutorial_cifar10'</span>)</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://pjreddie.com/media/files/cifar.tgz"</span>   <span class="comment"># url to data</span></span><br><span class="line">filename = url.split(<span class="string">"/"</span>)[<span class="number">-1</span>]                       <span class="comment"># download file name</span></span><br><span class="line">download_path = os.path.join(data_folder, filename) <span class="comment"># path to extract data to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(data_folder):</span><br><span class="line">    os.makedirs(data_folder)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果data不存在, 就下载并解压之</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(download_path.strip(<span class="string">'.tgz'</span>)):</span><br><span class="line">    <span class="comment"># Download data</span></span><br><span class="line">    r = requests.get(url, stream=<span class="keyword">True</span>)</span><br><span class="line">    print(<span class="string">"Downloading... &#123;&#125; to &#123;&#125;"</span>.format(url, download_path))</span><br><span class="line">    open(download_path, <span class="string">'wb'</span>).write(r.content)</span><br><span class="line">    print(<span class="string">"Finished downloading..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Unpack images from tgz file</span></span><br><span class="line">    print(<span class="string">'Extracting images from tarball...'</span>)</span><br><span class="line">    tar = tarfile.open(download_path, <span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> tar:</span><br><span class="line">        tar.extract(item, data_folder)</span><br><span class="line">    print(<span class="string">"Completed download and extraction!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Image directory already exists. Moving on..."</span>)</span><br></pre></td></tr></table></figure><p>接下来看一看数据集中的一些示例:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment"># Grab 5 image paths from training set to display</span></span><br><span class="line">sample_imgs = glob.glob(os.path.join(data_folder, <span class="string">"cifar"</span>, <span class="string">"train"</span>) + <span class="string">'/*.png'</span>)[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot images</span></span><br><span class="line">f, ax = plt.subplots(<span class="number">1</span>, <span class="number">5</span>, figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">plt.tight_layout()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    ax[i].set_title(sample_imgs[i].split(<span class="string">"_"</span>)[<span class="number">-1</span>].split(<span class="string">"."</span>)[<span class="number">0</span>])</span><br><span class="line">    ax[i].axis(<span class="string">'off'</span>)</span><br><span class="line">    ax[i].imshow(io.imread(sample_imgs[i]).astype(np.uint8))</span><br></pre></td></tr></table></figure></p><h1 id="创建label文件-写入LMDBs"><a href="#创建label文件-写入LMDBs" class="headerlink" title="创建label文件, 写入LMDBs"></a>创建label文件, 写入LMDBs</h1><p>现在我们已经拥有了数据, 接下来需要写入LMDBs用于训练, 验证和测试. 为了根据每个类别来分离图片, 下面将会使用到一个经常在caffe框架中使用的技术, 创建label files. 具体来说, label files就是将每个.png图片对应到它的类别上面去:<br>/path/to/im1.png 7<br>/path/to/im2.png 3<br>/path/to/im3.png 5<br>/path/to/im4.png 0<br>…</p><p>根据不同的数据集, 创建labels的方式有些许区别</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Paths to train and test directories</span></span><br><span class="line">training_dir_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'cifar'</span>, <span class="string">'train'</span>)</span><br><span class="line">testing_dir_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'cifar'</span>, <span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Paths to label files</span></span><br><span class="line">training_labels_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'training_dictionary.txt'</span>)</span><br><span class="line">validation_labels_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'validation_dictionary.txt'</span>)</span><br><span class="line">testing_labels_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'testing_dictionary.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Paths to LMDBs</span></span><br><span class="line">training_lmdb_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'training_lmdb'</span>)</span><br><span class="line">validation_lmdb_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'validation_lmdb'</span>)</span><br><span class="line">testing_lmdb_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'testing_lmdb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to labels.txt</span></span><br><span class="line">labels_path = os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'caffe2_notebooks'</span>, <span class="string">'tutorial_data'</span>, <span class="string">'cifar10'</span>, <span class="string">'cifar'</span>, <span class="string">'labels.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open label file handler</span></span><br><span class="line">labels_handler = open(labels_path, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create classes dictionary to map string labels to integer labels</span></span><br><span class="line">classes = &#123;&#125;</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">lines = labels_handler.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sorted(lines):</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    classes[line] = i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">labels_handler.close()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"classes:"</span>, classes)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出如下:</span></span><br><span class="line"><span class="comment"># classes: &#123;'automobile': 1, 'airplane': 0, 'truck': 9, 'ship': 8, 'dog': 5, 'horse': 7, 'cat': 3, 'frog': 6, 'deer': 4, 'bird': 2&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cpp-STL之unordered_map</title>
      <link href="/z_post/Cpp-STL%E4%B9%8Bunordered-map/"/>
      <url>/z_post/Cpp-STL%E4%B9%8Bunordered-map/</url>
      
        <content type="html"><![CDATA[<h1 id="与map的区别"><a href="#与map的区别" class="headerlink" title="与map的区别"></a>与<code>map</code>的区别</h1><p>在STL中, <code>map</code>对应的数据结构是红黑树, 红黑树是一种近似于平衡的二叉查找树, 里面的数据是有序的, 在红黑树上做查找的时间为 $O(lonN)$. 而<code>unordered_map</code>对应哈希表, 哈希表的特点就是查找效率高, 时间复杂度基本为 $O(1)$, 而额外空间复杂度较高.</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; hmap;</span><br><span class="line">    hmap.insert(<span class="built_in">std</span>::make_pair(<span class="number">1</span>, <span class="string">"Scala"</span>));</span><br><span class="line">    hmap.insert(&#123;<span class="number">3</span>, <span class="string">"three"</span>&#125;);</span><br><span class="line">    hmap.insert(&#123; &#123;<span class="number">4</span>, <span class="string">"Four"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"Five"</span>&#125;&#125;);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;hmap[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Detectron源码解读-utils/net.py 辅助函数</title>
      <link href="/z_post/Caffe2-Detectron-net%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"/>
      <url>/z_post/Caffe2-Detectron-net%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>这个文件经常会被使用到, 它主要的作用提供一些可以使 Caffe2 networks 更方便使用的辅助函数, 该文件解读如下(该文件中包含多个辅助函数, 按照函数在文件中的顺序从上到下逐个解读)</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>time-日期与时间</title>
      <link href="/z_post/Python-time/"/>
      <url>/z_post/Python-time/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中的日期和时间"><a href="#Python中的日期和时间" class="headerlink" title="Python中的日期和时间"></a>Python中的日期和时间</h1><p>Python程序能用很多方式处理日期和时间, 转换日期格式是一个常见的功能. Python提供了 time 和 calendar模块可以用来格式化日期和时间.  时间间隔是以秒为单位的浮点小数. 每个时间戳都以自1970年1月1日午夜(历元)经过了多长时间来表示.</p><p><code>time.time()</code>用于获取当前的时间戳, 单位为秒<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">ticks = time.time()</span><br><span class="line">print(ticks) <span class="comment"># 1540387897.1916292</span></span><br></pre></td></tr></table></figure></p><p>时间戳单位最适于做日期运算, 但是1970年之前的日期就无法以此表示了. 太遥远的日期也不行, UNIX和Windows只支持到2038年.</p><h1 id="时间元组"><a href="#时间元组" class="headerlink" title="时间元组"></a>时间元组</h1>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python模块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Caffe2-Detectron-日志工具类</title>
      <link href="/z_post/Caffe2-Detectron-%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/z_post/Caffe2-Detectron-%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Detectron源码解读-训练状态跟踪</title>
      <link href="/z_post/Caffe2-Detectron-%E8%AE%AD%E7%BB%83%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA/"/>
      <url>/z_post/Caffe2-Detectron-%E8%AE%AD%E7%BB%83%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="TrainingStats-类"><a href="#TrainingStats-类" class="headerlink" title="TrainingStats 类"></a>TrainingStats 类</h1><p>training_stats = TrainingStats(model)</p><p>在训练文件 <code>detectron/utils/train.py</code> 中创建(<code>create_model()</code>)并配置(<code>setup_model_for_training</code>)完模型以后, 调用了位于<code>detectron/utils/training_stats.py</code> 中<code>class TrainingStats()</code>类, 调用语句如下所示:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/utils/train.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    training_stats = TrainingStats(model)</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure></p><p>下面, 来看看这个类具体的内部实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/utils/training_stats.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该类用于跟踪关键的训练状态统计值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainingStats</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model)</span>:</span></span><br><span class="line">        <span class="comment"># TODO 这个window size是指什么? smoothing tracked values??</span></span><br><span class="line">        self.WIN_SZ = <span class="number">20</span></span><br><span class="line">        <span class="comment"># 输出logging的iterations间隔</span></span><br><span class="line">        self.LOG_PERIOD = <span class="number">20</span></span><br><span class="line">        self.smoothed_losses_and_metrics = &#123;</span><br><span class="line">            <span class="comment"># from detectron.utils.logging import SmoothedValue</span></span><br><span class="line">            <span class="comment"># 该类用于跟踪一系列值, 同时提供访问smoothed values的借口(基于WIN_SZ或者global series average).</span></span><br><span class="line">            key: SmoothedValue(self.WIN_SZ)</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> model.losses + model.metrics</span><br><span class="line">        &#125;</span><br><span class="line">        self.losses_and_metrics = &#123;</span><br><span class="line">            key: <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> model.losses + model.metrics</span><br><span class="line">        &#125;</span><br><span class="line">        self.smoothed_total_loss = SmoothedValue(self.WIN_SZ)</span><br><span class="line">        self.smoothed_mb_qsize = SmoothedValue(self.WIN_SZ)</span><br><span class="line">        self.iter_total_loss = np.nan</span><br><span class="line">        self.iter_timer = Timer() <span class="comment"># from detectron.utils.timer import Timer</span></span><br><span class="line">        self.model = model</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p><h1 id="SmoothedValue-类"><a href="#SmoothedValue-类" class="headerlink" title="SmoothedValue 类"></a>SmoothedValue 类</h1><p>从上面的代码可以看到, <code>TrainingStats</code> 类中的成员大多为<code>SmoothedValue</code>类对象, 该类的定义位于<code>detectron/utils/logging.py</code> 中, 下面先来看看这个文件的内部实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/utils/logging.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_json_stats</span><span class="params">(stats, sort_keys=True)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmoothedValue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 该类用于跟踪一系列值, 同时提供访问滑动值smoothed values的借口(基于WIN_SZ或者global series average).</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, window_size)</span>:</span></span><br><span class="line">        <span class="comment"># from collections import deque</span></span><br><span class="line">        self.deque = deque(maxlen = window_size)</span><br><span class="line">        self.series = []</span><br><span class="line">        self.total = <span class="number">0.0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AddValue</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 将指定的值value加入到对象中的各个成员变量中</span></span><br><span class="line">        self.deque.append(value)</span><br><span class="line">        self.series.append(value)</span><br><span class="line">        self.total += value</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedianValue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.median(self.deque) <span class="comment"># axis为None , 则按照一维数组来计算deque中的中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetAverageValue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.mean(self.deque) <span class="comment"># 同理, 返回deque的平均值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetGlobalAverageValue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.total / self.count <span class="comment"># 返回所有值的平均值, 而不仅仅只是窗口内的平均值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p><p>从上面的代码我们可以看出, 实际上<code>SmoothedValue</code> 类是用来维护滑动平均值的, 同时还会维护一个滑动中位数和总平均值.</p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer()"></a>Timer()</h1><p>接着, 在初始化函数中, <code>class TrainingStats</code>类的成员变量 <code>self.iter_timer</code>是<code>class Timer</code>的类对象, 该类位于<code>detectron/utils/timer.py</code>文件中, 主要封装了python的time模块, 下面具体看一下实现细节<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">detectron/utils/timer.py</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.reset() <span class="comment"># 调用类自身的reset()函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tic</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里使用了time.time 而不是 time.clock, 原因是因为time.clock对于多线程任务来说可能存在一些问题</span></span><br><span class="line">        self.start_time = time.time() <span class="comment"># 成员变量 start_time</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toc</span><span class="params">(self, average=True)</span>:</span></span><br><span class="line">        self.diff = time.time() - self.start_time <span class="comment"># diff的值为当前时间与开始时间之间的间隔(单位为秒)</span></span><br><span class="line">        self.total_time += self.diff <span class="comment"># 每调用一次toc函数, totaltime都会统计一次时间间隔</span></span><br><span class="line">        self.calls += <span class="number">1</span> <span class="comment"># 记录调用toc的次数</span></span><br><span class="line">        self.average_time = self.total_time / self.calls</span><br><span class="line">        <span class="keyword">if</span> average:</span><br><span class="line">            <span class="keyword">return</span> self.average_time</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.diff</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span> <span class="comment"># 将Timer内统计时间全部归0., 注意是浮点类型</span></span><br><span class="line">        self.total_time = <span class="number">0.</span></span><br><span class="line">        self.calls = <span class="number">0.</span></span><br><span class="line">        self.start_time = <span class="number">0.</span></span><br><span class="line">        self.diff = <span class="number">0.</span></span><br><span class="line">        self.average_time = <span class="number">0.</span></span><br></pre></td></tr></table></figure></p><h1 id="再看-TrainingStats-类"><a href="#再看-TrainingStats-类" class="headerlink" title="再看 TrainingStats 类"></a>再看 TrainingStats 类</h1><p>接下来, 我们继续看 TrainingStats 类中的其他方法:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/utils/timer.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainingStats</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IterTic</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.iter_timer.tic() <span class="comment"># 调用Timer类的tic方法, 记录当前time.time()时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IterTic</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.iter_timer.toc(average=<span class="keyword">False</span>) <span class="comment"># 返回距离上次掉要tic方法的时间间隔(单位为秒)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ResetIterTimer</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.iter_timer.reset() <span class="comment"># 重置所有时间相关的统计数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">UpdateIterStats</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 更新跟踪的迭代统计信息</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.losses_and_metrics.keys():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> self.model.losses:</span><br><span class="line">                <span class="comment"># import detectron.utils.net as nu</span></span><br><span class="line">                self.losses_and_metrics[k] = nu.sum_multi_gpu_blob(k) <span class="comment"># 计算多个gpu上的数据和</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.losses_and_metrics[k] = nu.average_multi_gpu_blob(k)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.smoothed_losses_and_metrics.items():</span><br><span class="line">            v.AddValue(self.losses_and_metrics[k])</span><br><span class="line">        self.iter_total_loss = np.sum(</span><br><span class="line">            np.array([self.losses_and_metrics[k] <span class="keyword">for</span> k <span class="keyword">in</span> self.model.losses])</span><br><span class="line">        )</span><br><span class="line">        self.smoothed_total_loss.AddValue(self.iter_total_loss)</span><br><span class="line">        self.smoothed_mb_qsize.AddValue(</span><br><span class="line">            self.model.roi_data_loader._minibatch_queue.qsize()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LogIterStats</span><span class="params">(self, cur_iter, lr)</span>:</span></span><br><span class="line">        <span class="comment"># 记录跟踪的统计信息</span></span><br><span class="line">        <span class="keyword">if</span>(cur_iter % self.LOG_PERIOD == <span class="number">0</span> <span class="keyword">or</span></span><br><span class="line">            cur_iter == cfg.SOLVER.MAX_ITER - <span class="number">1</span>):</span><br><span class="line">            stats = self.GetStats(cur_iter, lr)</span><br><span class="line">            log_json_stats(stats)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetStats</span><span class="params">(self, cur_iter, lr)</span>:</span></span><br><span class="line">        eta_seconds = self.iter_timer.average_time * (</span><br><span class="line">            cfg.SOLVER.MAX_ITER - cur_iter</span><br><span class="line">        ) <span class="comment"># 剩余时间</span></span><br><span class="line">        eta = str(datetime.timedelta(seconds=int(eta_seconds)))</span><br><span class="line">        mem_stats = c2_py_utils.GetGPUMemoryUsageStats()</span><br><span class="line">        mem_usage = np.max(mem_stats[<span class="string">'max_by_gpu'</span>][:cfg.NUM_GPUS])</span><br><span class="line">        stats = dict(</span><br><span class="line">            iter=cur_iter,</span><br><span class="line">            lr=float(lr),</span><br><span class="line">            time=self.iter_timer.average_time,</span><br><span class="line">            loss=self.smoothed_total_loss.GetMedianValue(),</span><br><span class="line">            eta=eta,</span><br><span class="line">            mb_qsize=int(</span><br><span class="line">                np.round(self.smoothed_mb_qsize.GetMedianValue()),</span><br><span class="line">            ),</span><br><span class="line">            mem=int(np.ceil(mem_usage / <span class="number">1024</span> / <span class="number">1024</span>)) <span class="comment"># 将字节转换成GB</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.smoothed_losses_and_metrics.items():</span><br><span class="line">            stats[k] = v.GetMedianValue()</span><br><span class="line">        <span class="keyword">return</span> stats</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Group Normalization</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ECCV2018-GroupNormalization/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ECCV2018-GroupNormalization/</url>
      
        <content type="html"><![CDATA[<p><strong>作者:</strong> Yuxin Wu and Kaiming He<br><strong>发表:</strong> ECCV 2018, Best Paper Honorable Mention</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>针对BN对batch size的依赖问题, 提出了一种新的通用型归一化方法</strong><br>提出了一个用于替代BN的简单算法, 称之为GN(Group Normalization). GN将输入图谱的通道分成不同的组, 并且计算每一组的mean和variance, 然后将其进行归一化. GN的计算复杂度与batch size 的大小是相互独立的, 并且它的准确度在不同范围内的batch size下仍然是稳定的. 并且在整体表现和不同任务上的效果均强于其他类型的归一化方法(LN,IN等)</p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fww0h6ugadj20s80kjacr.jpg" alt=""></p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>BN是深度学习中的一项里程碑式的技术, 它可以让不同网络进行训练. 但是按照batch进行归一化的过程会引入一些问题: 当batch的size比较小时, 由于batch的统计期望十分不精确, 会使得BN的误差大幅度增加. 这一点限制了BN在训练大型模型时的使用(如目标检测, 分割等等, 由于GPU内存的限制往往batch的值很小). 因此, 本文提出了一个用于替代BN的简单算法, 称之为GN(Group Normalization). GN将输入图谱的通道分成不同的组, 并且计算每一组的mean和variance, 然后将其进行归一化. GN的计算复杂度与batch size 的大小是相互独立的, 并且它的准确度在不同范围内的batch size下仍然是稳定的. 在ResNet50中, 当batch size为2时,  GN的错误率比BN要低10.6%, 当batch size为经典值时(32,64等), GN的表现也可以媲美BN, 同时, 也超越了其他归一化方法(Layer, Instance, Weight Normalization等). 不仅如此, GN还可以很自然的从预训练的模型中进行fine-tuning. GN在多个任务上都表现出了很好的效果, 可以用其替换掉BN. (只需数行代码即可实现GN).</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>BN在多项任务中都起到了很好的实验效果, 但是BN的有效性必须建立在足够大的batch size之上(如32/GPU). 当batch size 比较小时, BN往往无法取得好的效果, 并且还会提升模型的误差, 如图1所示.</p><p>由于硬件GPU显存大小的设置, 在使用较大的模型训练分辨率较高的图片时, 往往不能设置很高的batch size. 因此, 本文提出了GN算法来作为BN的代替.</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p><strong>Normalization</strong>: BN在很多任务上都取得了很好的效果(BN通常会在每一层都执行), 但是, BN依赖于batch的平均值和方差, 这使得batch size的大小对BN的效果有较大的影响, 同时, 在测试阶段, 单个的图片是没有均值和方差的, 所以只能用整个数据集的均值和方差来代替, 通常会使用滑动平均来维护这两个变量, 也就是说, 在使用BN时, 如果数据集改变了, 则均值和方差就会有较大改变, 这就造成了训练阶段和测试阶段的不一致性, 由此也会带来一些问题.<br>另一些Normalization方法, 尝试避开batch size, 如Layer Normalization(LN)和Instance Normalization等, 但他们通常是针对RNN/LSTM模型的, 并且在大多数的视觉任务上表现不如BN好, 还有Weight Normalization, 它不是对网络层的输入进行归一化, 而是对网络层的参数进行归一化, 同样, 在大多数的视觉任务上, 表现都不如BN.</p><p><strong>Addressing small batches:</strong> Ioffe在NIPS2017上提出Batch Renormalization(BR)尝试解决BN的小batch size问题. 它引入了两个额外的参数来限制BN的估计期望和方差, 减少它们在小batch size时的不稳定问题. 但是BR本质上还是依赖于batch的, 当batch较小时, 其性能也会相应下降(不过下降较少).<br>也有的工作尝试避免使用小batch size. CVPR2018的一篇文章通过同步BN的方法, 使得模型可以在多GPU上计算平均值和方差, 但是, 这个方法并没有才本质上解决BN的问题, 相反的, 它的方法更像是一种工程和硬件上的解决方案, 希望以此来达到BN的要求. 不仅如此, 这种同步BN方案也使得模型在工业中的大规模分布式训练下无法利用异步的优化方法, 如ASGD.</p><p><strong>Group-wise computation:</strong> Group convolution计算在多个模型中都有提及. 但是本文的GP并不需要组卷积计算, 它是一个一般化的网络层(generic layer).</p><h2 id="Group-Normalization"><a href="#Group-Normalization" class="headerlink" title="Group Normalization"></a>Group Normalization</h2><p>特征图谱中的各个channels之前也并不是完全互相独立的.</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>典型的归一化公式形式(BN,LN,IN,GN)为:</p><script type="math/tex; mode=display">\hat x_i = \frac{x_i - \mu_i}{\sigma_i}</script><p>上式中, $x$ 代表某一层的特征, $i$ 代表下标, 在2D图像中, $i=(i_N, i_C, i_H, i_W)$ , 是一个4D的向量. $\mu$ 和 $\sigma$ 分别为期望和标准差, 通过下式计算得到:</p><script type="math/tex; mode=display">\mu_i = \frac{\sum_{k\in S_i} x_k}{m}, \sigma_i = \sqrt{\frac{sum_{k\in S_i} (x_k-\mu_i)^2}{m} + \epsilon}</script><p>大多数的Normalization方法的不同之处就在于集合 $S_i$ 的不同(如图2所示):</p><ul><li>BN: $S_i = \{k | k_C = i_C \}$, 代表BN是在求每一个channel的均值和方差. 也即 $C$ 不变, 求固定 $C$ 时 $(N,H,W)$ 的均值和方差</li><li>LN: $S_i = \{k | k_N = i_N \}$, 代表 $N$ 不变, 求固定 $N$ 以后 $(C,H,W)$ 的均值和方差(可以看出, 此时的均值和方差已经不受batch size的影响)</li><li>IN: $S_i = \{k | k_N = i_N, k_C = i_C\}$, 代表 $N$ 和 $C$ 都固定时 , $(H,W)$ 的均值和方差. 也就是说是对单个特征中, 单个通道上的均值和方差.</li></ul><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fww4hqied3j21kw0esjwt.jpg" alt=""></p><p>上面所有的Normalization方法(BN,LN,IN)都使用了线性偏移来补偿可能引起的数据分布表征丢失问题:</p><script type="math/tex; mode=display">y_i = \gamma x_i + \beta</script><p><strong>Group Norm:</strong> 在Group Norm中, $\mu$, $\sigma$ 以及集合 $S_i$ 的定义如下:</p><script type="math/tex; mode=display">S_i = \{ k | k_N = i_N, \lfloor \frac{k_C}{C/G} \rfloor = \lfloor \frac{i_C}{C/G} \rfloor \}</script><p>上式中, $G$ 是group的数量, 是一个超参数(默认为32), $C/G$ 是每一个group中的channels的数量, $\lfloor \frac{k_C}{C/G} \rfloor = \lfloor \frac{i_C}{C/G} \rfloor \}$ 意味着下标 $i$ 和 $k$ 在同一个group内. GN计算的 $\mu$ 和 $\sigma$ 是处于同一个group的所有通道上的 $(H,W)$ 的均值和方差, 具体的计算方式如图2最右侧所示, 在该图实例中, G=2, 并且每一个group具有3个channels. GN同样会在每一个channel中使用参数 $\gamma$ 和 $\beta$ 对数据执行线性偏移.(注意是每一个通道, 而不是group, 也就是同一个group中的不同通道下的 $\gamma$ 和 $\beta$ 参数是不一样的!)</p><p><strong>Relation to Prior Work:</strong>  很明显, LN和IN实际上可以看做是GN的一种特例情况(如图2). 当 $G=1$ 时, GN就变成LN, 当 $G=C$ 时, GP就变成了IN.</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>就和GN的思想一样, GN实现起来也十分简单, 下图是GN基于python和tensorflow的实现代码, 从代码中可以看到, $\gamma$ 和 $\beta$ 的shape为 [1,C,1,1], 也就是说, $\gamma$ 和 $\beta$ 在同一个group中的不同channel来说, 值是不一样的.</p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwwerxxn0kj20s70haad2.jpg" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwwes3nh5zj21kw0j5dyd.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwwes7p05wj21kw0huwuz.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwwesbnq0mj20s809qmyz.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwwesfiq43j20sd0cajtw.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwwesjygdnj21kw0gpat8.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwwesnf0lvj20t20j6tcb.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwwesrox6zj20sl0jwtdr.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwwesvxyoej20sv0jkwyp.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwwet23060j21kw0nwag1.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwwet5sufej20sa0f5aoe.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwwet9mkjbj20s209s762.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>R-FCN-NIPS2016</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-NIPS2016-R-FCN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-NIPS2016-R-FCN/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> R-FCN: Object Detection via Region-based Fully Convolutional Networks</p><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><ul><li>全卷积网络怎分类任务上表现较好, 但是在目标检测任务往往精度不行, 这是因为在一般情况下, 分类任务具有平移不变性, 而检测任务却要求对目标的平移做出正确响应. 在Faster RCNN类的方法中RoI pooling之前都是卷积, 具有平移不变性, 但是一旦经过RoI pooling 之后, 后面的网络结果就不再具备平移不变性了. 因此, 本文了position sensitive score map来将目标位置的信息融合进RoI</li><li>对于Faster RCNN等基于感兴趣区域的检测方法来说, 实际上是分成了几个subnetwork, 第一个用来在整张图上做比较耗时的conv, 这些操作与region无关, 是计算共享的. 第二个subnetwork是用来产生候选区域(如RPN), 第三个subnetwork是用来分类或者进一步对box进行回归的, 这个subnetwork和region是有关系的, 衔接在这个subnetwork和前两个subnework中间的就是RoI pooling. 本文与FasterRCNN相比(前91层共享, RoI pooling之后, 后10层不共享)不同, 将ResNet所有的101层都放在的前面共享的subnetwork中, 最后用来进行prediction的卷积只有1层, 大大减少了计算量.</li><li>最终, 从实验结果来看, 本文提出的用于目标检测任务的全卷积网络在精度上仍然不如标准的Faster RCNN, 但是在test time上要好于FasterRCNN (因为有大部分层都变成参数共享的了). </li></ul><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文提出了一个用于精确高效进行物体检测的基于区域的全卷积网络. 在Fast/Faster RCNN中, 使用了计算成本很大的子网络来提取候选区域, 与之相比, 本文的基于区域的检测器是全卷积的, 因此几乎所有的计算都可以共享. 为了达到这个目标, 本文提出了一个位置敏感的score maps来解决图像分类问题中的平移不变性和物体检测中的平移可变性之间的鸿沟. 因此, 本文的方法可以很自然的使用全卷积图像分类网络, 比如ResNet. 本文的方法在检测阶段的速度大约为FasterRCNN的2.5~20倍.</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近的图像分类网络如ResNet何GoogleNets都是通过全卷积网络设计的.(只有最后一层是全连接的, 并且该层会在进行目标检测任务时被去掉).</p><p>我们讨论了之前提到的不自然的设计是由于图像分类的平移不变性和目标检测的平移可变性之间的鸿沟造成的. 一方面, 在图像级别上的分类任务倾向于平移不变性, 因此, 深度卷积网络的结构会尽可能是使得结果的检测具有一定的平移不变性. 另一方面, 物体检测任务需要坐标表示, 这是一种平移可变性的表现. 为了解决这个问题, ResNet的检测方法是插入了一个RoI pooling 层—-该层可以用来打破神经网络原有的平移不变性, RoI后续的卷积层在对不同区域进行评价时, 实际上已经不再具有平移不变性(出现在天空位置时, 行人的预测概率较低).  但是, 这种RoI的设计模型牺牲了训练和测试的高效性, 因为它引入了大量额外的快计算.</p><p>在这篇文章中, 我们构建了一个用于物体检测任务的基于区域的全卷积网络的框架模型. 我们的网络模型由共享的全卷积网络组成. 为了与FCN的平移可变性相协调, 我们构建了一个位置敏感型的score maps. 每一个score maps都根据相对空间位置将位置信息进行了编码. 在FCN之上, 我们添加了一个位置敏感的RoI pooling layer 用于指导从score maps中获取的信息, 并且在其后没有再使用带权重的层(全连接or全卷积).</p><h2 id="Our-approach"><a href="#Our-approach" class="headerlink" title="Our approach"></a>Our approach</h2><p><strong>Overview:</strong> 和RCNN一样, 本文使用了 two-stage 的物体检测策略, 包括:1) 区域推荐, 2)区域分类. 本文通过RPN网络来提取候选框(RPN网络本身也是一个全卷积网络). 和Faster RCNN一样, 我们令RPN和R-FCN网络的权重参数共享. 下面的图2显示了这个系统的整体视图 (位于上方的RPN网络和位于下方的R-FCN网络使用的卷积图谱都是来自同一段卷积网络, 因此参数共享):</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwlogvettvj21ae0llapa.jpg" alt=""></p><p>当给定感兴趣区域(proposals regions)后, R-FCN网络会用于对RoIs分类. 在R-FCN中, 所有的可学习的参数都是卷及参数, 并且都是在同一张图片上计算得到的. 最后一层卷积层对于每一类都会输出 $k^2$ 个位置敏感的socre maps, 因此总共有对于具有 $C$ 个物体类别来说, 输出层具有 $k^2(C+1)$ 个通道. $k^2$ 主要是根据用于描述相关位置的 $k\times k$ 的空间网格来决定. 比如, 当 $k \times k = 3\times 3$ 时, 对于每一个物体类别都会有9个score maps 根据下列情况进行编码: {top-left, top-center, top-right, … , bottom-right}.</p><p>R-FCN最后会有一个位置敏感的RoI pooling层, 这一层会将最后一层卷积层的输出全部整合, 并为每个RoI生成对应的score. 和之前的工作不同, 本文的位置敏感型的RoI层会执行selective pooling, 并且每一个$k\times k$ bin 都会整个仅一个score map. 下面的图展示了示例:</p><p><img src="https://wx1.sinaimg.cn/large/d7b90c85ly1fwlpc7oinsj215c0lbtq5.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwlpckwfuej215a0k3nej.jpg" alt=""></p><p><strong>Backbone architecture:</strong> R-FCN的网络主体是基于ResNet-101的, 我们将平均池化层和fc层移除, 只使用前面的卷积网络来计算特征图谱. 由于卷积段输出的维度为2048, 因此我们使用 $1\tims 1$ 的卷积层来进行降维, 使其维度变成1024.  然后我们使用通道数为 $k^2(C+1)$ 的卷积层来生成score maps.</p><p><strong>Position-sensitive score maps &amp; Position-sentitive RoI pooling.</strong> 为了具体的对每个RoI的位置信息进行编码, 我们将每一个RoI划分成 $k\times k$ 大小的普通网格, 然后, 最后一层卷积层对每一个类别都会生成 $k^2$ score maps, 在第 $(i,j)$ 个bin中 $(0 \leq i,j \leq k-1)$. 我们定义位置敏感的RoI pooling计算操作如下所示:</p><script type="math/tex; mode=display">r_c(i,j | \theta) = \sum_{(x,y)\in bin(i,j)} z_{i,j,c}(x+x_0, y+y_0 | \theta)/n</script>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Improving Object Detection With One Line of Code</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-SoftNMS/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-SoftNMS/</url>
      
        <content type="html"><![CDATA[<p><strong>作者:</strong> Navaneeth Bodla, Bharat Singh, Rama Chellappa, Larry S.Davis<br><strong>发表:</strong> ICCV2017<br><strong>机构:</strong> Center For Automation Research</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>提出了一种NMS的变体, 通过利用该变体, 基本上可以提升任何模型的检测准确率</strong><br>作者们提出了一种新式的NMS算法, 并且利用该算法, 可以普遍提高当前现有模型的召回率(尤其是面对重叠程度大的物体), 同时, 由于可以不增加复杂度的情况下直接用该算法替换传统NMS算法,  因此, 在替换SoftNMS时, 无需更改模型的任何参数, 也无需重新训练模型, 就可以达到提升召回率的作用. (对mAP的提升大约为1%左右)</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwskrv3tdtj20rt0p61kx.jpg" alt=""></p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><p><strong>传统NMS:</strong> 先将score倒序排列, 然后取socres值最大的box并将其置于final box列表中, 计算所有剩余box与该box的重叠度, 大于某一阈值的就将其删除, 然后迭代的使用此方法, 直到final box数量达到要求或者没有多的box了.(在FasterRCNN中, 生成候选框时会使用一次NMS, 预测还会分别对每一个类别都使用一次NMS)</p><p><strong>传统NMS存在的问题:</strong> 由上面的描述可知, 如果两个物体本身的重叠度过大, 那么其中一个物体的框就会被删除(score被置为0), 从而导致漏解.</p><p><strong>Soft-NMS:</strong> 在将具有最大score的box置于final box之后, 计算所有剩余box与该box的重叠度, 对于那些重叠度大于一定阈值的box, 我们并不将其删除, 而仅仅只是根据重叠程度来降低那些box的socre, 这样一来, 这些box仍旧处于box列表中, 至少socre的值变低了. 具体来说, 如果box的重叠程度高, 那么score的值就会变得很低, 如果重叠程度小, 那么box的score值就只会降低一点, Soft-NMS算法伪代码如下图所示:</p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwslfycxmyj20sc112dlw.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwsmozvvpsj20oh0omkb4.jpg" alt=""></p><p>设 $s_i$ 为第 $i$ 个box的score, 则在应用SoftNMS时各个box score 的计算公式如下:</p><script type="math/tex; mode=display">s_i = \begin{cases} s_i, & iou(M, b_i) < N_t \\ s_i(1-iou(M, b_i)), & iou(M, b_i) \geq N_t \end{cases}</script><p>上式过于简单直接, 为了函数的连续性, 文章改用了高斯惩罚系数:</p><script type="math/tex; mode=display">s_i = \begin{cases} s_i, & iou(M, b_i) < N_t \\ s_i e^{\frac{iou(M, b_i)^2}{\sigma}} , & iou(M, b_i) \geq N_t \end{cases}</script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NMS相关算法Python实现</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-NMS-Implementation/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-NMS-Implementation/</url>
      
        <content type="html"><![CDATA[<p>【链接】非极大值抑制算法(NMS)及python实现<br><a href="https://blog.csdn.net/Blateyang/article/details/79113030" target="_blank" rel="noopener">https://blog.csdn.net/Blateyang/article/details/79113030</a></p><p>【链接】NMS-非极大值抑制-Python实现<br><a href="https://blog.csdn.net/u011436429/article/details/80107042" target="_blank" rel="noopener">https://blog.csdn.net/u011436429/article/details/80107042</a></p><h1 id="NMS-概念"><a href="#NMS-概念" class="headerlink" title="NMS 概念"></a>NMS 概念</h1><p>非极大值抑制(Non-Maximum Suppression, NMS), 顾名思义就是抑制那些不是极大值的元素, 可以理解为局部最大值搜索. 这个局部代表的是一个领域, 领域有两个参数可变, 一是领域的维数, 而是领域的大小. 对于目标检测来说, 非极大值抑制主要用于提取局部区域内分数最高的窗口.</p><p>算法实现:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nms</span><span class="params">(boxes, scores, overlap=<span class="number">0.5</span>, top_k=<span class="number">200</span>)</span>:</span></span><br><span class="line">    <span class="comment"># boxes: Shape: [num_boxes, 4]</span></span><br><span class="line">    <span class="comment"># scores: Shape: [num_boxes]</span></span><br><span class="line"></span><br><span class="line">    keep = scores.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    img_path = <span class="string">"./nms_test.jpg"</span></span><br><span class="line"></span><br><span class="line">    bounding_boxes = [(<span class="number">187</span>, <span class="number">82</span>, <span class="number">337</span>, <span class="number">317</span>), (<span class="number">150</span>, <span class="number">67</span>, <span class="number">305</span>, <span class="number">282</span>), (<span class="number">246</span>, <span class="number">121</span>, <span class="number">368</span>, <span class="number">304</span>)]</span><br><span class="line">    scores = [<span class="number">0.9</span>, <span class="number">0.75</span>, <span class="number">0.8</span>]</span><br><span class="line"></span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line">    ori_img = img.copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Draw Parameters</span></span><br><span class="line">    font = cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">    font_scale = <span class="number">1</span></span><br><span class="line">    thickness = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    nms_threshold = <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (start_x, start_y, end_x, end_y), confidence <span class="keyword">in</span> zip(bounding</span><br><span class="line">    _boxes, scores):</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>计算机视觉-目标检测训练策略</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%AE%AD%E7%BB%83%E7%AD%96%E7%95%A5/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%AE%AD%E7%BB%83%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="NMS"><a href="#NMS" class="headerlink" title="NMS"></a>NMS</h1><h1 id="Multi-Scale"><a href="#Multi-Scale" class="headerlink" title="Multi-Scale"></a>Multi-Scale</h1><p>Training</p><p>Testing</p><p>哪些论文使用了?  大约提升多少</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Detectron源码解读-模型创建</title>
      <link href="/z_post/Caffe2-Detectron-%E6%A8%A1%E5%9E%8B%E5%88%9B%E5%BB%BA/"/>
      <url>/z_post/Caffe2-Detectron-%E6%A8%A1%E5%9E%8B%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="model-builder-create-方法"><a href="#model-builder-create-方法" class="headerlink" title="model_builder.create(...) 方法"></a><code>model_builder.create(...)</code> 方法</h1><p>在调用<code>detectron/utils/train.py</code>文件中的<code>train_model()</code>方法时,在第一行代码中调用了同属该文件的<code>create_model()</code>方法, 而在该方法中, 核心的创建语句为<code>model = model_builder.create(cfg.MODEL.TYPE, train=True)</code>, 其中, <code>model_builder.create(...)</code> 是位于文件 <code>detectron/modeling/model_builder.py</code>中<code>create(...)</code>方法, 该方法的详细实现如下所示:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/modeling/model_builder.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generalized_rcnn</span><span class="params">(model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rfcn</span><span class="params">(model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retinanet</span><span class="params">(model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(model_type_func, train=False, gpu_id = <span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 通用的模型创建函数, 该函数可以继续分派到特定的模型创建函数中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认情况下, 该函数将以并行模式(并行数量取决于cfg.NUM_GPUS)生成数据</span></span><br><span class="line">    <span class="comment"># 但是, 你可以将其限制在特定的GPU上进行(通过gpu_id), 在测试阶段使用optimizer.build_data_parallel_model()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># from detectron.modeling.detector import DetectionModelHelper</span></span><br><span class="line">    model = DetectionModelHelper(</span><br><span class="line">        name=model_type_func, <span class="comment"># 对于示例: model_type_func=generalized_rcnn</span></span><br><span class="line">        train=train,</span><br><span class="line">        num_classes=cfg.MODEL.NUM_CLASSES,</span><br><span class="line">        init_params=train</span><br><span class="line">    )</span><br><span class="line">    model.only_build_forward_pass = Fasle</span><br><span class="line">    model.target_gpu_id = gpu_id</span><br><span class="line">    <span class="keyword">return</span> get_func(model_type_func)(model) <span class="comment"># get_func(...)函数解析就在下面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_func</span><span class="params">(func_name)</span>:</span></span><br><span class="line">    <span class="comment"># 该函数会通过name返回一个函数对象,</span></span><br><span class="line">    <span class="comment"># func_name必须等于该module中的函数, 或者是与base 'modeling'相关的函数的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于示例: func_name = cfg.MODEL.TYPE = generalized_rcnn</span></span><br><span class="line">    <span class="keyword">if</span> func_name == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># import detectron.modeling.name_compat as name_compat</span></span><br><span class="line">    <span class="comment"># 貌似是因为名字做过改动, 这句话是为了兼容性而存在的</span></span><br><span class="line">    new_func_name = name_compat.get_new_name(func_name)</span><br><span class="line">    <span class="keyword">if</span> new_func_name != func_name:</span><br><span class="line">    <span class="comment"># 对于本例: new_func_name = func_name, 名字不变</span></span><br><span class="line">        logger.warn(</span><br><span class="line">            <span class="string">'Remapping old function name:&#123;&#125; -&gt; &#123;&#125;'</span>.</span><br><span class="line">            format(func_name, new_func_name)</span><br><span class="line">        )</span><br><span class="line">        func_name = new_func_name</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        parts = func_name.split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(parts) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> globals()[parts[<span class="number">0</span>]]</span><br><span class="line">        module_name = <span class="string">'detectron.modeling.'</span> + <span class="string">'.'</span>.join(parts[:<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 会根据module导入位于'detectrong/modeling'中的module</span></span><br><span class="line">        <span class="comment"># fast_rcnn_heads, FPN, mask_rcnn_heads 等等</span></span><br><span class="line">        module = importlib.import_module(module_name)</span><br><span class="line">        <span class="keyword">return</span> getattr(module, parts[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        logger.error(<span class="string">'Failed to find function: &#123;&#125;'</span>.format(func_name))</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure><h1 id="DetectionModelHelper-类"><a href="#DetectionModelHelper-类" class="headerlink" title="DetectionModelHelper 类"></a>DetectionModelHelper 类</h1><p>从上面的代码中可以看出 <code>create()</code> 函数中最主要的部分是使用了 <code>detectron/modeling/detector.py</code>文件中的 <code>class DetectionModelHelper()</code>类, 下面, 我们就对该类进行解析:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/modeling/detector.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from caffe2.python import cnn</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectionModelHelper</span><span class="params">(cnn.CNNModelHelper)</span>:</span></span><br><span class="line"><span class="comment"># 该类实际上是cnn.CNNModelHelper的一个子类, 这一点很重要</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 处理属于DetectionModelHelper的特定的参数, 其他的都会传到CNNModelHelper当中</span></span><br><span class="line">        self.train = kwargs.get(<span class="string">'train'</span>, <span class="keyword">False</span>) <span class="comment"># train</span></span><br><span class="line">        self.num_classes = kwargs.get(<span class="string">'num_classes'</span>, <span class="number">-1</span>) <span class="comment"># cfg.MODEL.NUM_CLASSES</span></span><br><span class="line">        <span class="keyword">assert</span> self.num_classes &gt; <span class="number">0</span>, <span class="string">'num_classes must be &gt; 0'</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> (<span class="string">'train'</span>, <span class="string">'num_classes'</span>):</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> kwargs:</span><br><span class="line">                <span class="keyword">del</span> kwargs[k]<span class="comment"># TODO 貌似是因为下面要再次调用构造函数的原因?</span></span><br><span class="line">        <span class="comment"># 设置数据的排列顺序: batchsize, channels, heiht, width</span></span><br><span class="line">        kwargs[<span class="string">'order'</span>] = <span class="string">'NCHW'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># TODO, 不懂这个选项的实际作用</span></span><br><span class="line">        kwargs[<span class="string">'cudnn_exhaustive_search'</span>] = <span class="keyword">False</span></span><br><span class="line">        super(DetectionModelHelper, self).__init__(**kwargs) <span class="comment"># TODO ?? 这样不会造成递归调用吗? 为什么要递归调用构造函数</span></span><br><span class="line">        self.roi_data_loader = <span class="keyword">None</span></span><br><span class="line">        self.losses = []</span><br><span class="line">        self.metrics = []</span><br><span class="line">        self.do_not_update_params = [] <span class="comment"># 位于该列表中的参数不会被更新</span></span><br><span class="line">        self.net.Proto().type = cfg.MODEL.EXECUTION_TYPE</span><br><span class="line">        self.net.Proto().num_workers = cfg.NUM_GPUS * <span class="number">4</span></span><br><span class="line">        self.prev_use_cudnn = self.use_cudnn</span><br><span class="line">        self.gn_params = [] <span class="comment"># 位于该列表中的元素是GroupNorm参数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OHEM-CVPR2016</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2016-OHEM/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2016-OHEM/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> Training Region-based Object Detectors with Online Hard Example Mining<br><strong>作者:</strong> Abhinav Shrivastava, Abhinav Gupta, Ross Girshick</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>提出了一种在线的难样例挖掘算法:</strong><br>作者根据每个RoIs的loss的大小来决定哪些是难样例, 哪些试试简单样例, 通过这种方法, 可以更高效的训练网络, 并且可以使得网络获得更小的训练loss. 同时, OHEM还具有以下两个优点:</p><ul><li><strong>消除FastRCNN系列模型中的一些不必要这参数</strong> , 这些参数大多都是为了解决难样例问题服务的, 在使用OHEM以后, 不仅无需在对这些超参数进行调优, 同时还能获得更好的性能表现.</li><li><strong>OHEM算法可以与其他多种提升模型精度的trick相结合</strong>, 对于大多数模型(RCNN系列), 在使用了OHEM以后, 都能够获得精度上的提高, 可以看做是一种普适性的提升精度的方法.</li></ul><p>注: 在实现OHEM上, 作者为了提升速度和效率, 特意设计了两个RoI网络, 以减少无用的计算.</p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>目前, 基于区域选择的CNN目标检测方法已经取得了很大的成功, 但是他们的训练过程仍然包含着许多启发法[注]和超参数(调优过程成本很高). 本文提出了一种针对区域选择目标检测方法的一种十分简单但非常有效的 <strong>在线的难样例挖掘(OHEM)算法</strong>. 我们的动机来源于数据集中存在的海量的简单样本, 而只有一小部分困难样本. 如果能够自动的选择这些困难样本用于训练, 那么就会使得训练过程更加高效和有效. OHEM 是一种简单且直观的算法, 它可以消除多个启发过程和超参数. 更重要的是, 它可以稳定的提升检测模型的算法性能, 当数据集越来越大, 越来越复杂时, 它的提升效果就越大.</p><p>[注] 启发法: 启发式方法(试探法)是一种帮你寻找答案的技术, 但它给出的答案是具有偶然性的(subject to chance), 因为启发式方法仅仅告诉你该如何去找, 而没有告诉你要找什么, 它并不会告诉你该如何直接从A点到B点, 他甚至可能连A点和B点在哪里都不知道. 启发式算法的难点是建立符合实际问题的一些列启发式规则, 启发式算法的有点在于它比盲目型的搜索法要高效, 一个经过仔细设计的启发函数, 往往在很快的时间内就可以得到一个搜索问题的最优解.</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>基于区域的CNN目标检测法使用的数据集中带物体标签的区域和背景区域之前的样本比例存在着巨大失衡. 在DPM中, 这种比例达到了1:100000. 一些算法(如Selective Search)对此进行了处理但失衡比例仍然很大(1:70).</p><p>bootstrapping(现在多称为 hard negative mining)问题至少已经存在了20年. 并且Bootstrapping技术已经在目标检测领域内流行了十几年(尤其是在训练针对目标检测的SVMs时). 很多现代的基于深度学习的目标检测方法都是用了基于难样例挖掘的SVMs来帮助训练检测模型(RCNN, SPPnet).</p><p>但是奇怪的是后来的一些模型(FastRCNN, FasterRCNN等) 都没有使用bootstrapping技术. 一个潜在的原因可能是在深度神经网络中, 存在一些技术上的困难, 是的bootstrapping使用效果不佳. 传统的bootstrapping需要先用一个固定的模型来找到新的样本已准备训练数据, 然后再用一个固定的样本将检测模型激活并训练. 而在训练深度神经网络时, 其需要成千上万的大量样本用于训练, 因此, 我们需要一个 <strong>纯粹在线</strong> 的难样例选择算法.</p><p>在本文中, 我们提出了一个新型的bootstrapping技术称为 <strong>online hard example mining(OHEM)</strong>, 并将其应用到基于深度学习的当前最先进的目标检测模型上. 该算法实际上是对SGD做了一些小改动, 使得训练样本可以从一个非均匀分布都采样得到, 该分布是一个基于当前样本loss的非静态分布. 该方法利用了目标检测问题特殊的结构优势, 那就是每一个SGD的mini-batch中仅仅包含一张或两张图片, 但是会有上千个候选样本. 这样候选样本会被继续按照特定的分布(倾向于那些不同的, 可以造成很高loss的样本)进行采样, 由于采样后的样本只是一小部分样本子集, 因此梯度下降优化算法仍然高效. 将OHEM算法用于标准的Fast RCNN算法以后,  显示除了三点好处:</p><ul><li>移除了一些在基于区域推荐的CNN目标检测算法中的启发方法和超参数</li><li>稳定且大幅度的提升了mAP</li><li>当training set变的更大更复杂时, OHEM的有效性会提升</li></ul><p>不仅如此, 从OHEM中获得的性能提升是对最近目标检测领域其他提升性能方法的一种补充, 如multiscale testing和迭代式bounding box回归. 在使用OHEM的同时结合这些tricks, 可以更进一步的提升mAP.</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>绝大多数目标检测模型都使用了结合bootstrapping算法的SVMs来作为检测的scoring function.<br>但是有一些特例, FastRCNN和FasterRCNN等没有使用结合bootstrapping的SVMs, 而是完全根据SGD进行训练, 这些模型通过引入一些在线的难样例挖掘算法来解决这个问题(送入minibatch的前后景比例1:3). 下面简单介绍一下 Hard example mining和CNN目标检测以及他们之间的关系</p><p><strong>Hard example mining:</strong> 目前常用的有两大算法.<br>第一种是用于优化SVMs的: 训练算法会维护一个工作样本集, 并且该样本集会依据特定的规则不断在训练SVMshe更新样本集之间迭代. 这些规则会将简单样本(很容易分类正确)从样本集中移除, 同时会添加困难样本到样本集中.<br>第二种方法用于非SVMs模型, 如浅层神经网络和boosted决策树: 该算法会从正样例和一部分随机负样例组成的数据集开始训练, 在该数据集上训练至收敛以后, 会继续在一个更大的, 包含更多负样例的数据集上进行训练. 这个过程通常只会进行一次迭代, 并且没有任何的收敛性证明.</p><p><strong>ConvNet-bases detection:</strong> 近年来CNN在目标检测领域迅速, 尤其是基于深度学习的目标检测方法(SPPNet, MRVNN Fast RCNN).</p><p><strong>Hard example selection in deep learning:</strong> 目前已经有很多专门针对目标检测算法hard example mining方法. 这些算法的基本思路与我们相同, 但是我们的算法更关注基于区域推荐的目标检测算法的 <strong>在线难样例挖掘</strong>.</p><h2 id="Overview-of-Fast-RCNN"><a href="#Overview-of-Fast-RCNN" class="headerlink" title="Overview of Fast RCNN"></a>Overview of Fast RCNN</h2><p>在Fast RCNN中, 每一个minibatch包含N=2张图片, 每一张图片会采样B/N=128/2=64个候选框. RoI sampling过程使用了多个启发式规则, 如下所示:</p><ul><li><strong>Foreground RoIs:</strong> 每一个RoI都会根据与真实框的IOU大小来分成前景框和后景框</li><li><strong>Background RoIs:</strong> 在[<code>bg_lo</code>,0.5) 区间的被认为是后景, <code>bg_lo</code>(FastRCNN为0.1)用来充当难样例挖掘的角色, 但是这样会忽视一些不频繁但是很重要的后景区域, OHEM移除了<code>bg_lo</code>阈值.</li><li><strong>Balancing <code>fg-bg</code> RoIs:</strong> 为了处理难样例问题, FastRCNN采取的策略是将minibatch中前后景的比例设置为 1:3 (25%为前景). 这是一个十分重要的启发式规则阈值, 在实验中, 将他移除或者改变都会引起mAP分数的大幅度下降(3 points). <strong>但是利用OHEM, 就可以在不损失mAP的情况下, 移除这个超参数.</strong></li></ul><h2 id="Our-approach"><a href="#Our-approach" class="headerlink" title="Our approach"></a>Our approach</h2><p>本文提出的OHEM算法可以简化复杂的FastRCNN系列模型的训练及调参过程, 同时可以获得更好的训练结果(lower training loss)和更高的测试性能(higher mAP)</p><h3 id="Online-hard-example-mining"><a href="#Online-hard-example-mining" class="headerlink" title="Online hard example mining"></a>Online hard example mining</h3><p>在RCNN中使用SVMs,大致有两个阶段, 阶段 a) 首先会筛选并处理指定数目(10or100)个图片, 然后在在这些图片进进行训练直到收敛. 重复这两个阶段直到SVMs找到所有的支持向量为止. RCNN所采用的这个优化策略效率是很低的, 因为在对图片进行筛选和处理的时候, 没有任何模型会进行更新.</p><p>OHEM算法流程如下: 对于处于第t次SGD迭代的输入图片来说, 首先计算器卷积特征图谱. 然后令RoI网络使用这个特征图谱和 <strong>所有</strong> 的RoIs (不是minibatch子集, 而是所有), 进行前向传播(仅包含RoI pooling层和几层fc层). 由此计算出的loss代表了当前网络在每一个RoI上的表现好坏. Hard examples的选择方法是将每个RoI的loss进行排序, 然后选择loss最大的 B/N 个样本作为hard examples. 直观上可以看出, 这些样本对于当前网络来说, 是最难正确分类的样本. 同时, <strong>由于RoI pooling层本身计算量不高, 且各个RoI之间的计算可以共享</strong>(//TODO,怎么共享??), 因此, 额外的计算成本相对来说并不高. 此外, 参与反向计算过程的样本集合很很小的一个集合, 因此, 相比以前的方法并不会带来更多的计算成本.<br>但是, 这里有一个小警告: 如果两个RoI之间的overlap较大, 那么很有可能这两个RoI的loss直接会有一定关联程度. 也就是说, 这些重叠度较高的RoIs可以映射到特征图谱上的同一块区域中, 又因为分辨率之间的差异性, 就可能导致loss的重复计算. 为了解决这种冗余计算和关联区域, 我们使用NMS算法来降低重复性. 具体来说, 给定RoIs列表和它们对应的losses, NMS迭代的选择那些具有最高loss的RoI, 然后移除所有与高RoI重叠度较高(IOU&gt;0.7)的其他RoI(这些RoI的loss更低).<br>可以看出, 上面的过程并不需要<code>fg-bg</code>比例这个超参数, 如果任何一类被忽视了, 那么这个类对应的loss就会一直升高, 知道这个类被采样的概率变大为止.  对于有些图片来说, 前景区域是简单样例, 此时网络就会只采用背景区域进行训练, 反之, 也有的图片会认为背景区域(草地, 天空)是简单样例.</p><h3 id="Implementatin-details"><a href="#Implementatin-details" class="headerlink" title="Implementatin details"></a>Implementatin details</h3><p>实现OHEM算法的方法有很多, 它们之间有着不同的权衡和考量. 一个明显的方法是修改loss层, 使其完成难样例的选取工作. loss层可以计算所有RoIs的loss, 然后将它们进行排序,并且根据loss的值进行难样例的选择, 同时将所有非难样例的RoIs的loss设置为0 (表示梯度下降时不会考虑这些样例). 这种方式很直接, 但是却不够高效, 因为RoI网络仍然需要申请空间来存储这些RoIs, 并且还要对所有的RoIs进行反向传播计算(非难样例的loss虽然为0, 但也要参与计算流程).<br>为了克服上面的效率问题, 本文提出了一种结构如图2所示. 我们的实现包含两个RoI网络的副本, 其中一个是 <strong>只读</strong> 的. 这意味着我们的只读RoI网络只需要申请前向传播计算的内存, 而不用像经典RoI网络一样, 需要同时申请前向计算和反向传播时的内存. 对于一次SGD迭代来说, 给定卷积特征图谱, 只读RoI网络会对所有的RoIs执行前向计算并计算loss( $R$ , 图2中的绿色箭头所示). 然后难样例采样模块会按照之前说的采样策略来选择难样例, 然后会将这些难样例输入到一个常规的RoI网络中( $R_{hard-sel}$ 图2中的红色箭头所示). 于是, 这个网络仅仅只会对难样例同时进行前向计算和反向传播计算. 在实际中, 我们使用所有图片的所有RoI作为 $R$, 因此对于只读RoI网络最后的minibatch的size为 $|R|$. (//TODO 嘛意思?)<br>在实验中, N=2(意味着 $|R|\approx 4000$ ), B = 128.</p><p><img src="http://wx4.sinaimg.cn/large/d7b90c85ly1fwi9ig4pthj213t0ls7fq.jpg" alt=""></p><h2 id="实验与分析"><a href="#实验与分析" class="headerlink" title="实验与分析"></a>实验与分析</h2><h3 id="OHEM-vs-heuristic-sampling"><a href="#OHEM-vs-heuristic-sampling" class="headerlink" title="OHEM vs. heuristic sampling"></a>OHEM vs. heuristic sampling</h3><p>如下表所示, 没有使用 <code>bg_lo</code> 超参数的OHEM在FasrRCNN上的mAP提高了4.8个点</p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwj7f29xztj20st0kyadj.jpg" alt=""></p><h3 id="Robust-gradient-estimates"><a href="#Robust-gradient-estimates" class="headerlink" title="Robust gradient estimates"></a>Robust gradient estimates</h3><p>因为N=2, 所以选出来的框之间很有很大的关联性, 这会不会使得梯度不稳定从而难以收敛. 实验结果表明, OHEM同样对这种情况具有鲁棒性, 即使将N设置为1, mAP也不会降低多少(仅降低了0.2%). (当然, 在硬件条件允许的情况下, 选取越大的N, 效果一般越好)</p><h3 id="Why-just-hard-examples-when-u-can-use-call"><a href="#Why-just-hard-examples-when-u-can-use-call" class="headerlink" title="Why just hard examples, when u can use call?"></a>Why just hard examples, when u can use call?</h3><p>如果使用所有的RoI loss参与权重更新(而不仅仅是hard examples)会怎么样呢? 在这种情况下, 那些简单样本将会拥有较小的loss, 从而不会对梯度的更新贡献太大, 整个训练过程会自动的专注于难样例的训练.(这种全训练的结果会使得相对于标准FastRCNN的mAP提升一点, 因为标准的FastRCNN并没有针对难样例, 而是随机选的minibatch), 但是这种全训练很是的训练时间大幅提高.</p><h3 id="Better-optimization"><a href="#Better-optimization" class="headerlink" title="Better optimization"></a>Better optimization</h3><p>利用OHEM可以获得更低的 mean loss per RoI  (取自各种方法的第20K次迭代)</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwj89dxiz3j20s40m0jvi.jpg" alt=""></p><h3 id="Computational-cost"><a href="#Computational-cost" class="headerlink" title="Computational cost"></a>Computational cost</h3><p>不论是耗时上还是内存占用上, 都变多了, 但总体来说, 是可以接受的</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwj89qxmy9j20s20c10un.jpg" alt=""></p><h1 id="PASXAL-VOC-and-MS-COCO-results"><a href="#PASXAL-VOC-and-MS-COCO-results" class="headerlink" title="PASXAL VOC and MS COCO results"></a>PASXAL VOC and MS COCO results</h1><p><strong>在训练阶段和测试阶段使用multi-scale和multi-stage bbox regression</strong> 可以大幅度提高mAP</p><p>multi-scale: $s\in \{ 480, 576, 688, 864, 900 \}$ for training, $s\in \{480, 576,688,864,1000\}$ for testing. 这些scales和caps的选择主要受制于GPU的显存大小.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>其他-Latex语法</title>
      <link href="/z_post/%E5%85%B6%E4%BB%96-Latex%E8%AF%AD%E6%B3%95/"/>
      <url>/z_post/%E5%85%B6%E4%BB%96-Latex%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><div class="table-container"><table><thead><tr><th>样式</th><th>指令</th><th>样式</th><th>指令</th><th>样式</th><th>指令</th><th>样式</th><th>指令</th><th>样式</th><th>指令</th><th>样式</th><th>指令</th></tr></thead><tbody><tr><td>$\uparrow$</td><td>\uparrow</td><td>$\Uparrow$</td><td>\Uparrow</td><td>$\downarrow$</td><td>\downarrow</td><td>$\Downarrow$</td><td>\Downarrow</td><td>$\leftarrow$</td><td>\leftarrow</td><td>$\Leftarrow$</td><td>\Leftarrow</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>样式</th><th>指令</th><th>样式</th><th>指令</th><th>样式</th><th>指令</th><th>样式</th><th>指令</th></tr></thead><tbody><tr><td>$\uparrow$</td><td><code>\uparrow</code></td><td>$\Uparrow$</td><td>\Uparrow</td><td>$\downarrow$</td><td>\downarrow</td><td>$\Downarrow$</td><td>\Downarrow</td></tr></tbody></table></div><pre><code>\rightarrow</code></pre><p>\Rightarrow<br>    \updownarrow<br>    \Updownarrow<br>    \leftrightarrow<br>\Leftrightarrow<br>长箭头表示<br>(其实就是在上述表示前加一个long/Long即可)</p><p>符号 符号</p><p>MarkDown MarkDown<br>\longleftarrow<br>\Longleftarrow<br>    \longrightarrow<br>\Longrightarrow<br>\longleftrightarrow<br>\Longleftrightarrow<br>更多的箭头符号</p><p>符号 符号</p><p>MarkDown MarkDown<br>\twoheadrightarrow<br>\rightarrowtail<br>\looparrowright<br>\curvearrowright<br>\circlearrowright<br>\Rsh<br>\multimap<br>    \leftrightsquigarrow<br>    \rightsquigarrow<br>    \leadsto<br>    \nearrow<br>    \searrow<br>    \swarrow<br>    \nwarrow<br>    \nleftarrow<br>    \nrightarrow<br>    \nLeftarrow<br>    \nRightarrow<br>    \nleftrightarrow<br>    \nLeftrightarrow<br>        \dashrightarrow<br>\dashleftarrow<br>    \leftleftarrows<br>    \leftrightarrows<br>    \Lleftarrow<br>    \twoheadleftarrow<br>    \leftarrowtail<br>    \looparrowleft<br>    \curvearrowleft<br>    \circlearrowleft<br>    \Lsh<br>    \mapsto<br>    \hookleftarrow<br>    \hookrightarrow<br>\upharpoonright<br>    \upharpoonleft<br>\downharpoonright<br>\downharpoonleft<br>    \leftharpoonup<br>\rightharpoonup<br>\leftharpoondown<br>    \rightharpoondown<br>    \upuparrows<br>    \downdownarrows<br>    \rightrightarrows<br>    \rightleftarrows<br>    \rightrightarrows<br>    \rightleftarrows<br>        \rightleftharpoons<br>\leftrightharpoons</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>其他-MarkDown语法</title>
      <link href="/z_post/%E5%85%B6%E4%BB%96-MarkDown%E8%AF%AD%E6%B3%95/"/>
      <url>/z_post/%E5%85%B6%E4%BB%96-MarkDown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>json模块</title>
      <link href="/z_post/Python-json/"/>
      <url>/z_post/Python-json/</url>
      
        <content type="html"><![CDATA[<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式, 易于阅读和编辑.</p><p>使用JSON函数之前需要导入<code>json</code>库: <code>import json</code></p><h1 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a>json.dumps</h1><p>该函数用于将Python对象编码成JSON字符串, 语法如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json.dumps(obj, skipkeys=<span class="keyword">False</span>, ensure_ascii=<span class="keyword">True</span>, check_circular=<span class="keyword">True</span>,</span><br><span class="line">            allow_nan=<span class="keyword">True</span>, cls=<span class="keyword">None</span>, indent=<span class="keyword">None</span>, separators=<span class="keyword">None</span>,</span><br><span class="line">            encoding=<span class="string">"utf-8"</span>, default=<span class="keyword">None</span>, sort_keys=<span class="keyword">False</span>, **kw)</span><br></pre></td></tr></table></figure><h1 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads"></a>json.loads</h1><p>可以解析json文件, 之后可以像使用字典一样进行操作.</p><p>json解码为Python类型转换对应表</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>FPN-CVPR2017</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2017-FPN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2017-FPN/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> Feature Pyramid Networks for Object Detectin<br><strong>作者:</strong> Tsung-Yi Lin, Piotr Dollar, Ross Girshick, Kaiming He, Bharath Hariharan, and Serge Belongie</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>提出了多尺度的特征金字塔结构</strong><br>将最后一层特征图谱进行不断尽快上采样, 并与每一个金字塔阶级的特征图谱进行加法合并操作, 得到新的表征能力更强的不同金字塔层次的特征图谱, 然后将RoI按照尺寸分别映射到这些特征图谱上, 再在每个特征图谱上进行类别和位置预测. 可以直观感受到, 这种多尺度的特征图谱在面对不同尺寸的物体时, 具有更好的鲁棒性, 尤其是在面对小型物体时. 同时, 这种特征金字塔结构是一种通用的特征提取结构, 可以应用到不同的网络框架中, 显著提高(5~8%)模型的召回率(因为提出了更多不同尺度, 不同特征信息的anchor box), 并且可以广泛提高(2~3%)模型的mAP.</p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在面对不同尺度的物体检测问题时, 特征金字塔结构是一个非常基本的组成部分, 但是最近的检测模型都舍弃了这一结构(Fast RCNN, Faster RCNN, YOLOv2等), 其一部分原因是因为这个结构对计算和内存的要求较高. 本文在控制资源消耗的情况下, 建立了一个跨所有层的特征金字塔结构网络, 达到了当时的STOA性能.</p><p>传统的特征金字塔结构对于计算资源和内存资源的依赖较为严重, 同时深度卷积网络在不同阶段的卷积层, 虽然较好的传递了特征, 但是因为每一层的输出通道数不同, 会导致层与层之间形成一种潜在的语义鸿沟. 较高的分辨率好好具有更多的低级信息(在深层会被过滤掉), 但是多于的信息也会对降低泛化能力, 较低的分辨率则具有权重更高的重要信息, 但是这样也会使得小目标物体难以检测.</p><h2 id="SSD与FPN中多尺度特征图谱融合的区别"><a href="#SSD与FPN中多尺度特征图谱融合的区别" class="headerlink" title="SSD与FPN中多尺度特征图谱融合的区别"></a>SSD与FPN中多尺度特征图谱融合的区别</h2><p>SSD算是首批结合多尺度特征金字塔的检测系统, 但是SSD为了避免用到过多的低级特征(高层卷积图谱上的特征), 放弃使用以及计算好的特征特普, 而是从网络的最后一层卷积层开始, 添加新的卷积层, 并在这些新添加的卷积层上进行特征金字塔融合. 这样做一个很直观的结果就是, 它会错过很多高分辨率特征图谱上的特征信息, 而这些特征信息在面对小物体检测时是十分有用的.(这也是SSD对小物体检测较为敏感的原因之一).</p><p><img src="https://wx2.sinaimg.cn/mw1024/d7b90c85ly1fwdnxf13omj20k50jxaem.jpg" alt=""></p><h2 id="Feature-Pyramid-Networks"><a href="#Feature-Pyramid-Networks" class="headerlink" title="Feature Pyramid Networks"></a>Feature Pyramid Networks</h2><p>输入: 任意尺寸的单张图片(不进行尺度缩放)<br>输出: 以全卷积的方式在不同层次上输出对应的映射尺寸的特征图谱</p><p>构建FPN包含以下步骤:</p><p><strong>自下而上的路径:</strong> 该方式是根据backbone 卷积网络的前馈计算过程进行的. 特征图通常经过卷积计算后是会越来越小的, 也有一些特征层的输出和原来大小一样, 成为处于同一个网络阶段(“same network stage”). 对于本文, 将每一个”network stage”看做是一个金字塔级别. 然后选择每个阶段的最后一层作为特征图的参考集合(因为最深层理应具有最强的特征表示). 具体来说, 对于ResNets, 使用了每一个阶段的最后一个残差结构的特征激活输出, 将这些残差模块conv2, conv3, conv4, conv5 的输出表示为 $\{C_2, C_3, C_4, C_5\}$, 并且注意到他们相对于输入图像具有 $\{4,8,16,32\}$ 像素的步长.</p><p><strong>自上而下的路径以及横向连接:</strong><br>自上而下的路径是通过在更粗糙, 但是语义更强的高层特征图(深层)上进行上采样来得到更高分辨率的图谱, 然后将这些上采样之后的feature map 与 自下而上(自浅而深)的特征图谱通过横向连接的方式拼接在一起.(横向连接的feature map的size是一样大的). 那些bottom-up frature map 具有较为低级的语义信息(低级是指抽象程度低), 但是这些图谱的位置精度更高, 因为它们经过的下采样次数更少. 下面的图3显示了构建top-down feature map的模块. 对于一个粗糙精度的特征图谱, 首先将其上采样至2倍(为了简单, 直接使用最近邻), 然后将上采样后的特征图谱与对应的自下而上的图谱进行按元素相加合并(合并前自下而上的图谱会将经过1×1卷积降低通道数). 这个过程会一直迭代, 知道最浅的卷积图谱也被合并为止. 在最开始的时候, 最深层的合并是使用1×1卷积来生成待合并的top-bottom feature map的.  最后, 会用3×3的卷积在所有合并后的特征图谱上进行卷积操作, 以此来得到最终的特征图谱(以此来消除上采样的混叠效应) $\{P_2, P_3, P_4, P_5\}$, 他们具有与$\{C_2, C_3, C_4, C_5\}$ 相同的大小.</p><p><img src="https://wx3.sinaimg.cn/mw1024/d7b90c85ly1fwcf7vmr0rj20j20cddh1.jpg" alt=""></p><p>由于所有层的金字塔卷积都是使用的共享的分类器和回归器, 因此文章固定了特征图谱的通道数量(256). 文章使用的是最简单的网络结构, 同时也存在其他更好的连接设计, 但本文的主要目的是探讨FPN的有效性, 因此没要尝试过多的连接组合.</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>FPN是一种用于在卷积网络内部建立特征金字塔的一般化的解决方案, 下面利用Faster RCNN来证明FPN的有效性.</p><h3 id="Feature-Pyramid-Networks-for-RPN"><a href="#Feature-Pyramid-Networks-for-RPN" class="headerlink" title="Feature Pyramid Networks for RPN"></a>Feature Pyramid Networks for RPN</h3><p>RPN会在最后一层的特征图谱上, 利用 3×3 的卷积核, 生成同样大小的特征图谱, 然后在这个新的图谱上画anchor boxes, 并利用两个1×1的卷积核进行二分类和回归任务. 本文用FPN替换了RPN的3×3的卷积核, 然后依然使用两个1×1的卷积核进行二分类和回归任务. 同时, 因为FPN会结合前面的backone网络的所有卷积段, 因此, 对于每一个金字塔层, 只使用一个固定尺寸的anchors. 本文中, 对于$\{P_2, P_3, P_4, P_5\}$,其anchors的大小分别为 ${32^2, 64^2, 128^2, 256^2, 512^2}$, 每一层anchors的宽高比例为{1:2, 1:1, 2:1}, 因此, 总共具有15个anchors(对于每一个location而言)</p><p>训练时的标签赋值策略和FasterRCNN是一样的.</p><h3 id="Feature-Pyramid-Networks-for-Fast-RCNN"><a href="#Feature-Pyramid-Networks-for-Fast-RCNN" class="headerlink" title="Feature Pyramid Networks for Fast RCNN"></a>Feature Pyramid Networks for Fast RCNN</h3><p>将FPN用于FastRCNN时, 需要在不同的层次上赋予不同尺度的RoI大小.(因为RoI pooling是根据物体在原图中的框决定)</p><p>本文宽度为 $w$ ,高度为 $h$ 的RoI 通过如下公式分配到特征金字塔的 $P_k$ 等级上:</p><script type="math/tex; mode=display">k = \lfloor k_0 + log_2(\frac{\sqrt{wh}}{224})</script><p>这里 224 是规范的ImageNet预训练的大小, 而 $K_0$ 是则大小为 $w\times h = 224^2$ 的RoI应该映射到的目标级别. 类似于基于ResNet的Faster RCNN使用 $C_4$ 作为单尺度特征映射, 我们将 $k_0$ 设置为4 (也就是说, 与图片一样大的RoI会映射到 $P_1$ 的特征图谱上). 上式表明, 如果RoI的尺度变的更小(如224的0.5倍), 那么该RoI就应该映射到分辨率更高的金字塔图谱上(如 $k=3$ ).(也就是说不同大小的RoI会映射到不同金字塔层级的特征图谱上, 总的来说, 越小的RoI, 会映射到更浅层的特征图谱上, 因为太深的图谱可能已经将小物体信息过滤掉了)</p><p>文章将预测器(分类和坐标回归)应用到所有金字塔层级的RoI上面. 需要注意, <strong>预测器在所有层级上的权重都是共享的.</strong> . 在ResNet中, 会在conv4的特征图谱上在加上一个conv5, 但是本章已经将conv5用于构建特征金字塔. 所以和ResNet不同, 文章很直接的利用RoI pooling来获取 $7\times 7$ 的特征 (注意不是基于滑动窗口的检测器, 这一点和YOLO差不多), 并且会使用2层1024维的隐藏层(后街ReLU), 然后才会送入最终的预测器层当中(分类和位置回归).</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>用COCO 80ktrain和35k val进行实验. 所有的网络均在ImageNet1k上预训练.</p><p><strong>实验细节:</strong></p><p>输入图片的尺寸被resize, 其最短边长为800像素. 8块GPU同步训练, 每个GPU的minibatch为两张图片, 每张图片的anchors为256. weight decay为0.0001, momentum为0.9. learning rate 开始的30k图片是0.02, 之后是0.002. 训练时包含了那些处于image之外的anchor boxes(Faster选择忽略).</p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><p>实验结果表明, RPN结构可以提高检测的AR(Average Recall)指标, 尤其是在面对小物体和中等物体等多尺度物体时, 会显著提高AR指标.</p><p><strong>top-down</strong> 的特征图谱加强可以使得特征图谱具有很强的语义特征信息和更好的分辨率.(原始的特征图谱之间的语义鸿沟更大, 层与层之间的联系比较简单粗糙)</p><p>虽然top-down方式的特征图谱具有很强的语义特征信息和更好的分辨率效果, 但是有过经过不断的降采样和上采样过程, 该特征图谱的位置信息可能会变得不够精确. <strong>lateral connections</strong> 同时结合具有精确位置信息的特征图谱和具有强语义信息的图谱, 进而达到更好的效果.</p><p><strong>Pyramid结构的重要性:</strong> 如果只在最后一层特征图谱 $P_2$ 上进行检测, 这就像是Faster RCNN的单尺度方法一样, 所有的anchors都在最后一层图谱上, 这种变体比Faster RCNN好但是比FPN差. 直观上来说, 在所有特征层上进行检测, 对不同尺度的物体的鲁棒性要更好.</p><h2 id="利用Fast-Faster-RCNN进行目标检测"><a href="#利用Fast-Faster-RCNN进行目标检测" class="headerlink" title="利用Fast/Faster RCNN进行目标检测"></a>利用Fast/Faster RCNN进行目标检测</h2><p>利用AP(Average Precision)指标对FPN进行验证</p><p>在Faster RCNN上使用FPN, mAP提高了 2%, 其中小物体的mAP提高了2.1%.(固定的候选区域集合)</p><p>在面对consistent proposals时(因为RPN和Fast RCNN要共享权重,所以会不断迭代训练), FPN比Faster RCNN的AP高 <strong>2.3</strong> 点, 比AP@0.5高 <strong>3.8</strong> 点.</p><p>FasterRCNN中RPN和FastRCNN的权重共享大约可以提升mAP值0.5左右(0.2~0.7), 同时, 权重共享也可以降低预测时间(0.148 vs 0.172, ResNet50, M40 GPU因为不用计算两个不同的权重参数, RPN与Fast RCNN用的是一个权重参数).</p><p><strong>FPN没有使用很多流行的提升精度的方法, 如迭代回归, 难样例挖掘, 上下文建模, 数据增强等等. 但是FPN仍然在目标检测, 实例分割, 关键点检测等多项任务上刷新了最高分. 如果使用这些trick, 理论上会获得更高的精度.</strong></p><p>FPN是一种通用的特征提取方法, 他同样也适用于实例分割任务, 并且可以取得很好的效果.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数学题</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h1 id="矩阵论"><a href="#矩阵论" class="headerlink" title="矩阵论"></a>矩阵论</h1><h2 id="线性变换的矩阵为什么强调在这组基下"><a href="#线性变换的矩阵为什么强调在这组基下" class="headerlink" title="线性变换的矩阵为什么强调在这组基下"></a>线性变换的矩阵为什么强调在这组基下</h2><h2 id="矩阵的奇异值和特征值有什么相似之处和区别之处"><a href="#矩阵的奇异值和特征值有什么相似之处和区别之处" class="headerlink" title="矩阵的奇异值和特征值有什么相似之处和区别之处?"></a>矩阵的奇异值和特征值有什么相似之处和区别之处?</h2><p>奇异值分解把线性变换清晰地分解为旋转, 缩放, 投影这三种基本线性变换.</p><p>首先, 矩阵是对线性变换的表示, 确定了定义域空间与目标空间的两组基, 就可以很自然的得到该线性变换的矩阵表示</p><h1 id="高数"><a href="#高数" class="headerlink" title="高数"></a>高数</h1><h1 id="一阶矩和二阶矩是什么"><a href="#一阶矩和二阶矩是什么" class="headerlink" title="一阶矩和二阶矩是什么?"></a>一阶矩和二阶矩是什么?</h1><p>期望, 方差</p><h1 id="有一个很大的二维数组-数组里面大部分都是nan值-有一小部分不是nan值-求这些不是nan值之间的欧式距离-并存到另一个数组中"><a href="#有一个很大的二维数组-数组里面大部分都是nan值-有一小部分不是nan值-求这些不是nan值之间的欧式距离-并存到另一个数组中" class="headerlink" title="有一个很大的二维数组, 数组里面大部分都是nan值, 有一小部分不是nan值, 求这些不是nan值之间的欧式距离, 并存到另一个数组中."></a>有一个很大的二维数组, 数组里面大部分都是nan值, 有一小部分不是nan值, 求这些不是nan值之间的欧式距离, 并存到另一个数组中.</h1><p>#</p><h1 id="正态函数的随机性是怎么实现的"><a href="#正态函数的随机性是怎么实现的" class="headerlink" title="正态函数的随机性是怎么实现的"></a>正态函数的随机性是怎么实现的</h1><h1 id="均匀分布随机函数是怎么实现的"><a href="#均匀分布随机函数是怎么实现的" class="headerlink" title="均匀分布随机函数是怎么实现的"></a>均匀分布随机函数是怎么实现的</h1><h1 id="如何用均匀分布来实现正态分布的随机函数"><a href="#如何用均匀分布来实现正态分布的随机函数" class="headerlink" title="如何用均匀分布来实现正态分布的随机函数"></a>如何用均匀分布来实现正态分布的随机函数</h1><h1 id="技巧题"><a href="#技巧题" class="headerlink" title="技巧题"></a>技巧题</h1><p>a,b~U[0,1]，互相独立<br>求Max(a,b) 期望</p><p>#</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>面试-面经汇总</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="优秀面经"><a href="#优秀面经" class="headerlink" title="优秀面经"></a>优秀面经</h1><p><a href="https://www.cnblogs.com/huanyi0723/p/8470866.html" target="_blank" rel="noopener">https://www.cnblogs.com/huanyi0723/p/8470866.html</a></p><p><a href="https://www.nowcoder.com/discuss/78195" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/78195</a></p><p><a href="http://www.zheyibu.com/article/5626.html" target="_blank" rel="noopener">http://www.zheyibu.com/article/5626.html</a></p><p><a href="https://www.jianshu.com/p/6671232cec79" target="_blank" rel="noopener">https://www.jianshu.com/p/6671232cec79</a></p><p><a href="https://www.zhihu.com/question/62482926" target="_blank" rel="noopener">https://www.zhihu.com/question/62482926</a></p><h2 id="在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug，-你如何调试这个bug。"><a href="#在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug，-你如何调试这个bug。" class="headerlink" title="在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug， 你如何调试这个bug。"></a>在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug， 你如何调试这个bug。</h2><p>解决Bug，第一步就是重现，第二步定位以及Reduce，第三步再来解。所以，不管百万次还是十万次，首先要重现出来，然后找出重现出来的计算机状态。计算机不会欺骗人，每一个问题出来肯定是有原因的，唯一要做的就是如何把这个计算机状态信息还原出来，你可以使用log跟踪等，怎么纪录还原都是工程师的选择。而若能把相关的状态信息拿到，剩下的就是定位是哪里的问题，而这时候最好的就是模拟和Reduce，把问题缩小，排除其它信息干扰。模拟与Reduce成功以后，再想办法解决，然后再来估计解决问题的难度与成本问题等，有些BUG我们是知道，但是解决太麻烦了，影响也不大，就放着。</p><p>作者：蓝色<br>链接：<a href="https://www.zhihu.com/question/43416744/answer/95944740" target="_blank" rel="noopener">https://www.zhihu.com/question/43416744/answer/95944740</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>另一方面，从管理上应该要考虑 bug 的严重性与成本／时间的问题。如果最终能找出问题，需要研究怎样防范相似的 bug。</p><h2 id="这个bug很难重现，这个时候你要怎么处理或者重现呢。"><a href="#这个bug很难重现，这个时候你要怎么处理或者重现呢。" class="headerlink" title="这个bug很难重现，这个时候你要怎么处理或者重现呢。"></a>这个bug很难重现，这个时候你要怎么处理或者重现呢。</h2><h1 id="有一个类指针，指向类实例化的对象，在这个对象程序的运行过程中，程序崩溃了，后来发现是这个类指针的虚函数表被破坏了，现在如何定位这个问题。"><a href="#有一个类指针，指向类实例化的对象，在这个对象程序的运行过程中，程序崩溃了，后来发现是这个类指针的虚函数表被破坏了，现在如何定位这个问题。" class="headerlink" title="有一个类指针，指向类实例化的对象，在这个对象程序的运行过程中，程序崩溃了，后来发现是这个类指针的虚函数表被破坏了，现在如何定位这个问题。"></a>有一个类指针，指向类实例化的对象，在这个对象程序的运行过程中，程序崩溃了，后来发现是这个类指针的虚函数表被破坏了，现在如何定位这个问题。</h1><p>需要先限定编译器和环节，比如，virtual table 在 Linux 下 GCC 4.9 的实现就是放在read only 段 .rodata，怎么可能被修改？好，就算可以被修改，我第一反应就是上GDB与Valgrind，被破坏的原因很多，你不让我调，我怎么跟你继续说下去，不如直接给我代码，我调给你看？ 那你首先准备一个这样的代码？</p><p>作者：蓝色<br>链接：<a href="https://www.zhihu.com/question/43416744/answer/95944740" target="_blank" rel="noopener">https://www.zhihu.com/question/43416744/answer/95944740</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1 id="模型压缩"><a href="#模型压缩" class="headerlink" title="模型压缩"></a>模型压缩</h1><h1 id="cuda"><a href="#cuda" class="headerlink" title="cuda"></a>cuda</h1><p>作者：oncecoder<br>链接：<a href="https://www.nowcoder.com/discuss/23418" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/23418</a><br>来源：牛客网</p><p>   面试官：看你简历上写熟悉CUDA，你能具体讲讲吗。<br>   我：写过图片的resize,padding,卷积，提取hog特征等的gpu代码（kernel函数），效果还不错。<br>   面试官问：具体说说怎么做到提升速度的。<br>   我：把处理安排到gpu的每个thread上。<br>   面试官：那看来你就相当于简单的利用了gpu的多核的特性？<br>   我一听感觉面试官不是很满意，于是扯了扯：还用了share_memory,const_memory等来提升速度，用了原子操作等来保证安全性。<br>   面试官：你能讲讲使用shared memory为什么快吗？<br>   我：在某些应用场景下会快，一来和使用场景有关，讲了下哪些场景用这个会好一些，二来可能是硬件方面的原因吧，硬件原理方面的我也不清楚。<br>    然后面试官从内存的金字塔结构，以及gpu的一些特性给我展开讲了很多，这个面试官感觉是gpu方面的行家，人非常好，感觉给我做了个讲座。。。<br>    然后面试官问：你知道warp这个概念吗？<br>    我说知道，就是gpu底层同时执行的指令数量，现在一般是32.所以在写内核函数的时候，thread的数目最好是32的倍数。其他的不太清楚。<br>    面试官好像点了点头，又给我balabala做了一次讲座。。。。<br>    面试官问：假如要申请一大片空间，一次性申请这么大的，和分多次申请很多小的，但总数一样，哪个快，为什么。<br>    我：在做项目的时候遇到过这种情况，前者会快很多，然后说了原因（答得不太标准，就不误导大家了）<br>    面试官：其实cpu和gpu在这方面是一样的，  都会维护一个表什么的，记不太清楚了。<br>    面试官：怎么看gpu使用情况。我：nvidia-smi(我用的是nvidia的卡)</p><h1 id="face-面经"><a href="#face-面经" class="headerlink" title="face++ 面经"></a>face++ 面经</h1><p>作者：一一后<br>链接：<a href="https://www.nowcoder.com/discuss/119900" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/119900</a><br>来源：牛客网</p><p>一面（30分钟+</p><pre><code>撸项目（很细节，第一个项目每一步都要问为什么不用某个其他的方法）讲讲adaboost和random frost的相同之处和不同，各自应用范围，实际应用选择对SVM的理解，简单推导SVM，为什么要用对偶问题（二次规划+核化）具体讲一下为什么要核化，核化的过程讲一下DL中目标检测的大类和特点（one stage、two stage）为什么two stage比one stage慢，为什么one stage比two stage精度高？one stage在哪些具体方面检测精度不高（ROI+default box的深层理解）讲讲梯度消失问题及其应对方案（BN、Relu、初始化）讲讲BN的细节（过程，公式，作用）为什么BN可以加快优化算法的速度有什么问题</code></pre><p>总结：问得很深入，基本都要非常理解才行，提到某个细节之后可能会深入问这个细节更细节的东西，千万别在回答的时候给自己挖坑。</p><p>二面：（40分钟+</p><pre><code>自我介绍；链表的倒数第k个结点（双指针）应用场景题抛一个不均匀的硬币，设计策略能得到1/2的概率（抛两次）如果要求得到1/3和2/3呢？设计策略（抛四次，我想着抛6次，小哥哥提醒了）给出一个0到n的随机数生成器，设计策略，让不得到x的条件下，得到其他数的均匀分布（只能生成一次）（hash映射，但是我找不到合适的映射函数，小哥哥提醒了）扩展：不得到两个数呢？m个数呢？（一样）房子500万，每年涨10%，程序员工资100万，不涨，问多少年能全款买房（几秒钟估算了一下，永远买不起…）（总觉得小哥哥在暗示我什么）堆介绍，插入元素时调整的时间复杂度（变成二叉树，递归定义）堆排序、其他排序方法介绍和特点（按时间复杂度分了三种去介绍），最常用哪种有什么问题（小哥哥建议多看些ML的实际场景（我其实想问智商怎么提升…）</code></pre><p>总结：二面考基本功，数学算法和ML的熟练运用能力。</p><p>三面（院长大佬面）（挂）</p><pre><code>自我介绍用到深度学习的项目（大部分时间聊项目）深度学习的前沿知识（最新的网络结构、精度最高的目标检测模型等）有什么问题（大佬很委婉地劝我说他们主要收深度学习方向的…）作者：jucic链接：https://www.nowcoder.com/discuss/108078来源：牛客网CV岗：一面：用C++将一个类改造成线程安全的类凸优化了解吗SLAM里面闭环检测是什么怎么做用深度学习做SLAM了解吗兼职offer上一原题交叉熵是什么二面:链表反转快排三面（院长面）一直在聊项目算法细节部分被怼的很厉害</code></pre><p>某个函数只能随机产生0或1，利用这个实现一个函数能等概率的返回1-n之间的数，手撕实现代码</p><p>一个文件有一亿条整数数据，算一下占用多大磁盘，里面有几十个重复的数据，怎么找出来，内存占用不要超过本身的文件大小</p><p>a) 概率是抽样的题目居多，计算正确，错误或者抽中没抽中的概率，与腾讯考察的要求差不多，但稍难<br>其中一题，第一题，问试卷中的10道题，每到5个选项，如果瞎猜，每道题的数学期望是多少，如果每道题猜错的概率是92%，那么每道题的数学期望是多少？<br>b) 计算甲乙两地距离的问题，甲乙分别从AB两地相向而行，甲乙速度比是常数，第一次相遇在距离甲地80KM处，分别到达对方起点后，再返回来相向而行，第二次相遇在距离甲地40KM处，计算甲乙两地相距多远的问题<br>c) 研究基础，问到了RANSAC抽样的问题，将它与概率结合，抽取两个样本，抽取10次，问抽样概率<br>d) ICCV会议2013与2015年分别是在哪里开的<br>e) 选做题：写HOG的伪代码；关于图像模糊问题；问常见的跟踪方法有哪些，简述他们的优缺点，举一个近五年CVPR中流行的跟踪方法，写出它的思想</p><p>作者：牛客网<br>链接：<a href="https://zhuanlan.zhihu.com/p/29695077" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29695077</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>中国平安 - 实习生(上海/北京)  1.卷积正向和反向传播  2.Caffe源码  3.斐波那契 memcpy  4.pooling反向  5.项目介绍  6.override overload 纯虚函数等  阿里巴巴 - 2017.3.23 - 实习生 - idst - 非内推  1.linux 修改环境变量  2.sql语句  3.gbdt xgboost区别  4.kaggle项目 30min  5.融合方法，改进  阿里巴巴 - 2017.3.28 - 实习生 - 淘宝搜索 - 内推一面  1.项目介绍(30分钟)—项目过程，融合方法，训练方法，augmentation等  2.batch normalization  3.有没有了解其他机器学习算法  4.介绍一个熟悉的算法(决策树)  5.在线写线性回归  6.对深度学习框架有没有了解，还是只是停留在使用的层面  7.有没有什么想问的  阿里巴巴 - 2017.3.31 - 实习生 - 淘宝搜索 - 内推二面  1.项目介绍  2.kd-tree  3.开放问题  100w商品 50个推荐窗口，怎么安排推荐  腾讯 - 2017.4.10 - 实习生非内推 - 优图实验室 - 一面  1.项目介绍  2.计算卷积核参数数量  3.如何处理深度学习overfitting  4.如何在测试中，加速1000倍(不改变网络结构)  5.pooling层的作用，以及为什么会选择maxpooling  6.有没有从头开始训练一个模型 vgg16 resnet googlenet收敛问题  今日头条 - 2017.4.11 - 日常实习生非内推 - 一面  1.项目介绍  2.如何训练深度学习网络  3.如何处理样本分布不均衡的问题  4.手写代码-反转链表  5.手写代码-前序遍历  今日头条 - 2017.4.11 - 日常实习生非内推 - 二面  1.项目介绍（为什么不尝试xgboost以外的模型）  2.xgboost gbdt区别  3.深度学习训练方法  4.改进方法  5.caffe框架结构  6.手写代码-旋转数组找出最大数字  今日头条 - 2017.4.13 - 日常实习生非内推 - 三面  1.前两面反应较好，聊天  2.对前两个面试官有什么看法  3.有什么问题  #腾讯挺坑的，一面过了，二面面试官打电话确认了面试时间，收到了确认邮件，然后鸽了  腾讯游戏 - 校招内推 - 一面  1.实习介绍  2.介绍svm，为什么要求对偶  3.介绍一个熟悉的算法  4.全局变量 局部变量存储位置不同，静态变量初始化，生存周期  5.python多线程的实现，死锁  6.优化算法 sgd 牛顿法。为什么牛顿法快？及其缺点？  网易 - 内推校招 - 人工智能事业部 - 一面  1.实习介绍  2.kaggle 深度学习项目介绍  3.几个框架对比  4.模型融合策略和方法  网易 - 内推校招 - 人工智能事业部 - 二面  1.项目介绍，讲你最好的项目  2.实习介绍  3.svm手推  4.kaggle融合的策略和方法  #前3面反映较好，加面  网易 - 内推校招 - 人工智能事业部 - special 加面  1.最好的项目介绍  2.batch normalization算法  3.实习经历  4.cnn现在发展以及不足  5.说对游戏ai感兴趣 - alphago的技术点，强化学习等  华为 - 内推校招 - 1,2,3面  #略  #Nvidia Deeplearning software 面试官很客气，提前定好这次面试时长40分钟  Nvidia - 内推校招 - 一面  1.项目介绍 30min  2.编程题2道  3.过拟合欠拟合 以及其背后本质，偏差方差角度如何理解  #Sensetime 商汤科技 每面30min  #号称最难进公司之一？  Sensetime - 2017.9.11 - 校招内推 - 计算机视觉&amp;深度学习 - 一面  1.kaggle比赛 问的比较详细  包括 data augmentation， KNN的trick， 模型融合等  2.实习经历  3.有什么问题  Sensetime - 2017.9.11 - 校招内推 - 计算机视觉&amp;深度学习 - 二面  1.kaggle比赛  2.头条实习  3.python set-list转化  4.caffe框架结构，learning rate设置  5.第K大的数  6.sgd adam区别  7.resnet vgg区别  8.python 变量拷贝规则  9.有什么要问的  Sensetime - 2017.9.11 - 内推校招 计算机视觉&amp;深度学习 - 三面  1.头条实习 比较详细以及为什么头条推荐这么厉害 #面试官是在做dl+推荐，所以比较关心头条所做的东西  2.熟悉什么框架  3.喜欢什么方向，cv还是推荐等，以及个人认为他们的前景  4.学术型硕士还是工程型硕士？  5.有什么问题  阿里巴巴 - 2017.9.13 - 校招 - 初面  1.头条实习 ——- 特征维度，为什么时延很低，在头条做了哪些，头条的算法  2.深度学习和传统机器学习  3.深度学习最近的发展和技术突破点  4.GBDT是什么 — 加法模型  5.为什么现在推荐可以使用GBDT的内部结点当做LR的特征 — 特征选择和子集评价，还是stack模型融合？  6.RF GBDT区别 — 方差偏差理论，bagging&amp;boost区别  7.GBDT xgboost区别 —泰勒二阶，并行化，正则项  8.手写MergeSort  9.熟悉什么语言  10.用什么框架  11.深度学习正则化  12.GBDT分布式如何实现 #没有了解过，然后简单说了自己的想法，面试官给我讲了许多这方面  阿里巴巴 - 2017.9.15 - 校招 - 终面  1.头条实习 ——- 模型介绍  2.GBDT xgboost区别  3.kaggle比赛  4.一个整数数组中，寻找3个数乘积最大  5.GBDT与bagging等方法区别  6.linux常用指令 sort grep等  阿里巴巴 - 2017.9.15 - 校招 - 加面  #压力面？  1.头条实习ffm替换skip gram模型，为什么？效果如何？为什么会有提速效果？线上如何部署等  2.头条所做？训练两个大模型，效果如何？  3.kaggle比赛  4.vgg16 resnet googlenet区别  5.手写代码-旋转数组找出最小数字  #其余记不清了  大疆 - 2017.9.17 - 校招 - 初面  1.头条实习  2.kaggle项目</p><h1 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h1><p><a href="http://www.cnblogs.com/mrxsc/articles/6266584.html" target="_blank" rel="noopener">http://www.cnblogs.com/mrxsc/articles/6266584.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/29633019" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29633019</a></p><p>【链接】依图面试经历（三轮面试，已得offer）<br><a href="https://zhuanlan.zhihu.com/p/27842581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27842581</a></p><p><a href="https://www.nowcoder.com/discuss/73739" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/73739</a></p><p><a href="https://zhuanlan.zhihu.com/p/38067051" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38067051</a></p><p>【链接】依图科技暑期实习生面试经验<br><a href="https://blog.csdn.net/wslf123/article/details/79924413" target="_blank" rel="noopener">https://blog.csdn.net/wslf123/article/details/79924413</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SSD-Single Shot MultiBox Detector</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-SSD-ECCV2016/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-SSD-ECCV2016/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> SSD: Single Shot MultiBox Detector<br><strong>作者:</strong> Wei Liu, Dragomir Anguelov, Dumitru Erhan</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>(1) 在不同层的feature map上使用网格法获取候选区域:</strong></p><p>某种程度上SSD可以看做是YOLOv1和FasterRCNN的结合, 在不同layer的输出的不同尺度的feature map上划格子, 在格子上利用<code>anchor</code>思想. 因此, . (YOLOv2也使用了Anchor的思想)</p><p><strong>(2) 使用了数据增广, 难样例挖掘, atrous算法等trick大幅度提升精度和速度</strong><br>这个其实算不上亮点, 只不过作者确实使用这些技术提升性能不少</p><p><strong>(3) 相对于那些需要object proposals的两阶段模型, SSD方法全完取消了 proposals generation, pixel resampling 或者 feature resampling 这些阶段</strong></p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>目前, 虽然Faster RCNN取得了很好的检测精度, 但是对于普通设备来说, Faster RCNN过于庞大, 计算时间太久, 不足以达到实时监测. YOLO虽然速度很快, 但是精度太低了, 达不到基本要求.</p><p>SSD的出现正是为了解决这些问题, 确定在不丢失过度精度的前提下, 提升检测的速度.</p><h2 id="Single-Shot-Detector-SSD"><a href="#Single-Shot-Detector-SSD" class="headerlink" title="Single Shot Detector(SSD)"></a>Single Shot Detector(SSD)</h2><p><img src="https://wx1.sinaimg.cn/mw1024/d7b90c85ly1fwb7fnbsu4j20oj09bgq8.jpg" alt=""></p><p>根据上图, 简单说一下SSD的关键要素</p><ul><li>输入: 图像以及每个物体对应的ground truth boxes</li><li>多特征图谱的anchor思想: 在不同尺度的特征图谱上(如上图的4×4和8×8), 对每个位置上设置多个具有不同大小和长宽比的boxes, 称之为 <strong>default boxes</strong>.</li><li>输出: 对于每一个default box, 都会输出4个相对位移用于边框回归, 同时会输出所有类别的预测概率</li><li>匹配: 在预测阶段, 需要将这些 <strong>defaults boxes</strong> 与 <strong>gt boxes</strong> 匹配. 在上图中, 最终有两个框(蓝色)与猫所在框匹配, 有一个框(红色)与狗所在框匹配. 这三个框被标记为正样本, 其余剩下的框都被标记为负样本. (可见负样本数量远远大于正样本数量)</li><li>损失函数: 边框回归损失(Smooth L1) 和 类别置信度损失(softmax 交叉熵损失) 的权重和.</li></ul><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>SSD 会产生固定数量的bounding box, 以及每个bounding box的各个类别的预测概率, 最后会使用NMS算法生成罪最终的检测结果.</p><p><strong>多尺度feature map:</strong> 在卷积网络的不同卷积层后面添加convolutional feature layers, 并且在每一层中都会进行检测任务.</p><p><strong>Convolutional predictors for detection:</strong> 每一个添加的特征层(或者在基础网络里的特征层), 都可以使用一系列的卷积核产生固定大小的predictions, 如图2所示. 对于一个大小为 $m\times n$, 具有 $p$ 通道的特征层, 使用的卷积核就是 $3\times 3\times p$ , 之后会产生相对于 default box 的预测坐标, 已经每一类的预测置信度. 对于特征图上 $m\times n$个位置, 在对每个位置使用卷积核之后, 都会产生一个输出值. (YOLO架构则是用一个全连接层来代替这里的卷积层)</p><p><strong>Default boxes and aspect ratios:</strong> 每一个feature map的cell都会与一系列 default bounding box 相关联. 对于每一个cell来说, 模型会预测与之关联的 default bounding box 相对于该cell的偏移量, 同时会预测这些boxes对应的每一类的出现概率. 具体来说, 对于一个位置上的 $k$ 个boxes中的每一个box, 都会计算出这个box的4个相对位移值 $c$ 个类别的score. 因此, 对于一个feature map来说, 总共需要 $(c+4)\times k$ 个卷积核, 最终该对于大小为 $m\times n$ 的 feature map来说, 其输出结果数量为: $(c+4)\times k\times m\times n$.</p><p><img src="https://wx2.sinaimg.cn/mw1024/d7b90c85ly1fwbhhr03m4j216z0rtdmo.jpg" alt=""></p><h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>SSD与二阶段检测方法在训练时的区别: SSD训练图像中的GT信息需要赋予到那些固定输出的boxes上面(也就是说不仅要使用bounding box的坐标, 还有把类别标签也与每一个box绑定, 这种方法在YOLO, FasterRCNN(只分前后景), MultiBOx中都有用到).</p><p><strong>Matching strategy:</strong></p><p>只要预测框与gt box之间的 jaccard overlap(就是交并比) 大于一个阈值(0.5), 就认为是配对成功, 反之, 认为是背景.</p><p><strong>Training objective:</strong></p><p>SSD的损失函数源自于MultiBox的损失函数, 但是SSD对其进行拓展, 使其可以处理多个目标类别.  用 $x_{ij}^p={1,0}$ 表示第 $i$ 个default box 与类别 $p$ 的第 $j$ 个gt box匹配, 否则若不匹配的话, 则 $x_{ij}^p = 0$.</p><p>根据上面的策略, 一定会有 $\sum_i x_{ij}^p &gt;1 $ 的情况出现, 意味着对于第 $j$ 个gt box, 很有可能有多个default box与之匹配.</p><p>总的目标函数是由Localization loss(loc) 和 confidence loss(conf) 的加权求和得到的:</p><script type="math/tex; mode=display">L(x,c,l,g) = \frac{1}{N} (L_{conf}(x,c) + \alpha L_{loc}(x,l,g))</script><p>式中:</p><ul><li>$N$是与ground truth box 相匹配的 default boxes个数(如果N为0, 则将该项loss设为0)</li><li>localization loss(loc) 是 Fast RCNN 中的Smooth L1 loss, 用于对bounding box进行回归, 与Faster RCNN一样, 我们会将真实的gt box坐标值转换成相对于default box( $d$ )中心 $(cx,cy)$ 的偏移量和缩放度, 预测的时候也是对偏移量和缩放度进行预测:</li></ul><script type="math/tex; mode=display">L_{loc}(x,l,g) = \sum_{i\in Pos}^N \sum_{m\in\{cx,cy,w,h\}} x_{ij}^k smooth_{L_1}(l_i^m - \hat g_j^m)</script><ul><li>confidence loss(conf) 是 Softmax 交叉熵loss</li></ul><script type="math/tex; mode=display">L_{conf}(x,c) = -\sum_{i\in Pos}^N x_{ij}^p log(\hat c_i^p) - \sum_{i\in Neg} log(\hat c_i^0), 其中, \hat c_i^p = \frac{exp(c_i^p)}{\sum_p exp(c_i^p)}</script><ul><li>权重项 \alpha, 默认设置为1.</li></ul><p><strong>Choosing scales and aspect ratios for default boxes:</strong></p><p>大部分CNN网络在越深的层, feature map的尺寸会越来越小, 这样做不仅仅是为了减少计算与内存的需求, 还有个好吃就是, feature map往往具有一定程度的平移和尺度不变性.</p><p>为了处理不同尺度的物体, OverFeat和SPPNet都是通过在feature map上进行不同尺度的pooling, 然后再将这些pooling综合进行获取固定长度的特征向量输出.</p><p>SSD采用的策略是使用同一个网络中不同层的feature map, 这些feature map也是不同尺度的, 同时也具有共享参数的好处. 本文使用了 8×8 和 4×4 大小的feature map 来进行目标检测.</p><p>假如feature maps数量为 $m$, 那么每一个feature map中的default box的尺寸大小计算如下:</p><script type="math/tex; mode=display">s_k = s_{min} + \frac{s_{max} - s_{min}}{m-1}(k-1), k\in [1,m]</script><p>上式中, $s_{min} = 0.2 , s_{max} = 0.95$, 然后, 截个不同的aspect ratio, 用 $a_r$ 表示: $a_r = {1,2,3,1/2,1/3}$, 则每一个default boxes 的width 和height就可以得到:</p><script type="math/tex; mode=display">w_k^a = s_k \sqrt{a_r}</script><script type="math/tex; mode=display">h_k^a = \frac{s_k}{\sqrt {a_r}}</script><p>每一个default box的中心, 设置为: $(\frac{i+0.5}{|f_k|}, \frac{j+0.5}{f_k})$, 其中, $|f_k|$ 是第k个feature map的大小.</p><p>这种多尺度的feature maps策略, 可以适应不同大小的物体的检测, 如下图, 对于体积较小的猫来说, 它会与 8×8 feature map 的default box匹配, 而对于体积较大的狗来说, 它会与 4×4 feature map 的default box 匹配, 而其余的都会被看做是负样本.</p><p><strong>Hard negative mining:</strong></p><p>在一系列的matching之后, 大多数default boxes都会被认为是负样本. 这会导致正负样本不均衡问题. 对于, SSD会将所有的负样本按照scores loss的高低进行排序(损失高的优先级在前), 然后每次只选择顶端的负样本进行训练, 负样本与正样本之间的比例为 3:1.</p><p><strong>Data augmentation:</strong></p><p>为了增强对物体多尺度和形状的鲁棒性, 对于每一张训练数据, 会随机使用下列数据增广技术:</p><ul><li>使用整张图片</li><li>采样一个patch (这里的patch我认为就是裁剪子区域的感觉), 使其与物体之间的最小交并比为0.1, 0.3, 0.5, 0.7, 0.9</li><li>随机采样一个patch</li></ul><p>采样的patch与原始图像大小的比例为[0.1, 1], aspect ratio在 0.5 到 2 之间. 当gt box的中心出现在采样的patch中时, 我们保留重叠部分. 在这些采样步骤之后, 每一个采样的patch被resize到固定的大小, 并且以0.5的概率被水平翻转.</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul><li>hole filling algorithm??//TODO</li><li>SSD模型对于bounding box的size非常敏感, 也就是说, SSD对于小物体目标较为敏感, 在检测小物体目标上表明交差, 主要也是因为对于小目标而言, 经过多层卷积之后, 剩余信息过少导致的.</li><li>数据增广对于结果的提升非常明显</li><li>多feature map对结果的提升是有很大帮助的</li><li>使用较多的default boxes, 效果较好(但也不能太多)</li><li>atrous: atrous是精度有一定提高, 同时对速度有很大提高(约20%)</li></ul><p><strong>Inference time:</strong></p><p>SSD会山城大量的bounding boxes, 使用NMS算法只留下top200 (这一步SSD300在VOC20类的每张图像上, 需耗时2.2msec)</p><p><img src="https://wx1.sinaimg.cn/mw1024/d7b90c85ly1fwbl46szs0j213m0ewag3.jpg" alt=""></p><p>上图看起来SSD300比YOLO还要快, 但实际上YOLO的网络层数是24层, 而SSD的层数是12层, 这样比起来有点不太公平( 但是层数多居然精度没SSD高, 这也值得吐槽, 但但是个人觉得这是因为YOLOv1的设计比较粗糙, 很多trick没有使用导致的, 所以看看YOLOv2, 和YOLOv3的版本, 结果还是挺不错的)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机视觉-模型结构汇总</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ethereon.github.io/netscope/quickstart.html" target="_blank" rel="noopener">https://ethereon.github.io/netscope/quickstart.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>STL之priority_queue</title>
      <link href="/z_post/Cpp-STL%E4%B9%8Bpriority-queue/"/>
      <url>/z_post/Cpp-STL%E4%B9%8Bpriority-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义排序方法"><a href="#自定义排序方法" class="headerlink" title="自定义排序方法"></a>自定义排序方法</h1><p>优先出列时会对 <code>!cmp</code> 判定, 所以如果希望小的在前, 那么就应该返回 <code>元素1 &gt; 元素2</code></p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> <span class="keyword">const</span></span>&#123; <span class="comment">// 仿函数</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b ; <span class="comment">// 排序后, 小的在前</span></span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Cpp-Book-STL源码剖析</title>
      <link href="/z_post/Cpp-Book-STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/z_post/Cpp-Book-STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="4-8-priority-queue"><a href="#4-8-priority-queue" class="headerlink" title="4.8 priority_queue"></a>4.8 priority_queue</h2><h3 id="4-8-1-priority-queue-概述"><a href="#4-8-1-priority-queue-概述" class="headerlink" title="4.8.1 priority_queue 概述"></a>4.8.1 priority_queue 概述</h3><p>priority_queue 首先是一个队列, 因此它允许在底端加入元素, 并从顶端取出元素, 除此之外别无其他存取元素的途径. priority_queue带有权值观念, 其内部的元素并非依照插入顺序排序, 而是按照元素的权值进行排列, 权值较高者, 排在最前面.</p><p>缺省情况下 priority_queue 利用一个 max-heap 完成, 也即 <code>top()</code> 元素表示的是队列中值最大的元素.</p><h3 id="4-8-2-priority-queue-定义完整列表"><a href="#4-8-2-priority-queue-定义完整列表" class="headerlink" title="4.8.2 priority_queue 定义完整列表"></a>4.8.2 priority_queue 定义完整列表</h3><p>priority_queue 的实现在缺省情况下是以 vector 为底部容器, 再加上 heap 相关处理规则, 所以其实现非常简单, 也因此, 我们通常并不认为 priority_queue 并非是一种新的容器, 而只是把它归类为 container adapter(容器配接器).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// priority_queue 内部完整实现</span></span><br></pre></td></tr></table></figure><h3 id="4-8-3-priority-queue-没有迭代器"><a href="#4-8-3-priority-queue-没有迭代器" class="headerlink" title="4.8.3 priority_queue 没有迭代器"></a>4.8.3 priority_queue 没有迭代器</h3><p>由于 priority_queue 只有顶端元素 (权值最高者) 才有机会被外界使用, 因此, priority_queue 不提供遍历功能, 也不提供迭代器.</p><h3 id="4-8-4-priority-queue-测试实例"><a href="#4-8-4-priority-queue-测试实例" class="headerlink" title="4.8.4 priority_queue 测试实例"></a>4.8.4 priority_queue 测试实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Detectron源码解读-roidb数据结构</title>
      <link href="/z_post/Caffe2-Detectron-roidb%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/z_post/Caffe2-Detectron-roidb%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="roidb数据结构"><a href="#roidb数据结构" class="headerlink" title="roidb数据结构"></a>roidb数据结构</h1><p>roidb的类型是<code>list</code>, 其中的每个元素的数据类型都是<code>dict</code>, roidb列表的长度为数据集的数量(即图片的数量), roidb中每个元素的详细情况如下表所示:</p><div class="table-container"><table><thead><tr><th><code>for entry in roidb</code></th><th>数据类型</th><th>详细说明</th></tr></thead><tbody><tr><td><code>entry[&#39;id&#39;]</code></td><td>int</td><td>代表了当前image的img_id</td></tr><tr><td><code>entry[&#39;file_name&#39;]</code></td><td>string</td><td>表示当前图片的文件名(带有.jpg后缀)</td></tr><tr><td><code>entry[&#39;dataset&#39;]</code></td><td>string</td><td>指明所属的数据集?</td></tr><tr><td><code>entry[&#39;image&#39;]</code></td><td>string</td><td>当前image的文件路径</td></tr><tr><td><code>entry[&#39;flipped&#39;]</code></td><td>bool</td><td>当前图片是否进行翻转</td></tr><tr><td><code>entry[&#39;height&#39;]</code></td><td>int</td><td>当前图片的高度</td></tr><tr><td><code>entry[&#39;width&#39;]</code></td><td>int</td><td>当前图片的宽度</td></tr><tr><td><code>entry[&#39;has_visible_keypoints&#39;]</code></td><td>bool</td><td>是否含有关键点</td></tr><tr><td><code>entry[&#39;boxes&#39;]</code></td><td>float32, numpy数组(num_objs, 4)</td><td>num_objs为当前图片中的目标物体个数, 4代表bbox的坐标</td></tr><tr><td><code>entry[&#39;segms&#39;]</code></td><td>二维列表[[],[],…]</td><td>列表中每个元素都还是一个列表, 其中存储着每个物体的ploygon实例标签</td></tr><tr><td><code>entry[&#39;gt_classes&#39;]</code></td><td>int32, numpy数组(num_objs)</td><td>指明当前图片中每一个obj的真实类别</td></tr><tr><td><code>entry[&#39;seg_areas&#39;]</code></td><td>float32, numpy数组(num_objs)</td><td>代表当前图片中每一个obj的掩膜面积</td></tr><tr><td><code>entry[&#39;gt_overlaps&#39;]</code></td><td>float32, scipy.sparse.csr_matrix数据(num_objs, 81)</td><td>代表每一个obj与81个不同类别的overlap</td></tr><tr><td><code>entry[&#39;is_crowd&#39;]</code></td><td>bool, numpy数组(num_objs)</td><td>代表当前掩膜是否为群落</td></tr><tr><td>entry[‘box_to_gt_ind_map’]</td><td>int32, numpy数组(num_objs)</td><td>该列表存储着box的顺序下标值, 同样是一维数组, 直接拼接,将每一个roi映射到一个index上, index是在entry[‘gt_classes’]&gt;0的rois列表的下标</td></tr></tbody></table></div><h1 id="combined-roidb-for-training-方法"><a href="#combined-roidb-for-training-方法" class="headerlink" title="combined_roidb_for_training() 方法"></a><code>combined_roidb_for_training()</code> 方法</h1><p>在目标检测类任务中, 有一个很重要的数据结构roidb, 它将作为基本的数据结构在数据队列中存在, Detectron 的数据载入类 <code>RoIDdataLoader</code> 也是将该数据结构作为成员变量使用的, 因此, 有必要对这个数据结构展开分析.</p><p>首先, 在运行训练脚本时, 就会调用到 <code>detectron/utils/train.py</code> 中的 <code>train()</code>函数, 而<code>train()</code>函数内部又会调用当前文件的<code>add_model_training_inputs()</code> 函数, 在这个函数内部, 就会调用到 <code>detectron/datasets/roidb</code> 文件中的 <code>combined_roidb_for_training()</code> 函数, 该函数的返回值正是<code>roidb</code>, 这是贯穿整个训练过程的训练数据, 故我们对此函数进行分析. 该函数代码解析如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/datasets/roidb.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载并连接一个或多个数据集的roidbs, along with optional object proposals</span></span><br><span class="line"><span class="comment"># 每个roidb entry都带有特定的元数据类型, 对其进行准备工作后进行训练</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combined_roidb_for_training</span><span class="params">(dataset_names, proposal_files)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_roidb</span><span class="params">(dataset_name, proposal_file)</span>:</span></span><br><span class="line">        <span class="comment"># 注意 dataset_name 没有 's'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># from detectron.datasets.json_dataset import JsonDataset</span></span><br><span class="line">        <span class="comment"># 可以看到, roidb 是利用JsonDataset类对象的get_roidb()方法获取的</span></span><br><span class="line">        <span class="comment"># 因此, 我们先在下面看一下这个类的实现细节</span></span><br><span class="line">        ds = JsonDataset(dataset_name)</span><br><span class="line">        roidb = ds.get_roidb(</span><br><span class="line">            gt=<span class="keyword">True</span>,</span><br><span class="line">            proposal_file=proposal_file,</span><br><span class="line">            crowd_filter_thresh=cfg.TRAIN.CROWD_FILTER_THRESH</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> cfg.TRAIN.USE_FLIPPED:</span><br><span class="line">            logger.info(<span class="string">"Appending horizontally-flipped training examples..."</span>)</span><br><span class="line">            extend_with_flipped_entries(roidb, ds)</span><br><span class="line">        logger.info(<span class="string">"Loaded dataset: &#123;:s&#125;"</span>.format(ds.name))</span><br><span class="line">        <span class="keyword">return</span> roidb</span><br><span class="line">    <span class="keyword">if</span> isinstance(dataset_names, basestring):</span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure><h1 id="get-roidb-方法"><a href="#get-roidb-方法" class="headerlink" title="get_roidb() 方法"></a><code>get_roidb()</code> 方法</h1><p>在上面的函数中我们可以发现, <code>combined_roidb_for_training</code>函数内部又定义了另一个函数<code>get_roidb()</code>, 而该函数主要是基于<code>detectron/datasets/json_dataset.py</code>中的<code>JsonDataset</code>类及该类的成员方法<code>get_roidb</code>实现的, 因此, 我们先跳到<code>json_dataset.py</code>文件中去看看这个类的内部实现是怎样的:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/datasets/json_dataset.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonDataset</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 这个类的设计主要是基于COCO的json格式数据集</span></span><br><span class="line">    <span class="comment"># 当我们需要训练自己的数据集时, 最好的方式就是将自己的数据集的格式改为</span></span><br><span class="line">    <span class="comment"># COCO数据集的json格式, 这样一来, 我们就无需重写数据载入代码了.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> dataset_catalog.contains(name), \</span><br><span class="line">            <span class="string">"Unknown dataset name: &#123;&#125;"</span>.format(name)</span><br><span class="line">        <span class="keyword">assert</span>...</span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 准备数据集的类别信息</span></span><br><span class="line">        category_ids = self.COCO.getCatIds() <span class="comment"># 1~80, 对应80个类</span></span><br><span class="line">        <span class="comment"># coco的loadCats函数, 必须指定需要加载的cat的id, 否则返回空列表</span></span><br><span class="line">        <span class="comment"># 若指定后, 则返回id对应的类别信息, 每个类别信息是一个字典, 包括'name','id','supercategory'三个字段</span></span><br><span class="line">        <span class="comment"># 获取每个类的名字, person, bicycle,bus等等, 返回的名字在列表中的位置与id在cat_ids列表中的位置一致</span></span><br><span class="line">        categories = [c[<span class="string">'name'</span>] <span class="keyword">for</span> c <span class="keyword">in</span> sefl.COCO.loadCats(category_ids)]</span><br><span class="line">        <span class="comment"># 建立类别的name 与 id之间的对应关系, 其中cat_name为key,cat_id为值</span></span><br><span class="line">        self.category_to_id_map = dict(zip(categories, category_ids)) <span class="comment"># 注意, 没有'__background__'</span></span><br><span class="line">        self.classes = [<span class="string">'__background__'</span>] + categories <span class="comment"># 将'__background__'添加到categories类别名字列表中</span></span><br><span class="line">        self.num_classes = len(self.classes)</span><br><span class="line">        <span class="comment"># coco下标最大值为90,但实际上只有80个类, 有的地方跳过了, 因此id不是连续的,</span></span><br><span class="line">        self.json_category_id_to_contiguous_id = &#123;</span><br><span class="line">            v: i + <span class="number">1</span> <span class="comment"># key为coco的非连续id, value为1~80的连续id, 均为整数</span></span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(self.COCO.getCatIds())</span><br><span class="line">        &#125;</span><br><span class="line">        self.contiguous_category_id_to_json_id = &#123;</span><br><span class="line">            v: k <span class="comment"># key为1~80的连续id, value为coco的非连续id, 均为整数</span></span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> self.json_category_id_to_contiguous_id.items()</span><br><span class="line">        &#125;</span><br><span class="line">        self._init_keypoints() <span class="comment"># 调用类内的keypoints初始化方法.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_roidb</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        gt=False,</span></span></span><br><span class="line"><span class="function"><span class="params">        proposal_file=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        min_proposal_size=<span class="number">2</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        proposal_limit=<span class="number">-1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        crowd_filter_thresh=<span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回json dataset对应的roidb数据, 提供以下四种选项:</span></span><br><span class="line"><span class="string">        - 在roidb中包含gt boxes</span></span><br><span class="line"><span class="string">        - 添加位于proposal file里面的特定proposals</span></span><br><span class="line"><span class="string">        - 基于最短边长的proposals过滤器</span></span><br><span class="line"><span class="string">        - 基于群落区域交集的proposals过滤器</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> gt <span class="keyword">is</span> <span class="keyword">True</span> <span class="keyword">or</span> crowd_filter_thresh == <span class="number">0</span>, \</span><br><span class="line">            <span class="string">"Crowd filter threshold must be 0 if gt "</span> \</span><br><span class="line">            <span class="string">"annotations are not included."</span></span><br><span class="line">        <span class="comment"># 这里调用了COCO的官方API, 关于COCO数据集的结构和标注格式解析, 可以查看我的另一篇文章</span></span><br><span class="line">        <span class="comment"># 没有指定筛选条件, 获取数据集标签中所有的图片id</span></span><br><span class="line">        image_ids = self.COCO.getImgIds()</span><br><span class="line">        image_ids.sort() <span class="comment"># 将id按照从小到大的顺序排列</span></span><br><span class="line">        <span class="comment"># roidb为列表结构, 列表中的每一项是一个字典, 代表着对应imageid的标签内容.</span></span><br><span class="line">        <span class="comment"># 键值包括:coco_url, license, width, filename, height, flickr_url, id, date_captured</span></span><br><span class="line">        roidb = copy.deepcopy(self.COCO.loadImgs(image_ids))</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> roidb:</span><br><span class="line">            <span class="comment"># 调用了本类的私有函数 _prep_roidb_entry(), entry为字典.</span></span><br><span class="line">            <span class="comment"># 主要是为entry赋初值, 占位符等等, 包含box, segms,等各种字段, 详细信息可以看下面的函数解析</span></span><br><span class="line">            <span class="comment"># 注意, 这里的字段值都是预测值相关的值, 因此也会局域gt_overlap等字段</span></span><br><span class="line">            self._prep_roidb_entry(entry)</span><br><span class="line">        <span class="keyword">if</span> gt:</span><br><span class="line">            <span class="comment"># 如果参数声明是gt信息, 则会调用_add_gt_annotations</span></span><br><span class="line">            <span class="comment"># 访问标注文件, 以便添加相关字段信息, 具体看下面的相关函数解析</span></span><br><span class="line">            self.debug_timer.tic()</span><br><span class="line">            <span class="keyword">for</span> entry <span class="keyword">in</span> roidb:</span><br><span class="line">                <span class="comment"># 注意, 是单独对每个entry调用该函数, 因此每次会载入指定imgid的相关标签</span></span><br><span class="line">                <span class="comment"># 关于_add_gt_annotations函数具体解析可以看后面的部分</span></span><br><span class="line">                self._add_gt_annotations(entry)</span><br><span class="line">            logger.debug(</span><br><span class="line">                <span class="string">'_add_gt_annotations took &#123;:.3f&#125;s'</span>.</span><br><span class="line">                format(self.debug_timer.toc(average=<span class="keyword">False</span>))</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">if</span> proposal_file <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.debug_timer.tic()</span><br><span class="line">            <span class="comment"># 加载proposals文件到roidb中, 关于此函数的详细解析可以看后文</span></span><br><span class="line">            self._add_proposals_from_file(</span><br><span class="line">                roidb, proposal_file, min_proposal_size, proposal_limit,</span><br><span class="line">                crowd_filter_thresh</span><br><span class="line">            )</span><br><span class="line">            logger.debug(</span><br><span class="line">                <span class="string">'_add_proposals_from_file took &#123;:.3f&#125;s'</span>.</span><br><span class="line">                format(self.debug_timer.toc(average=<span class="keyword">False</span>))</span><br><span class="line">            )</span><br><span class="line">        <span class="comment"># 类外部的函数, 用于计算与每个roidb相关的box的类别</span></span><br><span class="line">        _add_class_assignments(roidb)</span><br><span class="line">        <span class="keyword">return</span> roidb</span><br></pre></td></tr></table></figure><h1 id="prep-roidb-entry-方法"><a href="#prep-roidb-entry-方法" class="headerlink" title="_prep_roidb_entry() 方法"></a><code>_prep_roidb_entry()</code> 方法</h1><p>数据准备函数 <code>_prep_roidb_entry()</code> 的实现解析<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/datasets/json_dataset.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonDataset</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(...)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_roidb</span><span class="params">(...)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="comment"># 该函数主要将空的元数据添加到roidb entry中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_prep_roidb_entry</span><span class="params">(self, entry)</span>:</span></span><br><span class="line">        <span class="comment"># entry的'dataset'关键字, 值为self.</span></span><br><span class="line">        entry[<span class="string">'dataset'</span>] = self</span><br><span class="line">        im_path = os.path.join(self.image_directory, self.image_prefix+entry[<span class="string">'file_name'</span>])</span><br><span class="line">        <span class="keyword">assert</span> os.path.exists(im_path), <span class="string">"Image \"&#123;&#125; \" not found"</span>.format(im_path)</span><br><span class="line">        <span class="comment"># entry的'image'关键字, 值为当前imageid对应的image路径</span></span><br><span class="line">        entry[<span class="string">'image'</span>] = im_path</span><br><span class="line">        entry[<span class="string">'flipped'</span>] = <span class="keyword">False</span> <span class="comment"># 禁止反转</span></span><br><span class="line">        entry[<span class="string">'has_visible_keypoints'</span>] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下面entry键的对应值均为空, 暂为占位键</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># entry的'boxes'关键字,值为n×4的numpy数组, n代表box的数量,这里暂时为0</span></span><br><span class="line">        entry[<span class="string">'boxes'</span>] = np.empty((<span class="number">0</span>,<span class="number">4</span>), dtype=np.float32)</span><br><span class="line">        entry[<span class="string">'segms'</span>] = [] <span class="comment"># entry的'segms'关键字, 值为一个列表,暂时为空</span></span><br><span class="line">        <span class="comment"># entry的'gt_classes'关键字, 是个一维数组, 维度与box的数量n对应,暂时为0</span></span><br><span class="line">        entry[<span class="string">'gt_classes'</span>] = np.empty((<span class="number">0</span>), dtype=np.int32)</span><br><span class="line">        <span class="comment"># 代表掩膜的面积, 供n项, 与boxes数目相对</span></span><br><span class="line">        entry[<span class="string">'seg_areas'</span>] = np.empty((<span class="number">0</span>), dtype=np.float32)</span><br><span class="line">        <span class="comment"># TODO, 这里是一个矩阵压缩, 矩阵大小为n×c, c为类别数量, 没太搞懂要压缩成什么?</span></span><br><span class="line">        entry[<span class="string">'gt_overlaps'</span>] = scipy.sparse.csr_matrix(</span><br><span class="line">            np.empty((<span class="number">0</span>, self.num_classes), dtype=np.float32)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 同样是n行1列, n与boxes数目对应, 表示是否为`一群物体`</span></span><br><span class="line">        entry[<span class="string">'is_crowd'</span>] = np.empty((<span class="number">0</span>), dtype=np.bool)</span><br><span class="line">        <span class="comment"># shape大小与roi相关, 将每一个roi映射到一个index上</span></span><br><span class="line">        <span class="comment"># index是在entry['gt_classes']&gt;0的rois列表的下标 TODO还是不太清楚映射关系</span></span><br><span class="line">        entry[<span class="string">'box_to_gt_ind_map'</span>] = np.empty((<span class="number">0</span>), dtype=np.int32)</span><br><span class="line">        <span class="comment"># 关键点信息, 默认情况下不设置</span></span><br><span class="line">        <span class="keyword">if</span> self.keypoints <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            entry[<span class="string">'gt_keypoints'</span>] = np.empty(</span><br><span class="line">                (<span class="number">0</span>, <span class="number">3</span>, self.num_keypoints), dtype=np.int32</span><br><span class="line">            )</span><br><span class="line">        <span class="comment"># 删除那些从json file中获取到的不需要的字段</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">'date_captured'</span>, <span class="string">'url'</span>, <span class="string">'license'</span>, <span class="string">'file_name'</span>]:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> entry:</span><br><span class="line">                <span class="keyword">del</span> entry[k]</span><br></pre></td></tr></table></figure></p><h1 id="add-gt-annotations-方法"><a href="#add-gt-annotations-方法" class="headerlink" title="_add_gt_annotations() 方法"></a><code>_add_gt_annotations()</code> 方法</h1><p>加载标注文件的函数 <code>_add_gt_annotations()</code>的实现解析<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/datasets/json_dataset.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonDataset</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(...)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_roidb</span><span class="params">(...)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_prep_roidb_entry</span><span class="params">(self, entry)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="comment"># 该函数将标注文件的元数据添加到roidb entry中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add_gt_annotations</span><span class="params">(self, entry)</span>:</span></span><br><span class="line">        <span class="comment"># 获取指定imgid的annid列表 (对应多个box)</span></span><br><span class="line">        ann_ids = self.COCO.getAnnIds(imgIds=entry[<span class="string">'id'</span>], iscrowd=<span class="keyword">None</span>)</span><br><span class="line">        <span class="comment"># 根据annids的id列表, 获取这些id对应的标注信息, objs是一个列表</span></span><br><span class="line">        <span class="comment"># 列表中的每一个元素都是一个字典,字典的内容是标注文件中的内容,包含bbox,segmentation等字段</span></span><br><span class="line">        objs = self.COCO.loadAnns(ann_ids)</span><br><span class="line">        <span class="comment"># 下面的代码会对bboxes进行清洗, 因为有些是无效的数据</span></span><br><span class="line">        valid_objs=[] <span class="comment"># 存储有效的objs</span></span><br><span class="line">        valid_segms=[] <span class="comment"># 存储有效的segms</span></span><br><span class="line">        width = entry[<span class="string">'width'</span>] <span class="comment"># 获取entry中的width字段, 代表图片的宽度</span></span><br><span class="line">        height = entry[<span class="string">'height'</span>] <span class="comment"># 获取entry中的height字段, 代表图片的高度</span></span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> objs:</span><br><span class="line">            <span class="comment"># crowd区域采用RLE编码</span></span><br><span class="line">            <span class="comment"># import detectron.utils.segms as segm_utils</span></span><br><span class="line">            <span class="comment"># 用于判断当前的segmentation是polygon编码还是rle编码, 前者是列表类型, 后者是字典类型</span></span><br><span class="line">            <span class="comment"># 返回True为polygon编码, 返回Fasle为rle编码</span></span><br><span class="line">            <span class="keyword">if</span> segm_utils.is_poly(obj[<span class="string">'segmentation'</span>]):</span><br><span class="line">                <span class="comment"># poly编码必须含有&gt;=3个点才能组成一个多边形, 因此需要&gt;=6个坐标点</span></span><br><span class="line">                <span class="comment"># 类似于这样的检查操作只在PLOYGON中存在, 在面对RLE时无需检查, 可以直接接受后面的检查</span></span><br><span class="line">                obj[<span class="string">'segmentation'</span>] = [</span><br><span class="line">                    p <span class="keyword">for</span> p <span class="keyword">in</span> obj[<span class="string">'segmentation'</span>] <span class="keyword">if</span> len(p) &gt;=<span class="number">6</span></span><br><span class="line">                ]</span><br><span class="line">            <span class="keyword">if</span> obj[<span class="string">'area'</span>] &lt; cfg.TRAIN.GT_MIN_AREA:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 如果面积不达标, 则认为该标注无效, 不将其加入valid列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">'ignore'</span> <span class="keyword">in</span> obj <span class="keyword">and</span> obj[<span class="string">'ignore'</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># import detectron.utils.boxes as box_utils</span></span><br><span class="line">            <span class="comment"># 将[x1,y1,w,h]的边框格式转换成[x1,y1,x2,y2]的格式</span></span><br><span class="line">            x1, y1, x2, y2 = box_utils.xywh_to_xyxy(obj[<span class="string">'bbox'</span>])</span><br><span class="line">            <span class="comment"># 将[x1,y1,x2,y2]的边框坐标限制在图片的[width,height]范围内, 防止越界</span></span><br><span class="line">            x1, y1, x2, y2 = box_utils.clip_xyxy_to_image(</span><br><span class="line">                x1, y1, x2, y2, height, width</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> obj[<span class="string">'area'</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> x2 &gt; x1 <span class="keyword">and</span> y2 &gt; y1: <span class="comment"># 若数据有效, 则加入到列表当中</span></span><br><span class="line">                obj[<span class="string">'clean_bbox'</span>] = [x1, y1, x2, y2]</span><br><span class="line">                valid_objs.append(obj)</span><br><span class="line">                valid_segms.append(obj[<span class="string">'segmentation'</span>]) <span class="comment"># 将数据的segms存在列表中(RLE/PLOYGON)</span></span><br><span class="line">        num_valid_objs = len(valid_objs) <span class="comment"># num_valid_objs持有objs的有效个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意, 下面的数据内容都被初始化为0</span></span><br><span class="line">        <span class="comment"># boxes为 有效objs数×4 的numpy数组, 用来表示每个objs的边框坐标</span></span><br><span class="line">        boxes = np.zeros((num_valid_objs,<span class="number">4</span>), dtype=entry[<span class="string">'seg_areas'</span>].dtype)</span><br><span class="line">        <span class="comment"># 每个objs的真实类别</span></span><br><span class="line">        gt_classes = np.zeros((num_valid_objs), dtype=entry[<span class="string">'gt_classes'</span>].dtype)</span><br><span class="line">        gt_overlaps = np.zeros( <span class="comment"># 形状为 有效objs数×num_class数 的numpy数组, 表示与每个类的IoU大小</span></span><br><span class="line">            (num_valid_objs, self.num_classes),</span><br><span class="line">            dtype=entry[<span class="string">'gt_overlaps'</span>].dtype</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 掩膜面积</span></span><br><span class="line">        seg_areas = np.zeros((num_valid_objs), dtype=entry[<span class="string">'seg_areas'</span>].dtype)</span><br><span class="line">        <span class="comment"># 是否crowd</span></span><br><span class="line">        is_crowd = np.zeros((num_valid_objs), dtype=entry[<span class="string">'is_crowd'</span>].dtype)</span><br><span class="line">        <span class="comment"># 这个是???</span></span><br><span class="line">        box_to_gt_ind_map = np.zeros(</span><br><span class="line">            (num_valid_objs), dtype=entry[<span class="string">'box_to_gt_ind_map'</span>].dtype</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> self.keypoints <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            gt_keypoints = np.zeros(</span><br><span class="line">                (num_valid_objs, <span class="number">3</span>, self.num_keypoints),</span><br><span class="line">                dtype=entry[<span class="string">'gt_keypoints'</span>].dtype</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 图片是否有可视的关键点?</span></span><br><span class="line">        im_has_visible_keypoints = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> ix, obj <span class="keyword">in</span> enumerate(valid_objs):<span class="comment"># ix为下标, obj为下标对应元素</span></span><br><span class="line">            <span class="comment"># category_id为coco类别id,json_category_id_to_contiguous_id 为字典类型</span></span><br><span class="line">            <span class="comment"># 其中, key为coco的非连续id, value为1~80的连续id, 均为整数, 所以这里是将coco的非连续id转换成对应的连续id</span></span><br><span class="line">            cls = self.json_category_id_to_contiguous_id[obj[<span class="string">'category_id'</span>]]</span><br><span class="line">            boxes[ix, :] = obj[<span class="string">'clean_box'</span>] <span class="comment"># 将当前obj的box填入boxes列表</span></span><br><span class="line">            gt_classes[ix] = cls <span class="comment"># 将连续id填入gt_classes列表</span></span><br><span class="line">            seg_areas[ix] = obj[<span class="string">'area'</span>] <span class="comment"># 将area填入seg_areas列表</span></span><br><span class="line">            is_crowd[ix] = obj[<span class="string">'iscrowd'</span>]</span><br><span class="line">            box_to_gt_ind_map[ix] = ix <span class="comment"># 该列表存储着box的顺序下标值</span></span><br><span class="line">            <span class="keyword">if</span> self.keypoints <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="comment"># ...</span></span><br><span class="line">            <span class="keyword">if</span> obj[<span class="string">'iscrowd'</span>]:</span><br><span class="line">                <span class="comment"># 如果当前物体是crowd的话, 则将所有类别的overlap都设置为-1,</span></span><br><span class="line">                <span class="comment"># 这样一来在训练的时候, 这些物体都会被排除在外!!</span></span><br><span class="line">                gt_overlaps[ix, :] = <span class="number">-1.0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                gt_overlaps[ix, cls] = <span class="number">1.0</span>  <span class="comment"># 仅仅将对应类的overlap设置为1, 其他为0</span></span><br><span class="line">        <span class="comment"># 将gt的boxes添加到entry中, 注意axis为0, 则会按照第0维拼接, 即最后是一个n×4的数组</span></span><br><span class="line">        <span class="comment"># 注意, entry['boxes']初始时候是空的, 因此这就相当于是只添加了真实的框</span></span><br><span class="line">        entry[<span class="string">'boxes'</span>] = np.append(entry[<span class="string">'boxes'</span>], boxes, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 由于segms是以列表形式存储, 所以利用列表的extend方法来将valid_segms添加到其中</span></span><br><span class="line">        entry[<span class="string">'segms'</span>].extend(valid_segms)  </span><br><span class="line">        <span class="comment"># gt_classes的类型内一维numpy数组(维度为有效obj的数量), 因此这里不用指定axis的值, 直接按照一维数组拼接即可</span></span><br><span class="line">        entry[<span class="string">'gt_classes'</span>] = np.append(entry[<span class="string">'gt_classes'</span>], gt_classes)</span><br><span class="line">        <span class="comment"># 同理, 一维numpy数组(维度为有效obj的数量), 无须指定axis的值</span></span><br><span class="line">        entry[<span class="string">'seg_areas'</span>] = np.append(entry[<span class="string">'seg_areas'</span>], seg_areas)</span><br><span class="line">        <span class="comment"># gt_overlaps为 num_objs × num_classes的numpy数组, 表示每个obj与任意一个类的重叠度</span></span><br><span class="line">        <span class="comment"># 因为entry['gt_overlaps']的类型为scipy.sparse.csr.csr_matrix, 因此这里需要调用toarray方法将其转换成numpy数组, 然后再与gt_overlaps拼接,</span></span><br><span class="line">        <span class="comment">#由于entry['gt_overlaps']的维度为 0 × 81 , 因此拼接后的维度为num_objs × num_classes的numpy数组</span></span><br><span class="line">        entry[<span class="string">'gt_overlaps'</span>] = np.append(</span><br><span class="line">            entry[<span class="string">'gt_overlaps'</span>].toarray(), gt_overlaps, axis=<span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 再将其包装成scipy.sparse.csr.csr_matrix类型</span></span><br><span class="line">        entry[<span class="string">'gt_overlaps'</span>] = scipy.sparse.csr_matrix(entry[<span class="string">'gt_overlaps'</span>])</span><br><span class="line">        <span class="comment"># 一维numpy数组, 可直接拼接</span></span><br><span class="line">        entry[<span class="string">'is_crowd'</span>] = np.append(entry[<span class="string">'is_crowd'</span>], is_crowd)</span><br><span class="line">        <span class="comment"># 该列表存储着box的顺序下标值, 同样是一维数组, 直接拼接</span></span><br><span class="line">        entry[<span class="string">'box_to_gt_ind_map'</span>] = np.append(</span><br><span class="line">            entry[<span class="string">'box_to_gt_ind_map'</span>], box_to_gt_ind_map</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> self.keypoints <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            entry[<span class="string">'gt_keypoints'</span>] = np.append(</span><br><span class="line">                entry[<span class="string">'gt_keypoints'</span>], gt_keypoints, axis=<span class="number">0</span></span><br><span class="line">            )</span><br><span class="line">            entry[<span class="string">'has_visible_keypoints'</span>] = im_has_visible_keypoints</span><br></pre></td></tr></table></figure></p><h1 id="add-proposals-from-file"><a href="#add-proposals-from-file" class="headerlink" title="_add_proposals_from_file()"></a><code>_add_proposals_from_file()</code></h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/datasets/json_dataset.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonDataset</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(...)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_roidb</span><span class="params">(...)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_prep_roidb_entry</span><span class="params">(self, entry)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add_gt_annotations</span><span class="params">(self, entry)</span>:</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add_proposals_from_file</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self, roidb, proposal_file, min_proposal_size, top_k, crowd_thresh</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span>:</span></span><br></pre></td></tr></table></figure><h1 id="续解combined-roidb-for-training-方法"><a href="#续解combined-roidb-for-training-方法" class="headerlink" title="续解combined_roidb_for_training() 方法"></a>续解<code>combined_roidb_for_training()</code> 方法</h1><p>接下来, 重新回到刚才<code>detectron/datasets/roidb.py</code> 文件 的 <code>combined_roidb_for_training</code> 函数中, 继续往下看:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/datasets/roidb.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载并连接一个或多个数据集的roidbs, along with optional object proposals</span></span><br><span class="line"><span class="comment"># 每个roidb entry都带有特定的元数据类型, 对其进行准备工作后进行训练</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combined_roidb_for_training</span><span class="params">(dataset_names, proposal_files)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_roidb</span><span class="params">(dataset_name, proposal_file)</span>:</span> <span class="comment"># 注意没有 's'</span></span><br><span class="line">        <span class="comment"># from detectron.datasets.json_dataset import JsonDataset</span></span><br><span class="line">        <span class="comment"># 可以看到, roidb 是利用JsonDataset类对象的get_roidb()方法获取的</span></span><br><span class="line">        <span class="comment"># 注意gt参数是True, 所以表明加载的是训练集的真实数据及其标签</span></span><br><span class="line">        ds = JsonDataset(dataset_name)</span><br><span class="line">        roidb = ds.get_roidb(</span><br><span class="line">            gt=<span class="keyword">True</span>,</span><br><span class="line">            proposal_file=proposal_file,</span><br><span class="line">            crowd_filter_thresh=cfg.TRAIN.CROWD_FILTER_THRESH</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 如果图片翻转属性为真, 则对加载好以后的数据集进行翻转操作</span></span><br><span class="line">        <span class="keyword">if</span> cfg.TRAIN.USE_FLIPPED:</span><br><span class="line">            logger.info(<span class="string">"Appending horizontally-flipped training examples..."</span>)</span><br><span class="line">            extend_with_flipped_entries(roidb, ds)</span><br><span class="line">        logger.info(<span class="string">"Loaded dataset: &#123;:s&#125;"</span>.format(ds.name))</span><br><span class="line">        <span class="comment"># 以上, 数据集加载操作完成, 将roidb数据结构返回</span></span><br><span class="line">        <span class="keyword">return</span> roidb</span><br><span class="line">    <span class="keyword">if</span> isinstance(dataset_names, basestring):</span><br><span class="line">        dataset_names=(dataset_names, )</span><br><span class="line">    <span class="keyword">if</span> isinstance(proposal_files, basestring):</span><br><span class="line">        proposal_files = (proposal_files, )</span><br><span class="line">    <span class="keyword">if</span> len(proposal_files) == <span class="number">0</span>:</span><br><span class="line">        proposal_files = (<span class="keyword">None</span>, ) * len(dataset_names)</span><br><span class="line">    <span class="keyword">assert</span> len(dataset_names) == len(proposal_files)</span><br><span class="line">    roidbs = [get_roidb(*args) <span class="keyword">for</span> args <span class="keyword">in</span> zip(dataset_names, proposal_files)]</span><br><span class="line">    roidb = roidbs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> roidbs[<span class="number">1</span>:]:</span><br><span class="line">        roidb.extend(r)</span><br><span class="line">    roidb = filter_for_training(roidb)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"Computing bounding-box regression targets..."</span>)</span><br><span class="line">    <span class="comment"># 为训练bounding-box 回归其添加必要的information</span></span><br><span class="line">    add_bbox_regression_targets(roidb)</span><br><span class="line">    logger.info(<span class="string">"done"</span>)</span><br><span class="line">    _compute_and_log_stats(roidb)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> roidb</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Queue模块-队列</title>
      <link href="/z_post/Python-Queue/"/>
      <url>/z_post/Python-Queue/</url>
      
        <content type="html"><![CDATA[<p><code>Queue</code> 是Python标准库中的线程安全的队列 (FIFO) 实现, 提供了一个适用于多线程变成的先进先出的数据结构, 主要用于在生产者和消费者线程之间的信息传递</p><h1 id="Queue-基本FIFO队列"><a href="#Queue-基本FIFO队列" class="headerlink" title="Queue-基本FIFO队列"></a>Queue-基本FIFO队列</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>.<span class="title">Queue</span><span class="params">(maxsize=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>Queue.Queue</code> 提供了一个基本的FIFO容器, <code>maxsize</code> 指明了队列中能存放的数据个数的上线. 一旦达到上限, 就会导致队列阻塞, 指责队列中的数据被消费掉. 如果将 <code>maxsize</code> 的值设置为小于或者等于 0, 则队列的大小没有限制.</p><p>```py<br>import</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-Python2和Python3的兼容问题</title>
      <link href="/z_post/Python-Python2%E5%92%8CPython3%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
      <url>/z_post/Python-Python2%E5%92%8CPython3%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在看社区里面开源的深度学习或者python项目时, 经常会看到诸如<code>__future__</code>或者<code>six.moves</code> 这种名字很奇怪的包, 实际上, 这些包都是为了实现python2与python3的兼容性而设置的, 在python社区里, 很多公司或者个人为了只维护一套代码, 一般都会写同时兼容Python2/3的代码.</p><h1 id="future"><a href="#future" class="headerlink" title="future"></a><strong>future</strong></h1><p>python3 出来的时候, python的设计者们当然也考虑过代码之间的兼容问题, 许多为兼容性设计的功能可以通过 <code>__future__</code> 这个包来导入, 较常用的例如:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="comment"># 让python2可以使用python3的print函数, 同时禁用python2的print语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literal</span><br><span class="line"><span class="comment"># 像python3一样, 字符串字面量的类型为文本( 文本是python2中的unicode, python中的str), 而不是字节( python2中的str, python3中的bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="comment"># 让python2像python3一样, int/int = float, int // int = int</span></span><br></pre></td></tr></table></figure><p>上面四条语句导入以后, python2中的很多语法就和python3差不多了</p><h1 id="six"><a href="#six" class="headerlink" title="six"></a>six</h1><p>由于 python2/3 之间还有很多别的差异, 因此只用 <code>__future__</code> 是不够的. 用 <code>six</code> 这个 <strong>第三方模块</strong> 可以解决这个问题.</p><p>例如, Python2 和 Python3 中字符串类型名字不同, six可以把它们变成统一的第三种形式: <code>six.text_type</code> , <code>six.binary_type</code></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>collections模块-集合型数据结构</title>
      <link href="/z_post/Python-collections/"/>
      <url>/z_post/Python-collections/</url>
      
        <content type="html"><![CDATA[<p><code>collections</code> 是Python的一个集合模块, 它在内置数据结构 (<code>dict</code>, <code>list</code>, <code>set</code>, <code>tuple</code>) 的基础上, 提供了一些额外的集合型数据结构:</p><div class="table-container"><table><thead><tr><th>类型</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>deque</code></td><td>双端队列, 可以快速的从头/尾两端添加或删除元素</td><td>New in 2.4</td></tr><tr><td><code>defaultdict</code></td><td>带有默认值的字典</td><td>New in version 2.5</td></tr><tr><td><code>namedtuple</code></td><td>命名元组, 可以使用名字访问元素</td><td>New in version 2.6</td></tr><tr><td><code>Counter</code></td><td>计数器, 用于对某项数据进行计数</td><td>New in version 2.7</td></tr><tr><td><code>OrderedDict</code></td><td>有序字典, 按<code>key</code>对字典元素排序</td><td>New in version 2.7</td></tr><tr><td><code>ChainMap</code></td><td>合并多个map(dict), 但保持原数据结构</td><td>New in version 3.3</td></tr><tr><td>UserDict</td><td>将字典包装起来使得创建字典的子类更容易</td><td></td></tr><tr><td>UserList</td><td>列表对象的包装器</td><td></td></tr><tr><td>UserString</td><td>字符串对象的包装器</td></tr></tbody></table></div><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p><code>deque</code> 是double-ended queue 的缩写, 即双端队列. List存储数据的优势在于按索引查找元素很快, 但是插入和删除元素就很慢了, 因为List是基于数组实现的. <code>deque</code> 是为了高效插入和删除的双向列表, 适合用于跌列和栈, 而且线程安全, 其原型如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collections.deque([iterable[, maxlen]])</span><br></pre></td></tr></table></figure><p><code>deque</code> 除了list固有的方法外, 还新增了 <code>appendleft / popleft</code> 等方法允许高效的在队列的开头插入或删除元素, 其时间复杂度为 $O(1)$</p><h1 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h1><h1 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h1><h1 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h1><h1 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h1><p><code>OrderedDict</code> 是 <code>dict</code> 的一个自雷, 支持所有的 <code>dict</code> 方法, 它能够保持 <code>dict</code> 的有序性, 其原型如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collections.OrderedDict([items])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【置顶】深度学习框架底层实现原理-caffe2源码探究</title>
      <link href="/z_post/Caffe2-caffe2%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/z_post/Caffe2-caffe2%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo博客相关问题及解决方案汇总</title>
      <link href="/z_post/%E5%85%B6%E4%BB%96-hexo%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/"/>
      <url>/z_post/%E5%85%B6%E4%BB%96-hexo%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="数学公式渲染异常"><a href="#数学公式渲染异常" class="headerlink" title="数学公式渲染异常"></a>数学公式渲染异常</h1><p><a href="https://www.once4623.site/2017/10/03/2017-10-04--Use-MathJax-In-Hexo-Next/" target="_blank" rel="noopener">https://www.once4623.site/2017/10/03/2017-10-04--Use-MathJax-In-Hexo-Next/</a></p><h1 id="hexo-实现置顶功能"><a href="#hexo-实现置顶功能" class="headerlink" title="hexo 实现置顶功能"></a>hexo 实现置顶功能</h1><h1 id="hexo-站内搜索"><a href="#hexo-站内搜索" class="headerlink" title="hexo 站内搜索"></a>hexo 站内搜索</h1><p><a href="https://www.jianshu.com/p/519b45730824" target="_blank" rel="noopener">https://www.jianshu.com/p/519b45730824</a></p><p><a href="https://blog.csdn.net/ksws0292756/article/details/82714984" target="_blank" rel="noopener">https://blog.csdn.net/ksws0292756/article/details/82714984</a></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MultiBox-CVPR2014</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2014-MultiBox/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2014-MultiBox/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> Scalable Object Detection using Deep Neural Networks<br><strong>作者:</strong> Dumitru Erhan, Christian Szegedy, Alexander Toshev, and Dragomir Anguelov</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>(1) 回归问题:</strong><br>将物体检测问题定义为输出多个bounding box的回归问题. 同时每个bounding box会输出关于是否包含目标物体的置信度, 使得模型更加紧凑和高效</p><p><strong>(2) 损失函数:</strong><br>将训练bounding box检测器作为整个网络训练过程的一部分, 也就是说在损失函数中包含了关于bounding box的损失项. 通过联合训练, 不仅利用了神经网络强大的特征表示能力, 而且将检测器的训练集成到了网络中</p><p><strong>(3) 无类别监督训练</strong><br>作者将本文的目标边框检测器在无监督的样本下训练, 由于本方法主要完成的功能就是画框, 并不会输出框中包含的物体类别, 因此训练的时候无需知道样本的类别信息. 这也使得该方法的计算复杂度与类别信息几乎无关, 可以轻易的推广到未知的类别当中. (当然也可以进行相关类别的训练, 对每个类别都训练一个检测器, 模型的总参数会随着类别数线性增加)</p><p><strong>关键技术</strong></p><p>作者将bounding box的检测过程集成到了神经网络中, 使其转变成了一个回归问题, 通过BP算法优化下面的损失函数即可获得预测的框, 相比于SS算法, 计算复杂度更低.</p><p>$x_{ij}=1$ 当且仅当第 $i$ 个预测框与第 $j$ 个真实框匹配. $l_i$ 和 $g_j$ 分别是预测框和真实框的归一化后的坐标, $c_i$ 代表置信度:</p><script type="math/tex; mode=display">F_{match}(x,l) = \frac{1}{2} \sum_{i,j} x_{ij} \|l_i - g_j\|_2^2</script><script type="math/tex; mode=display">F_{conf}(x,c) = -\sum{i,j} x_{i,j} log(c_i) - \sum_i (1 - \sum_j x_{ij}) log(1-c_i)</script><script type="math/tex; mode=display">F(x,l,c) = \alpha F_{match}(x,l) + F_{conf}(x,c)</script><script type="math/tex; mode=display">x^* = \arg \min_x F(x,l,c)</script><script type="math/tex; mode=display">\text{subject to } x_{ij} \in \{0, 1\}, \sum_i x_{ij}=1</script><p>利用BP算法分别对 $l_i$ 和 $c_i$ 求导, 以便更新相关参数使其损失函数值更低.</p><script type="math/tex; mode=display">\frac{\partial F}{\partial l_i} = \sum_j (l_i - g_j) x^*_{ij}</script><script type="math/tex; mode=display">\frac{\partial F}{\partial c_i} = \frac{\sum_j x^*_{ij} c_i}{c_i(1-c_i)}</script><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在(2014年)之前的工作中, 对于目标检测任务都是对整个图片进行检测, 无法检测出同一张图片中的多个目标物. 于是, 本文就提出了一种目标检测模型, 可以在一张图片中预测多个bounding boxes, 并且每个box都对应了包含某个类别物体的置信度.</p><p>作者使用了一个单一的DNN网络, 来生成候选区域框, 并且每个区域框都会带有一个置信度, 代表这框内包含物体的可能性大小.</p><p><strong>Model:</strong> 模型最后一层的神经元的输出值代表着每个框的坐标和对应的置信度.</p><p><strong>Bounding Box:</strong> 将左上角和右下角的坐标分别作为四个神经元的输出值. 这些坐标都是经过归一化的.</p><p><strong>Confidence:</strong> 每个Box对应的置信度会单独作为一个神经元节点输出.</p><p>在预测阶段, 可以利用该模型输出 $K$ 个bounding box预测结果, 同时可以利用NMS算法得到置信度更高的Box集合, 然后将这些集合送到分类器中进行分类.</p><p><strong>训练目标:</strong> 假设对于一个训练样本, 具有 $M$ 个已经标注好的GT bounding box. 然后, 检测器会生成 $K$ 个预测的bounding box, $K$ 的值一般远远大于 $M$. 因此, 我们仅仅需要优化 $K$ 中与 $M$ 个GT匹配度最高的一个子集合. 优化的时候, 我们尽可能的提高这些子集合内部的预测框的置信度, 同时降低其他那些不在子集合里面的框的置信度. 对此, 形式化描述为下面的函数:</p><script type="math/tex; mode=display">F_{match}(x,l) = \frac{1}{2} \sum_{i,j} x_{ij} \|l_i - g_j\|_2^2</script><p>上式中, $x_{ij}=1$ 当且仅当第 $i$ 个预测框与第 $j$ 个真实框匹配. $l_i$ 和 $g_j$ 分别是预测框和真实框的归一化后的坐标.</p><p>此外, 我们还希望对预测框的置信度进行优化, 将匹配框的置信度最大化, 这个过程转换成最小化下面的式子:</p><script type="math/tex; mode=display">F_{conf}(x,c) = -\sum{i,j} x_{i,j} log(c_i) - \sum_i (1 - \sum_j x_{ij}) log(1-c_i)</script><p>从上式可以看到, $\sum_j x_{ij} = 1$ 当且仅当预测框 $i$ 可以匹配到某个真实框. 在这种情况下, $c_i$ 将王越来越大的方向优化. 上面这个式子正式交叉熵.</p><p>结合上面的两个公式, 最终的损失函数如下所示, 其中 $\alpha$ 用于调节两部分的权重:</p><script type="math/tex; mode=display">F(x,l,c) = \alpha F_{match}(x,l) + F_{conf}(x,c)</script><p><strong>优化:</strong> 对于每一个训练样本, 都希望按照如下最优化问题求得 $x^*$ (也就是最优化预测框与真实框的匹配方案) :</p><script type="math/tex; mode=display">x^* = \arg \min_x F(x,l,c)</script><script type="math/tex; mode=display">\text{subject to } x_{ij} \in \{0, 1\}, \sum_i x_{ij}=1</script><p>由于标记物体的数量非常少, 所以上面公式的计算复杂度并不高. 对于上面的公式, 可以利用BP算法分别对 $l_i$ 和 $c_i$ 求导, 以便更新相关参数使其损失函数值更低.</p><p><strong>Training Details:</strong></p><p>使用了三个小改动, 进一步提升了精度的速度</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>协变(covariance)与逆变(contravariance)</title>
      <link href="/z_post/Cpp-%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/"/>
      <url>/z_post/Cpp-%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>thread和threading模块-多线程处理</title>
      <link href="/z_post/Python-thread%E5%92%8Cthreading/"/>
      <url>/z_post/Python-thread%E5%92%8Cthreading/</url>
      
        <content type="html"><![CDATA[<p>Python的标准库提供了两个多线程模块: <code>thread</code> 和 <code>threading</code>. 其中, <code>thread</code> 是低级模块, <code>threading</code> 是高级模块, 对<code>thread</code>进行了封装, 大多数情况下, 我们只需要使用<code>threading</code>这个高级模块.</p><p>python中使用线程有两种方式: 函数或者用类来包装线程对象</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Caffe2-Detectron源码解读-数据载入</title>
      <link href="/z_post/Caffe2-Detectron-%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5/"/>
      <url>/z_post/Caffe2-Detectron-%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Coordinator-类"><a href="#Coordinator-类" class="headerlink" title="Coordinator 类"></a>Coordinator 类</h1><p>由于 RoIDataLoader 类将 Coordinator 类对象作为成员变量, 因此我们先看一下这个类的作用和底层实现, 该类位于<code>detectron/utils/coordinator.py</code>文件中, 定义如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#detectron/utils/coordinator.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从名字可以看出, 该类的作用主要是协调各个数据载入管道之间的信息同步</span></span><br><span class="line"><span class="comment"># 实现上, 该类主要封装了threading多线程模块的一些功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># import threading</span></span><br><span class="line">        self._event = threading.Event()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request_stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        log.debug(<span class="string">"Coordinator stopping"</span>)</span><br><span class="line">        self._event.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 当Event()对象使用set()方法后, is_set()方法返回镇</span></span><br><span class="line">        <span class="keyword">return</span> self._event.is_set()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="meta">    @contextlib.contextmanager 上下文环境管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop_on_exception</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.should_stop():</span><br><span class="line">                traceback.print_exc()</span><br><span class="line">                self.request_stop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coordinated_get</span><span class="params">(coordinator, queue)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> coordinator.should_stop():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 从队列中获取数据</span></span><br><span class="line">            <span class="keyword">return</span> queue.get(block=<span class="keyword">True</span>, timeout=<span class="number">1.0</span>)</span><br><span class="line">        <span class="keyword">except</span> Queue.Empty:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"Coordinator stopped during get()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coordinated_put</span><span class="params">(coordinator, queue, element)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> coordinator.shuold_stop():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            queue.put(element, block=<span class="keyword">True</span>, timeout=<span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> Queue.Full:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"Coordinator stopped during put()"</span>)</span><br></pre></td></tr></table></figure><h1 id="RoIDataLoader-类"><a href="#RoIDataLoader-类" class="headerlink" title="RoIDataLoader 类"></a>RoIDataLoader 类</h1><p>在之前分析的<code>tools/train_net.py</code> 文件中, 关于数据载入的部分被封装在了<code>detectron/roi_data/loader.py</code>文件中的<code>RoIDataLoader</code>类中, 而数据载入对于任何模型和工程来说, 都是非常重要的一步, 下面, 我们就具体看看这个类的底层实现是怎么样的.</p><p>文件开头, 有一段非常详细的注释:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/roi_data/loader.py</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""Detectron data loader. The design is generic and abstracted away from any</span></span><br><span class="line"><span class="string">details of the minibatch. A minibatch is a dictionary of blob name keys and</span></span><br><span class="line"><span class="string">their associated numpy (float32 or int32) ndarray values.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Outline of the data loader design:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">loader thread\</span></span><br><span class="line"><span class="string">loader thread \                    / GPU 1 enqueue thread -&gt; feed -&gt; EnqueueOp</span></span><br><span class="line"><span class="string"><span class="meta">... </span>          -&gt; minibatch queue -&gt;  ...</span></span><br><span class="line"><span class="string">loader thread /                    \ GPU N enqueue thread -&gt; feed -&gt; EnqueueOp</span></span><br><span class="line"><span class="string">loader thread/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;---------------------------- CPU -----------------------------|---- GPU ----&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A pool of loader threads construct minibatches that are put onto the shared</span></span><br><span class="line"><span class="string">minibatch queue. Each GPU has an enqueue thread that pulls a minibatch off the</span></span><br><span class="line"><span class="string">minibatch queue, feeds the minibatch blobs into the workspace, and then runs</span></span><br><span class="line"><span class="string">an EnqueueBlobsOp to place the minibatch blobs into the GPU's blobs queue.</span></span><br><span class="line"><span class="string">During each fprop the first thing the network does is run a DequeueBlobsOp</span></span><br><span class="line"><span class="string">in order to populate the workspace with the blobs from a queued minibatch.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>从上面的注释我们可以看出, 这个文件定义了<code>Detectron</code>的数据载入器<code>data loader</code>, 这个类的设计是一种抽象的一般化的设计, 并且会与所有minibatch的细节隔离开来. 在这个类中, minibatch被记录为一个字典结构, 它的key值为blob name, 其value值为对应的numpy ndarray.</p><p>每一个GPU都具有一个enqueue线程, 可以从minibatch queue中获取数据, 然后会将minibatch blobs喂到workspace中去, 之后运行 EnqueueBlobsOp 来将minibatch blobs 放置到 GPU的blob queue中.</p><p>在每一次前向传播过程中, 模型最先做的事情就是运行 DequeueBlobsOp 来构建工作空间.</p><p>下面, 看一下<code>RoIDataLoader</code>类的具体实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron/roi_data/loader.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoIDataLoader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        roidb,</span></span></span><br><span class="line"><span class="function"><span class="params">        num_loaders = <span class="number">4</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        minibatch_queue_size=<span class="number">64</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        blobs_queue_capacity=<span class="number">8</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span>:</span></span><br><span class="line">        self._roidb = roidb</span><br><span class="line">        self._lock = threading.Lock()</span><br><span class="line">        self._perm = deque(range(len(self._roidb)))</span><br><span class="line">        self._cur = <span class="number">0</span> <span class="comment"># _perm cursor</span></span><br><span class="line">        <span class="comment"># minibatch队列会在CPU内存当中持有准备好的训练数据</span></span><br><span class="line">        <span class="comment"># 当训练N&gt;1个GPUs时, 在minibatch队列中的每一个元素</span></span><br><span class="line">        <span class="comment"># 实际上是只是一部分minibatch, 对整个minibatch贡献了</span></span><br><span class="line">        <span class="comment"># 1/N的样例</span></span><br><span class="line">        <span class="comment"># from six.moves import queue as Queue</span></span><br><span class="line">        self._minibatch_queue = Queue.Queue(maxsize=minibatch_queue_size)</span><br><span class="line">        <span class="comment"># TODO, 其他参数的初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># from detectron.utils.coordinator import Coordinator</span></span><br><span class="line">        self.coordinator = Coordinator()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载mini-batches, 并且将它们放进mini-batch 队列中.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minibatch_loader_thread</span><span class="params">(slef)</span>:</span></span><br><span class="line">        <span class="comment"># coordinator的上下文管理器, 当有异常出现时会调用coordinator.request_stop()方法</span></span><br><span class="line">        <span class="keyword">with</span> self.coordinator.stop_on_exception():</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.coordinator.should_stop():</span><br><span class="line">                <span class="comment"># RoIDataLoader的成员函数, 返回用于下一个minibatch的blobs,</span></span><br><span class="line">                <span class="comment"># 函数内部调用了另一个成员函数_get_next_minibatch_inds()</span></span><br><span class="line">                <span class="comment"># 该函数返回下一个minibatch的roidb的下标</span></span><br><span class="line">                <span class="comment"># 还调用了detectron/roi_data/minibatch.py文件中的get_minibatch方法</span></span><br><span class="line">                <span class="comment"># 该方法会在给定roidb的情况下, 从中构造一个minibatch</span></span><br><span class="line">                blobs = self.get_next_minibatch()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># from collections import OrderedDict</span></span><br><span class="line">                <span class="comment"># Blobs必须根据self.get_output_names()在队列中进行排序</span></span><br><span class="line">                ordered_blobs = OrderedDict()</span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> self.get_output_names():</span><br><span class="line">                    <span class="keyword">assert</span> blobs[key].dtype <span class="keyword">in</span> (np.int32, np.float32), \</span><br><span class="line">                        <span class="string">"Blob &#123;&#125; of dtype &#123;&#125; must have dtype of"</span> \</span><br><span class="line">                        <span class="string">"np.int32 or np.float32"</span>.format(key, blobs[key].dtype)</span><br><span class="line"></span><br><span class="line">                    ordered_blobs[key] = blobs[key]</span><br><span class="line">                <span class="comment"># from detectron.utils.coordinator import coordianted_put</span></span><br><span class="line">                <span class="comment"># 此处是将minibatch中数据blobs放入队列的关键代码</span></span><br><span class="line">                coordinated_put(self.coordinator, self._minibatch_queue, ordered_blobs)</span><br><span class="line">        logger.info(<span class="string">"Stopping mini-batch loading thread"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将mini-batches从mini-batch队列中转移到BlobsQueue中.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue_blobs_thread</span><span class="params">(self, gpu_id, blob_names)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.coordinator.stop_on_exception():</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.coordinator.should_stop():</span><br><span class="line">                <span class="keyword">if</span> self._minibatch_queue.qsize == <span class="number">0</span>:</span><br><span class="line">                    logger.warning(<span class="string">"Mini-batch queue is empty"</span>)</span><br><span class="line">                blobs = coordinated_get(self.coordinate, self._minibatch_queue)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SPPNet-ECCV2014</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-SPPNet-ECCV2014/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-SPPNet-ECCV2014/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</p><p><strong>作者:</strong> Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>(1) 提出了一种新的池化方法—-空间金字塔池化SPP</strong>:</p><ul><li>可以接受任意尺寸的输入图片,并生成固定长度的表征向量</li><li>可以进行多尺度的联合训练, 提升模型精度</li><li>这种池化方法是比较general的, 可以提升不同模型架构的性能(分类任务)</li></ul><p><strong>(2) 将SPP用于目标检测, 并且提出了先求卷积特征图谱, 后取区域的的策略:</strong></p><ul><li>大大提升了模型训练和预测的速度(在预测阶段, 比RCNN快24~102倍, 同时取得了更好的精度).</li></ul><p><strong>注1: 在特征图谱上使用检测方法不是首次提出</strong>, 而SPP的贡献可以结合了deep CNN结构强大的特征提取能力和SPP的灵活性, 使得精度和速度同时提高<br>注2: 相比于RCNN, SPPNet使用了EdgeBoxes( $0.2s/img$ )的方法来进行候选区域推荐, 而不是Selective Search( $1\sim 2s/img$ )<br>注3: SPPNet在ILSVRC2014的目标检测任务上取得第二名, 在图片分类任务上取得第三名</p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>指明固定图片输入尺寸的缺点: 需要剪裁或wrap图片, 无法包含整个图片信息, 导致信息丢失或引起形变</p><p>破除尺寸限制的做法: 在最后一个卷积层之后, 添加SPP层,  <strong>SPP层可以将不同尺寸的feature map池化成固定长度的特征向量.</strong>, 之后, 仍然与普通网络一样, 后街全连接层或者其他分类器</p><h2 id="SPP"><a href="#SPP" class="headerlink" title="SPP"></a>SPP</h2><p>本文的核心就在于SPPNet, 其主要用法是在卷积神经网络的最后一层卷积特征图谱上, 通过多尺度的网格划分, 接受任意尺寸的特征图谱输入, 同时输出固定长度的特征向量, 以此来实现网络模型接受任意尺寸图片输入的目的.</p><p>SPPNet实现原理如下图所示:</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw6muop69aj20mn0j7mzu.jpg" alt=""></p><p>首先, 设定好固定的网格划分方法, 以便得到spatial bins, 如上图, 有三种不同spatial bins, 网格划分力度分别为 4×4, 2×2 和 1×1, 因此, spatial bins的数量为:$4\times 4+2\times 2+ 1\times 1 = 21 = M$, 图中的256代表最后一层卷积层的filter的数量, 也就是特征图谱的depth = $k$. 因此, SPP层的输出为 $kM$ 维的一维向量.</p><p>注意: 这里最粗粒度的spatial bins 是对整张特征图谱上进行pooling, 这实际上是为了获得一些全局信息.(之前也很很多work集成了这种全局pooling方法, 貌似有助于提升精度, 同时由于是全局信息, 所以相当general, 可以一定程度上起到降低过拟合的作用)</p><p>SPP可以看做是Bag-of-Words(BoW)模型的一种扩展</p><p>SPP用于deep CNNs时, 具有一些瞩目的性质:</p><ol><li>相比于sliding window pooling的方式, SPP可以生成固定尺寸的特征向量</li><li>SPP使用了多尺寸的spatial bins, 而sliding window只是用了单一的window size. 这使得SPP对于物体的形变更加鲁棒</li><li>由于输入尺寸的灵活性, SPP可以在不同尺度下提取图片特征(可以在训练时接受多尺寸土木, 降低过拟合风险)</li></ol><p>SPP使用了MutiBoxes来进行候选区域推荐.</p><h2 id="Deep-Networks-With-Spatial-Pyramid-Pooling"><a href="#Deep-Networks-With-Spatial-Pyramid-Pooling" class="headerlink" title="Deep Networks With Spatial Pyramid Pooling"></a>Deep Networks With Spatial Pyramid Pooling</h2><h3 id="卷积层和特征图谱"><a href="#卷积层和特征图谱" class="headerlink" title="卷积层和特征图谱"></a>卷积层和特征图谱</h3><p>卷积层可以接受任意尺寸的图片, 并且可以在特征图谱上得到相应的响应.</p><p>根据BoW的思想, 在 deep convolutional features 上也可以使用(与Bow)相似的pooling方式使得输出固定长度的特征向量</p><h3 id="Training-the-Network"><a href="#Training-the-Network" class="headerlink" title="Training the Network"></a>Training the Network</h3><p>虽然上面的work可以接受任意尺度的图片输入, 但在实际训练中, GPU相关组件如caffe或者cuda-convnet还是倾向于接受固定尺寸的输入. 因此作者介绍了他们的training solution, 以便在使用GPU高计算能力的同时, 保留SPP的pooling特点.</p><h4 id="Single-size-training"><a href="#Single-size-training" class="headerlink" title="Single-size training"></a>Single-size training</h4><p>假设最后一层卷积层的特征图谱的size为 $a\times a$. pyramid level为 $n\times n$ bins. 那么实现该pyramid pooling的方式可以看做是 $win=\lceil  a / n\rceil , stride = \lfloor a/n \rfloor$ 的sliding window pooling. 对于不同级别的pyramid, 使用同样的方法, 最终将所有的bins的输出连接起来组成一个一维向量.</p><p>上面用一句话总结: 在实际实现中, 使用sliding window pooling的方式来实现spp的, 对于单一尺寸的输入, 可以提前计算好需要的windows size, 编码时直接常量定义相关pooling即可.</p><h4 id="Multi-size-training"><a href="#Multi-size-training" class="headerlink" title="Multi-size training"></a>Multi-size training</h4><p>对于不同的尺寸输入, 分别计算不同的windows, 然后定义相关的pooling. (需要重新定义网络的pooling参数)</p><p>为了减少训练不同size网络的间接成本, 作者会先训练一个网络, 在一个epoch完成后, 会转向训练另一个网络(两个网络共享参数, 注意pooling是没有参数的)</p><p>也就是说, 对于两个网络, spp的参数设置是根据图片的尺寸来调节的, 因为要得到固定长度的特征向量, 所以如果图片尺寸较大, 那么最后一层卷积层的特征图谱也就较大, 那么久需要比较大的sliding windows size 来实现spp. 作者为了能一次性训练不同尺寸图片, 采用了这种迭代训练的方式(反正 <strong>pooling层是没有参数的</strong> , 只不过是定义时需要指定window size).</p><p>进行多尺度训练的目的: 为了协同不同尺度下的图片特征提取, 同时利用已有的优化技术.</p><p>注意: 以上策略仅仅在training阶段使用.</p><h2 id="SPP-Net-For-Image-Classification"><a href="#SPP-Net-For-Image-Classification" class="headerlink" title="SPP-Net For Image Classification"></a>SPP-Net For Image Classification</h2><h3 id="Experiments-on-ImageNet-2012-Classifization"><a href="#Experiments-on-ImageNet-2012-Classifization" class="headerlink" title="Experiments on ImageNet 2012 Classifization"></a>Experiments on ImageNet 2012 Classifization</h3><p>训练策略:</p><p>images resize 使得图片的短边长度为256, 然后对其进行224×224 crop(四角+中心).</p><p>图像增强: horizontal flipping, color altering.</p><p>dropout: 用于2层全连接层</p><p>lr: 0.01, 两次衰减10分之1</p><h4 id="Baseling-Network-Architectures"><a href="#Baseling-Network-Architectures" class="headerlink" title="Baseling Network Architectures"></a>Baseling Network Architectures</h4><p>ZF-5, Convnet*-5, Overfeat-5/7</p><h4 id="Multi-level-Pooling-Improves-Accuracy"><a href="#Multi-level-Pooling-Improves-Accuracy" class="headerlink" title="Multi-level Pooling Improves Accuracy"></a>Multi-level Pooling Improves Accuracy</h4><p>需要注意的是, 模型精度的不是因为更多参数(pooling没有参数), 但是因为考虑了这种spatial结构, 从而使得模型的精度提升.</p><h4 id="Multi-size-Training-Improves-Accuracy"><a href="#Multi-size-Training-Improves-Accuracy" class="headerlink" title="Multi-size Training Improves Accuracy"></a>Multi-size Training Improves Accuracy</h4><p>顾名思义, 作者使用了多尺度的训练, 同样提升了精度</p><h4 id="Full-image-Representations-Improve-Accuracy"><a href="#Full-image-Representations-Improve-Accuracy" class="headerlink" title="Full-image Representations Improve Accuracy"></a>Full-image Representations Improve Accuracy</h4><p>作者将Full-Image和crop(224×224, center)的策略进行了实验比较, 发现未经裁剪的Full-Image的精度更高, 说明维持原始图片的完整输入是很有必要的.</p><p>作者发现, <strong>即使使用了很多视角下的crop结果进行投票, 额外的增加两个full-image(with flipping) 仍然可以提升模型 0.2%的精度</strong></p><h4 id="Multi-view-Testing-on-Feature-Maps"><a href="#Multi-view-Testing-on-Feature-Maps" class="headerlink" title="Multi-view Testing on Feature Maps"></a>Multi-view Testing on Feature Maps</h4><p>受到目标检测算法的启发, 作者发现整合在feature maps上面进行不同视角的预测, 会使得模型精度有所提高. 实验结果证明, 在features maps上面进行10-view投票相比于直接在原始图上面进行10-view投票, 精度提高了0.1% (top-5 error)</p><p>作者使用了是不同image size, 结合了不同的view(18种, center+四角+四边中心+filp,), 总共有96种view(18*5 + 6(图片size只有224的时候)). 将top-5 error 从10.95% 降到 9.36%, 再结合two full image view, 降到了9.14%.</p><p><strong>Overfeat 也是从feature map中获取不同views的, 但它不能处理多尺度的图片</strong></p><h3 id="Experiments-on-VOC-2007-Classification"><a href="#Experiments-on-VOC-2007-Classification" class="headerlink" title="Experiments on VOC 2007 Classification"></a>Experiments on VOC 2007 Classification</h3><h3 id="Experiments-on-Caltech101"><a href="#Experiments-on-Caltech101" class="headerlink" title="Experiments on Caltech101"></a>Experiments on Caltech101</h3><h2 id="SPP-Net-For-Object-Detection"><a href="#SPP-Net-For-Object-Detection" class="headerlink" title="SPP-Net For Object Detection"></a>SPP-Net For Object Detection</h2><p>RCNN: 先从原始图像中选出大约2000个框, 然后将这些图像区域缩放到227×227大小, 然后对每个区域进行卷积分类, 使用了SVM分类器.  <strong>特征提取存在大量重复计算, 占用了绝大部分的时间</strong></p><p>改进:</p><p>从feature maps提取对应框,只进行一次卷积计算:  之前的DPM在HOG特征图谱上选框, SS在SIFT特征图谱上选框, Overfeat在深度卷积特征图谱上选框, 但是Overfeat必须固定图片尺寸.</p><p>相比之前的这些方法, SPP具有在深度卷积特征图谱上的灵活性, 可以接受任意尺寸的输入,</p><h3 id="Detection-Algorithm"><a href="#Detection-Algorithm" class="headerlink" title="Detection Algorithm"></a>Detection Algorithm</h3><p>使用 “fast” mode的SS来生成2000个候选区域框, 然后将image 进行resize ,使其 min(w,h) = s. 接着对整张图片计算卷积特征图谱. 然后在特征图谱上选框, 接着对这些框进行spp, 最后使用svm进行分类.</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw6pd0czr9j20n10ltn0b.jpg" alt=""></p><p>使用了strandard hard negative mining来训练svm.</p><h3 id="Detection-Results"><a href="#Detection-Results" class="headerlink" title="Detection Results"></a>Detection Results</h3><h3 id="Complexity-and-Running-Time"><a href="#Complexity-and-Running-Time" class="headerlink" title="Complexity and Running Time"></a>Complexity and Running Time</h3><p>改用了MultiBox算法, 处理每张图片只需要0.2左右, 原来的SS算法大约需要1~2s才可以.</p><h3 id="Model-Combination-for-Detection"><a href="#Model-Combination-for-Detection" class="headerlink" title="Model Combination for Detection"></a>Model Combination for Detection</h3><p>在ImageNet上训练另一个模型, 使用相同的网络结构, 但是随机初始化状态不同. 如此得到两个模型, 他们的性能表现差不多.</p><p>首先分别用这两个模型给所有的测试样例的候选框进行打分, 然后利用NMS消除这些候选框(包含两个模型的预测结果)中的重复框, 这样一来, 就会保留下置信度更高的框. mAP从 59.1%, 59.2% 提升到了 60.9%</p><h3 id="ILSVRC-2014-Detection"><a href="#ILSVRC-2014-Detection" class="headerlink" title="ILSVRC 2014 Detection"></a>ILSVRC 2014 Detection</h3><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h2 id="Appendix-A"><a href="#Appendix-A" class="headerlink" title="Appendix A"></a>Appendix A</h2><h3 id="Mean-Subtraction"><a href="#Mean-Subtraction" class="headerlink" title="Mean Subtraction"></a>Mean Subtraction</h3><h3 id="Implementatioin-of-Pooling-Bins"><a href="#Implementatioin-of-Pooling-Bins" class="headerlink" title="Implementatioin of Pooling Bins"></a>Implementatioin of Pooling Bins</h3><h3 id="Mapping-a-Window-to-Featrue-Maps"><a href="#Mapping-a-Window-to-Featrue-Maps" class="headerlink" title="Mapping a Window to Featrue Maps"></a>Mapping a Window to Featrue Maps</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试-Python面试总结</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-Python%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-Python%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/L1nwatch/interview_collect/tree/master/Python%20%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7" target="_blank" rel="noopener">https://github.com/L1nwatch/interview_collect/tree/master/Python%20%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7</a></p><h1 id="Python有哪些特点和优点"><a href="#Python有哪些特点和优点" class="headerlink" title="Python有哪些特点和优点"></a>Python有哪些特点和优点</h1><ul><li>可解释</li><li>动态特性</li><li>面向对象</li><li>简明简单</li></ul><h1 id="python中-对于基本类型-每次的-赋值都会生成新的地址"><a href="#python中-对于基本类型-每次的-赋值都会生成新的地址" class="headerlink" title="python中, 对于基本类型, 每次的=赋值都会生成新的地址:"></a>python中, 对于基本类型, 每次的=赋值都会生成新的地址:</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">print(id(a))</span><br><span class="line"><span class="comment"># 4490543616</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">print(id(a))</span><br><span class="line"><span class="comment"># 4490543648</span></span><br></pre></td></tr></table></figure><h1 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h1><p>深拷贝是完全的拷贝, 当对一个对象的深拷贝做出改变时, 不会影响原对象的状态, 使用<code>b = copy.deepcopy(a)</code> 来完成深拷贝</p><p>浅拷贝是将一个对象的引用拷贝到另一个对象上, 如果在拷贝中进行改动, 则会影响到原对象的状态, 使用<code>b = copy.copy(a)</code> 完成浅拷贝</p><ul><li>python中对象的赋值操作都是进行对象引用的传递(也就是浅拷贝的形态)</li><li>对于非容器类型(如数字, 字符串, 和其他原子类型的对象), 没有拷贝一说(除非使用=运算符, 否则经过拷贝的对象中的非容器类型, 与原对象的元素都是相对独立的,不会互相影响)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">origin = [<span class="string">"will"</span>, <span class="number">28</span>, [<span class="string">"python"</span>, <span class="string">"C++"</span>]]</span><br><span class="line">op_equal = origin</span><br><span class="line">cp_shallow = copy.copy(origin)</span><br><span class="line">cp_deep = copy.deepcopy(origin)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"origin:"</span>)</span><br><span class="line">print(id(origin))</span><br><span class="line">print(origin)</span><br><span class="line">print([id(item) <span class="keyword">for</span> item <span class="keyword">in</span> origin])</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">origin[<span class="number">0</span>] = <span class="string">"new_will"</span></span><br><span class="line">origin[<span class="number">1</span>] = <span class="number">30</span></span><br><span class="line">origin[<span class="number">2</span>].append(<span class="string">"Caffe2"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"changed origin:"</span>)</span><br><span class="line">print(id(origin))</span><br><span class="line">print(origin)</span><br><span class="line">print([id(item) <span class="keyword">for</span> item <span class="keyword">in</span> origin])</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"op_equal:"</span>)</span><br><span class="line">print(id(op_equal))</span><br><span class="line">print(op_equal)</span><br><span class="line">print([id(item) <span class="keyword">for</span> item <span class="keyword">in</span> op_equal])</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"cp_shallow:"</span>)</span><br><span class="line">print(id(cp_shallow))</span><br><span class="line">print(cp_shallow)</span><br><span class="line">print([id(item) <span class="keyword">for</span> item <span class="keyword">in</span> cp_shallow])</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"cp_deep"</span>)</span><br><span class="line">print(id(cp_deep))</span><br><span class="line">print(cp_deep)</span><br><span class="line">print([id(item) <span class="keyword">for</span> item <span class="keyword">in</span> cp_deep])</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">origin:</span><br><span class="line"><span class="number">4339513864</span></span><br><span class="line">[<span class="string">'will'</span>, <span class="number">28</span>, [<span class="string">'python'</span>, <span class="string">'C++'</span>]]</span><br><span class="line">[<span class="number">4334051088</span>, <span class="number">4330878304</span>, <span class="number">4339513928</span>]</span><br><span class="line"></span><br><span class="line">changed origin:</span><br><span class="line"><span class="number">4339513864</span></span><br><span class="line">[<span class="string">'new_will'</span>, <span class="number">30</span>, [<span class="string">'python'</span>, <span class="string">'C++'</span>, <span class="string">'Caffe2'</span>]]</span><br><span class="line">[<span class="number">4339502384</span>, <span class="number">4330878368</span>, <span class="number">4339513928</span>]</span><br><span class="line"><span class="comment"># str和int在修改时会被赋予新的地址空间, 同时替换对应的旧元素</span></span><br><span class="line"></span><br><span class="line">op_equal:</span><br><span class="line"><span class="number">4339513864</span></span><br><span class="line">[<span class="string">'new_will'</span>, <span class="number">30</span>, [<span class="string">'python'</span>, <span class="string">'C++'</span>, <span class="string">'Caffe2'</span>]]</span><br><span class="line">[<span class="number">4339502384</span>, <span class="number">4330878368</span>, <span class="number">4339513928</span>]</span><br><span class="line"><span class="comment"># =赋值, 会将所有元素及对象的地址传递, 不会生成新的变量及对象, 与原对象完全关联</span></span><br><span class="line"></span><br><span class="line">cp_shallow:</span><br><span class="line"><span class="number">4339513736</span></span><br><span class="line">[<span class="string">'will'</span>, <span class="number">28</span>, [<span class="string">'python'</span>, <span class="string">'C++'</span>, <span class="string">'Caffe2'</span>]]</span><br><span class="line">[<span class="number">4334051088</span>, <span class="number">4330878304</span>, <span class="number">4339513928</span>]</span><br><span class="line"><span class="comment">#浅拷贝会生成一个新对象, 但是, 对于对象内的元素, 浅拷贝只会使用原始元素的引用</span></span><br><span class="line"><span class="comment"># 对于非容器类型, 没有拷贝深浅之分, 因为原对象改变后, 其会指向一个新的地址, 而浅拷贝的地址不受影响, 所以二者是独立的</span></span><br><span class="line"><span class="comment"># 但如果是可变类型, 则不会生成新的地址, 这会的话原对象的改变会对浅拷贝对象造成影响</span></span><br><span class="line"></span><br><span class="line">cp_deep</span><br><span class="line"><span class="number">4339513672</span></span><br><span class="line">[<span class="string">'will'</span>, <span class="number">28</span>, [<span class="string">'python'</span>, <span class="string">'C++'</span>]]</span><br><span class="line">[<span class="number">4334051088</span>, <span class="number">4330878304</span>, <span class="number">4339513608</span>]</span><br><span class="line"><span class="comment"># 深拷贝, 与原对象完全独立, 没有任何关系</span></span><br></pre></td></tr></table></figure><h1 id="列表和元组之间的区别是"><a href="#列表和元组之间的区别是" class="headerlink" title="列表和元组之间的区别是:"></a>列表和元组之间的区别是:</h1><p>二者的区别主要是列表是可变的, 而元组是不可变的</p><h1 id="Python-三元运算子"><a href="#Python-三元运算子" class="headerlink" title="Python 三元运算子"></a>Python 三元运算子</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[on true] <span class="keyword">if</span> [expression] <span class="keyword">else</span> [on false]</span><br></pre></td></tr></table></figure><h1 id="Python的继承"><a href="#Python的继承" class="headerlink" title="Python的继承"></a>Python的继承</h1><p>单继承: 一个类继承自单个基类<br>多继承: 一个类继承自多个基类<br>多级继承: 一个类继承自单个继承, 后者则继承自另一个基类<br>分层继承: 多个类继承自单个基类<br>混合继承: 两种或多种类型继承的混合</p><h1 id="Python中是如何管理内存的"><a href="#Python中是如何管理内存的" class="headerlink" title="Python中是如何管理内存的?"></a>Python中是如何管理内存的?</h1><p>Python有一个四有堆空间来保存所有的对象和数据结构, 作为开发者, 无法对其进行访问, 是由解释器在管理它, 但是有了核心API之后, 可以访问一些工具, Python内存管理器控制内存分配.</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>logging模块-打印日志信息</title>
      <link href="/z_post/Python-logging/"/>
      <url>/z_post/Python-logging/</url>
      
        <content type="html"><![CDATA[<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"debug msg"</span>)</span><br><span class="line">logging.info(<span class="string">"info msg"</span>)</span><br><span class="line">logging.warn(<span class="string">"warn msg"</span>)</span><br><span class="line">logging.error(<span class="string">"error msg"</span>)</span><br><span class="line">logging.critical(<span class="string">"critical msg"</span>)</span><br></pre></td></tr></table></figure><p>默认情况下, logging模块将日志打印到屏幕上, 只有日志级别高于WARNING的日志信息才回输出</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Detectron源码解读-模型训练</title>
      <link href="/z_post/Caffe2-Detectron-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
      <url>/z_post/Caffe2-Detectron-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h1 id="运行Faster-RCNN指令"><a href="#运行Faster-RCNN指令" class="headerlink" title="运行Faster-RCNN指令"></a>运行Faster-RCNN指令</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python tools/train_net.py \</span><br><span class="line">    --cfg configs/getting_started/tutorial_1gpu_e2e_faster_rcnn_R<span class="number">-50</span>-FPN.yaml \</span><br><span class="line">    OUTPUT_DIR /tmp/detectron-output</span><br></pre></td></tr></table></figure><p>上面两行指令第一行指定了config文件的位置, 第二行指定了输出文件的位置.</p><p>在<code>tutorial_1gpu_e2e_faster_rcnn_R-50-FPN.yaml</code>文件中, 主要包含了以下几个关键信息:</p><ul><li>MODEL: 包含模型类型, 卷积网络的骨干, 样本类别数目</li><li>SOLVER: 包含一些参数的值, 如: 权重衰减系数, LR_POLICY, GAMMA, MAX_ITER等等</li><li>FPN: 包含若干布尔值, 指示是否开启FPN, MULTILEVEL_ROIS/RPN 等等</li><li>FAST_RCNN: 与ROI相关的一些信息</li><li>TRAIN: 指定初始化权重文件的url, 以及数据集相关信息</li><li>TEST: 指定TEST数据集相关信息, NMS阈值</li><li>OUTPUT_DIR: . 被命令行的参数覆盖</li></ul><p><img src="http://wx1.sinaimg.cn/large/d7b90c85ly1fw6x5xbfw6j213z0f977z.jpg" alt=""></p><p>上图为<code>tools/train_net.py</code>文件函数调用的关系图, 几乎所有的模型都是通过这个脚本运行的, 源码分析如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tools/train_net.py</span></span><br><span class="line"><span class="keyword">from</span> __future <span class="keyword">import</span> ... <span class="comment"># 导入__future__的相关包, 兼容python2</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="comment">#由于cv2自身的bug, cv2必须在caffe2之前被导入</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> workspace</span><br><span class="line"><span class="comment"># 导入detectron相关</span></span><br><span class="line"><span class="keyword">from</span> detectron.core.config <span class="keyword">import</span> assert_and_infer_cfg</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> detectron.core.config <span class="keyword">import</span> cfg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> detectron.utils.logging <span class="keyword">import</span> setup_logging</span><br><span class="line"><span class="comment"># helpful utilities for working with caffe2</span></span><br><span class="line"><span class="keyword">import</span> detectron.utils.c2 <span class="keyword">as</span> c2_utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练文件</span></span><br><span class="line"><span class="keyword">import</span> detectron.utils.train</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入Detectron需要的相关contirb ops(nccl ops)</span></span><br><span class="line">c2_utils.import_contrib_ops()</span><br><span class="line"><span class="comment"># 导入Detectron ops</span></span><br><span class="line">c2_utils.import_detectron_ops()</span><br><span class="line"></span><br><span class="line">cv2.ocl.setUseOpenCL(<span class="keyword">False</span>) <span class="comment">#源码注释已经说得很清楚, 就是为了安全而特意禁用opencl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_args</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># 定义了各种命令行参数, 一般只需要关注--cfg参数, 其他默认即可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># 初始化caffe2的全局环境,</span></span><br><span class="line">  <span class="comment">#如果希望看到更加详细的初始化信息, 可以将log_level设置为1</span></span><br><span class="line">  workspace.GlobalInit(</span><br><span class="line">    [<span class="string">'caffe2'</span>, <span class="string">'--caffe2_log_level=0'</span>, <span class="string">'--caffe2_gpu_memory_tracking=1'</span>]</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">## 设置logging, __name__ = '__main__', 使用了python的logging模块,</span></span><br><span class="line">  logger = setup_logging(__name__)  </span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  <span class="comment"># 解析命令行参数</span></span><br><span class="line">  args = parse_args()</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> args.cfg_file <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">    <span class="comment"># from detectron.core.config import merge_cfg_from_file</span></span><br><span class="line">    merge_cfg_from_file(args.cfg_file)</span><br><span class="line">  <span class="keyword">if</span> args.opts <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">    <span class="comment"># from detectron.core.config import merge_cfg_from_list</span></span><br><span class="line">    merge_cfg_from_list(args.opts)</span><br><span class="line">  assert_and_infer_cfg()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 获取并显示当前的nvidia相关信息</span></span><br><span class="line">  smi_output, cuda_ver, cudnn_ver = c2_utils.get_nvidia_info()</span><br><span class="line">  logger.info(...)</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 设置随机种子, 以便每次训练时的网络状态都不同</span></span><br><span class="line">  np.random.seed(cfg.RNG_SEED)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 最重要的一行代码, 执行训练!</span></span><br><span class="line">  <span class="comment"># import detectron.utils.train</span></span><br><span class="line">  checkpoints = detectron.utils.train.train_model()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 测试训练好的模型</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> args.skip_test:</span><br><span class="line">    test_model(...)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(...)</span>:</span></span><br><span class="line">  <span class="comment"># 测试训练好的模型</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h1 id="train-py-文件"><a href="#train-py-文件" class="headerlink" title="train.py 文件"></a>train.py 文件</h1><p>可以看到, 上面只是一个启动训练代码的脚本文件, 接下来看一下<code>train.py</code>文件中的<code>train_model()</code>函数的详细情况:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#detectron/utils/train.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="string">"""循环训练模型"""</span></span><br><span class="line">  model, weights_file, start_iter, checkpoints, output_dir = create_model()</span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure><h1 id="create-model"><a href="#create-model" class="headerlink" title="create_model()"></a><code>create_model()</code></h1><p>在这里, <code>train_model()</code>函数的开始调用了<code>create_model()</code>函数, 在进行后面的代码分析之前, 需要先看看这个函数具体做了什么, 返回了什么:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#detectron/utils/train.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_critical_error</span><span class="params">(model,msg)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_model</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="string">"""创建模型, 并且寻找保存的checkpoints用以继续训练"""</span></span><br><span class="line">  logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">  start_iter = <span class="number">0</span></span><br><span class="line">  checkpoints = &#123;&#125;</span><br><span class="line">  <span class="comment"># from detectron.core.config import get_output_dir</span></span><br><span class="line">  <span class="comment"># def get_output_dir(datasets, training=True)</span></span><br><span class="line">  <span class="comment"># 这里只是用了数据集的名字, 并不是使用数据集</span></span><br><span class="line">  <span class="comment"># 在OUTPUT文件夹(由config定义)会创建一个新的文件夹, 并返回该路径:</span></span><br><span class="line">  <span class="comment"># &lt;output-dir&gt;/&lt;train|test&gt;/&lt;dataset-name&gt;/&lt;model-type&gt;/</span></span><br><span class="line">  <span class="comment"># 对于本例来说, cfg.TRAIN.DATASETS = ('coco_2014_train',)</span></span><br><span class="line">  output_dir = get_output_dir(cfg.TRAIN.DATASETS, train = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 默认为R-50.pkl的 url 下载地址</span></span><br><span class="line">  weights_file = cfg.TRAIN.WEIGHTS</span><br><span class="line">  <span class="keyword">if</span> cfg.TRAIN.AUTO_RESUME: <span class="comment">#TODO, 这个参数在哪里??</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 对于本例, cfg.MODEL.TYPE = generalized_rcnn</span></span><br><span class="line">  logger.info(<span class="string">"Building model: &#123;&#125;"</span>.format(cfg.MODEL.TYPE))</span><br><span class="line"></span><br><span class="line">  <span class="comment"># from detectron.modeling import model_builder</span></span><br><span class="line">  <span class="comment"># def create(model_type_func, train=False, gpu_id=0)</span></span><br><span class="line">  <span class="comment"># 创建一个一般化的模型, 然后将其转化成特定的模型</span></span><br><span class="line">  <span class="comment"># 函数内部使用了detectron/modeling/detector.py 中的DetectionModelHelper类</span></span><br><span class="line">  <span class="comment"># 同时将cfg.MODEL.NUM_CLASSES信息传递给了该类</span></span><br><span class="line">  <span class="comment"># cfg.MODEL.TYPE = generalized_rcnn</span></span><br><span class="line">  <span class="comment"># <span class="doctag">TODO:</span> 此行代码涉及的文件和代码较多, 暂时先不深入探讨, 可以认为是创建了一个模型</span></span><br><span class="line">  model = model_builder.create(cfg.MODEL.TYPE, train=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> cfg.MEMONGER: <span class="comment"># TODO, 这个参数在哪里?</span></span><br><span class="line">      optimize_memory(model)</span><br><span class="line"></span><br><span class="line">  workspace.RunNetOnce(model.param_init_net)</span><br><span class="line">  <span class="keyword">return</span> model, wright_file, start_iter, checkpoints, output_dir</span><br></pre></td></tr></table></figure></p><h1 id="setup-model-for-training"><a href="#setup-model-for-training" class="headerlink" title="setup_model_for_training(...)"></a><code>setup_model_for_training(...)</code></h1><p>接着回到刚才的<code>train_model()</code>函数:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#detectron/utils/train.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""循环训练模型"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 由上面的函数可知:</span></span><br><span class="line">    <span class="comment"># model为DetectionModelHelper类创建的模型对象</span></span><br><span class="line">    <span class="comment"># weights_file即为cfg文件里定义的权重文件的url</span></span><br><span class="line">    <span class="comment"># start_iter = 0</span></span><br><span class="line">    <span class="comment"># checkpoints =&#123;&#125; 字典类型哦!</span></span><br><span class="line">    <span class="comment"># output_dir为根据cfg.OUTPUT_DIR和DATASETS名字创建的输出目录</span></span><br><span class="line">    model, weights_file, start_iter, checkpoints, output_dir = create_model()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">"final"</span> <span class="keyword">in</span> checkpoints:</span><br><span class="line">        <span class="comment"># 如果已经训练完成, 则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> checkpoints</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里调用了本文件的函数, 主要是为训练模型做准备工作</span></span><br><span class="line">    setup_model_for_training(model, weights_file, output_dir)</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure></p><p>具体看一下<code>setup_model_for_training</code>函数的内部实现</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#detectron/utils/train.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载保存的权重文件, 同时在 C2 workspace 中创建 network</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_model_for_training</span><span class="params">(model, weights_file, output_dir)</span>:</span></span><br><span class="line">    logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#调用了本文件的函数, 主要用于加载训练数据集, 并且将训练输入绑定到model中</span></span><br><span class="line">    <span class="comment"># def add_model_training_inputs(model), 无返回值</span></span><br><span class="line">    <span class="comment"># 核心代码:</span></span><br><span class="line">    <span class="comment"># from detectron.datasets.roidb import combined_roidb_for_trainig</span></span><br><span class="line">    <span class="comment"># roidb = combined_roidb_for_training(cfg.TRAIN.DATASETS, cfg.TRAIN.PROPOSAL_FILES)</span></span><br><span class="line">    <span class="comment"># model_builder.add_training_inputs(model, roidb = roidb)</span></span><br><span class="line">    <span class="comment"># 添加roidb, 内部会调用model_builder.add_training_inputs,</span></span><br><span class="line">    <span class="comment"># 该函数会为model创建用于训练网络的input ops 和blobs, 需要在调用了model_builder.create()之后调用</span></span><br><span class="line">    <span class="comment"># 创建位于detectron.roi_data.loader中的RoIDataLoader对象进行数据载入</span></span><br><span class="line">    <span class="comment"># model.roi_data_loader = RoIDataLoader()</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 数据集加载过程涉及文件较多,后面会单独解析, 此处不太多讨论</span></span><br><span class="line">    add_model_training_inputs(model)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># import detectron.utils.net as nu</span></span><br><span class="line">    <span class="keyword">if</span> weights_file:</span><br><span class="line">        <span class="comment"># 从权重文件中初始化模型, 覆盖随机初始化参数权重, 并且指定gpu</span></span><br><span class="line">        nu.initialize_gpu_from_weights_file(model, weights_file, gpu_id=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多GPU训练时,训练同步GPU之间的参数信息</span></span><br><span class="line">    <span class="comment"># if cfg.NUM_GPUS = 1 直接return, 所以这句话在单GPU下可有可无</span></span><br><span class="line">    nu.broadcast_parameters(model)</span><br><span class="line">    <span class="comment"># 正式创建caffe2网络</span></span><br><span class="line">    workspace.CreateNet(model.net)</span><br><span class="line">    <span class="comment">#...log info</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 本文件内的函数: def dump_proto_files(model, output_dir)</span></span><br><span class="line">    <span class="comment"># 保存训练网络的参数初始化的prototxt 描述信息</span></span><br><span class="line">    <span class="comment"># 分别为output_dir里面的net.pbtxt和param_init_net.pbtxt文件</span></span><br><span class="line">    dump_proto_files(model, output_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 载入mini-batches, 同时enqueuing blobs</span></span><br><span class="line">    model.roi_data_loader.register_sigint_handler()</span><br><span class="line">    model.roi_data_loader.start(prefill=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output_dir</span><br></pre></td></tr></table></figure><h1 id="add-model-training-inputs-model"><a href="#add-model-training-inputs-model" class="headerlink" title="add_model_training_inputs(model)"></a>add_model_training_inputs(model)</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#detectron/utils/train.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_training_inputs</span><span class="params">(model)</span>:</span></span><br><span class="line">    logger = logging.getLogger(__name__)</span><br><span class="line">    logger.info(<span class="string">'Loading dataset: &#123;&#125;'</span>.format(cfg.TRAIN.DATASETS))</span><br><span class="line">    roidb = combined_roidb_for_training(</span><br><span class="line">        cfg.TRAIN.DATASETS, cfg.TRAIN.PROPOSAL_FILES</span><br><span class="line">    )</span><br><span class="line">    logger.info(<span class="string">'&#123;:d&#125; roidb entries'</span>.format(len(roidb)))</span><br><span class="line">    model_builder.add_training_inputs(model, roidb=roidb)</span><br></pre></td></tr></table></figure><h1 id="再看-train-model"><a href="#再看-train-model" class="headerlink" title="再看 train_model()"></a>再看 <code>train_model()</code></h1><p>接着回到刚才的<code>train_model()</code>函数:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#detectron/utils/train.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""循环训练模型"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用本文件的create_model()函数, 由上面的函数可知:</span></span><br><span class="line">    <span class="comment"># model为DetectionModelHelper类创建的模型对象</span></span><br><span class="line">    <span class="comment"># weights_file即为cfg文件里定义的权重文件的url</span></span><br><span class="line">    <span class="comment"># start_iter = 0</span></span><br><span class="line">    <span class="comment"># checkpoints =&#123;&#125; 字典类型哦!</span></span><br><span class="line">    <span class="comment"># output_dir为根据cfg.OUTPUT_DIR和DATASETS名字创建的输出目录</span></span><br><span class="line">    model, weights_file, start_iter, checkpoints, output_dir = create_model()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">"final"</span> <span class="keyword">in</span> checkpoints:</span><br><span class="line">        <span class="comment"># 如果已经训练完成, 则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> checkpoints</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里调用了本文件的函数, 主要是为训练模型做准备工作, 加载权重, 创建网络等等</span></span><br><span class="line">    setup_model_for_training(model, weights_file, output_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># from detectron.utils.training_stats import TrainingStats</span></span><br><span class="line">    <span class="comment"># def __init__(self, model)</span></span><br><span class="line">    <span class="comment"># 跟踪模型训练时的关键统计数据</span></span><br><span class="line">    training_stats = TrainingStats(model)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO SNAPSHOT_ITERS参数在哪?</span></span><br><span class="line">    CHECKPOINT_PERIOD = int(cfg.TRAIN.SNAPSHOT_ITERS/cfg.NUM_GPUS)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#循环训练过程cfg.SOLVER.MAX_ITER=60000次</span></span><br><span class="line">    <span class="keyword">for</span> cur_iter <span class="keyword">in</span> range(start_iter, cfg.SOLVER.MAX_ITER):</span><br><span class="line">        <span class="comment"># model.roi_data_loader是位于detectron.roi_data.loader中的RoIDataLoader对象</span></span><br><span class="line">        <span class="comment"># def has_stopped(self): return self.coordinator.should_stop()</span></span><br><span class="line">        <span class="comment"># coordinator是位于detectron.utils.coordinator中的Coordinator类的对象, 该类用于多线程处理数据队列</span></span><br><span class="line">        <span class="keyword">if</span> model.roi_data_loader.has_stopped():</span><br><span class="line">            handle_critical_error(model, <span class="string">'roi_data_loader failed'</span>)</span><br><span class="line">        <span class="comment"># from detectron.utils.training_stats import TrainingStats</span></span><br><span class="line">        <span class="comment"># 用于训练计时, 计时开始</span></span><br><span class="line">        training_stats.IterTic()</span><br><span class="line">        <span class="comment">#更新学习率</span></span><br><span class="line">        lr = model.UpdateWorkspaceLr(cur_iter, lr_policy.get_lr_at_iter(cur_iter))</span><br><span class="line">        <span class="comment"># 运行网络!关键步骤</span></span><br><span class="line">        workspace.RunNet(model.net.Proto().name)</span><br><span class="line">        <span class="keyword">if</span> cur_iter == start_iter: <span class="comment">#首次迭代打印模型信息</span></span><br><span class="line">        <span class="comment"># import detectron.utils.net as nu</span></span><br><span class="line">            nu.print_net(model)</span><br><span class="line">        training_stats.IterToc() <span class="comment"># 计时结束</span></span><br><span class="line">        training_stats.UpdateIterStats()</span><br><span class="line">        training_stats.LogIterStats(cur_iter, lr)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 迭代到指定次数以后, 自动保存模型</span></span><br><span class="line">        <span class="keyword">if</span> (cur_iter+<span class="number">1</span>) % CHECKPOINT_PERIOD ==<span class="number">0</span> <span class="keyword">and</span> cur_iter&gt;start_iter:</span><br><span class="line">            checkpoints[cur_iter] = os.path.join(output_dir, <span class="string">"model_iter&#123;&#125;.pkl"</span>.format(cur_iter))</span><br><span class="line">            nu.save_model_to_weights_file(checkpoints[cur_iter], model)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur_iter == start_iter + training_stats.LOG_PERIOD:</span><br><span class="line">            training_stats.ResetIterTimer()</span><br><span class="line">        <span class="comment"># 判断损失函数是否出现了nan值, 如果出现,则报错,注意,nan不是inf, nan值代表不存在的值, 如log(-1), 而log(0)是inf, 不是nan</span></span><br><span class="line">        <span class="keyword">if</span> np.isnan(training_stats.iter_total_loss):</span><br><span class="line">            handle_critical_error(model, <span class="string">"loss is NaN"</span>)</span><br><span class="line"></span><br><span class="line">    checkpoints[<span class="string">'final'</span>] = os.path.join(output_dir, <span class="string">'model_final.pkl'</span>)</span><br><span class="line">    nu.save_model_to_weights_file(checkpoints[<span class="string">'final'</span>], model)</span><br><span class="line">    model.roi_data_loader.shutdown()</span><br><span class="line">    <span class="keyword">return</span> checkpoints</span><br></pre></td></tr></table></figure></p><p>以上,便是<code>train_model()</code>函数的整体流程, 执行该函数后,训练过程就已经开始, 在detectron中, 所有的模型可数据都是用这个脚本训练的, 根据config文件的具体参数来决定载入哪个model, 或者使用哪个数据集. 但是上面的过程太过笼统, 给人一种隔了一堵墙的感觉. 因此, 我们需要更加深入了理解detectron是如何处理数据的, 又是如何将数据送到模型中去的, 另外, 每个模型的定义又是怎样的. 这些信息我会在后面的文章里一一解读.</p>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Caffe2 基础</title>
      <link href="/z_post/Caffe2-%E5%9F%BA%E7%A1%80/"/>
      <url>/z_post/Caffe2-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="from-caffe2-python-import-core"><a href="#from-caffe2-python-import-core" class="headerlink" title="from caffe2.python import core :"></a>from caffe2.python import core :</h1><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>Caffe2中的Operators有点像函数, 从C++的角度来说, 它们都是从一个通用接口派生而来的, 并且通过类型注册(什么意思?), 因此我们可以在runtime下调用不同的operators. 关于operators的接口定义在 <code>caffe2/proto/caffe2.proto</code> 中. 通常情况下, 它会接受一大批输入, 同时会返回一大批输出.</p><p>记住, 当我们说在 Caffe2 Python 中创建一个operator时, 还没有任何东西开始运行. 这仅仅是创建了一个<code>protocal buffer</code>(协议缓冲区), 用于指定具体的operator, 在稍后的一段时间内, 它将会被送入到C++后台去执行.(protobuf仅仅是一个针对结构化数据的json-like的序列化工具).</p><h3 id="Relu"><a href="#Relu" class="headerlink" title="Relu"></a>Relu</h3><p>下面的代码创建了一个<code>operator</code>:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">op = core.CreateOperator(</span><br><span class="line">    <span class="string">"Relu"</span>, <span class="comment"># 我希望运行的operator的类型</span></span><br><span class="line">    [<span class="string">"X"</span>], <span class="comment"># 一个列表, 里面存放的是输入的blobs的名字</span></span><br><span class="line">    [<span class="string">"Y"</span>] <span class="comment"># 仍然是一个列表, 里面存放的是输出的blobs的名字</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(type(op)) <span class="comment"># &lt;class 'caffe2.proto.caffe2_pb2.OperatorDef'&gt;</span></span><br><span class="line">print(op)</span><br><span class="line"><span class="comment"># input: "X"</span></span><br><span class="line"><span class="comment"># output: "Y"</span></span><br><span class="line"><span class="comment"># name: ""</span></span><br><span class="line"><span class="comment"># type: "Relu"</span></span><br></pre></td></tr></table></figure></p><p>接下来, 尝试使用operator, 首先将输入blobs添加到workspace中, 然后使用最简单的运行operator的方法, 即调用<code>workspace.RunOperatorOnce(operator)</code>:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workspace.FeedBlob(<span class="string">"X"</span>, np.random.randn(<span class="number">2</span>,<span class="number">3</span>).astype(np.float32))</span><br><span class="line">workspace.RunOperatorOnce(op) <span class="comment"># 指定需要运行的operator变量</span></span><br></pre></td></tr></table></figure></p><p>执行了<code>RunOperatorOnce</code>以后, workspace中会多出一个名字为<code>name=&quot;Y&quot;</code>的blobs, 用<code>FetchBlobs()</code>获取该blobs以后, 可以看到Y的值实际上就是对X执行Relu函数以后的结果(对应位置大于0的元素保留, 其他位置归0). <strong>注意, 只有在执行了RunOperatorOnce以后, 名字为Y的blobs才会存在于workspace中, 此时使用FetchBlobs()才能够获取到对应值, 否则, Y是不存在的</strong></p><h3 id="GaussianFill"><a href="#GaussianFill" class="headerlink" title="GaussianFill"></a>GaussianFill</h3><p>operators同时也可以接受一些可选参数, 这些参数可以通过键值的方式来指定:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">op = core.CreateOperator(</span><br><span class="line">    <span class="string">"GaussianFill"</span>,</span><br><span class="line">    [], <span class="comment"># 填充时不需要输入任何数据</span></span><br><span class="line">    [<span class="string">"Z"</span>], <span class="comment"># 指定输出的名字</span></span><br><span class="line">    shape=[<span class="number">100</span>,<span class="number">100</span>], <span class="comment"># 指定shape, 这里是一个100×100的二维列表</span></span><br><span class="line">    mean=<span class="number">1.0</span>, <span class="comment"># 指定平均值</span></span><br><span class="line">    std=<span class="number">1.0</span> <span class="comment"># 指定标准差</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="Nets"><a href="#Nets" class="headerlink" title="Nets"></a>Nets</h2><p>Nets本质上就是计算图. 一个Net由多个operators组成, 当我们谈到Nets的时候, 我们同时也会谈到 BlobReference, 这是一个对象, 通过它我们可以轻易的将各种operators连接起来.</p><p>在创建网络时, 暗示着protocal buffer除了name以外其余都是空的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_net = core.Net(<span class="string">"my_first_net"</span>)  <span class="comment"># 重复调用时, 会不断创建net, 每次都会在后面加上一个后缀以区别不同的net, 如my_first_net, my_first_net_1, my_first_net_2等等</span></span><br><span class="line">print(my_net.Proto()) <span class="comment"># name: "my_first_net"</span></span><br><span class="line">print(type(my_net)) <span class="comment"># &lt;class 'caffe2.python.core.Net'&gt;</span></span><br></pre></td></tr></table></figure></p><p>接下来, 向net中创建一些blobs<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = my_net.GaussianFill([], [<span class="string">"X"</span>], mean=<span class="number">0.0</span>, shape=[<span class="number">2</span>,<span class="number">3</span>], std=<span class="number">1.0</span>, run_once=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>此时, <code>my_net</code>中就创建了一个operator, 其类型为”GaussianFill”. 在这里, 对象<code>X</code>的类型为: <code>&lt;class &#39;caffe2.python.core.BlobReference&#39;&gt;</code>, 它会记录两个值, 一个是blob的名字, 另一个记录该对象是从哪个net中来的(<code>_from_net</code>).</p><p>上面没有使用<code>core</code>, 而是直接利用<code>my_net</code>进行operator的创建, 同样也可以使用<code>core</code>中的<code>CreateOperator</code>来创建operator, 并将其添加到对应的net中, 如下所示:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">op = core.CreateOperator(<span class="string">"op_name"</span>, ... )</span><br><span class="line">net.Proto().op.append(op)</span><br></pre></td></tr></table></figure></p><p>继续创建W和b:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = net.GaussianFill([], [<span class="string">"W"</span>], mean=<span class="number">0.0</span>, std=<span class="number">1.0</span>, shape=[<span class="number">5</span>,<span class="number">3</span>], run_once=<span class="number">0</span>)</span><br><span class="line">b = net.ConstantFill([], [<span class="string">"b"</span>], shape=[<span class="number">5</span>,], value=<span class="number">1.0</span>, run_once=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>下面利用了一个简单的语法糖, 由于<code>BlobReference</code>对象知道自己是从哪个net中来的, 因此, 可以直接利用<code>BlobReference</code>对象来创建operators, 下面显示了如何创建FC operator:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = X.FC([W,b], [<span class="string">"Y"</span>])</span><br></pre></td></tr></table></figure></p><p>如果利用net创建则是下面的形式:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = my_net.FC([X,W,b], [<span class="string">"Y"</span>])</span><br></pre></td></tr></table></figure></p><p>此时, 如果利用<code>my_net.Proto()</code>来查看net信息的话, 由于参数变多, 难以观察, 因此 Caffe2 提供了一个精简的minimal graph视图来帮助观察net:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> net_drawer</span><br><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display</span><br><span class="line">graph = net_drawer.GetPydotGraph(net, rankdir=<span class="string">"LR"</span>)</span><br><span class="line">display.Image(graph.create_pgn(), width=<span class="number">800</span>)</span><br></pre></td></tr></table></figure></p><p>通过上面的代码, 我们创建一个Net, 但是还没有任何东西被运行, 当我们运行network的时候, 会发生下面两件事情:</p><ul><li>一个C++的net对象会从protobuf中实例化</li><li>实例化的网络的Run()函数会被调用</li></ul><p>再做其他事情之前, 我们需要先用<code>ResetWorkspace()</code>清空早前的workspace, 然后有两种方式可以用来run net, 首先看看第一种:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">workspace.ResetWorkspace()</span><br><span class="line">print(workspace.Blobs()) <span class="comment"># []  可以看到, 列表为空, 因为X,Y,W,b均是operators</span></span><br><span class="line">workspace.RunNetOnce(net)  <span class="comment"># 只执行一次, 无需调用CreateNet</span></span><br><span class="line">print(workspace.Blobs()) <span class="comment"># ['W','X','Y','b'], 在执行了RunNetOnce以后, workspace内被添加了有关operators的blobs.</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> workspace.Blobs():</span><br><span class="line">    print(name, workspace.FetchBlobs(name))</span><br></pre></td></tr></table></figure></p><p>下面是第二种创建并执行net的方式, 首先, 清空workspace里面的blobs, 然后创建net对象, 最后, 执行net<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">workspace.ResetWorkspace()</span><br><span class="line">print(workspace.Blobs()) <span class="comment">#[] 之前的blobs又被清空了</span></span><br><span class="line">workspace.CreateNet(net)  <span class="comment"># 先创建net</span></span><br><span class="line">workspace.RunNet(net.Proto().name) <span class="comment"># 执行net, 传入net.Proto().name参数</span></span><br><span class="line">print(workspace.Blobs()) <span class="comment"># ['W','X','Y','b']</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> workspace.Blobs():</span><br><span class="line">    print(name, workspace.FetchBlob(name))</span><br></pre></td></tr></table></figure></p><p><code>RunNetOnce</code> 和 <code>RunNet</code> 之间有一点小区别, 最重要的区别就是计算开销的不同. 因为<code>RunNetOnce</code>包含了序列化protobuf, 同时还要将其在Python和C中传递, 并对network进行初始化, 因此它需要更长的执行时间.</p><h1 id="from-caffe2-python-import-workspace"><a href="#from-caffe2-python-import-workspace" class="headerlink" title="from caffe2.python import workspace"></a>from caffe2.python import workspace</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="comment"># NOQA(Must import before importing caffe2 due to bug in cv2)</span></span><br><span class="line"><span class="keyword">from</span> caffe2.python <span class="keyword">import</span> workspace</span><br><span class="line"><span class="comment"># 初始化caffe2的全局环境,</span></span><br><span class="line"><span class="comment">#如果希望看到更加详细的初始化信息, 可以将log_level设置为1</span></span><br><span class="line">workspace.GlobalInit(</span><br><span class="line">  [<span class="string">'caffe2'</span>, <span class="string">'--caffe2_log_level=0'</span>, <span class="string">'--caffe2_gpu_memory_tracking=1'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>caffe2的工作空间由你创建的blobs组成, 并且将其存储在内存当中. 将blob当做是numpy中的一个N维数组, 可以从<code>Basics.ipynb</code>中看出, blob实际上是一个指针, 它指向可以存储任意类型的一个C++对象, 但是最常存储的类型仍然是 <code>Tensor</code> 类型.</p><h1 id="workspace-Blobs"><a href="#workspace-Blobs" class="headerlink" title="workspace.Blobs()"></a><code>workspace.Blobs()</code></h1><p>方法可以打印出workspace中的所有存在的blobs (只会显示出blobs的名称).</p><h1 id="workspace-HasBlob-quot-blob-name-quot"><a href="#workspace-HasBlob-quot-blob-name-quot" class="headerlink" title="workspace.HasBlob(&quot;blob_name&quot;)"></a><code>workspace.HasBlob(&quot;blob_name&quot;)</code></h1><p>用于查询workspace中是否存在名为<code>blob_name</code>的blob, 返回一个布尔值</p><h1 id="workspace-FeedBlob"><a href="#workspace-FeedBlob" class="headerlink" title="workspace.FeedBlob()"></a><code>workspace.FeedBlob()</code></h1><p>用于向workspace中添加blobs<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.random.randn(<span class="number">2</span>,<span class="number">3</span>).astype(np.float32)</span><br><span class="line">print(<span class="string">"Generated X from numpy:\n&#123;&#125;"</span>.format(X))</span><br><span class="line">workspace.FeedBlob(<span class="string">"X"</span>, X) <span class="comment"># 若添加成功, 则返回True, 否则, 返回False</span></span><br><span class="line"><span class="comment"># 如果调用该函数时, 名字已经在workspace中存在, 则后添加的值会覆盖之前添加的值</span></span><br></pre></td></tr></table></figure></p><h2 id="workspace-FetchBlob-quot-X-quot"><a href="#workspace-FetchBlob-quot-X-quot" class="headerlink" title="workspace.FetchBlob(&quot;X&quot;)"></a><code>workspace.FetchBlob(&quot;X&quot;)</code></h2><p>用来获取对应名字的blob的值, 如果获取的名字不在workspace中, 那么就会抛出错误, 我们可以用利用<code>try except</code>语句来输出错误信息:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    workspace.FetchBlob(<span class="string">"not_exists_name"</span>)</span><br><span class="line"><span class="keyword">except</span> RuntimeError <span class="keyword">as</span> err:</span><br><span class="line">    print(err)  <span class="comment"># Can't find blob:...</span></span><br></pre></td></tr></table></figure></p><h1 id="workspace-SwitchWorkspace"><a href="#workspace-SwitchWorkspace" class="headerlink" title="workspace.SwitchWorkspace()"></a><code>workspace.SwitchWorkspace()</code></h1><p>同时, 你可以拥有多个不同的workspaces, 每一个workspace都有不同的名字, 你可以调用<code>workspace.SwitchWorkspace(&quot;name&quot;)</code>来在这些不同的名字之间交换. 不同workspace中的blobs是相互独立的,  你可以使用<code>workspace.CurrentWorkspace</code>来查询当前所有的workspace:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Switch the workspace. The second argument "True" means creating</span></span><br><span class="line"><span class="comment"># the workspace if it is not exists</span></span><br><span class="line">workpsace.SwitchWorkspace(<span class="string">"new_workspace_name"</span>, <span class="keyword">True</span>) <span class="comment"># 如果名为"new_workspace_name"的workspace存在, 则切换当前workspace到该workspace, 如果不存在, 那么就创建它.</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Current workspace:&#123;&#125;"</span>.format(workspace.CurrentWorkspace())) <span class="comment"># 默认的workspace的名称为: default</span></span><br><span class="line">print(<span class="string">"Current blobs in the workspace:&#123;&#125;"</span>.format(workspace.Blobs()))</span><br></pre></td></tr></table></figure></p><p>利用<code>workspace.ResetWorkspace()</code>可以清空当前workspace中的所有东西, 谨慎使用<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workspace.ResetWorkspace()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>OverFeat-ICLR2014</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICLR2014-OverFeat/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICLR2014-OverFeat/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> OverFeat: Integrated Recognition, Localization and Detectin using Convolutional Networks</p><p><strong>作者:</strong></p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>Multi-Scale Classification:</strong><br>在分类任务上, 虽然训练时采用和AlexNet相同的multi crop方法, 但是在预测阶段没有使用AlexNet的crop投票策略, 而是提出了Multi-Scale Classification方法, 一句话概括就是 <strong>对整个图片以不同的尺寸, 并且对每一个location进行模型预测</strong></p><p><strong>利用了全卷积的思想代替全连接, 降低了滑动窗口的计算代价</strong></p><p><strong>可以用同一个模型完成分类, 定位, 检测任务:</strong><br>同一个模型, 只需要用回归层替换分类层, 即可完成目标定位任务, 同时利用了贪心策略来融合最终的定位结果</p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>提出了一种新的深度学习方法, 通过预测物体的边界来对目标物体进行定位.</p><p>本文的模型是ILSVRC2013的冠军</p><p>从表现最好的模型中开源了特征提取器, 并取名为OverFeat</p><p>作者为了避免大量的时间消耗, 没有在背景样例中训练, 但同时声称效果也不错?(持怀疑态度)</p><p>物体画框的时候, 因为画到了物体的一部分, 而没有画到整个物体, 更别说将框画到物体的正中心了. 因此, 希望可以对框进行预测回归, 使之画出来的框更加准确</p><p>与Krizhevsky等人之前的图像分类的paper做了个简单的比较</p><h2 id="2-视觉任务"><a href="#2-视觉任务" class="headerlink" title="2. 视觉任务"></a>2. 视觉任务</h2><p>本文研究了三种计算机视觉任务, 分别为: 分类, 定位和检测</p><h2 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h2><p>本文的分类体系架构与Krizhevsky在12年使用的体系结构类似, 但是对模型中的一些细节进行了更多的探索</p><h3 id="3-1-模型设计和训练"><a href="#3-1-模型设计和训练" class="headerlink" title="3.1 模型设计和训练"></a>3.1 模型设计和训练</h3><p>训练数据集: ImageNet 2012 (1.2 million 张图片, 共1000类)</p><p>输入尺寸: 训练阶段先将所有的图片downsample, 使其最小尺寸为256, 然后从每张图片(包括反转图片)中裁剪出5张子图(加上反转共10张), 尺寸为221*221, 这与AlexNet的策略相同, 但是在预测阶段, 使用了不同Multi-Scale Classificatioin方法, 具体见下文.</p><p>mini-batch: 128</p><p>模型权重初始化: 随机初始化 $(\mu, \sigma) = (0, 1\times 10^{-2})$</p><p>momentmu项为: 0.6</p><p>L2 权重衰减系数: $1\times 10^{-5}$</p><p>学习率: $5\times 10^{-2}$, 每经过(30,50,60,70,80)epochs时, 衰减1/2.</p><p>Dropout: 0.5(用于6,7层的全连接)</p><p>模型结果细节图:</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fw5dt28gbnj20wi0e3aet.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw5dx6jm9ej20vr0an408.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw5e0t8ilxj20r006w3z5.jpg" alt=""></p><h3 id="3-2-Feature-Extractor"><a href="#3-2-Feature-Extractor" class="headerlink" title="3.2 Feature Extractor"></a>3.2 Feature Extractor</h3><p>根据本文的方法, 开源了一个名为”OverFeat”的Feature Extractor, 有两个版本, 分别是精度优先和速度优先. 模型结构以及他们之间的比较都在上面两张图中显示.</p><h3 id="3-3-Multi-Scale-Classificaion"><a href="#3-3-Multi-Scale-Classificaion" class="headerlink" title="3.3 Multi-Scale Classificaion"></a>3.3 Multi-Scale Classificaion</h3><p><strong>在测试阶段</strong>, 之前的Alex-Net中, 使用了multi-view投票来提升性能(一张图片crop出10个子图, 分别为四角和中心,以及他们的反转图片). 但是这个方法有一些问题: 忽视了图片中的很多区域, 并且计算存在冗余重复, 同时, 生成子图的操作都是在同一尺度上进行的, 这有时候不是最佳的尺度选择策略.</p><p>与此相反, <strong>本文提出对整个图片以不同的尺寸, 并且对每一个location进行模型预测</strong> , 虽然这种滑动窗口的方法在计算上是不可取的, 但是, 结合下面的3.5节中的策略, 可以缓解计算复杂问题.</p><p><strong>上面方法的好处:</strong> 可以对同一张图片生成更多不同角度下的预测结果, 并将结果用于投票, 使得最终结果更鲁棒.</p><p><strong>但是存在问题:</strong> 上面提到的subsampling方法的比例为 2×3×2×3, 也就是36. 这样一来, 模型在只能依赖36个像素点来生成分类向量. 这样粗粒度的分布使得模型的性能表现低于10-view方法.  主要原因是因为网络窗口没有和图片中的物体边界对齐. 于是本文提出了一种方法来克服这个问题, 对最后一个subsampling在不同的offset上进行pooling, 这样做可以缓解这一层的loss of resolution问题, 生成的总的subsampling比例为12, 而不是36. //TODO 这一段啥意思?, 36怎么来的, 12怎么来</p><p>下来解释具体是如何进行resolution augmentation的, 本文对于同一张图片, 使用了6种不同的尺寸, 如下图所示(C为类别):</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw5f5me3b3j20t608o0ub.jpg" alt=""></p><p>具体过程如下:</p><ol><li>对于一个给定的scale的图片,  我们从第5层, 还未pooling的特征图谱开始</li><li>对于每一个未经过pooling的特征图谱, 进行 3×3 的pooling操作(非重叠池化), 重复 3×3 次($\Delta x, \Delta y)$ 以不同的offset {0,1,2}).  </li><li>这样可以得到 3×3 个pooling后的特征图谱.</li><li>分类器(6,7,8层)具有一个 5×5 的固定的输入大小, 同时对于每一个location的土整图谱都会生成 C 维的输出向量</li><li>根据不同的offset, 可以得到不同的结果</li></ol><p>下面的图以一维向量为例讲解了offset pooling的原理, 可以类推到3维结构中</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw5g21ruxgj20vu0g0gox.jpg" alt=""></p><p>上面的操作可以看做是以一个像素为单位, 在特征图谱上进行了位移操作, 进而得到了不同角度下的图谱结果用于分类, 与之前的crop方法相比, 这个方法没有对图片进行裁剪, 但同时又达到了获取同一张图片不同视角结果的目的. 这样做最大的优点在于: <strong>对于一张图片, 可以宏观的将网络分成两个部分, 分别是特征提取层和分类层, 在特征提取部分, 同一张图片只会进行一次前向计算, 在这计算角度来说, 大大提高了计算效率, 减少了荣冗余计算.</strong></p><p>这种极致的pooling策略(exhaustive pooling scheme) 确保了我们可以在分类器和特征图的对象之间获得准确的边界对齐.</p><h3 id="3-4-结果"><a href="#3-4-结果" class="headerlink" title="3.4 结果"></a>3.4 结果</h3><p>实验结果如下表所示:</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw5h2ottzhj20vz0d0whr.jpg" alt=""></p><p>分类错误率在18个队伍中的排名为第5 (主要本篇文章的两点也不在分类, 还是在目标检测上)</p><h3 id="3-5-convNets和滑动窗口效率"><a href="#3-5-convNets和滑动窗口效率" class="headerlink" title="3.5 convNets和滑动窗口效率"></a>3.5 convNets和滑动窗口效率</h3><p> 首先, 要知道全卷积与全连接层之间的关系, 利用全卷积层代替全连接层以后, 可以接受不同图片尺寸的输入, 同时, 在计算时, 由于卷积操作本身的计算共享特性, 可以使得计算过程更加高效, 以此来缓解滑动窗口方法带来的计算问题.</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fw5hncxz5yj20vz0lmtip.jpg" alt=""></p><p>// TODO  这块还是不是很懂</p><h2 id="4-定位-Localization"><a href="#4-定位-Localization" class="headerlink" title="4. 定位 Localization"></a>4. 定位 Localization</h2><p>用回归网络代替分类网络, 同时训练网络使其在每一个空间location和scale下预测目标物体的bounding boxes.  然后将回归预测结果与每个位置的分类结果结合在一起.</p><h3 id="4-1-生成预测"><a href="#4-1-生成预测" class="headerlink" title="4.1 生成预测"></a>4.1 生成预测</h3><p>由于可以共享特征提取层的计算结果, 因此只需要重新计算最终的回归层即可. 因为每个位置的分类结果为所有的类别都赋予了一个置信度, 因此, 我们可以将这个置信度作为bounding box的置信度使用.</p><h3 id="4-2-回归训练-Regressor-Training"><a href="#4-2-回归训练-Regressor-Training" class="headerlink" title="4.2 回归训练 Regressor Training"></a>4.2 回归训练 Regressor Training</h3><p>回归网络将第5层的池化后的特征图谱作为输入. 后面接入两个全连接层, 隐藏神经元个数分别为4096和1024. 最终的输出层具有4个神经元, 用于指定bounding box的坐标. 和分类网络一样, 也是用了基于offset的pooling策略.  该网络的结构如下图所示</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw5i3k7yjzj20ws0rp43x.jpg" alt=""></p><p>训练时, 固定前5层的特征提取层, 然后使用每个样本的真实边界与预测边界之间的L2损失(平方损失)来训练回归网络. 最后的这个回归层根据与特定类相关的, 每一个类都会有一个回归层(也就是说有1000个不同的回归层版本).</p><p>当输入图片与目标物体的IOU小于50%时, 则不会进行训练</p><p>同时使用了多尺度的输入进行训练(与第三节相同), 以便更好的进行不同尺度下的预测.</p><h3 id="4-3-联合预测"><a href="#4-3-联合预测" class="headerlink" title="4.3 联合预测"></a>4.3 联合预测</h3><p>通过对回归得到的bounding boxes使用贪心融合策略, 来得到单个目标物的预测结果. 具体算法过程如下:</p><p>1.<br><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw5if40q6lj20vw1fu163.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw5ifyu74ij20x00ql47d.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>string用法笔记</title>
      <link href="/z_post/Cpp-string%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/z_post/Cpp-string%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h1><h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>at() 返回char类型的字符</p><p>[] 返回char类型的字符</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>push_back: 将字符添加到字符串结尾</p><p>pop_back: 移除末尾字符</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h2><p>std::string str;<br>int i = std::stoi(str);<br>1<br>2<br>同样, 可以使用 stol(long), stof(float), stod(double) 等</p><h2 id="最简单的将int转换成string的方法"><a href="#最简单的将int转换成string的方法" class="headerlink" title="最简单的将int转换成string的方法"></a>最简单的将int转换成string的方法</h2><p>方法一：C风格的itoa<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>* intStr = itoa(a);</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>(intStr);</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; a;</span><br><span class="line"><span class="built_in">string</span> str = ss.str();</span><br></pre></td></tr></table></figure></p><p>方法三：C++风格的std::to_string<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="built_in">std</span>::to_string(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> s = <span class="built_in">std</span>::to_string(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STL之map</title>
      <link href="/z_post/Cpp-STL%E4%B9%8Bmap/"/>
      <url>/z_post/Cpp-STL%E4%B9%8Bmap/</url>
      
        <content type="html"><![CDATA[<h1 id="1、map简介"><a href="#1、map简介" class="headerlink" title="1、map简介"></a>1、map简介</h1><p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p><p>map是一类关联式容器。它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。</p><p>对于迭代器来说，可以修改实值，而不能修改key。</p><h1 id="2、map的功能"><a href="#2、map的功能" class="headerlink" title="2、map的功能"></a>2、map的功能</h1><p>自动建立Key － value的对应。key 和 value可以是任意你需要的类型。</p><p>根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。</p><p>快速插入Key -Value 记录。</p><p>快速删除记录</p><p>根据Key 修改value记录。</p><p>遍历所有记录。</p><h1 id="3、使用map"><a href="#3、使用map" class="headerlink" title="3、使用map"></a>3、使用map</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //注意，STL头文件没有扩展名.h</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、       <span class="built_in">map</span>的构造函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>共提供了<span class="number">6</span>个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些<span class="built_in">map</span>的构造方法，这里要说下的就是，我们通常用如下方法构造一个<span class="built_in">map</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、     数据的插入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在构造<span class="built_in">map</span>容器后，我们就可以往里面插入数据了。这里讲三种插入数据的方法：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一种：用insert函数插入pair数据，下面举例说明(以下代码虽然是随手写的，应该可以在VC和GCC下编译通过，大家可以运行下看什么效果，在VC下请加入这条语句，屏蔽<span class="number">4786</span>警告 ＃pragma warning (disable:<span class="number">4786</span>) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[cpp] view plain copy</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据的插入--第一种：用insert函数插入pair数据  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line"></span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line"></span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line"></span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line"></span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二种：用insert函数插入value_type数据，下面举例说明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[cpp] view plain copy</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：用insert函数插入value_type数据，下面举例说明  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line"></span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line"></span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line"></span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line"></span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【置顶】Detectron源码解读</title>
      <link href="/z_post/Caffe2-Detectron/"/>
      <url>/z_post/Caffe2-Detectron/</url>
      
        <content type="html"><![CDATA[<p><a href="../Caffe2-Detectron源码解读-roidb数据结构">roidb数据结构</a></p><p><a href="../Caffe2-Detectron源码解读-数据载入">数据载入</a></p><p><a href="../Caffe2-Detectron源码解读-模型训练">模型训练</a></p><h1 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h1><h2 id="dirs"><a href="#dirs" class="headerlink" title="dirs:"></a>dirs:</h2><p>— build: 有关cython构建的文件</p><p>— cmake: 各种编译配置文件</p><p>— configs: 使用模型时的config文件</p><p>— demo: 一些图片的demo</p><p>— Detectron.egg-info: 源码信息</p><p>— detectron: 最主要的文件夹, 存放几乎所有的模型源文件</p><p>— docker: 顾名思义, 存放了Dorkerfile<br>&emsp;|— Dockerfile</p><p>— projects<br>&emsp;|— gn.jpg<br>&emsp;|— README.md</p><p>— tools</p><h2 id="files"><a href="#files" class="headerlink" title="files:"></a>files:</h2><p>— CMakeLists.txt</p><p>— CONTRIBUTING.md</p><p>— FAQ.md</p><p>— GETTING_STARTED.md</p><p>— INSTALL.md</p><p>— LICENSE</p><p>— Makefile</p><p>— MODEL_ZOO.md</p><p>— NOTICE</p><p>— README.md</p><p>— requiresments.txt</p><p>— setup.py</p><h1 id="core目录"><a href="#core目录" class="headerlink" title="core目录"></a>core目录</h1><h1 id="detectron目录"><a href="#detectron目录" class="headerlink" title="detectron目录"></a>detectron目录</h1>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-Git用法笔记</title>
      <link href="/z_post/Linux-Git%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/z_post/Linux-Git%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>初始化当前本地文件夹为仓库</p><p>git init</p><p>添加文件:</p><p>单个: git add readme.md<br>全部: git add -A  / git add ./</p><p>提交修改: git commit -m “must write commit”</p><p>查看状态: git status</p><p>查看日志: git log</p><p>版本回退:</p><p>回退一个: git reset -hard HRAD^</p><p>回退两个: git reset -hard HARD^^</p><p>回退多个: git reset -hard HEAD~100</p><p>首次连接: git remote add origin https//www.github…</p><p>提交: git push origin master</p><p>更新本地仓库:</p><p>git fetch origin master  获取</p><p>git merge origin/master  合并</p><p>如果将别人的仓库拉到了自己的仓库里,  为了push成功:</p><ol><li>删除.git相关</li><li>git rm rf —cached ./themes/next</li><li>git add ./themes/next</li><li>git commit -m “next”</li><li>git push origin master</li></ol><p>子模块: 可以独立提交</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>shutil模块-shell命令行指令</title>
      <link href="/z_post/Python-shutil/"/>
      <url>/z_post/Python-shutil/</url>
      
        <content type="html"><![CDATA[<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shutil.copyfile(<span class="string">"old"</span>,<span class="string">"new"</span>) 　　　　  <span class="comment"># 复制文件，都只能是文件</span></span><br><span class="line"></span><br><span class="line">shutil.copytree(<span class="string">"old"</span>,<span class="string">"new"</span>)　　　　 <span class="comment"># 复制文件夹，都只能是目录，且new必须不存在</span></span><br><span class="line"></span><br><span class="line">shutil.copy(<span class="string">"old"</span>,<span class="string">"new"</span>)　　　　       <span class="comment"># 复制文件/文件夹，复制 old 为 new（new是文件，若不存在，即新建），复制 old 为至 new 文件夹（文件夹已存在）</span></span><br><span class="line"></span><br><span class="line">shutil.move(<span class="string">"old"</span>,<span class="string">"new"</span>)  　　　　    <span class="comment"># 移动文件/文件夹至 new 文件夹中</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PASCAL VOC数据集</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E6%95%B0%E6%8D%AE%E9%9B%86-VOC/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E6%95%B0%E6%8D%AE%E9%9B%86-VOC/</url>
      
        <content type="html"><![CDATA[<h1 id="COCO数据集介绍"><a href="#COCO数据集介绍" class="headerlink" title="COCO数据集介绍"></a>COCO数据集介绍</h1><p>COCO数据集具有5种标签类型, 分别为: 目标检测, 关键点检测, 物体分割, 多边形分割 以及 图像描述. 这些标注数据使用<code>JSON</code>格式存储. 所有文件除了标签项以外都共享同样的数据结构, 如下所示:</p><p><img src="https://wx1.sinaimg.cn/mw1024/d7b90c85ly1fwcngpaj5nj20s60lv405.jpg" alt=""></p><p>标签结构各有不同, 如下所示:</p><h2 id="Object-Detection"><a href="#Object-Detection" class="headerlink" title="Object Detection"></a>Object Detection</h2><p>每一个目标实例的标签都具有一系列条目, 包括该目标的类别id以及分割掩膜(segmentation mask). 分割掩膜的格式取决于实例表示的是一个单一的目标(iscrowd=0, 使用polygons标注)还是一群目标(iscrowd=1, 使用RLE标注). 注意, 一个单一的物体(iscrowd=0)在被遮挡的情况下, 可能会需要多个多边形来表示. Crowd标签用来标注一大群目标(如一群人). 另外, 每一个物体都会提供一个闭合的bounding box( box的坐标系从图左上角开始,0-indexed). 最后, 标注结构的类别条目存储着从cat id 到类别的映射以及超类别的名字.</p><h2 id="关键点检测"><a href="#关键点检测" class="headerlink" title="关键点检测"></a>关键点检测</h2><h2 id="Stuff-Segmentation"><a href="#Stuff-Segmentation" class="headerlink" title="Stuff Segmentation"></a>Stuff Segmentation</h2><p>Stuff Segmentation的格式和object detection的格式几乎一模一样, 但是stuff segmentation无需<code>iscrowd</code>条目, 因为该条默认置为0. 为了方便访问, coco提供了json和png两种标注格式. 在 json 格式中, <strong>每一个出现在图片中的类别都会单独用一个RLE标签条目编码</strong>(也就是说同类的会被放到同一个RLE编码里面). category_id 则代表当前的物体类别的id.</p><h2 id="Panoptic-Segmentation"><a href="#Panoptic-Segmentation" class="headerlink" title="Panoptic Segmentation"></a>Panoptic Segmentation</h2><p><img src="https://wx4.sinaimg.cn/mw1024/d7b90c85ly1fwcnkqsfkxj20rs0au0tk.jpg" alt=""></p><h2 id="数据集信息"><a href="#数据集信息" class="headerlink" title="数据集信息"></a>数据集信息</h2><h2 id="标注格式"><a href="#标注格式" class="headerlink" title="标注格式"></a>标注格式</h2><h1 id="COCO-API-使用方法及源码解析"><a href="#COCO-API-使用方法及源码解析" class="headerlink" title="COCO-API 使用方法及源码解析"></a>COCO-API 使用方法及源码解析</h1><p>最常用的是 <code>pycocotools/coco.py</code> 文件中的<code>COCO</code>类, 其内部实现如下:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pycocotools/coco.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先, 是一大串的注释</span></span><br><span class="line"><span class="comment"># COCO API提供了一系列的辅助函数来帮助载入,解析以及可视化COCO数据集的annotations</span></span><br><span class="line"><span class="comment"># 该文件定义了如下API 函数:</span></span><br><span class="line"><span class="comment"># COCO        - COCO api 类, 用于载入coco的annotation 文件, 同时负责准备对应数据结构来存储</span></span><br><span class="line"><span class="comment"># decodeMask  - 通过rle编码规范, 来对二值mask M进行解码</span></span><br><span class="line"><span class="comment"># encodeMask  - 使用rle编码规范来对二值mak M进行编码</span></span><br><span class="line"><span class="comment"># getAnnIds   - 获得满足给定过滤条件的ann ids(标注)</span></span><br><span class="line"><span class="comment"># getCatIds   - 获得满足给定过滤条件的cat ids(类别)</span></span><br><span class="line"><span class="comment"># getImgIds   - 获得满足给定过滤条件的img ids(图片)</span></span><br><span class="line"><span class="comment"># loadAnns    - 根据指定的ids加载anns</span></span><br><span class="line"><span class="comment"># loadCats    - 根据指定的ids加载cats</span></span><br><span class="line"><span class="comment"># loadImgs    - 根据指定的ids加载imgs</span></span><br><span class="line"><span class="comment"># annToMask   - 将annotation里面的segmentation信息转换成二值mask</span></span><br><span class="line"><span class="comment"># showAnns    - 可视化指定的annotations</span></span><br><span class="line"><span class="comment"># loadRes     - 加载算法结果同时创建API以便访问它们</span></span><br><span class="line"><span class="comment"># download    - 从Mscoco.org.server上下载COCO数据集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来, 具体看一下COCO类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COCO</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, annotation_file=None)</span>:</span></span><br><span class="line">        <span class="comment"># 构造函数</span></span><br><span class="line">        <span class="comment"># 参数annotation_file: 指定了annotation文件的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dataset, anns, cats, imgs均为字典类型数据</span></span><br><span class="line">        self.dataset, self.anns, self.cats, self.imgs = dict(), dict(), dict(), dict()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># imgToAnns, catToImgs均为defaultdict数据类型(带有默认值的字典)</span></span><br><span class="line">        self.imgToAnns, self.catToImgs = defaultdict(list), defaultdict(list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> annotation_file == <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 以只读方式加载json标注文件</span></span><br><span class="line">            dataset = json.load(open(annotation_file, <span class="string">'r'</span>))</span><br><span class="line">            <span class="keyword">assert</span> type(dataset)==dict <span class="comment"># 确保读出来的是字典类型</span></span><br><span class="line">            <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 正式将读取的字典数据赋给该类的成员变量</span></span><br><span class="line">            self.dataset = dataset</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 创建索引</span></span><br><span class="line">            self.createIndex()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createIndex</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 创建索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 三个都是字典数据类型</span></span><br><span class="line">        anns,cats,imgs=&#123;&#125;,&#123;&#125;,&#123;&#125;</span><br><span class="line">        <span class="comment"># 两个defaultdict数据类型</span></span><br><span class="line">        imgToAnns, catToImgs = defaultdict(list), defaultdict(list)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'annotations'</span> <span class="keyword">in</span> self.dataset:</span><br><span class="line">            <span class="keyword">for</span> ann <span class="keyword">in</span> self.dataset[<span class="string">'annotations'</span>]:</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MicroSoft COCO数据集</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E6%95%B0%E6%8D%AE%E9%9B%86-COCO/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E6%95%B0%E6%8D%AE%E9%9B%86-COCO/</url>
      
        <content type="html"><![CDATA[<h1 id="COCO数据集介绍"><a href="#COCO数据集介绍" class="headerlink" title="COCO数据集介绍"></a>COCO数据集介绍</h1><p>COCO数据集具有5种标签类型, 分别为: 目标检测, 关键点检测, 物体分割, 多边形分割 以及 图像描述. 这些标注数据使用<code>JSON</code>格式存储. 所有文件除了标签项以外都共享同样的数据结构, 如下所示:</p><p><img src="https://wx1.sinaimg.cn/mw1024/d7b90c85ly1fwcngpaj5nj20s60lv405.jpg" alt=""></p><p>标签结构各有不同, 如下所示:</p><h2 id="Object-Detection"><a href="#Object-Detection" class="headerlink" title="Object Detection"></a>Object Detection</h2><p>每一个目标实例的标签都具有一系列条目, 包括该目标的类别id以及分割掩膜(segmentation mask). 分割掩膜的格式取决于实例表示的是一个单一的目标(iscrowd=0, 使用polygons标注)还是一群目标(iscrowd=1, 使用RLE标注). 注意, 一个单一的物体(iscrowd=0)在被遮挡的情况下, 可能会需要多个多边形来表示. Crowd标签用来标注一大群目标(如一群人). 另外, 每一个物体都会提供一个闭合的bounding box( box的坐标系从图左上角开始,0-indexed). 最后, 标注结构的类别条目存储着从cat id 到类别的映射以及超类别的名字.</p><h2 id="关键点检测"><a href="#关键点检测" class="headerlink" title="关键点检测"></a>关键点检测</h2><h2 id="Stuff-Segmentation"><a href="#Stuff-Segmentation" class="headerlink" title="Stuff Segmentation"></a>Stuff Segmentation</h2><p>Stuff Segmentation的格式和object detection的格式几乎一模一样, 但是stuff segmentation无需<code>iscrowd</code>条目, 因为该条默认置为0. 为了方便访问, coco提供了json和png两种标注格式. 在 json 格式中, <strong>每一个出现在图片中的类别都会单独用一个RLE标签条目编码</strong>(也就是说同类的会被放到同一个RLE编码里面). category_id 则代表当前的物体类别的id.</p><h2 id="Panoptic-Segmentation"><a href="#Panoptic-Segmentation" class="headerlink" title="Panoptic Segmentation"></a>Panoptic Segmentation</h2><p><img src="https://wx4.sinaimg.cn/mw1024/d7b90c85ly1fwcnkqsfkxj20rs0au0tk.jpg" alt=""></p><h2 id="数据集信息"><a href="#数据集信息" class="headerlink" title="数据集信息"></a>数据集信息</h2><h2 id="标注格式"><a href="#标注格式" class="headerlink" title="标注格式"></a>标注格式</h2><h1 id="COCO-API-使用方法及源码解析"><a href="#COCO-API-使用方法及源码解析" class="headerlink" title="COCO-API 使用方法及源码解析"></a>COCO-API 使用方法及源码解析</h1><p>最常用的是 <code>pycocotools/coco.py</code> 文件中的<code>COCO</code>类, 其内部实现如下:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pycocotools/coco.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先, 是一大串的注释</span></span><br><span class="line"><span class="comment"># COCO API提供了一系列的辅助函数来帮助载入,解析以及可视化COCO数据集的annotations</span></span><br><span class="line"><span class="comment"># 该文件定义了如下API 函数:</span></span><br><span class="line"><span class="comment"># COCO        - COCO api 类, 用于载入coco的annotation 文件, 同时负责准备对应数据结构来存储</span></span><br><span class="line"><span class="comment"># decodeMask  - 通过rle编码规范, 来对二值mask M进行解码</span></span><br><span class="line"><span class="comment"># encodeMask  - 使用rle编码规范来对二值mak M进行编码</span></span><br><span class="line"><span class="comment"># getAnnIds   - 获得满足给定过滤条件的ann ids(标注)</span></span><br><span class="line"><span class="comment"># getCatIds   - 获得满足给定过滤条件的cat ids(类别)</span></span><br><span class="line"><span class="comment"># getImgIds   - 获得满足给定过滤条件的img ids(图片)</span></span><br><span class="line"><span class="comment"># loadAnns    - 根据指定的ids加载anns</span></span><br><span class="line"><span class="comment"># loadCats    - 根据指定的ids加载cats</span></span><br><span class="line"><span class="comment"># loadImgs    - 根据指定的ids加载imgs</span></span><br><span class="line"><span class="comment"># annToMask   - 将annotation里面的segmentation信息转换成二值mask</span></span><br><span class="line"><span class="comment"># showAnns    - 可视化指定的annotations</span></span><br><span class="line"><span class="comment"># loadRes     - 加载算法结果同时创建API以便访问它们</span></span><br><span class="line"><span class="comment"># download    - 从Mscoco.org.server上下载COCO数据集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来, 具体看一下COCO类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COCO</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, annotation_file=None)</span>:</span></span><br><span class="line">        <span class="comment"># 构造函数</span></span><br><span class="line">        <span class="comment"># 参数annotation_file: 指定了annotation文件的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dataset, anns, cats, imgs均为字典类型数据</span></span><br><span class="line">        self.dataset, self.anns, self.cats, self.imgs = dict(), dict(), dict(), dict()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># imgToAnns, catToImgs均为defaultdict数据类型(带有默认值的字典)</span></span><br><span class="line">        self.imgToAnns, self.catToImgs = defaultdict(list), defaultdict(list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> annotation_file == <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 以只读方式加载json标注文件</span></span><br><span class="line">            dataset = json.load(open(annotation_file, <span class="string">'r'</span>))</span><br><span class="line">            <span class="keyword">assert</span> type(dataset)==dict <span class="comment"># 确保读出来的是字典类型</span></span><br><span class="line">            <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 正式将读取的字典数据赋给该类的成员变量</span></span><br><span class="line">            self.dataset = dataset</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 创建索引</span></span><br><span class="line">            self.createIndex()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createIndex</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 创建索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 三个都是字典数据类型</span></span><br><span class="line">        anns,cats,imgs=&#123;&#125;,&#123;&#125;,&#123;&#125;</span><br><span class="line">        <span class="comment"># 两个defaultdict数据类型</span></span><br><span class="line">        imgToAnns, catToImgs = defaultdict(list), defaultdict(list)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'annotations'</span> <span class="keyword">in</span> self.dataset:</span><br><span class="line">            <span class="keyword">for</span> ann <span class="keyword">in</span> self.dataset[<span class="string">'annotations'</span>]:</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法题杂记</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%9D%82%E8%AE%B0/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="交换两个数的特殊方法"><a href="#交换两个数的特殊方法" class="headerlink" title="交换两个数的特殊方法"></a>交换两个数的特殊方法</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p><strong>注意: 有可能导致溢出</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;         <span class="comment">//但是加法可能会最终导致溢出</span></span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure><p>上面的实习原理是利用异或的自身特性:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ^ a = <span class="number">0</span></span><br><span class="line">a ^ <span class="number">0</span> = a</span><br></pre></td></tr></table></figure><p><strong>注意: 用异或交换两个整数存在一个陷阱</strong></p><p>当交换两个相同的数字时, 由于异或自身的特性, 会使得这两个数字都变成0, 解决方法是加上一个判断条件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">  a = a^b;</span><br><span class="line">  b = a^b;</span><br><span class="line">  a = a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不开根号求平方根"><a href="#不开根号求平方根" class="headerlink" title="不开根号求平方根"></a>不开根号求平方根</h1><h2 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h2><p>假设要对 $a$ 进行开根, 那么就需要找到一个值 $x$, 满足 $x^2 = a$, 我们令 $f(x) = x^2 - a$ , 则只需找到使 $f(x)=0$ 的值 $x$ 即为开根后的值, 也就是说要求 $f(x)$ 与x轴的交点, 在x轴上任选一点 $(x_0, f(x_0))$, 求该点在函数 $f(x)$ 上面的切线方程如下:</p><script type="math/tex; mode=display">f(x) - f(x_0) = f'(x_0)(x - x_0)</script><p>也就是:</p><script type="math/tex; mode=display">f(x) - (x_0^2 - a) = 2x_0(x - x_0)</script><p>我们求该直线与x轴的交点, 即 $f(x)=0$ , 求得 $x$ 的值为:</p><script type="math/tex; mode=display">x = x_0 - \frac{x_0^2 -a}{2x_0}</script><p>如果上面求得的 $x$ 不是 $f(x)$ 与 x 轴的交点, 那么久继续这个过程, 直到结果满足我们需要的精度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">24</span>;<span class="comment">//欲求24的开根</span></span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(x*x-a)&gt;<span class="number">0.0001</span>)&#123;</span><br><span class="line">        x = x- (x*x-a)/(<span class="number">2</span>*x+<span class="number">1e-9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">24</span>;<span class="comment">//欲求24的开根</span></span><br><span class="line">    <span class="keyword">double</span> high = a;</span><br><span class="line">    <span class="keyword">double</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(high-low&gt;<span class="number">0.0001</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (high+low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid &gt; t) high = mid;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid &lt; t) low = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有两个数组-数组很大-其中一个数组存储着n个人的名字-另一个数组存储着这n个人的身高"><a href="#有两个数组-数组很大-其中一个数组存储着n个人的名字-另一个数组存储着这n个人的身高" class="headerlink" title="有两个数组, 数组很大, 其中一个数组存储着n个人的名字, 另一个数组存储着这n个人的身高?"></a>有两个数组, 数组很大, 其中一个数组存储着n个人的名字, 另一个数组存储着这n个人的身高?</h1><h2 id="问题一-现在需要找出m个身高最高的人的名字-要求时间和空间复杂度最低"><a href="#问题一-现在需要找出m个身高最高的人的名字-要求时间和空间复杂度最低" class="headerlink" title="问题一: 现在需要找出m个身高最高的人的名字, 要求时间和空间复杂度最低"></a>问题一: 现在需要找出m个身高最高的人的名字, 要求时间和空间复杂度最低</h2><h2 id="问题二-哪些排序算法时间复杂度是-O-1-的-哪些不是"><a href="#问题二-哪些排序算法时间复杂度是-O-1-的-哪些不是" class="headerlink" title="问题二: 哪些排序算法时间复杂度是 $O(1)$ 的, 哪些不是"></a>问题二: 哪些排序算法时间复杂度是 $O(1)$ 的, 哪些不是</h2><h2 id="问题三-哪些排序算法是稳定的-哪些是不稳定的"><a href="#问题三-哪些排序算法是稳定的-哪些是不稳定的" class="headerlink" title="问题三: 哪些排序算法是稳定的, 哪些是不稳定的"></a>问题三: 哪些排序算法是稳定的, 哪些是不稳定的</h2><ul><li>稳定: 冒泡, 插入排序, 归并(合并), 基数排序</li><li>不稳定: 选择, 快排, 希尔排序, 堆排序</li></ul><h2 id="问题四-现在需要设计一个算法-每次从这n个人当中挑出一个人-要求最终跳出的所有人当中-身高高的人站的比例大"><a href="#问题四-现在需要设计一个算法-每次从这n个人当中挑出一个人-要求最终跳出的所有人当中-身高高的人站的比例大" class="headerlink" title="问题四: 现在需要设计一个算法, 每次从这n个人当中挑出一个人, 要求最终跳出的所有人当中, 身高高的人站的比例大"></a>问题四: 现在需要设计一个算法, 每次从这n个人当中挑出一个人, 要求最终跳出的所有人当中, 身高高的人站的比例大</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="轮盘赌算法"><a href="#轮盘赌算法" class="headerlink" title="轮盘赌算法"></a>轮盘赌算法</h3><h1 id="求下面函数的返回值"><a href="#求下面函数的返回值" class="headerlink" title="求下面函数的返回值:"></a>求下面函数的返回值:</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> countx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        countx++;</span><br><span class="line">        x=x&amp;(x<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假定x=9999, 答案:8<br>思路: 将x转化为2进制, 看含有1的个数</p><h1 id="在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug，-你如何调试这个bug。"><a href="#在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug，-你如何调试这个bug。" class="headerlink" title="在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug， 你如何调试这个bug。"></a>在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug， 你如何调试这个bug。</h1><h1 id="n个数里面求最大的m个数-堆"><a href="#n个数里面求最大的m个数-堆" class="headerlink" title="n个数里面求最大的m个数, (堆)"></a>n个数里面求最大的m个数, (堆)</h1><p>建立size为m的最小堆, 堆顶为最小的值,  堆内的数据都比堆顶小, 所以这m个数字即为n个数里面最大的m个数.</p><h1 id="求两个不相交的连续子数组的最大和"><a href="#求两个不相交的连续子数组的最大和" class="headerlink" title="求两个不相交的连续子数组的最大和"></a>求两个不相交的连续子数组的最大和</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>有一个整数数组n，a和b是n里两个互不相交的子数组。返回sum(a)+sum(b)的最大值。</p><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumOfTwoSubarray</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n.size() &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n.size()), right(n.size());</span><br><span class="line"><span class="keyword">int</span> sum = n[<span class="number">0</span>], maxnum = n[<span class="number">0</span>];</span><br><span class="line">left[<span class="number">0</span>] = n[<span class="number">0</span>];</span><br><span class="line">right.back() = n.back();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; n.size()<span class="number">-1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">sum += n[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sum = n[i];</span><br><span class="line"><span class="keyword">if</span> (sum &gt; maxnum)</span><br><span class="line">&#123;</span><br><span class="line">maxnum = sum;</span><br><span class="line">&#125;</span><br><span class="line">left[i] = maxnum;</span><br><span class="line">&#125;</span><br><span class="line">sum = n.back();</span><br><span class="line">maxnum = n.back();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = n.size()<span class="number">-2</span>; i &gt;=<span class="number">1</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">sum += n[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sum = n[i];</span><br><span class="line"><span class="keyword">if</span> (sum &gt; maxnum)</span><br><span class="line">&#123;</span><br><span class="line">maxnum = sum;</span><br><span class="line">&#125;</span><br><span class="line">right[i] = maxnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; n.size() - <span class="number">1</span>; ++i)</span><br><span class="line">res = max(res, left[i] + right[i + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建两个数组left和right，left[i]表示n[0:i]的连续子数组的最大和，right[i]表示n[i:length-1]的连续子数组的最大和。left[i]+right[i+1]的最大值就是答案。</p><p><a href="https://blog.csdn.net/bupt8846/article/details/48115931" target="_blank" rel="noopener">https://blog.csdn.net/bupt8846/article/details/48115931</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Caffe2基础</title>
      <link href="/z_post/Caffe2-Caffe%E5%85%A5%E9%97%A8/"/>
      <url>/z_post/Caffe2-Caffe%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/carle-09/p/9033608.html" target="_blank" rel="noopener">https://www.cnblogs.com/carle-09/p/9033608.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/26451014" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26451014</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="　简介"></a>　简介</h1><h1 id="Caffe2-基本概念"><a href="#Caffe2-基本概念" class="headerlink" title="Caffe2 基本概念"></a>Caffe2 基本概念</h1><h2 id="Blobs-and-Workspace-Tensors"><a href="#Blobs-and-Workspace-Tensors" class="headerlink" title="Blobs and Workspace, Tensors"></a>Blobs and Workspace, Tensors</h2><p>blobs: Caffe2中的数据组织形式.  大多数blobs都包含tensor, 并且在Python中会被转换成numpy数组</p><p>Workspace: 存储所有blobs</p><p>可以通过 <code>workspace.FeedBlob()</code> 和 <code>workspace.FetchBlob()</code> 来feed和fetch numyp数组</p><h2 id="Nets-and-Operators"><a href="#Nets-and-Operators" class="headerlink" title="Nets and Operators"></a>Nets and Operators</h2><p>Caffe2的基础网络模型抽象是 net(short of network).  一个net是由operator组成的图结构, 每个operator可以接受blobs集合的输入, 并且可以输出一个或多个output blobs</p><h2 id="Brewing-Models"><a href="#Brewing-Models" class="headerlink" title="Brewing Models"></a>Brewing Models</h2><p>brew 是caffe2 中用于搭建模型的新的API, 它封装了新的ModelHelper, 使得搭建模型更加容易</p><h2 id="Models-and-Datasets"><a href="#Models-and-Datasets" class="headerlink" title="Models and Datasets"></a>Models and Datasets</h2>]]></content>
      
      
      <categories>
          
          <category> Caffe2 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>面试-个人简历总结</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%E6%80%BB%E7%BB%93/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍一下自己"><a href="#介绍一下自己" class="headerlink" title="介绍一下自己"></a>介绍一下自己</h1><p>一定要想办法主导后面面试的侧重点, 突出自己的优势, 强调自己的擅长领域</p><h1 id="ZeroTensor"><a href="#ZeroTensor" class="headerlink" title="ZeroTensor"></a>ZeroTensor</h1><h2 id="你的项目和tiny-dnn有什么区别。比它优势在哪里？"><a href="#你的项目和tiny-dnn有什么区别。比它优势在哪里？" class="headerlink" title="你的项目和tiny dnn有什么区别。比它优势在哪里？"></a>你的项目和tiny dnn有什么区别。比它优势在哪里？</h2><h2 id="你从tiny-dnn这个项目中学到了什么？"><a href="#你从tiny-dnn这个项目中学到了什么？" class="headerlink" title="你从tiny dnn这个项目中学到了什么？"></a>你从tiny dnn这个项目中学到了什么？</h2><h1 id="要问的问题"><a href="#要问的问题" class="headerlink" title="要问的问题?"></a>要问的问题?</h1><p>目前我们现在工业界在目标检测的落地应用方面, 通常会怎么做? 具体一点就是说, 是让检测过程本地上做计算, 还是说把模型放到服务器端, 然后在服务器上计算再返回结果?  如果是在本地计算的话? 会不会对本地设备要求有点高? 还有就是RCNN在实际场景用到底用的多不多?  是不是主要还是YOLO用的多一些?</p><h1 id="如果商汤-face-和我们公司同时给了你offer-你会怎么选择"><a href="#如果商汤-face-和我们公司同时给了你offer-你会怎么选择" class="headerlink" title="如果商汤/face++和我们公司同时给了你offer, 你会怎么选择"></a>如果商汤/face++和我们公司同时给了你offer, 你会怎么选择</h1><p>从三个方面选择<br>-<br>-</p><ul><li>薪资</li></ul><p>三个方面的权重分别是 4:4:2</p><h1 id="说说你的职业规划"><a href="#说说你的职业规划" class="headerlink" title="说说你的职业规划"></a>说说你的职业规划</h1><h1 id="在竞赛中，使用了有哪些提升最终精度的方法-每种方法分别提升了多少精度"><a href="#在竞赛中，使用了有哪些提升最终精度的方法-每种方法分别提升了多少精度" class="headerlink" title="在竞赛中，使用了有哪些提升最终精度的方法, 每种方法分别提升了多少精度?"></a>在竞赛中，使用了有哪些提升最终精度的方法, 每种方法分别提升了多少精度?</h1><p>multi-scale training $\{ 480, 576, 688, 864, 900\}$ and testing $\{480, 576, 688, 864, 1000\}$ 提升mAP 3~5%</p><p>Iterative bounding box regression (multi-stage box regression):</p><p>数据增广.</p><p>目标检测大多论文出自何恺明之手, 最大的感觉就是，总是能从网络的baseline中挖掘中值得改进的地方，每一个改进都能够提高目标检测的精度或者速度。</p><h1 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h1><p>擅长 C++、Python 编程语言<br>算法基础扎实，具有良好的代码风格和质量意识<br>对CNN 等深度学习技术了解透彻，擅长 TensorFlow 深度学习框架<br>熟悉GPU并行计算及CUDA编程语言</p><h1 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h1><p>代码工程能力强,可快速将想法付诸于代码实现, 对计算机技术充满热情，尤其是对计算机视觉领域，有极大的兴趣和求知欲，喜欢面对挑战，敢于尝试，有良好的沟通能力和团队合作精神</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>os模块-系统操作</title>
      <link href="/z_post/Python-os/"/>
      <url>/z_post/Python-os/</url>
      
        <content type="html"><![CDATA[<p>os.path.isabs(…) 　　　　 # 判断是否绝对路径</p><p>os.path.exists(…)　　　　 # 判断是否真实存在</p><p>os.path.isdir(…)　　　　   # 判断是否是个目录</p><p>os.path.isfile(…)　　　　   # 判断是否是个文件</p><p>os.path.split(…)         　　 # 分隔目录和文件名/文件夹名         </p><p>os.path.splitdrive(…)        # 分隔盘符(windows系统)     </p><p>os.path.splitext(…)           # 分隔文件和扩展名</p><p>os.walk() 方法用于通过在目录树中游走输出在目录中的文件名，向上或者向下。</p><p><code>os.mkdir(path[, mode])</code><br>创建一个目标, 参数可以是相对或者绝对路径, mode的模式默认为0777,<br><strong>如果目录有多级, 则创建最后一级. 如果最后一级目录的上级有不存在的或者目录已经存在, 则会抛出一个OSError</strong></p><p><code>os.makedirs(path[, mode])</code><br>创建 <strong>递归</strong> 的目录树, 参数可以是相对或者绝对路径, mode的默认模式也是0777.<br><strong>如果子目录已经存在, 则创建失败, 会抛出一个OSError的异常</strong></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>matplotlib模块-数据绘图</title>
      <link href="/z_post/Python-matplotlib/"/>
      <url>/z_post/Python-matplotlib/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>Matplotlib是一个Python 2D绘图库，可以在各种平台上以各种硬拷贝格式和交互式环境生成出版质量数据。Matplotlib可用于Python脚本，Python和IPython shell，jupyter笔记本，Web应用程序服务器和四个图形用户界面工具。</p><p>matplotlib画板一般由以下部分组成</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw1p7jm9rkj20hs0hsdhr.jpg" alt=""></p><p>创建了subplot后, 如果发出绘图指令，matplotlib这时就会在你最后一个用过的subplot中（没有则创建）绘制.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个figure</span></span><br><span class="line">x = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line">y2 = <span class="number">2</span>**x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用figure()函数重新申请一个figure对象</span></span><br><span class="line"><span class="comment"># 注意，每次调用figure的时候都会重新申请一个figure对象</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># 第一个是横坐标的值，第二个是纵坐标的值</span></span><br><span class="line">plt.plot(x, y1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个参数表示的是编号，第二个表示的是图表的长宽</span></span><br><span class="line">plt.figure(num = <span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 当我们需要在画板中绘制两条线的时候，可以使用下面的方法：</span></span><br><span class="line">plt.plot(x, y2)</span><br><span class="line">plt.plot(x, y1,</span><br><span class="line">         color=<span class="string">'red'</span>,   <span class="comment"># 线颜色</span></span><br><span class="line">         linewidth=<span class="number">1.0</span>,  <span class="comment"># 线宽</span></span><br><span class="line">         linestyle=<span class="string">'--'</span>  <span class="comment"># 线样式</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">plt.show()  <span class="comment"># 会将所有的figure对象显示出来, 这里有2个</span></span><br></pre></td></tr></table></figure><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw1qdgondtj20e40fqjrz.jpg" alt=""></p><h1 id="用matplotlib显示图片"><a href="#用matplotlib显示图片" class="headerlink" title="用matplotlib显示图片"></a>用matplotlib显示图片</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># plt 用于显示图片</span></span><br></pre></td></tr></table></figure><h1 id="2D图表风格"><a href="#2D图表风格" class="headerlink" title="2D图表风格"></a>2D图表风格</h1><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.scatter(x, y, s=<span class="keyword">None</span>, c=<span class="keyword">None</span>, marker=<span class="keyword">None</span>, cmap=<span class="keyword">None</span>, norm=<span class="keyword">None</span>, vmin=<span class="keyword">None</span>, vmax=<span class="keyword">None</span>,</span><br><span class="line">alpha=<span class="keyword">None</span>, linewidths=<span class="keyword">None</span>, verts=<span class="keyword">None</span>, edgecolors=<span class="keyword">None</span>, hold=<span class="keyword">None</span>, data=<span class="keyword">None</span>, ** kwargs)</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>x/y: 一维向量, 且长度相等</li><li>s: 标记大小, 以平方磅为单位的标记面积，指定为下列形式之一：<ul><li>数值标量 ： 以相同的大小绘制所有标记。</li><li>行或列向量 ： 使每个标记具有不同的大小。x、y 和 sz 中的相应元素确定每个标记的位置和面积。sz 的长度必须等于 x 和 y 的长度。</li><li>[] ： 使用 36 平方磅的默认面积</li></ul></li><li>c: 标记颜色, 指定为下列形式之一:<ul><li>RGB 三元数或颜色名称 - 使用相同的颜色绘制所有标记。</li><li>由 RGB 三元数组成的三列矩阵 - 对每个标记使用不同的颜色。矩阵的每行为对应标记指定一种 RGB 三元数颜色。行数必须等于 x 和 y 的长度。</li><li>向量 - 对每个标记使用不同的颜色，并以线性方式将 c 中的值映射到当前颜色图中的颜色。c 的长度必须等于 x 和 y 的长度。要更改坐标区的颜色图，请使用 colormap 函数</li></ul></li><li>marker: 标记样式</li><li>linewidths: 线宽</li></ul><p>颜色种类</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fw1t1nzajlj20ra0a8my0.jpg" alt=""></p><p>样式种类</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw1t1o08knj20r40gpgmh.jpg" alt=""></p><h2 id="直方图-hist"><a href="#直方图-hist" class="headerlink" title="直方图 hist"></a>直方图 hist</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">matplotlib.pyplot.hist(x, bins=<span class="number">10</span>, range=<span class="keyword">None</span>, normed=<span class="keyword">False</span>, weights=<span class="keyword">None</span>, cumulative=<span class="keyword">False</span>, bottom=<span class="keyword">None</span>, histtype=<span class="string">u'bar'</span>, align=<span class="string">u'mid'</span>, orientation=<span class="string">u'vertical'</span>, rwidth=<span class="keyword">None</span>, log=<span class="keyword">False</span>, color=<span class="keyword">None</span>, label=<span class="keyword">None</span>, stacked=<span class="keyword">False</span>, hold=<span class="keyword">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>x: 横轴对应的数据</li><li>bins: 指定条状图的条形个数</li><li>range: 横轴的范围, 默认为数据最小和最大的值作为范围</li><li>normed: 默认为False, 纵轴表示频数, 如果置为True, 则纵轴表示频率</li><li>rwidth: 条状图柱子与柱子之间的距离, 默认为0</li></ul><h2 id="饼状图-pie"><a href="#饼状图-pie" class="headerlink" title="饼状图 pie"></a>饼状图 pie</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>skimage模块-图像处理</title>
      <link href="/z_post/Python-skimage/"/>
      <url>/z_post/Python-skimage/</url>
      
        <content type="html"><![CDATA[<p>比opencv的速度要慢很多, 但是使用起来更加简单, 真的对速度要求很高的话, 一般都会C++和opecv使用. 所以一般情况下, 首先看skimage能否实现, 不行的话再转用opencv</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> skimage</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io <span class="comment">#  IO is a submodule. Submodules need to be imported from the parent module explicitly.</span></span><br><span class="line">img = io.imread(<span class="string">"1.jpg"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>opencv模块-计算机视觉算法库</title>
      <link href="/z_post/Python-opencv/"/>
      <url>/z_post/Python-opencv/</url>
      
        <content type="html"><![CDATA[<h1 id="opencv-基础知识"><a href="#opencv-基础知识" class="headerlink" title="opencv 基础知识"></a>opencv 基础知识</h1><h2 id="opencv与numpy"><a href="#opencv与numpy" class="headerlink" title="opencv与numpy"></a>opencv与numpy</h2><p>opencv的基础类型为<code>numpy.ndarray</code>, 因此可以直接使用 <code>ndarray</code> 的一些属性的方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">image = cv2.imread(<span class="string">'./test.jpg'</span>)</span><br><span class="line">print(type(image) <span class="comment">#&lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line">print(image.shape) <span class="comment">#(500, 1069, 3)  (高, 宽, 通道),</span></span><br></pre></td></tr></table></figure><p>利用 <code>cv2.merge</code> 方法将 <code>numpy.ndarray</code> 数据转换成opencv的图片数据:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片的分辨率为300*200(宽*高)，这里b, g, r设为随机值，注意dtype属性</span></span><br><span class="line">b = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, (<span class="number">200</span>, <span class="number">300</span>), dtype=np.uint8)</span><br><span class="line">g = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, (<span class="number">200</span>, <span class="number">300</span>), dtype=np.uint8)</span><br><span class="line">r = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, (<span class="number">200</span>, <span class="number">300</span>), dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并通道，形成图片</span></span><br><span class="line">img = cv2.merge([b, g, r])  <span class="comment"># opencv的通道是b在最前,r在最后</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图片</span></span><br><span class="line">cv2.imshow(<span class="string">'test'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyWindow(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure><h1 id="opencv-基本图像操作"><a href="#opencv-基本图像操作" class="headerlink" title="opencv 基本图像操作"></a>opencv 基本图像操作</h1><h2 id="通道的拆分与合并"><a href="#通道的拆分与合并" class="headerlink" title="通道的拆分与合并"></a>通道的拆分与合并</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片的分辨率为800*200(宽*高)，这里b, g, r设为随机值，注意dtype属性</span></span><br><span class="line">b = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, (<span class="number">200</span>, <span class="number">800</span>), dtype=np.uint8)</span><br><span class="line">g = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, (<span class="number">200</span>, <span class="number">800</span>), dtype=np.uint8)</span><br><span class="line">r = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, (<span class="number">200</span>, <span class="number">800</span>), dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并通道，形成图片</span></span><br><span class="line">img = cv2.merge([b, g, r])  <span class="comment"># opencv的通道是b在最前,r在最后</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图片</span></span><br><span class="line">cv2.imshow(<span class="string">'test'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyWindow(<span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆分通道, 每个通道都变成了单通道数组</span></span><br><span class="line">[blue, green, red] = cv2.split(img)</span><br></pre></td></tr></table></figure><h2 id="用matplotlib显示图像"><a href="#用matplotlib显示图像" class="headerlink" title="用matplotlib显示图像"></a>用matplotlib显示图像</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b,g,r=cv2.split(img)</span><br><span class="line">img2=cv2.merge([r,g,b])</span><br><span class="line">plt.imshow(img2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong> 更方便的转换通道的方式:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgb_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br></pre></td></tr></table></figure></p><h1 id="opencv-核心图像算法"><a href="#opencv-核心图像算法" class="headerlink" title="opencv 核心图像算法"></a>opencv 核心图像算法</h1><h1 id="cv2"><a href="#cv2" class="headerlink" title="cv2"></a>cv2</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image_path = <span class="string">'./test.jpg'</span></span><br><span class="line"></span><br><span class="line">src_image = cv2.imread(image_path) <span class="comment"># 读取图片</span></span><br><span class="line"></span><br><span class="line">size = src_image.shape  <span class="comment"># 获取图片的尺寸, 返回一个元组: (height, width, depth)</span></span><br><span class="line"></span><br><span class="line">copy_image = src_image.copy() <span class="comment"># 复制图片</span></span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">'./dst_test.jpg'</span>, copy_image) <span class="comment"># 保存图片</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>, src_image) <span class="comment"># 显示图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用下标访问指定像素</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(src_image.shape[<span class="number">0</span>]): <span class="comment"># 以行为主, 行数=图片height</span></span><br><span class="line">  <span class="keyword">for</span> y <span class="keyword">in</span> range(src_image.shape[<span class="number">1</span>]):  <span class="comment"># 列数 = 图片width</span></span><br><span class="line">    src_image[x,y] = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>)   <span class="comment"># (blue, green, red)  值越高表示对应颜色越显著, 全0为黑, 全255为白</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>numpy模块-线性代数计算库</title>
      <link href="/z_post/Python-numpy/"/>
      <url>/z_post/Python-numpy/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy基础知识"><a href="#numpy基础知识" class="headerlink" title="numpy基础知识"></a>numpy基础知识</h1><h2 id="ndarray-对象"><a href="#ndarray-对象" class="headerlink" title="ndarray 对象"></a>ndarray 对象</h2><h3 id="ndarray对象的属性"><a href="#ndarray对象的属性" class="headerlink" title="ndarray对象的属性"></a>ndarray对象的属性</h3><p>表示一个 n 维数组, 描述相同类型的元素集合, 基于0的索引访问</p><p>创建 <code>ndarray</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype = <span class="keyword">None</span>, copy = <span class="keyword">True</span>, order = <span class="keyword">None</span>, subok = <span class="keyword">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>object: 可以返回一个数组或任何(嵌套)序列的对象。</li><li>dtype: 数据类型对象</li><li>copy: 对象是否被复制</li><li>order: <code>C</code> 安行, <code>F</code> 按列,  或者默认(<code>A</code>)</li><li>subok: 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类</li><li>ndmin: 指定返回数组的最小维数。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最小维度  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]], dtype= float ,ndmin =  <span class="number">2</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line">print(a.dtype)</span><br><span class="line">print(a.ndim)</span><br><span class="line">print(a.size)</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">2.</span>  <span class="number">3.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">2.</span>  <span class="number">4.</span>]]</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">float64</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><code>numpy.array</code> 中的 <code>object</code> 传入参数必须是同一结构的, 否则将进行自动类型转换, 如果指定了 <code>dtype</code> 参数, 则以该参数类型为准(规则与C++类似)</p><h3 id="ndarray对象的方法"><a href="#ndarray对象的方法" class="headerlink" title="ndarray对象的方法"></a>ndarray对象的方法</h3><p>ndarray.ptp(axis=None, out=None)</p><p>ndarray.clip()<br>ndarray.all()<br>ndarray.any()<br>ndarray.swapaxes(axis1, axis2)</p><h2 id="numpy支持的数据类型"><a href="#numpy支持的数据类型" class="headerlink" title="numpy支持的数据类型"></a>numpy支持的数据类型</h2><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw0xe4k4jij20kg0k8gpk.jpg" alt=""></p><h2 id="数据类型对象-dtype"><a href="#数据类型对象-dtype" class="headerlink" title="数据类型对象 dtype"></a>数据类型对象 dtype</h2><p>dtype是一个对象, 这个对象所属类的名字叫做 “数据类型”</p><p>dtype 通常用于结构化数据类型:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">dt = np.dtype([(<span class="string">'age'</span>,np.int8)])  </span><br><span class="line">print(dt) <span class="comment">#输出如下： [('age', 'i1')]</span></span><br></pre></td></tr></table></figure><h1 id="numpy基本操作"><a href="#numpy基本操作" class="headerlink" title="numpy基本操作"></a>numpy基本操作</h1><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]], dtype= float ,ndmin =  <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 可以对ndarray中的值依次进行比较运算符, 返回bool数组</span></span><br><span class="line">print(a == <span class="number">3</span>)</span><br><span class="line"><span class="comment">#out</span></span><br><span class="line">[[<span class="keyword">False</span> <span class="keyword">False</span>  <span class="keyword">True</span>]</span><br><span class="line"> [<span class="keyword">False</span> <span class="keyword">False</span> <span class="keyword">False</span>]]</span><br><span class="line"><span class="comment">#out</span></span><br><span class="line"></span><br><span class="line"> print(a &lt; <span class="number">3</span>)</span><br><span class="line"> <span class="comment">#out</span></span><br><span class="line">[[ <span class="keyword">True</span>  <span class="keyword">True</span> <span class="keyword">False</span>]</span><br><span class="line"> [ <span class="keyword">True</span>  <span class="keyword">True</span> <span class="keyword">False</span>]]</span><br><span class="line"><span class="comment">#out</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以根据bool数组对ndarray中的值进行筛选, 返回1维数组</span></span><br><span class="line">print(a[ a&lt;<span class="number">3</span> ])</span><br><span class="line"><span class="comment">#out</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"><span class="comment">#out</span></span><br></pre></td></tr></table></figure><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><p><strong>矩阵运算主要注意的是<code>axis</code>参数的选择, axis参数的作用是, 沿着axis参数进行运算, 即运算后, 其他维度不变, axis指定的维度消失(所以维度会减1)</strong></p><h1 id="numpy常用函数"><a href="#numpy常用函数" class="headerlink" title="numpy常用函数"></a>numpy常用函数</h1><h2 id="ndarray对象的创建"><a href="#ndarray对象的创建" class="headerlink" title="ndarray对象的创建"></a>ndarray对象的创建</h2><h3 id="np-array"><a href="#np-array" class="headerlink" title="np.array"></a>np.array</h3><p>该函数会返回一个ndarray对象(注意numpy中不存在<code>array</code>这种数据对象类型).</p><h3 id="np-ndarray"><a href="#np-ndarray" class="headerlink" title="np.ndarray"></a>np.ndarray</h3><p>该函数也会返回一个ndarray对象, 但是不推荐使用(为啥?), np.ndarray是一个底层的方法, 会被其他多维数组创建方法所调用</p><h3 id="np-zeros"><a href="#np-zeros" class="headerlink" title="np.zeros()"></a>np.zeros()</h3><p>生成默认元素为 <code>0.</code> (注意是float64类型)的ndarray</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.zeros ((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><h3 id="np-ones"><a href="#np-ones" class="headerlink" title="np.ones()"></a>np.ones()</h3><p>生成默认元素为 <code>1.</code> (注意是float64类型)的ndarray</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z = np.ones ((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><h3 id="np-arange"><a href="#np-arange" class="headerlink" title="np.arange()"></a>np.arange()</h3><p>指定范围和数值间的间隔生成 array，注意范围包左不包右</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="comment"># 这里与python中的range不同的是, 必须指定第一个元素, 其次, 这里步长可以为小数, python的则不行</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="np-random"><a href="#np-random" class="headerlink" title="np.random"></a>np.random</h3><p><strong>np.random.random:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">random,  生成<span class="number">0</span>~<span class="number">1</span>的随机小数,默认类型为float64, 还有其他更多类型的random</span><br><span class="line">np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0.86166627</span>,  <span class="number">0.37756207</span>,  <span class="number">0.94265883</span>],</span><br><span class="line">       [ <span class="number">0.9768257</span> ,  <span class="number">0.96915312</span>,  <span class="number">0.33495431</span>]])</span><br></pre></td></tr></table></figure></p><p><strong>np.random.randn:</strong> 从标准正态分布中随机输出<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randn(d1,d2,...,dn) <span class="comment"># d1,d2,...,dn为维度</span></span><br></pre></td></tr></table></figure></p><p><strong>np.random.rand:</strong> 生成[0,1)之间的随机数据<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.rand(d1,d2,...,dn) <span class="comment"># d1,d2,...,dn为维度</span></span><br></pre></td></tr></table></figure></p><h2 id="ndarray-reshape"><a href="#ndarray-reshape" class="headerlink" title="ndarray.reshape()"></a>ndarray.reshape()</h2><p>可以对ndarray的维度重新进行调整</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure><h2 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h2><h3 id="np-append"><a href="#np-append" class="headerlink" title="np.append()"></a>np.append()</h3><p><code>np.append(arr, values, axis=None)</code><br>参数:</p><ul><li>arr</li></ul><p>返回:</p><h3 id="np-concatenate"><a href="#np-concatenate" class="headerlink" title="np.concatenate()"></a>np.concatenate()</h3><h2 id="统计类数值"><a href="#统计类数值" class="headerlink" title="统计类数值"></a>统计类数值</h2><h3 id="np-median"><a href="#np-median" class="headerlink" title="np.median()"></a>np.median()</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.median(a, axis=<span class="keyword">None</span>, out=<span class="keyword">None</span>, overwrite_input=<span class="keyword">False</span>, keepdims=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>沿着指定的轴计算中位数<br>参数:</p><ul><li>a: 类似数组的变量. 不一定非要是<code>ndarray</code>类型, 只要是任何可以转换成<code>ndarray</code>类型的数据变量都可以</li></ul><h3 id="np-mean"><a href="#np-mean" class="headerlink" title="np.mean()"></a>np.mean()</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.mean(a, axis=<span class="keyword">None</span>, dtype=<span class="keyword">None</span>, out=<span class="keyword">None</span>, keepdims=&lt;no value&gt;)</span><br></pre></td></tr></table></figure><p>返回沿着指定轴的算数平均值<br>参数:</p><ul><li>a: 类似数组的变量.</li><li>dtype: 数据类型, 可选参数.  对于整数输入来说, 默认返回值为<code>float64</code>, 对于其他<code>floating</code>输入来说, 返回值类型与输入类型保持一致.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集成学习方法</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="个体与集成"><a href="#个体与集成" class="headerlink" title="个体与集成"></a>个体与集成</h1><p>集成学习(ensemble learning): 通过构建并结合多个学习器来完成学习任务</p><p>同质集成(homogeneous): 集成中只包含同种类型的个体学习器( 神网+神网, 决策树+决策树), 其中的个体学习器称为”基学习器”, 算法为”基学习算法”.</p><p>异质集成(heterogenous): 集成中包含不同类型的个体学习器( 神网+决策树 ), 其中的个体学习器称 “组件学习器”或”个体学习器”</p><p><strong>要获得好的集成效果, 每个个体学习器应 “好而不同”, 即个体学习器要有一定的准确性, 同时还要有一定的差异性(否则多个学习器会退化成单一学习器,因为每个学习器都差不多)</strong></p><p>事实上, 个体学习器的”准确性”和”差异性”本身就存在冲突, 一般的, 当准确性很高之后, 要增加多样性就需要牺牲准确性. 根据个体学习器的生成方式, 目前的集成学习方法大致可分为两大类:</p><ul><li>个体学习器间存在依赖关系, 必须串行生成的序列化方法, eg: Boosting</li><li>个体学习器间不存在依赖关系, 可同时生成的并行化方法, eg: Bagging 和 随机森林(Random Forest)</li></ul><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><p>工作机制: 先从初始训练集训练出一个基学习器, 再根据基学习器的表现对训练样本进行调整, 使得先前基学习器做错的训练样本在后续受到更多关注, 然后基于调整后的样本分布来训练下一个基学习器, 如此重复进行, 直至基学习器数目达到事先指定的值T, 最终将这T个基学习器进行加权结合</p><p>Boosting族有很多种算法, 最著名的代表是 AdaBoost</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python 基础</title>
      <link href="/z_post/Python-%E5%9F%BA%E7%A1%80/"/>
      <url>/z_post/Python-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表:"></a>遍历列表:</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">zz_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> list:</span><br><span class="line">    print(index)</span><br><span class="line">    <span class="comment"># 0</span></span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(list)):</span><br><span class="line">    print(index)</span><br><span class="line">    <span class="comment"># 0</span></span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(list):</span><br><span class="line">    print(index, val)</span><br><span class="line">    <span class="comment"># 0 a</span></span><br><span class="line">    <span class="comment"># 1 b</span></span><br><span class="line">    <span class="comment"># 2 c</span></span><br><span class="line">    <span class="comment"># 3 d</span></span><br><span class="line"><span class="comment"># 设置遍历的开始序号, val的输出不变</span></span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(list, <span class="number">2</span>):</span><br><span class="line">    print(index, val)</span><br><span class="line">    <span class="comment"># 2 a</span></span><br><span class="line">    <span class="comment"># 3 b</span></span><br><span class="line">    <span class="comment"># 4 c</span></span><br><span class="line">    <span class="comment"># 5 d</span></span><br></pre></td></tr></table></figure><h2 id="extend-方法"><a href="#extend-方法" class="headerlink" title="extend() 方法"></a>extend() 方法</h2><p>extend()函数用于在列表末尾一次性追加另一个序列中的多个值(用新列表扩展原来的列表).<br>该方法没有返回值, 会直接在已经存在的列表中添加新的列表内容<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a= [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">b= [[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>]]</span><br><span class="line">a.extend(b)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [[1, 2, 3], [4, 5, 6], ['a', 'b', 'c'], ['d', 'e', 'f']]</span></span><br></pre></td></tr></table></figure></p><h2 id="序列切片-双冒号"><a href="#序列切片-双冒号" class="headerlink" title="序列切片(双冒号)"></a>序列切片(双冒号)</h2><p>Python序列切片地址可以写为 <code>[开始(包含) : 结束(不包含) : 步长]</code>. 当<code>开始</code>省略的时候, 默认从第0项开始, 当<code>结尾</code>省略的时候, 默认到数组最后, 当<code>步长</code>省略的时候, 默认为1. 步长可以为负数, 代表从右向左取数.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = range(<span class="number">10</span>) <span class="comment"># a = [0, 1, 2, 3, 4, 5, 6, 7, 8 ,9]</span></span><br><span class="line">a[<span class="number">0</span>:<span class="number">9</span>:<span class="number">1</span>] <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8] 包含开始下标, 不包含结束下标</span></span><br><span class="line">a[<span class="number">1</span>::<span class="number">2</span>] <span class="comment"># [1, 3, 5, 7, 9]</span></span><br><span class="line">a[::<span class="number">3</span>] <span class="comment"># [0, 3, 6, 9]</span></span><br><span class="line">a[::<span class="number">-1</span>] <span class="comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br><span class="line">a[::<span class="number">-2</span>] <span class="comment"># [9, 7, 5, 3, 1]</span></span><br></pre></td></tr></table></figure></p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p><strong>遍历字典:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zz_dict = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>, <span class="string">'z'</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>遍历keys:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出均为: x y z</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> zz_dict:</span><br><span class="line">    print(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> zz_dict.iterkeys():</span><br><span class="line">    print(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> zz_dict.keys():</span><br><span class="line">    print(key)</span><br></pre></td></tr></table></figure><p>遍历values:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出均为 1 2 3</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> zz_dict.itervalues():</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> zz_dict.values():</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><p>遍历keys和values</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出为: x corresponds to 1 (其余两个也一样)</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> zz_dict.iteritems():</span><br><span class="line">    print(key, <span class="string">"corresponds to"</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> zz_dict.items():</span><br><span class="line">    print(key, <span class="string">"corresponds to"</span>, value)</span><br></pre></td></tr></table></figure><h2 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只读csv文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./csvfile.csv'</span>) <span class="keyword">as</span> csv_file:</span><br><span class="line">  csv_reader = csv.reader(csv_file)</span><br><span class="line">  csv_head = next(csv_reader)</span><br><span class="line">  <span class="keyword">for</span> csv_row <span class="keyword">in</span> csv_reader:</span><br><span class="line">    print(csv_row)</span><br></pre></td></tr></table></figure><h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><h1 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce() 函数"></a>reduce() 函数</h1><p>reduce() 函数会对参数序列中元素进行累积</p><p>函数将一个数据集合(列表, 元组等) 中的所有数据进行以下操作: 用传给reduce中的函数function(有两个参数)先对集合中的第1,2个元素进行操作, 得到的结果再与第三个数据用function函数运算, 最后得到一个结果</p><p>语法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure><h1 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip() 函数"></a>zip() 函数</h1><p>zip() 函数用于将可迭代的对象作为参数, 将对象中对应的元素打包成一个个 <strong>元组</strong> ,然后返回有这些元组组成的 <strong>对象</strong>. ( <strong>相比于python2中返回列表的方式, 这样做的好处是节约了不少的内存</strong> )<br>可以用<code>list()</code>转换或者<code>dict()</code>转换将对象转换成相应的数据类型<br>如果各个迭代器的元素个数不一致, 则返回列表长度与最短的对象相同, 多出来的部分会被舍弃, 利用<code>*</code>号操作符, 可以将元组解压成列表.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line">zip_ab = zip(a,b)</span><br><span class="line">print(zip_ab) <span class="comment"># &lt;zip object at 0x104605348&gt;</span></span><br><span class="line">print(dict(zip_ab)) <span class="comment"># &#123;1: 4, 2: 5, 3: 6&#125;</span></span><br><span class="line"><span class="comment"># !!!注意, 一旦将zip_ab转换成dict以后, zip_ab内部就为空了!! 例如, 再次调用上面的语句:</span></span><br><span class="line">print(dict(zip_ab)) <span class="comment"># &#123;&#125;</span></span><br><span class="line"><span class="comment"># 但是zip_ab对象本身不会消失, 地址仍然不变</span></span><br><span class="line">print(zip_ab) <span class="comment"># &lt;zip object at 0x104605348&gt;</span></span><br><span class="line"></span><br><span class="line">zip_abc = zip(a,b,c) <span class="comment"># 注意, 三个元素的zip是不能转换成dict类型的</span></span><br><span class="line">print(zip_abc) <span class="comment"># &lt;zip object at 0x1046054c8&gt;</span></span><br><span class="line">print(list(zip_abc)) <span class="comment"># [(1, 4, 'a'), (2, 5, 'b'), (3, 6, 'c')]</span></span><br><span class="line"></span><br><span class="line">zip_abc = zip(a,b,c)</span><br><span class="line">z_a, z_b, z_c = zip(*zip_abc) <span class="comment"># 利用zip(*)可以将zip对象重新解压, 返回类型是元组</span></span><br><span class="line">print(z_a) <span class="comment"># (1,2,3)</span></span><br><span class="line">print(z_b) <span class="comment"># (4,5,6)</span></span><br><span class="line">print(z_c) <span class="comment"># ('a','b','c')</span></span><br></pre></td></tr></table></figure><h1 id="getattr-函数"><a href="#getattr-函数" class="headerlink" title="getattr() 函数"></a>getattr() 函数</h1><p><code>getattr()</code>函数用于返回一个对象的属性值, 语法如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(object, name[, default])</span><br></pre></td></tr></table></figure></p><p>参数:</p><ul><li>object: 对象</li><li>name: 字符串, 对象属性</li><li>default: 默认返回值, 如果不提供该参数, 在没有对应属性时, 将触发Attributerror</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-常用指令助记</title>
      <link href="/z_post/Linux-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8A%A9%E8%AE%B0/"/>
      <url>/z_post/Linux-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8A%A9%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h1><h1 id="grep指令"><a href="#grep指令" class="headerlink" title="grep指令"></a>grep指令</h1><h1 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h1><h2 id="统计文件个数"><a href="#统计文件个数" class="headerlink" title="统计文件个数"></a>统计文件个数</h2><h1 id="更换国内镜像源"><a href="#更换国内镜像源" class="headerlink" title="更换国内镜像源"></a>更换国内镜像源</h1><p>清华源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/</span><br></pre></td></tr></table></figure></p><p>中科大源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://mirrors.ustc.edu.cn/help/homebrew-bottles.html</span><br></pre></td></tr></table></figure><p>阿里源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"># apt</span><br><span class="line"></span><br><span class="line"># pip</span><br><span class="line"></span><br><span class="line"># brew</span><br><span class="line"></span><br><span class="line">中科大</span><br></pre></td></tr></table></figure></p><p>cd “$(brew —repo)”<br>git remote set-url origin <a href="https://mirrors.ustc.edu.cn/brew.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/brew.git</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># npm</span><br><span class="line"></span><br><span class="line">https://npm.taobao.org/</span><br></pre></td></tr></table></figure></p><p>npm config set registry <a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a><br>```</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>项目-竞赛-Apollo</title>
      <link href="/z_post/%E9%A1%B9%E7%9B%AE-%E7%AB%9E%E8%B5%9B-Apollo/"/>
      <url>/z_post/%E9%A1%B9%E7%9B%AE-%E7%AB%9E%E8%B5%9B-Apollo/</url>
      
        <content type="html"><![CDATA[<p>处理流程:</p><p><a href="https://www.kaggle.com/kmader/data-preprocessing-and-unet-segmentation-gpu" target="_blank" rel="noopener">https://www.kaggle.com/kmader/data-preprocessing-and-unet-segmentation-gpu</a></p><p><a href="https://github.com/matterport/Mask_RCNN/issues/5" target="_blank" rel="noopener">https://github.com/matterport/Mask_RCNN/issues/5</a></p><p>遇到的问题</p><p><a href="https://www.kaggle.com/c/cvpr-2018-autonomous-driving/discussion/56888" target="_blank" rel="noopener">https://www.kaggle.com/c/cvpr-2018-autonomous-driving/discussion/56888</a></p><p><a href="https://github.com/pandas-dev/pandas/issues/18355" target="_blank" rel="noopener">https://github.com/pandas-dev/pandas/issues/18355</a></p><p><a href="https://github.com/matterport/Mask_RCNN/issues/44" target="_blank" rel="noopener">https://github.com/matterport/Mask_RCNN/issues/44</a></p><p><a href="https://github.com/matterport/Mask_RCNN/issues/628" target="_blank" rel="noopener">https://github.com/matterport/Mask_RCNN/issues/628</a><br><a href="https://github.com/matterport/Mask_RCNN/issues/658" target="_blank" rel="noopener">https://github.com/matterport/Mask_RCNN/issues/658</a><br><a href="https://github.com/matterport/Mask_RCNN/issues/521" target="_blank" rel="noopener">https://github.com/matterport/Mask_RCNN/issues/521</a></p><p><a href="https://github.com/matterport/Mask_RCNN/issues/5" target="_blank" rel="noopener">https://github.com/matterport/Mask_RCNN/issues/5</a></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LeetCode算法题(Hard)</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-LeetCode-3/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-LeetCode-3/</url>
      
        <content type="html"><![CDATA[<h1 id="004-Median-of-Two-Sorted-Arrays"><a href="#004-Median-of-Two-Sorted-Arrays" class="headerlink" title="004. Median of Two Sorted Arrays"></a>004. Median of Two Sorted Arrays</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h2 id="解法一-根据中位数的特性"><a href="#解法一-根据中位数的特性" class="headerlink" title="解法一: 根据中位数的特性"></a>解法一: 根据中位数的特性</h2><p>题目要求需要时间复杂度为 $O(log (m+n))$.</p><p>首先我们思考中位数的作用: 中位数可以将一个数组分成两个长度相同的部分, 并且一部分中的数字总比另一部分中的小</p><p>那么对于两个数组的情况, 我们需要做的就是找到一个数字, 可以使这两个数组分别分成两部分, 并且两部分长度相同, 前一部分比后一部分的数字小</p><p>首先,我们将数组A分成两部分, 由于A有m个数字,  所以它可以有m中不同的分法, 我们以 i 为界限, 将A分成两部分, 前一部分的长度为i (从0到 i-1 ), 后一部分的长度为 m-i (从 i 到 m-1):</p><p>A[1,2,…,i-1] | A[i, i+1, …, m-1]</p><p>同理,数组 B 也可以做如下分割:</p><p>B[1,2,…,j-1] | B[j, j+1, …, n-1]</p><p>因此, 两个数组A和B都被分到了两部分, 将它们合起来, 第一部分的数字为 A[1,2,…,i-1] 和 B[1,2,…,j-1], 第二部分的数字为 A[i, i+1, …, m-1] 和 B[j, j+1, …, n-1], 我们并不关系两部分内部的顺序, 我们只关心一件事, 那就是: <strong>第一部分和第二部分的长度相等, 并且第一部分的数字都比第二部分小</strong> , 于是, i 和 j和取值就必须满足下列关系:</p><p>i+j = m-i + n-j 或 m-i + n-j + 1   (加1的原因是因为有可能数组总长为奇数, 我们令前一部分比后一部分多1个元素)</p><p>A[i-1] &lt;= B[j] 或 i==0 (说明A全部在后半段, 因此无需判断A的元素是否小于后半段的第一个B元素)</p><p>B[j-1] &lt;= A[i] 或 i==m (说明A全部在前半段, 因此无需判断A的元素是否大于前半段的最后一个B元素)</p><p>由于上式 i+j = m-i + n-j 或 m-i + n-j + 1 , 因此有 j = (m+n+1)/2 - i ;  (向下取整).  故而可以只对 i 进行判断i是否越界, 只要i满足条件,  j就不会等于0或n(即不会越界)</p><p>根据上面的分析, 解题过程如:</p><ul><li>根据两数组的长度, 将短的一方设为A数组 (j要对应较长的那个数组, 否则的话j有可能小于0 ), 令start=0, end=A.size</li><li>令 i=(start+end+1)/2 (加1 的原因是因为i代表的含义是前一部分有i个元素)</li><li>计算j = (m+n+1)/2 - i</li><li>判断当前 i和j是否满足条件,有三种情况(对这三种情况不断重复, 直到i,j位置刚刚好):<ul><li>A[i-1] &gt; B[j] 或 i 越界 , 说明 i 的位置过大, 令 end = i-1</li><li>B[j-1] &gt; A[i] 或 i 越界 , 说明 i 的位置过小, 令 start = i+1;</li><li>其他情况(A[i-1] &lt;= B[j] 或 i==0 并且 B[j-1] &lt;= A[i] 或 i==m), 说明 i 和 j的位置刚刚好</li></ul></li><li>当i,j位置刚好时, 根据数组整体长度的奇偶, 返回正确的中位数:<ul><li>奇数: 返回前半段的最大元素</li><li>偶数: 返回前半段最大元素和后半段最小元素的平均值<br>-<h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() &gt; nums2.size())&#123;</span><br><span class="line">            nums1.swap(nums2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end=m;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = (start+end+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = (n+m+<span class="number">1</span>)/<span class="number">2</span> - i;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])  <span class="comment">//注意 , 只要i&gt;start, j就一定不会超出数组限制</span></span><br><span class="line">                end = i<span class="number">-1</span>; <span class="comment">//i太大</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;end &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i])</span><br><span class="line">                start = i+<span class="number">1</span>; <span class="comment">// i太小</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> leftmax;<span class="comment">// 取左边最大的</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) leftmax=nums2[j<span class="number">-1</span>];  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) leftmax=nums1[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> leftmax = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]) ;</span><br><span class="line">                <span class="keyword">if</span>( (n+m)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> leftmax;  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> rightmin; <span class="comment">// 取右边最小的</span></span><br><span class="line">                <span class="keyword">if</span>(i==m) rightmin = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==n) rightmin = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> rightmin = min(nums1[i] ,nums2[j]);</span><br><span class="line">                <span class="keyword">return</span> (leftmax+rightmin) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">       <span class="comment">// return 0.0;  //因为, 两数组不会同时为空, 所以这句话主要用于调试</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() &lt;= nums2.size())</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, <span class="number">0</span> , nums1.size(),nums2);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(nums2, <span class="number">0</span> , nums2.size(),nums1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (start1+end1+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = (nums1.size()+nums2.size()+<span class="number">1</span>)/<span class="number">2</span> - i;</span><br><span class="line">        <span class="keyword">if</span>(start1 &gt; end1) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span>( (i==<span class="number">0</span> || nums1[i<span class="number">-1</span>]&lt;=nums2[j]) &amp;&amp; (i==nums1.size() || nums2[j<span class="number">-1</span>]&lt;=nums1[i]))&#123; <span class="comment">// 如果找到i</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> res11, res12;  </span><br><span class="line">            <span class="keyword">int</span> res21, res22;</span><br><span class="line">            <span class="comment">// 首先将左边部分的两个数组分别赋值, 如果i或j为0, 说明对应数组在左边</span></span><br><span class="line">            <span class="comment">//只有0个元素 , 将其赋值为INT_MIN(因为要取max(res11, res21))</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) res11= INT_MIN;          </span><br><span class="line">            <span class="keyword">else</span> res11=nums1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>) res21= INT_MIN;</span><br><span class="line">            <span class="keyword">else</span> res21=nums2[j<span class="number">-1</span>];            </span><br><span class="line">            <span class="comment">//同理, 对右边进行处理, 取min(res12, res22)</span></span><br><span class="line">            <span class="keyword">if</span>(i==nums1.size()) res12= INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> res12=nums1[i];</span><br><span class="line">            <span class="keyword">if</span>(j==nums2.size()) res22= INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> res22=nums2[j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据数组奇偶个数返回结果</span></span><br><span class="line">            <span class="keyword">if</span>((nums1.size() + nums2.size())%<span class="number">2</span> == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">return</span> max(res11, res21);</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ( max(res11,res21)+min(res12,res22) ) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] &gt; nums2[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, start1, i<span class="number">-1</span>, nums2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, i+<span class="number">1</span>, end1, nums2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="010"><a href="#010" class="headerlink" title="010."></a>010.</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-递归实现-速度很慢-只超过0-97-的提交"><a href="#解法一-递归实现-速度很慢-只超过0-97-的提交" class="headerlink" title="解法一: 递归实现( 速度很慢, 只超过0.97%的提交)"></a>解法一: 递归实现( 速度很慢, 只超过0.97%的提交)</h2><p>采用递归法, 首先判断当前字母后面是否是’ * ‘, ,如果是, 则需要分别进行下面两种情况的判断:</p><ul><li>当前字母出现0次</li><li>当前字母出现1次或以上(前提是当前字母可以匹配)</li></ul><p>其次, 就是终止条件的判断, 总共有三种情况:</p><ul><li>都走到了尽头, 返回ture</li><li>只有p走到了尽头, 返回false</li><li>只有s走到了尽头, 需要查看p后续的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">( <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> s_i, <span class="built_in">string</span>&amp; p, <span class="keyword">int</span> p_i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s_i == s.size() &amp;&amp; p_i == p.size()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 若都走到了最后, 则返回ture</span></span><br><span class="line">        <span class="keyword">if</span>(p_i == p.size() ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若只有p走到了最后, 返回false</span></span><br><span class="line">        <span class="keyword">if</span>(s_i == s.size() &amp;&amp; p_i+<span class="number">1</span>&lt;p.size() &amp;&amp; p[p_i+<span class="number">1</span>] == <span class="string">'*'</span>) <span class="comment">//若只有s走到了最后, 则需要看p后面是否有*, 如果有*, 则仍有可能匹配</span></span><br><span class="line">            <span class="keyword">return</span> helper(s, s_i, p, p_i+<span class="number">2</span>); <span class="comment">// 若没有*,返回false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s_i == s.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p_i + <span class="number">1</span> &lt; p.size() &amp;&amp; p[p_i+<span class="number">1</span>] == <span class="string">'*'</span>)&#123; <span class="comment">//如果后面有星号, 则需要进行两种判断</span></span><br><span class="line">            <span class="keyword">bool</span> b1 = helper(s, s_i, p, p_i+<span class="number">2</span>); <span class="comment">// 星号前的字母出现0次</span></span><br><span class="line">            <span class="keyword">bool</span> b2 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[s_i] == p[p_i] || p[p_i] == <span class="string">'.'</span>)</span><br><span class="line">                b2 = helper(s, s_i+<span class="number">1</span>, p , p_i) || helper(s, s_i+<span class="number">1</span>, p, p_i+<span class="number">2</span>);<span class="comment">// 出现一次或一次以上</span></span><br><span class="line">            <span class="keyword">return</span> b1 || b2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[s_i] == p[p_i] || p[p_i] == <span class="string">'.'</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(s, s_i+<span class="number">1</span>, p, p_i+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-动态规划"><a href="#解法二-动态规划" class="headerlink" title="解法二: 动态规划"></a>解法二: 动态规划</h2><p>This problem has a typical solution using Dynamic Programming. We define the state P[i][j] to be true if s[0..i) matches p[0..j) and false otherwise. Then the state equations are:</p><ul><li>P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’);</li><li>P[i][j] = P[i][j - 2], if p[j - 1] == ‘*’ and the pattern repeats for 0 times;</li><li>P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times.</li></ul><p>Putting these together, we will have the following code.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> dp[s.size()+<span class="number">1</span>][p.size()+<span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;p.size()+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>) <span class="comment">//  注意这里是j-1</span></span><br><span class="line">                    dp[i][j] =  ( j &gt; <span class="number">1</span> &amp;&amp; dp[i][j<span class="number">-2</span>] )|| ( i&gt;<span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i<span class="number">-1</span>][j]);  <span class="comment">// 注意这里是j-2, i-1, 一定要知道这些是为什</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = i&gt;<span class="number">0</span> &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][p.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="23"><a href="#23" class="headerlink" title="23."></a>23.</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-基于比较的合并"><a href="#解法一-基于比较的合并" class="headerlink" title="解法一: 基于比较的合并"></a>解法一: 基于比较的合并</h2><p>时间复杂度: $O(k * max(len))$  k为需要合并和链表个数, 在比较时需要遍历k个链表的头结点, 以便找出最小的<br>空间复杂度: $O(1)$</p><p>将该问题看做是两个有序链表的合并问题, 只不过每次选择最小的节点时, 需要从vector.size()个节点中选择, 同时还要注意及时移除vector中已经走到头的空链表, 并判断size当前的大小, 当vector中的size大小为1时, 说明其余链表都已经合并完成, 此时退出循环, 直接将该链表接入即可.</p><p>另外要注意vector为空, 以及vector中全是nullptr链表的特殊情况.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//处理[]的情况</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur_node = dummy;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> min_node_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;lists.size() ;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lists[i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    lists.erase(lists.begin()+i);</span><br><span class="line">                    i--; <span class="comment">//移除第i个元素后, 下一个元素会自动成为第i个元素,因此, 将当前i--</span></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// continue后, i会++, 最终i指向了下一个元素</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lists[min_node_index]-&gt;val &gt; lists[i]-&gt;val)&#123;</span><br><span class="line">                    min_node_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//主要是应对 [[], []] 的情况, 本身vector的size大于0, 但是经过erase以后size就变成0了, 此时应返回nullptr</span></span><br><span class="line">            cur_node-&gt;next = lists[min_node_index];</span><br><span class="line">            cur_node = cur_node-&gt;next;</span><br><span class="line">            lists[min_node_index] = lists[min_node_index]-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(lists[min_node_index] == <span class="literal">nullptr</span>) lists.erase(lists.begin()+min_node_index);</span><br><span class="line">        &#125;</span><br><span class="line">        cur_node-&gt;next = lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-用小顶堆对解法一的比较操作进行优化"><a href="#解法二-用小顶堆对解法一的比较操作进行优化" class="headerlink" title="解法二: 用小顶堆对解法一的比较操作进行优化"></a>解法二: 用小顶堆对解法一的比较操作进行优化</h2><p>时间复杂度: $O(logk * max(len))$<br>空间复杂度: $O(k)$  由于要构造堆, 所以需要额外空间</p><p>由于我们只需要找到k个节点里面数值最小的那一个, 因此可以利用Priority Queue (实际上就是大顶堆和小顶堆)对上面的比较操作进行优化, 使得比较操作的复杂度从 $k$ 降到 $logk$.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="comment">// 仿函数</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* &amp; node1, ListNode* &amp;node2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node1-&gt;val &gt; node2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode * &gt;&amp; lists)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;ListNode * , <span class="built_in">vector</span>&lt;ListNode * &gt;, cmp&gt; min_q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> head_node : lists)</span><br><span class="line">            <span class="keyword">if</span>(head_node != <span class="literal">nullptr</span>) min_q.push(head_node); <span class="comment">// 入队列之前检查是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(min_q.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 如果队列为空, 说明没有非空元素入队列, 所有链表为空, merge后也为空</span></span><br><span class="line">        ListNode* res = min_q.top(); min_q.pop();</span><br><span class="line">        <span class="keyword">if</span>(res-&gt;next!=<span class="literal">nullptr</span>) min_q.push(res-&gt;next);</span><br><span class="line">        ListNode* cur_node = res;</span><br><span class="line">        <span class="keyword">while</span>(!min_q.empty())&#123;</span><br><span class="line">            cur_node-&gt;next = min_q.top(); min_q.pop();</span><br><span class="line">            cur_node = cur_node-&gt;next; <span class="comment">// 将cur_node指向top元素, 以便查看top的next是否为空</span></span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;next!=<span class="literal">nullptr</span>) min_q.push(cur_node-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-转化成双列表合并问题"><a href="#解法三-转化成双列表合并问题" class="headerlink" title="解法三: 转化成双列表合并问题"></a>解法三: 转化成双列表合并问题</h2><p>时间复杂度: $O(k * max(len))$<br>空间复杂度: $O(1)$</p><p>双列表合并问题的时间复杂度为 $O(max(m,n))$ , 可以将多链表合并问题看做是k次双列表合并.</p><h2 id="解法四-对解法三进行优化"><a href="#解法四-对解法三进行优化" class="headerlink" title="解法四: 对解法三进行优化"></a>解法四: 对解法三进行优化</h2><p>时间复杂度: $O(logk * max(len))$<br>空间复杂度: $O(1)$</p><p>对列表合并时, 每次都是两两合并(不是解法三中的逐一合并), 这样, 只需要经过 $logk$ 次两两合并就可完成所有合并过程.</p><h1 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a>41. First Missing Positive</h1><p>寻找数组中缺失的最小的正数</p><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>Given an unsorted integer array, find the smallest missing positive integer.</p><p>Example 1:</p><p>Input: [1,2,0]<br>Output: 3<br>Example 2:</p><p>Input: [3,4,-1,1]<br>Output: 2<br>Example 3:</p><p>Input: [7,8,9,11,12]<br>Output: 1<br>Note:</p><p>Your algorithm should run in O(n) time and uses constant extra space.</p><h2 id="解法一-下标与正数对应"><a href="#解法一-下标与正数对应" class="headerlink" title="解法一: 下标与正数对应"></a>解法一: 下标与正数对应</h2><p><strong>时间复杂度:</strong> $O(n)$ (但是for循环内部存在while循环, 因此有争议)<br><strong>空间复杂度:</strong> $O(1)$ (但是对改变了原始的数组, 这是一个小缺陷)</p><p>将下标与正数相应对, 例如对于正数5, 我们就将放置在nums[4]上, 这样一来, 再次遍历数组的时候, 当遇到第一个与下标不对应的数字时, 该下标对应的正数(i+1)就是缺少的正数.</p><p>放置正数到正确位置上时, 需要注意几点:</p><ul><li>swap之后需要继续将原来位置上(nums[4])的数放置到正确的位置上, 这里需要一个while循环</li><li>在检查数组时, 如果所有数组内所有数字都处在正确位置上, 那么就应该返回nums.size+1 (包括了数组为空的情况: 返回0+1=1)</li></ul><p><strong>写法一: for+while</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i]&lt;nums.size() &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>写法二: while</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp;nums[i]&lt;nums.size() &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i]<span class="number">-1</span>]); <span class="comment">// 如果进行了swap, 就不要i++</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法二-哈希"><a href="#解法二-哈希" class="headerlink" title="解法二: 哈希"></a>解法二: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$ (3次for循环, 毫无争议的 $O(n)$ )<br><strong>空间复杂度:</strong> $O(1)$ (但是对改变了原始的数组, 这是一个小缺陷)</p><p><strong>注意:</strong> 虽然这里的时间复杂度是毫无争议的 $O(n)$ , 但是不一定会上面的速度快, 因为上面只有两次循环, 内第一次内部的循环次数一般情况下都不会很大.</p><p><strong>从哈希的角度理解: 可以将数组下标看成是hash的key</strong></p><ol><li>for any array whose length is l, the first missing positive must be in range [1,…,l+1],<br> so we only have to care about those elements in this range and remove the rest.</li><li>we can use the array index as the hash to restore the frequency of each number within<br>  the range [1,…,l+1]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 丢失的最小正数只可能在 [1,2,...,nums.size()+1] 之间</span></span><br><span class="line">        <span class="comment">// 这里的pushback是必须的, 因为下面会将不符合要求的元素都置为0,</span></span><br><span class="line">        <span class="comment">//因此nums[0]需要与0对应, 以代表所有的非法元素,</span></span><br><span class="line">        <span class="comment">//这点与上面基于swap的方法不同, 上面的swap是让nums[0] 与 1 对应.</span></span><br><span class="line">        nums.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> || nums[i] &gt;= length)</span><br><span class="line">                nums[i] = <span class="number">0</span>; <span class="comment">// 将所有不符合丢失正数的数移除, 这一步必须单独用一个for循环做</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            nums[nums[i]%length] += length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]/length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42 Trapping Rain Water"></a>42 Trapping Rain Water</h1><p>数组中每个值代表柱状体的高度, 每个柱状体的宽度都为1, 根据数组内的值组成的高低不同的块, 能够存储多少个bin (1×1)的水</p><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwj4ej0utpj20d904mglk.jpg" alt=""></p><p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p><p>Example:</p><p>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p><h2 id="解法一-左右指针"><a href="#解法一-左右指针" class="headerlink" title="解法一: 左右指针"></a>解法一: 左右指针</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p><p>分别用两个变量left和right指向左边和右边的柱子, 并再用两个变量maxleft和maxright维护左边最高的柱子和右边最高的柱子, 统计的时候, 先固定left和right当中柱子高度较高的那一个, 然后统计较低柱子上存储的水量. 利用, 如果当前left的高度小于right的高度, 则我们计算left上面能够存储的水量, 有两种情况, 当left柱子的高度大于等于maxleft时, 则left柱子上没法存储水, 因为谁会从左边全部流失(右边比左边高, 所以不会从右边流失).  如果left的高度小于maxleft时, 由于水无法从左边流失, 也不能从右边流失, 因此当前柱子上就会存储水, 存储的水量为<code>maxleft-height[left]</code> (不考虑maxright, 因为maxright大于maxleft).</p><p><strong>注意:</strong> 此题中的柱子是有 <strong>宽度</strong> 的, 这一点很重要, 如果柱子的宽度为0 , 那么就是另一种情况了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, maxleft = <span class="number">0</span>, maxright = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt;= height[right])&#123; <span class="comment">//固定较大的一个柱子</span></span><br><span class="line">                <span class="keyword">if</span>(height[left] &gt; maxleft) maxleft = height[left];<span class="comment">// 如果当前柱子的高度大于左边max柱子的高度, 那么该柱子所处位置一定存不下水</span></span><br><span class="line">                <span class="keyword">else</span> res = res + maxleft - height[left]; <span class="comment">// 反之, 该柱子位置上可以存储的水的量为 坐标max高度减去当前的高度</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right] &gt; maxright) maxright = height[right];</span><br><span class="line">                <span class="keyword">else</span> res = res + maxright - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"># <span class="number">44.</span> Wildcard Matching</span><br><span class="line"></span><br><span class="line">字符串模式匹配</span><br><span class="line"></span><br><span class="line">## Description</span><br><span class="line">Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.</span><br><span class="line"></span><br><span class="line"><span class="string">'?'</span> Matches any single character.</span><br><span class="line">'*' Matches any sequence of characters (including the empty sequence).</span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">s could be empty <span class="keyword">and</span> contains only lowercase letters a-z.</span><br><span class="line">p could be empty <span class="keyword">and</span> contains only lowercase letters a-z, <span class="keyword">and</span> characters like ? <span class="keyword">or</span> *.</span><br><span class="line">Example <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: <span class="string">"a"</span> does <span class="keyword">not</span> match the entire <span class="built_in">string</span> <span class="string">"aa"</span>.</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"*"</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: <span class="string">'*'</span> matches any sequence.</span><br><span class="line">Example <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = <span class="string">"cb"</span></span><br><span class="line">p = <span class="string">"?a"</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: <span class="string">'?'</span> matches <span class="string">'c'</span>, but the second letter is <span class="string">'a'</span>, which does <span class="keyword">not</span> match <span class="string">'b'</span>.</span><br><span class="line">Example <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = <span class="string">"adceb"</span></span><br><span class="line">p = <span class="string">"*a*b"</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: The first <span class="string">'*'</span> matches the empty sequence, <span class="keyword">while</span> the second <span class="string">'*'</span> matches the substring <span class="string">"dce"</span>.</span><br><span class="line">Example <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = <span class="string">"acdcb"</span></span><br><span class="line">p = <span class="string">"a*c?b"</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">## 解法一: 迭代</span><br><span class="line"></span><br><span class="line">时间复杂度: $O(m+n)$</span><br><span class="line">空间复杂度: $O(<span class="number">1</span>)$</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isMatch(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> try_i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> star_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> len_s = s.size(), len_p = p.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len_s)&#123;</span><br><span class="line">            <span class="keyword">if</span>( j&lt; len_p &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'?'</span>) )&#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( j&lt;len_p &amp;&amp; p[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                star_index = j;</span><br><span class="line">                j++;</span><br><span class="line">                match = i; <span class="comment">// 该变量用于回溯</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( star_index != <span class="number">-1</span>)&#123; <span class="comment">//如果之前是 * , 则进行回溯</span></span><br><span class="line">                j = star_index + <span class="number">1</span>;</span><br><span class="line">                match++;</span><br><span class="line">                i = match;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p[j] == <span class="string">'*'</span>) j++;</span><br><span class="line">        <span class="keyword">return</span> i==len_s &amp;&amp; j == len_p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-DP"><a href="#解法二-DP" class="headerlink" title="解法二: DP"></a>解法二: DP</h2><p>时间复杂度: $O(n^2)$<br>空间复杂度: $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pLen = p.size(), sLen = s.size(), i, j, k, cur, prev;</span><br><span class="line">        <span class="keyword">if</span>(!pLen) <span class="keyword">return</span> sLen == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> matched[<span class="number">2</span>][sLen+<span class="number">1</span>];</span><br><span class="line">        fill_n(&amp;matched[<span class="number">0</span>][<span class="number">0</span>], <span class="number">2</span>*(sLen+<span class="number">1</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        matched[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=pLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = i%<span class="number">2</span>, prev= <span class="number">1</span>-cur;</span><br><span class="line">            matched[cur][<span class="number">0</span>]= matched[prev][<span class="number">0</span>] &amp;&amp; p[i<span class="number">-1</span>]==<span class="string">'*'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[i<span class="number">-1</span>]==<span class="string">'*'</span>) <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=sLen; ++j) matched[cur][j] = matched[cur][j<span class="number">-1</span>] || matched[prev][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=sLen; ++j)            matched[cur][j] =  matched[prev][j<span class="number">-1</span>] &amp;&amp; (p[i<span class="number">-1</span>]==<span class="string">'?'</span> || p[i<span class="number">-1</span>]==s[j<span class="number">-1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> matched[cur][sLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="076-Minimum-Window-Substring"><a href="#076-Minimum-Window-Substring" class="headerlink" title="076. Minimum Window Substring"></a>076. Minimum Window Substring</h1><p>求包含子串字符的最小窗口</p><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>Example:</p><p>Input: S = “ADOBECODEBANC”, T = “ABC”<br>Output: “BANC”<br>Note:</p><p>If there is no such window in S that covers all characters in T, return the empty string “”.<br>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p><h2 id="解法-两个变量记录当前窗口大小"><a href="#解法-两个变量记录当前窗口大小" class="headerlink" title="解法: 两个变量记录当前窗口大小"></a>解法: 两个变量记录当前窗口大小</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hmap(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t) hmap[<span class="keyword">int</span>(c)]++;</span><br><span class="line">        <span class="keyword">int</span> count = t.size(), begin=<span class="number">0</span>, end=<span class="number">0</span>, head=<span class="number">0</span>, cur_window=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">            <span class="comment">// 这里可以直接写成 if(hmap[int(s[end++])]-- &gt; 0) count--;  但是可读性很差,  不建议这样写.</span></span><br><span class="line">            <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[end])] &gt; <span class="number">0</span>) count--;</span><br><span class="line">            hmap[<span class="keyword">int</span>(s[end])]--; end++;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span>)&#123; <span class="comment">//end 超尾</span></span><br><span class="line">                <span class="keyword">if</span>( (end-begin) &lt; cur_window) cur_window = end - (head=begin);</span><br><span class="line">                <span class="comment">// 同样, 可以直接写成 if(hmap[int(s[begin++])]++ &gt; 0) count++;  但是可读性很差</span></span><br><span class="line">                <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[begin])] == <span class="number">0</span>) count++;</span><br><span class="line">                hmap[<span class="keyword">int</span>(s[begin])]++; begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_window==INT_MAX ? <span class="string">""</span> : s.substr(head, cur_window);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="子串相关题目的模板解法"><a href="#子串相关题目的模板解法" class="headerlink" title="子串相关题目的模板解法"></a>子串相关题目的模板解法</h2><p>对于大多数的子串相关的问题, 通常可以描述为给定一个字符串, 要求找到满足某些限制条件的子串, 这类都可以用下面的基于哈希表和两个辅助指示变量的模板来求解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hmap(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 用于检查子串是否合法</span></span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">// 两个指示变量, 分别指向子串的头和尾(end会在++后退出循环, 因此最后end会变成超尾)</span></span><br><span class="line">    <span class="keyword">int</span> len_sub; <span class="comment">// 子串的长度</span></span><br><span class="line">    <span class="keyword">for</span>()&#123; &#125;<span class="comment">//对hasp map进行初始化</span></span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">        <span class="comment">//if(hmap[s[end++]]-- ? ) &#123; &#125; //修改count</span></span><br><span class="line">        <span class="comment">//上面的语句可读性很差, 最后拆开来写, 后面也同理, 拆开写</span></span><br><span class="line">        <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[end])] ? ) &#123; &#125; <span class="comment">//修改count</span></span><br><span class="line">        hmap[<span class="keyword">int</span>(s[end])]--; <span class="comment">//注意顺序</span></span><br><span class="line">        end++;</span><br><span class="line">        <span class="keyword">while</span>( count? )&#123; <span class="comment">// 检查count是否满足条件</span></span><br><span class="line">            <span class="comment">// update len_sub</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[begin])] ?) &#123; &#125; <span class="comment">//修改count</span></span><br><span class="line">            hmap[<span class="keyword">int</span>(s[begin])]++;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如, 对于问题 <strong>Longest Substring At Two Distinct Characters</strong> 的模板解法如下:</p><p>对于问题 <strong>Longest Substring Without Repeating Characters</strong> 的模板解法如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,len_sub=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[<span class="keyword">int</span>(s[end])] &gt; <span class="number">0</span>) count++;</span><br><span class="line">        <span class="built_in">map</span>[<span class="keyword">int</span>(s[end])]++;</span><br><span class="line">        end++;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[<span class="keyword">int</span>(s[begin])] &gt; <span class="number">1</span>) count;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>智力题</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题:"></a>智力题:</h1><h1 id="如果一个女生说，她集齐了十二个星座的前男友，我们应该如何估计她前男友的数量？"><a href="#如果一个女生说，她集齐了十二个星座的前男友，我们应该如何估计她前男友的数量？" class="headerlink" title="如果一个女生说，她集齐了十二个星座的前男友，我们应该如何估计她前男友的数量？"></a>如果一个女生说，她集齐了十二个星座的前男友，我们应该如何估计她前男友的数量？</h1><p><a href="https://www.zhihu.com/question/38331955" target="_blank" rel="noopener">https://www.zhihu.com/question/38331955</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智力题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>优化方法整理总结</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><div class="table-container"><table><thead><tr><th>名称</th><th>公式</th><th>优化方法简述</th></tr></thead><tbody><tr><td>SGD</td><td>$g_t = \nabla_{\theta_{t-1}} f(\theta_{t-1})$ <br> $\delta \theta_t = - \eta * g_t$</td><td>每一次都计算mini-batch的梯度, 然后对参数进行更新</td></tr><tr><td>Momentum</td><td>$m_t = \mu <em> m_{t-1} + g_t$ <br> $\delta \theta_t = -\eta </em> m_t$</td><td>公式中的 $\mu$ 为动量因子,  借助于物理学里面动量的概念, 通过动量的积累来在相关方向上加速SGD优化速度, 同时有助于跳出局部最优, 进而加快收敛</td></tr><tr><td>Nesterov</td><td>$\delta_t = -\eta <em> \mu </em> m_{t-1} - \eta * g_t$</td><td>Nesterov在梯度更新时做一个矫正, 避免前进太快, 同时提高灵敏度, 从公式可以看出, 动量项 $m_{t-1}$ 没有改变当前的梯度 $g_t$, 而是利用之前的动量来影响当前的动量</td></tr><tr><td>Adagrad</td><td>$n_t = n_{t-1} + g^2_t$ <br> $\delta \theta_t = -\frac{\eta}{\sqrt{n_t + \epsilon}} * g_t$</td><td>Adagrad相当于在学习率前面乘了一个约束项 $\frac{\eta}{n_t + \epsilon}, 使得 $g_t$ 较小的时候, 能够放大梯度, 反之, 在 $g_t$ 较大的时候, 能够约束梯度</td></tr><tr><td>Adadelta</td><td>…</td><td>Adadelta是对Adagrad的扩展, 核心思想依然是对学习率乘上一个约束项, 但是进行了计算上的简化</td></tr><tr><td>RMSprop</td><td>…</td><td>RMSprop可以算作是Adadelta的一个特例</td></tr><tr><td>Adam</td><td>$m_t = \mu <em> m_{t-1} + (1-\mu) </em> g_t$ <br> $n_t = \nu<em>n_{t-1} + (1 - \nu) </em> g^2_t$ <br> $\hat m_t = \frac{m_t}{1-\mu_t}$ <br> $\hat n_t = \frac{n_t}{1- \nu_t}$ <br> $\delta \theta_t = -\frac{\hat m_t}{\sqrt{\hat n_t} + \epsilon} * \eta$</td><td>Adam本质上是带有动量项的RMSprop, 它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率. 公式中, $m_t, n_t$ 分别是对梯度的一阶矩估计和二阶矩估计, 可以看作对期望 $E</td><td>g_t</td><td>, E</td><td>g^2_t</td><td>$ 的估计, $\hat m_t, \hat n_t$ 是对 $m_t$, $n_t$ 的校正, 这样可以近似为对期望的无偏估计.</td></tr><tr><td>Adamax</td><td>…</td><td>…</td></tr><tr><td>Nadam</td><td>…</td><td>…</td></tr></tbody></table></div><p>损失平面等高线:</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw1zh9xp8fj20hq0dtjuw.jpg" alt=""></p><p>鞍点处的比较:</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw1zh9w3n9j20j90femz6.jpg" alt=""></p><h1 id="损失函数选择经验"><a href="#损失函数选择经验" class="headerlink" title="损失函数选择经验"></a>损失函数选择经验</h1><ul><li>对于稀疏数据, 尽量使用学习率可自适应的优化方法, 因为自适应的优化方法对不同的参数会赋予不同的更新步长</li></ul><p>// TODO 以下四点未确认正确性</p><ul><li>SGD通常训练时间更长, 但是在好的初始化和学习率调度方案的情况下, 结果更可靠</li><li>如果在意更快的收敛, 并且需要训练较深较复杂的网络时, 推荐使用学习率自适应的优化方法</li><li>Adadelta, RMSprop, Adam是比较相近的算法, 在相似情况下表现差不多</li><li>在想使用带动量的RMSprop, 或者Adam的地方, 大多可以使用Nadam取得更好的效果</li></ul><h1 id="深入解析各个损失函数的优缺点"><a href="#深入解析各个损失函数的优缺点" class="headerlink" title="深入解析各个损失函数的优缺点"></a>深入解析各个损失函数的优缺点</h1><h2 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h2><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>因为要兼顾整个神经网络的训练效果, 因此通常学习率的选择比较困难. 并且训练过程中, 无法调节学习率.</p><p>某些情况下容易被困在鞍点, 需要使用合适的初始化和步长, 才能跳出鞍点</p><h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><h1 id="区别于联系"><a href="#区别于联系" class="headerlink" title="区别于联系"></a>区别于联系</h1><h1 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h1><p><strong>learning rate:</strong></p><p>学习率决定了权值更新的速度, 设置的太大会使结果超过最优值, 太小会使下降速度过慢, 仅靠认为干预调整参数需要不断修改学习率, 十分不合理.</p><p><strong>weight decay:</strong></p><p>就是正则项, L1或L2正则项</p><p><strong>momentum:</strong></p><p><strong>learning rate decay:</strong></p><p>每经过一段迭代次数以后, 就会减小learning rate的大小.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>机器学习/深度学习面试问题汇总</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统面试问题汇总</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++面试总结</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-Cpp%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-Cpp%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[ToC]</p><p><a href="https://zhuanlan.zhihu.com/p/46237848?utm_source=wechat_session&amp;utm_medium=social" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46237848?utm_source=wechat_session&amp;utm_medium=social</a></p><h1 id="vector-和-list-的区别"><a href="#vector-和-list-的区别" class="headerlink" title="vector 和 list 的区别"></a>vector 和 list 的区别</h1><h1 id="new-delete-malloc-free的关系"><a href="#new-delete-malloc-free的关系" class="headerlink" title="new, delete, malloc, free的关系"></a>new, delete, malloc, free的关系</h1><p>delete会调用对象的析构函数, 和new对应</p><p>free只会释放内存, 和malloc.</p><p>malloc/free是C++/C 语言的标准库函数,  new/deletec是C++语言的运算符.</p><p>它们都可用于申请动态内存和释放内存, 对于非内部数据类型的对象而言, 光用malloc/free无法满足动态对象的要求, 对象在创建的同时要自动执行构造函数, 在消亡之时要自动执行析构函数, 由于malloc/free是库函数而不是运算符, 因此不在编译器控制权限之内, 不能够把执行构造函数和析构函数的任务强加于malloc/free. 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new, 以及一个能完成清理与释放内存工作的运算符delete.</p><h1 id="new-delete-malloc-free的内部实现"><a href="#new-delete-malloc-free的内部实现" class="headerlink" title="new, delete, malloc, free的内部实现"></a>new, delete, malloc, free的内部实现</h1><h1 id="delete-和-delete-的区别"><a href="#delete-和-delete-的区别" class="headerlink" title="delete 和 delete []的区别"></a>delete 和 delete []的区别</h1><p>delete只会调用一次析构函数, 而delete[]会调用数组内每一个成员的析构函数. 在More Effective C++中有更为详细的解释: 当delete操作符用于数组时, 它为每个数组元素调用析构函数, 然后调用operator delete来释放内存</p><p>在对 <strong>内建数据类型</strong> 使用时, delete和delete[]是等价的, 因此delete[]会调用数组元素的析构函数, 但是内部数据类型没有析构函数, 所以可以直接使用.</p><h1 id="子类析构时要调用父类的析构函数吗"><a href="#子类析构时要调用父类的析构函数吗" class="headerlink" title="子类析构时要调用父类的析构函数吗?"></a>子类析构时要调用父类的析构函数吗?</h1><p>调用</p><p>析构函数调用的次序是先调用派生类的析构, 后调用基类的析构, 也就是说在基类的析构函数调用的时候, 派生类的信息已经全部销毁了.</p><p>定义一个对象时先调用基类的构造函数, 然后调用派生类的构造函数, 析构的时候恰好相反, 先调用派生类的析构函数, 然后调用基类的析构函数</p><h1 id="什么是引用-声明和使用引用时要注意哪些问题"><a href="#什么是引用-声明和使用引用时要注意哪些问题" class="headerlink" title="什么是引用? 声明和使用引用时要注意哪些问题?"></a>什么是引用? 声明和使用引用时要注意哪些问题?</h1><p>引用就是某个变量的”别名”(alias).</p><p>声明一个引用的时候, 切记要对其进行初始化.</p><p>声明完毕后, 相当于目标变量具有了两个名称, 即原名称和引用名, 引用名与该变量绑定, 不能再把该引用名作为其他变量名的别名.</p><p>对引用求地址, 就是对目标变量取地址, 即我们常说引用名是目标变量名的一个别名. 注意, <strong>引用是占据空间的, 编译器一般将引用实现为const指针, 即指向位置不可变的指针. 所以实际上引用与一般指针同样占用内存</strong></p><p><strong>不能建立引用的数组.</strong> 因为数组是一个由若干个元素所组成的集合, 所以无法建立一个由引用组成的集合. <strong>但是可以建立数组的引用(即数组的别名)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x=2,y=3,z=4;</span><br><span class="line">int&amp; ref[3] = &#123;&amp;x, &amp;y, &amp;z&#125;; //非法!</span><br><span class="line"></span><br><span class="line">int arr[3]&#123;1,2,3&#125;;</span><br><span class="line">int(&amp;ref) [3] = arr; //合法, ref是一个引用, 指向一个包含3个元素的一维数组</span><br></pre></td></tr></table></figure><h1 id="引用和指针的关系与区别"><a href="#引用和指针的关系与区别" class="headerlink" title="引用和指针的关系与区别?"></a>引用和指针的关系与区别?</h1><p><strong>关系:</strong></p><p>编译器一般会将引用实现为const指针, 所以可以将引用看做是一种特殊的指针</p><p><strong>区别:</strong></p><ol><li>引用不能为空, 即引用必须连接到一块合法的内存 <code>int &amp;a;</code> 错误</li><li>一旦引用被初始化为一个对象, 就不能再被指向另一个对象(因为引用时const指针)</li><li>引用必须在创建的同时被初始化, 而指针可以在任何时间被初始化</li></ol><h1 id="将引用作为函数参数有哪些特点"><a href="#将引用作为函数参数有哪些特点" class="headerlink" title="将引用作为函数参数有哪些特点?"></a>将引用作为函数参数有哪些特点?</h1><ol><li>由于引用可以看做是const指针, 因此传递引用给函数和传递指针给函数的效果是一样的, 这时, 被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用, 所以在被调函数中对形参变量的操作就是对其相应的目标对象的操作.</li><li>使用引用传递参数时, 在内存中并不会产生实参的副本, 因此, 当参数传递的数据较大时, 用引用的空间利用率高</li></ol><h1 id="将引用作为函数返回值类型的优势和注意事项"><a href="#将引用作为函数返回值类型的优势和注意事项" class="headerlink" title="将引用作为函数返回值类型的优势和注意事项?"></a>将引用作为函数返回值类型的优势和注意事项?</h1><p>优势:<br>在内存中不会产生被返回值的副本 ( <strong>注意:</strong> 正是因为这个原因, 所以返回一个局部变量的引用是不可取的. )</p><p>注意事项:</p><ol><li>不能返回局部变量的引用: 因为在内存中不会产生被返回值的副本, 随着该局部变量生存期的结束, 引用指向的变量就失效了, 此时会产生runtime error错误.</li><li>不要返回函数内部<code>new</code>分配的内存的引用: 虽然不存在局部变量的自动销毁问题, 但是对于这种情况, 又是会面临其他尴尬局面. 例如, 被函数返回的引用只是作为一个临时变量出现, 而没有被赋予一个实际的变量, 那么这个引用所指向的空间(由new分配)就无法释放 很容易造成内存泄漏.</li><li>可以返回对象成员的引用, 但最好是const. 主要原因是当对象的属性与某种业务规则相关联的时候, 其赋值常常与某些其他属性或者对象的状态有关, 因此有必要将赋值操作封装在一个业务规则中. 如果其他对象可以获得该属性的非常量引用(或指针), 那么对该属性的单纯赋值会破坏业务规则的完整性.</li><li>引用和流操作符的重载, 因为这两个操作符常常希望被连续使用, 因此这两个操作符重载时的返回值应该是一个仍然支持操作符特性的流引用</li></ol><p><a href="http://wyude.lofter.com/post/1cb19406_68f16ad" target="_blank" rel="noopener">http://wyude.lofter.com/post/1cb19406_68f16ad</a></p><h1 id="在什么时候需要使用常引用"><a href="#在什么时候需要使用常引用" class="headerlink" title="在什么时候需要使用常引用?"></a>在什么时候需要使用常引用?</h1><p>如果既要利用引用提高程序的效率, 又要保护传递给函数的数据不在函数中被改变, 就应该使用常引用, 同时如果传入的实参是const类型的变量, 则形参必须也声明为const. <strong>通常, 如果引用型参数在能够被定义为const的情况下, 优先定义为const</strong>.</p><h1 id="什么是函数指针"><a href="#什么是函数指针" class="headerlink" title="什么是函数指针?"></a>什么是函数指针?</h1><h1 id="结构体和联合体有什么区别"><a href="#结构体和联合体有什么区别" class="headerlink" title="结构体和联合体有什么区别?"></a>结构体和联合体有什么区别?</h1><ol><li>结构体和联合体都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合体中只存放了一个被选中的成员(所有成员共用一块地址空间), 而结构体的所有成员都存在(不同成员的存放地址不同)</li><li>对于联合体的不同成员赋值, 将会对覆盖其他成员, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的</li></ol><h1 id="重载-overload-和重写-覆盖-override-的区别"><a href="#重载-overload-和重写-覆盖-override-的区别" class="headerlink" title="重载(overload)和重写/覆盖(override)的区别?"></a>重载(overload)和重写/覆盖(override)的区别?</h1><p>从定义上来说:</p><ul><li>重载: 是指允许存在多个同名函数, 但是这些函数的参数签名不同(参数个数, 参数类型, const)</li><li>重写: 是在继承时体现的, 是指子类重新定义父类虚函数的方法, 其中父类函数必须有<code>virtual</code>关键字, 且不能有<code>static</code>, 子类函数与父类函数签名相同, 且返回值也要相同(或者 <strong>返回值协变</strong> ), 访问权限修饰符可以不同.</li></ul><p>从实现原理上来说:</p><ul><li>重载: 编译器会根据函数不同的函数签名, 对这些同名函数的名称做一些修饰, 然后这些同名函数就成了不同的函数(至少对编译器来说是这样的), 这些修饰后的同名函数的调用, 在编译期间就已经确定了, 因此它们的地址也已经确定了, 因此, <strong>重载与多态无关</strong></li><li>重写: 重写与多态息息相关. 当子类重新定义了父类的虚函数以后, 父类指针会根据赋给它的不同的子类指针, <strong>动态</strong> 的调用属于子类的该函数, 这样的函数调用在编译期间是无法确定的(无法给出子类的虚函数的地址). 只有在执行阶段, 子类的函数地址才能够确定.</li></ul><h1 id="C-中的协变与逆变"><a href="#C-中的协变与逆变" class="headerlink" title="C++中的协变与逆变"></a>C++中的协变与逆变</h1><p><a href="https://www.jianshu.com/p/db76a8b08694" target="_blank" rel="noopener">https://www.jianshu.com/p/db76a8b08694</a></p><h1 id="哪些情况下只能用初始化列表-initialization-list-而不能用赋值-assignment"><a href="#哪些情况下只能用初始化列表-initialization-list-而不能用赋值-assignment" class="headerlink" title="哪些情况下只能用初始化列表(initialization list) 而不能用赋值 (assignment)?"></a>哪些情况下只能用初始化列表(initialization list) 而不能用赋值 (assignment)?</h1><p><a href="../Cpp-初始化列表">Cpp-初始化列表</a></p><h1 id="C-是不是类型安全的"><a href="#C-是不是类型安全的" class="headerlink" title="C++是不是类型安全的?"></a>C++是不是类型安全的?</h1><p>不是, 因为两个不同类型的指针之间可以强制转换.</p><h1 id="描述内存分配方式以及它们之间的区别"><a href="#描述内存分配方式以及它们之间的区别" class="headerlink" title="描述内存分配方式以及它们之间的区别?"></a>描述内存分配方式以及它们之间的区别?</h1><ol><li>从静态存储区域分配: 内存在程序 <strong>编译</strong> 时就已经分配好, 这块内存在程序的整个运行期间都一直存在, 例如全局变量, static变量等.</li><li>从栈中分配: 函数内的局部变量的存储单元都会在栈上创建, 函数执行结束时这些存储单元会被自动释放</li><li>从堆中分配: 也称为动态内存. 程序在运行的时候用<code>malloc</code>或<code>new</code>申请任意大小的内存, 程序员自己负责在何时使用和释放这些内存. 动态内存的生存期由程序员自己决定, 使用非常灵活, 但相关的内存泄漏问题也尝尝发生.</li></ol><h1 id="float与0比较时需要注意什么"><a href="#float与0比较时需要注意什么" class="headerlink" title="float与0比较时需要注意什么?"></a>float与0比较时需要注意什么?</h1><p>需要注意精度表示的问题, 不能使用<code>f == 0</code> 而应使用<code>f&lt;0.00001 &amp;&amp; f&gt;0.00001</code>类似的语句.</p><h1 id="const和-define相比-有何优点"><a href="#const和-define相比-有何优点" class="headerlink" title="const和#define相比, 有何优点?"></a>const和#define相比, 有何优点?</h1><ol><li><code>const</code>常量具有数据类型, 而宏常量没有数据类型. 编译器可以对前者进行类型安全检查, 而对后者只会进行字符替换, 没有类型安全检查, 容易发生意想不到的错误.</li><li>有些集成化的调试工具可以对const常量进行调试, 但是不能对宏常量进行调试</li></ol><h1 id="什么情况下会发生运行时错误-runtime-error"><a href="#什么情况下会发生运行时错误-runtime-error" class="headerlink" title="什么情况下会发生运行时错误(runtime error)?"></a>什么情况下会发生运行时错误(runtime error)?</h1><p>数组越界访问, 除数为0 , 堆栈溢出</p><h1 id="数组和指向数组名的指针有什么区别"><a href="#数组和指向数组名的指针有什么区别" class="headerlink" title="数组和指向数组名的指针有什么区别?"></a>数组和指向数组名的指针有什么区别?</h1><p>数组的内存空间要么在静态存储区中(全局数组), 要么在栈中. 而指针可以随时指向任意类型的内存块.</p><p>在使用sizeof运算符时, 数组返回的是整个数组所占的字节数, 指针返回的是指针变量本身的字节数. C++/C 语言没有办法知道指针所指的内存容量, 除非在申请内存时记住它, <strong>注意当数组作为函数的参数进行传递时, 该数组名就会自动退化为同类型的指针, 也就是说此时再使用sizeof时, 返回的是指针变量的大小, 而不是数组大小</strong></p><h1 id="int-a-10-int-表示的是什么"><a href="#int-a-10-int-表示的是什么" class="headerlink" title="int (* a[10])(int) 表示的是什么?"></a>int (* a[10])(int) 表示的是什么?</h1><p>a是一个函数指针数组, 数组中的每个元素都是函数指针, 指向参数和返回值为int的函数.</p><h1 id="栈内存与文字常量区"><a href="#栈内存与文字常量区" class="headerlink" title="栈内存与文字常量区"></a>栈内存与文字常量区</h1><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><ul><li><code>this</code>指针是一个 <strong>隐含于</strong> 每一个非静态成员函数中的特殊指针. 它指向正在被该成员函数操作的那个对象</li><li>当一个对象调用其成员函数时, 编译程序会先将对象的地址赋给<code>this</code>指针, 然后调用成员函数, 每次成员函数存取数据成员时, 会隐含使用<code>this</code>指针.</li><li>当一个成员函数被调用时, 自动向它传递一个隐含的参数, 该参数是一个指向这个成员函数所在的对象的指针</li><li><code>this</code>指针被隐含的声明为: <code>ClassName *const this</code>, 这意味着不能给<code>this</code>指针不能再指向其他对象, 在<code>ClassName</code>类的<code>const</code>成员函数中, <code>this</code>指针的类型为<code>const ClassName* const</code>, 这说明也不能对<code>this</code>指针所指向的这种对象进行赋值操作.</li><li><code>this</code>并不是一个常规变量, 而是一个 <strong>右值</strong>, 所以不能取得<code>this</code>的地址.(不能<code>&amp;this</code>, 左值右值的区别就在于是否可以取地址)</li><li>在以下场景中, 经常需要显式使用<code>this</code>指针:<ul><li>为实现对象的链式引用</li><li>为避免对同一对象进行赋值操作(this.obj = obj, 在构造函数中这种很常用)</li><li>为实现一些数据结构时, 如<code>list</code></li></ul></li></ul><h1 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h1><p>在C/C++中, 如果有一些函数被频繁调用, 那么就会不断的进行函数入栈出栈的操作, 这会造成栈空间以及程序运行时间的消耗. 栈空间就是指放置程序的局部数据以及函数内数据的内存空间, 在正常情况下, 栈空间都是有限的, 如果频繁大量的使用就会造成栈空间不足的问题, <strong>函数的死循环递归调用的最终结果就是导致占内存空间的枯竭</strong></p><p><strong>特征:</strong></p><ul><li>相当于把内联函数里面的内容直接写在了调用内联函数处 (类似于<code>#define</code>或者<code>typedef</code>的那种<code>替换</code>操作)</li><li>相当于不用执行进入函数的步骤, 直接执行函数体</li><li>相当于 <strong>宏</strong>, 却比宏多了类型检查, 真正具有函数特性(这也是与<code>#define</code>的区别所在)</li><li><strong>在类声明中定义的函数, 除了虚函数的其他函数都会自动隐式的成为内联函数</strong></li><li><strong>关键字<code>inline</code>必须与函数定义体放在一起才能使函数成为内联, 仅将inline放在函数声明前不起任何作用</strong></li><li>与非内联函数不同的是, <code>inline</code>函数必须在调用该函数的每个文本文件中定义. 当然, 对于同一程序的不同文件, 如果<code>inline</code>函数出现的话,其定义必须相同.</li></ul><p><strong>优点:</strong></p><ul><li>内敛函数会像宏函数一样在被调用处展开, 省去了参数压栈, 栈帧开辟, 结构返回等步骤, 从而提高了程序的运行速度</li><li>内联函数相比宏函数来说, 在代码展开处会做安全检查和类型转换(同普通函数), 而宏定义函数则不会</li><li>在类声明中同时定义的成员函数, 会自动转化为内联函数, 因此 <strong>内联函数可以访问类的成员变量</strong>, 宏定义则不能.</li><li>内联函数在运行时可以调试, 而宏定义则不行(因为宏定义是被预定义处理的, 所以不会有人黑的编译符号和调试信息, 调试的时候基本只能用肉眼去看)</li></ul><p><strong>缺点:</strong></p><ul><li>代码膨胀. 内联函数是以代码膨胀(复制)为代价, 消除函数调用带来的开销. 如果执行函数体内代码的时间, 相比于函数调用的开销较大, 那么效率的收获就会很少. 另一方面, 每一处内联函数的调用都要复制代码, 将使程序的总代码量增大, 消耗更多的内存空间.</li><li><code>inline</code>函数无法随着函数库升级而升级. <code>inline</code>函数的改变需要重新编译, 不像非内联函数那样可以直接链接</li><li>是否内联, 程序员不可控, 内联函数只是对编译器的建议, 对于最终实现的决定权在于编译器.</li></ul><p><strong>虚函数可以是内联函数吗</strong></p><ul><li><p>虚函数在语法上可以是内联函数, 内联是可以修饰虚函数的, 但是当虚函数表现多态性的时候是不能内联的. (在具体实现时, 到底是否内联, 是由编译器决定的), 如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"Base::Foo()\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"Derived::Foo()\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Base* b = <span class="keyword">new</span> Derived; <span class="comment">// 非 static 令编译器不能在编译期知道 b 指向那个类型的对像</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    b-&gt;Foo();       <span class="comment">// 不可能内联</span></span><br><span class="line">    b-&gt;Base::Foo(); <span class="comment">// 非多态调用，可以内联（但具体是否内联由编译器决定）</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内联实际上是在建议编译器内联, 而虚函数的多态性需要在运行期起作用, 编译器无法知道运行期具体调用哪个代码, 因此虚函数表现为多态性时, 不可以内联</p></li><li><code>inline virtual</code> 唯一可以内联的时候是: 编译器知道所调用的对象是哪个类(如 Base::who()), 这只有在编译器具有 <strong>实际对象而不是对象的指针或引用时才会发生</strong>.</li></ul><h1 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h1><p>用<code>explicit</code>关键字修饰的构造函数可以用来防止函数参数的隐式转换</p><p><strong><code>explicit</code>关键字只能用于类内部的构造函数的声明上, 而不能用在类外部的函数定义上</strong></p><p>Effective C++建议, 除非有一个好的理由允许构造函数被用于隐式类型转换, 否则应该将其声明为<code>explicit</code>.</p><h1 id="友元类和友元函数"><a href="#友元类和友元函数" class="headerlink" title="友元类和友元函数"></a>友元类和友元函数</h1><ul><li>能访问私有成员</li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h1 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h1><ul><li>全局作用域符(<code>::name</code>): 用于名称(类, 类成员, 成员函数, 变量等)前, 表示作用域为全局命名空间</li><li>类作用域符(<code>class::name</code>): 用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符(<code>namespace::name</code>): 用于表示指定类型的作用域范围是具体某个命名空间的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">//全局(::)的count</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">20</span>; <span class="comment">//局部的count</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;::count; <span class="comment">// 输出 10, std为命名空间</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;count; <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode算法题(Medium)</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-LeetCode-2/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-LeetCode-2/</url>
      
        <content type="html"><![CDATA[<h1 id="002-Add-Two-Numbers"><a href="#002-Add-Two-Numbers" class="headerlink" title="002. Add Two Numbers"></a>002. Add Two Numbers</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example:</p><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p><h2 id="解法一-顺序相加-注意进位"><a href="#解法一-顺序相加-注意进位" class="headerlink" title="解法一: 顺序相加, 注意进位"></a>解法一: 顺序相加, 注意进位</h2><p>从链表的第一个节点开始, 将两个节点的值和进位位想加, 如果大于10, 则当前结果节点的值对10取余, 同时将进位位置1, 如果小于10, 则直接赋值给当前结果节点, 同时将进位位置0.</p><p>特别注意l1和l2的长度问题, 当二者节点遇到nullptr时, 将较长的剩余部分重新赋给l1, 并继续判断</p><p>最后, 需要注意是否有进位位, 如果有, 则要申请一个新节点, 并将其置为1</p><p>时间复杂度: $O(\max(m,n))$</p><p>空间复杂度: $O(1)$  (这种做法会破坏原有链的结构)</p><p>空间复杂度: $O(\max(m,n))$  (这种做法需要额外申请空间, 但不会破坏原有链的结构)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//创建指向最终结果的头指针</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>)  head-&gt;next = l1; <span class="comment">// 虽然题目指明为非空链表, 但是最好还是做一下判断</span></span><br><span class="line">        <span class="keyword">else</span> head-&gt;next = l2;</span><br><span class="line">        ListNode* pre=head; <span class="comment">// pre用于保存l1的上一个指针</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            l1-&gt;val = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next; l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>)&#123; <span class="comment">// 此时说明l2比l1长, 用l1的上一个指针指向当前l2剩余的部分,</span></span><br><span class="line">            l1 = pre;</span><br><span class="line">            l1-&gt;next =  l2;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>)&#123;  <span class="comment">// 此时l1为剩余(l1或l2) 的部分,  只需要考虑是否有进位即可</span></span><br><span class="line">            l1-&gt;val = l1-&gt;val + carry;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;  <span class="comment">// 如果没有进位, 一定要将此处置0, 否则会引起错误</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;  <span class="comment">// 对应 999 + 001 的特殊情况,  此时进位会不断传递, 最终数字位数加1, 最高位为1</span></span><br><span class="line">            ListNode* newnode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            l1 = pre;</span><br><span class="line">            l1-&gt;next = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>What if the the digits in the linked list are stored in non-reversed order? For example:</p><p>$(3 \to 4 \to 2) + (4 \to 6 \to 5) = 8 \to 0 \to 7 (3→4→2)+(4→6→5)=8→0→7$</p><p>思路:</p><p>先将链表转置 , 再用上面的方法求解</p><p>转置时间复杂度: $O(n)$<br>转置空间复杂度: $O(1)$</p><h1 id="003-Longest-Substring-Without-Repeating-Characters"><a href="#003-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="003. Longest Substring Without Repeating Characters"></a>003. Longest Substring Without Repeating Characters</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Example 1:</p><p>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3.<br>Example 2:</p><p>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.<br>Example 3:</p><p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><h2 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一:暴力"></a>解法一:暴力</h2><p>时间复杂度: $O(n^3)$ 对于每一个字符, 子串的添加以及查重过程时间复杂度为 $O(n^2)$ , 总共n个字符, 所以为 $O(n^3)$</p><p>时间复杂度: $O(min(n,m))$ 需要将当前子串存在起来以便查询是否相等, n为字符串length, m为字符集size</p><h2 id="解法二-前后两个指示变量"><a href="#解法二-前后两个指示变量" class="headerlink" title="解法二: 前后两个指示变量"></a>解法二: 前后两个指示变量</h2><p>思路: 首先构造一个哈希表, 用来存储当前子串中出现的字符, 这样, 新来的字符可以直接查询哈希表来判断字符是否存在, 构建哈希表空间复杂度为 <script type="math/tex">O(min(n,m))</script> (m为字符集合的大小,一般为26(字母), 128(ASCII), 256(ASCII))</p><p>然后, 使用两个指示变量, 分别指向当前未重复子串的首字符, 和超尾字符, 进行如下几个判断:</p><ul><li>如果超尾字符与当前子串中的字符不重复, 那么将超尾字符加入到当前子串中,并将length加1</li><li>如果超尾字符与当前子串中的字符重复, 利用哈希表查的重复字符的所在位置, 将当前子串的首字符直接跳向该重复字符的下一个位置( <strong>这样可以保证只遍历一遍</strong> ), 并将包括重复字符在内的之前所有字符都从哈希表中删除(之前的字符不再可能组成更长的子串了), 同时将超尾字符加入, length赋予新值: 超尾位置-重复位置-1;</li><li>判断首字符与超尾字符是否相等, 如果相等, 将超尾字符加1, 并将length置为1</li><li>看当前length是否比maxlength大, 并重复以上过程,直到超尾字符超出size</li></ul><p>时间复杂度: $O(n)$<br>空间复杂度: $O(min(n,m))$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; ch_exists;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        ch_exists.insert(&#123;s[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>,j = <span class="number">1</span> ; j &lt; s.size() ; )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ch_exists.count(s[j]) == <span class="number">0</span> )&#123; <span class="comment">// j对应的字母未重复, length增加</span></span><br><span class="line">                length++;</span><br><span class="line">                ch_exists.insert(&#123;s[j], j&#125;);</span><br><span class="line"></span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// j对应的字母重复, 将i置于重复字母的下一个(因为之前都都不可能产生更长的未重复子串了)</span></span><br><span class="line">                <span class="keyword">int</span> index = ch_exists[s[j]];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= index; k++)</span><br><span class="line">                    ch_exists.erase(s[k]);</span><br><span class="line">                i=index + <span class="number">1</span>;</span><br><span class="line">                ch_exists.insert(&#123;s[i], i&#125;);</span><br><span class="line">                length = j - index - <span class="number">1</span>;                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i==j)&#123; <span class="comment">//这里如果写在开头, j++之后有可能超过size, 导致有问题,</span></span><br><span class="line">                <span class="comment">//所以写在后面, 以便在for循环中检查j是否超过size</span></span><br><span class="line">                j++;</span><br><span class="line">                length = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(length &gt; max_length)</span><br><span class="line">                max_length = length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二的另一种写法"><a href="#解法二的另一种写法" class="headerlink" title="解法二的另一种写法"></a>解法二的另一种写法</h2><p>该写法核心思路与上面的一样, 所以时间复杂度和空间复杂度也一样, 唯一不同的是hash表, 前面的会将i与重复字符之间的都删除, 这里不删除, 利用max控制, 使i永远不会倒退</p><p><strong>这里写法更加简洁, 应值得学习</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; s_hash;      </span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ,j=<span class="number">0</span> ; j&lt; s.size() ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_hash.count(s[j]))&#123;</span><br><span class="line">                i = max(i,s_hash[s[j]]+<span class="number">1</span>); <span class="comment">//如果遇到重复的, 就将当前的i指向重复的下一个</span></span><br><span class="line">                <span class="comment">// (这里用max的原因是, 没有删除当前i到重复字符之间的其他字符, 这些字符</span></span><br><span class="line">                <span class="comment">//  后续还可能被检测到,  所以这里只取max的, 也就是i不会倒退)</span></span><br><span class="line">                s_hash.erase(s[j]); <span class="comment">// 将重复的删除, 以便赋予新的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            s_hash.insert(&#123;s[j], j&#125;);</span><br><span class="line">            max_length = max_length &gt; (j-i+<span class="number">1</span>) ? max_length : (j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="005-Longest-Palindromic-Substring-最大回文子串"><a href="#005-Longest-Palindromic-Substring-最大回文子串" class="headerlink" title="005. Longest Palindromic Substring(最大回文子串)"></a>005. Longest Palindromic Substring(最大回文子串)</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:</p><p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.<br>Example 2:</p><p>Input: “cbbd”<br>Output: “bb”</p><h2 id="解法一：最长公共子串"><a href="#解法一：最长公共子串" class="headerlink" title="解法一：最长公共子串"></a>解法一：最长公共子串</h2><p>$O(n^2)$</p><p>$O(n)$</p><h2 id="解法二：-穷举"><a href="#解法二：-穷举" class="headerlink" title="解法二： 穷举"></a>解法二： 穷举</h2><p>$O(n^3)$</p><p>$O(1)$</p><h2 id="解法三：-动态规划"><a href="#解法三：-动态规划" class="headerlink" title="解法三： 动态规划"></a>解法三： 动态规划</h2><p>？</p><h2 id="解法三：-扩展中心法"><a href="#解法三：-扩展中心法" class="headerlink" title="解法三： 扩展中心法"></a>解法三： 扩展中心法</h2><p>以每一个字符为中心， 向两边扩展， 将当前能够扩展的长度 len 和最大扩展长度 max_len 作比较, 记录较大者, 同时记录较大者的所对应的重心字符的下标 max_index. 最后, 根据最大扩展的长度max_len 和中心字符的下标 max_index 计算最大回文子串的开始位置和总长度</p><p>此处注意, 回文子串有奇偶两种情况, 可采用以下举措之一解决:</p><ul><li>分别检查奇数和偶数的情况</li><li>向字符内插入特殊符号 ‘#’, 这样不管偶数奇数, 都可以当做奇数处理, 缺点是占用了额外的 $O(n)$ 空间</li></ul><p>时间复杂度: $O(n^2)$</p><p>空间复杂度: $O(1)$ 或者 $O(n)$</p><p>注意: 既然已经使用了空间复杂度为 $O(n)$ 的方法, 实际上更应该将其该写成马拉车算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(1)$</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> left=i, right = i;  <span class="comment">//通过left和right , 是的对奇偶的分别处理更方便</span></span><br><span class="line">            <span class="keyword">while</span>( left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len1 = right-left<span class="number">-1</span>; <span class="comment">// 注意, 这里一定是-1, 而不是+1</span></span><br><span class="line"></span><br><span class="line">            left=i;</span><br><span class="line">            right=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len2 = right-left<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;max_len)&#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                start = i- (len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(n)$</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>*  cs = <span class="keyword">new</span> <span class="keyword">char</span>[s.size() * <span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        cs[<span class="number">0</span>]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size() ; i++)&#123; <span class="comment">//插入 '#'</span></span><br><span class="line">            cs[i*<span class="number">2</span>+<span class="number">1</span>] = s[i];</span><br><span class="line">            cs[i*<span class="number">2</span>+<span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size()*<span class="number">2</span>+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>; <span class="comment">//记录当前扩展长度len</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i-j&gt;=<span class="number">0</span> &amp;&amp; i+j&lt;s.size()*<span class="number">2</span>+<span class="number">1</span> ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cs[i-j] == cs[i+j])&#123; <span class="comment">//两边字符若相等, 则len长度增1</span></span><br><span class="line">                    len++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; max_len)&#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = (max_index - max_len)/<span class="number">2</span>;  <span class="comment">//根据maxlen和index 计算回文子串开始坐标</span></span><br><span class="line">        <span class="keyword">int</span> len = max_len;</span><br><span class="line">        <span class="keyword">delete</span> cs;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法五-马拉车-Manacher-算法"><a href="#解法五-马拉车-Manacher-算法" class="headerlink" title="解法五: 马拉车(Manacher) 算法"></a>解法五: 马拉车(Manacher) 算法</h2><p>时间复杂度: $O(n)$<br>空间复杂度: $O(n)$</p><p>There is even an O(n)O(n) algorithm called Manacher’s algorithm, explained here in detail. However, it is a non-trivial algorithm, and no one expects you to come up with this algorithm in a 45 minutes coding session. But, please go ahead and understand it, I promise it will be a lot of fun</p><p>马拉车算法的核心思想还是从中心扩展发出发, 不过他必须使用 ‘#’ 字符先对原始字符串插入, 如下所示:</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg" alt=""></p><p>接下来, 在每一次for循环当中, 都需要保存这么几个值(命名是个人习惯, 可以用其他名字代替):</p><ul><li>P: P为最大右边界下标值, 对应的是所有已检测的回文子串中, 右边界下标最大的那个</li><li>P_center: 该值是P对应的回文子串的中心下标</li><li>max_len: 对应当前最大回文子串的半径(aba的半径为1, a的半径为0)</li><li>max_index: 对应当前最大回文子串的中心下标</li></ul><p>然后, 还需要构建一个和插入’#’后的字符串长度相关的数组<code>p_len</code>, 里面存放着对应位置的回文串半径, 用以后续的计算, 这一步是关键, 有了这个数组 ,才能实现利用之前计算结果</p><p>接下来, 遍历 “新字符串”(即插入’#’之后的字符串) 的每一个字符, 设当前下标为 i, 则有如下情况, 分别处理:</p><ul><li>P&gt;i, 说明 i 在 P 的范围内, 可以利用前面的计算结果</li><li>P&lt;=i, 说明i不在 P 的范围内, 无法利用前面的计算结果, 只能逐个判断</li></ul><p>对上面两种情况具体分析如下:</p><p>第一种情况: P&gt;i</p><p>找到i相对于 P_center 的对称位置，设为j，那么如果Len[j]&lt;P-i, 如下图所示:</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1ft6j20hd08kzki.jpg" alt=""></p><p> 则以i为中心的回文串的长度至少和以j为中心的回文串一样 , 即Len [i]&gt;=Len[j] , 因此可以直接从Len[j]+1开始判断回文</p><p>如果Len[j]&gt;=P-i, 如下图所示:</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1afaj20ge08dwep.jpg" alt=""></p><p>由对称性，说明以i为中心的回文串可能会延伸到P之外，而大于P的部分我们还没有进行匹配，所以要从P+1位置开始一个一个进行匹配，直到发生失配</p><p>第二种情况: P&lt;=i</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1khnj20ie06b3yh.jpg" alt=""></p><p>如果i比P还要大，说明对于中点为i的回文串还一点都没有匹配，这个时候，就只能老老实实地一个一个匹配了</p><p>在这一次循环完成之前, 更新上面提及的四个变量</p><p>循环结束后, 根据 max_index 和 max_len 的值返回最长回文子串</p><p>时间复杂度分析:</p><p>对于每一个字符, 由于如果之间比较过, 那么就可以利用之前比较的结果直接判断, 所以每个字符都只进行了一次比较, 故而时间复杂度为 $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cs_size = s.size()*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* cs = <span class="keyword">new</span> <span class="keyword">char</span>[cs_size];</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size(); i++)&#123;</span><br><span class="line">            cs[i*<span class="number">2</span> + <span class="number">1</span>] = s[i];</span><br><span class="line">            cs[i*<span class="number">2</span> + <span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> P = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> P_center = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>* p_len = <span class="keyword">new</span> <span class="keyword">int</span>[cs_size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;cs_size; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i &lt; P)&#123; <span class="comment">// 如果i&lt;P, 说明可以复用前面的计算结果</span></span><br><span class="line">                <span class="keyword">int</span> j = P_center*<span class="number">2</span> - i; <span class="comment">// j对i关于P_center的对称点</span></span><br><span class="line">                <span class="keyword">if</span>(P-i &gt; p_len[j])&#123; <span class="comment">// 如果i与P之间的距离比 j 的回文串长度还大,</span></span><br><span class="line">                    <span class="comment">//说明可以直接从p_len[j] + 1开始比较, 之前的子串一定是回文串</span></span><br><span class="line">                    <span class="keyword">int</span> k = p_len[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果距离没有p_len[j] + 1大, 则从超出P的部分开始比较</span></span><br><span class="line">                    <span class="keyword">int</span> k = P - i;</span><br><span class="line">                    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果i不在P范围内, 则必须从1开始逐个比较, 无法利用之前的计算结果</span></span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p_len[i] &gt; max_len)&#123;</span><br><span class="line">                max_len = p_len[i];</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+p_len[i] &gt; P)&#123;</span><br><span class="line">                P = i+p_len[i];</span><br><span class="line">                P_center = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> cs;</span><br><span class="line">        <span class="keyword">delete</span> p_len;</span><br><span class="line">        <span class="keyword">int</span> start = (max_index - max_len)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len = max_len;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="008"><a href="#008" class="headerlink" title="008."></a>008.</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>此题时间复杂度为 $O(n)$ , 重点考察是否考虑的全面, 主要有以下几种情况, 缺一不可:</p><ul><li>+123 dd   // 返回123</li><li>+123d   // 返回123</li><li>d-123  // 返回0</li><li>-123+ //返回-123</li><li>-123+4 // 返回-123</li><li>323123423423423 // 返回INT_MAX</li><li>-1231238923894234 // 返回INT_MIN</li><li>1234-5 // 返回1234</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_first = <span class="literal">true</span>; <span class="comment">//记录当前非数字字符是否是第一个非空格字符, 如果是, 返回0</span></span><br><span class="line">        <span class="keyword">bool</span> has_sign = <span class="literal">false</span>; <span class="comment">// 记录正负号的出现次数, 出现多于1次的, 返回0</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;  <span class="comment">//记录当前的int值, 要出现int范围, 返回对应的INT</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;str.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span> &amp;&amp; is_first) <span class="keyword">continue</span>; <span class="comment">// 空格, 且没有出现任何非空格字符(如出现了, 则空格也会跟着变成循环停止的标志)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( !has_sign &amp;&amp; (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) )&#123; <span class="comment">// 判断符号</span></span><br><span class="line">                has_sign = <span class="literal">true</span>;</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                sign = str[i]==<span class="string">'+'</span> ? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt;= <span class="string">'9'</span> &amp;&amp; str[i] &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">                has_sign = <span class="literal">true</span>;</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                res = res*<span class="number">10</span> + <span class="keyword">int</span>(str[i] - <span class="string">'0'</span>) * sign; <span class="comment">// 数字累加, 注意这里使用了sign, 因此无需在后面判断正负, 直接加就可以</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> INT_MAX; <span class="comment">// 超限</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(is_first)&#123;  <span class="comment">//首字符为非法字符, 返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="011-Container-With-Most-Water"><a href="#011-Container-With-Most-Water" class="headerlink" title="011. Container With Most Water"></a>011. Container With Most Water</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p><p>The below vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw0kh84zz9j20gh085dg5.jpg" alt=""></p><h2 id="解法一-暴力-1"><a href="#解法一-暴力-1" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p>时间复杂度: $O(n^2)$</p><p>用max_area标记当前最大容器的取值, 然后两个for循环遍历所有容器的可能取值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max_area &lt; min( height[i],height[j] ) * (j-i))&#123;</span><br><span class="line">                    max_area = min( height[i],height[j] ) * (j-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-用两个指针"><a href="#解法二-用两个指针" class="headerlink" title="解法二: 用两个指针"></a>解法二: 用两个指针</h2><p>时间复杂度: $O(n)$</p><p>分别用两个指针指向数组的第一个元素和最后一个元素, 并计算当前的area, 然后移动指针元素值较小的一方, 移动过程中更新max_area的值</p><p>原理:</p><p>首先假设容器可以具有最大长度的宽, 也就是分别指向首尾元素,  这时候 , 我们想查看是否还有比当前最大容积更大的容器,  那么, 我们必须维持较高的垂直边不动, 而将较低的垂直边移动, 因为只有这样, 我们才 <strong>有可能</strong> (注意不是一定)获得比当前容积更大的容器, 这个时候虽然宽变小了, 但是高度却可能增加(因为新增的边有可能大于当前较低边的高).  如果移动较高的边, 那么新增的边由于受到当前较低边的作用, 只有可能减小容器的面积</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = min( height[low], height[high] ) * (high-low);</span><br><span class="line">            <span class="keyword">if</span>(max_area &lt; area)&#123;</span><br><span class="line">                max_area = area;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[low] &lt; height[high])</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="015-3Sum"><a href="#015-3Sum" class="headerlink" title="015. 3Sum"></a>015. 3Sum</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-固定一个数-按照two-sum的方式来解"><a href="#解法一-固定一个数-按照two-sum的方式来解" class="headerlink" title="解法一: 固定一个数, 按照two sum的方式来解"></a>解法一: 固定一个数, 按照two sum的方式来解</h2><p>因为不能包含重复的元祖, 因此不能直接固定然后用two sum 的方式求解, 首先要对数组进行排序, 然后从第一个开始逐个判断, 期间要去除重复的元组</p><p>时间复杂度: $O(n^2)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[low] != nums[(low+high)/<span class="number">2</span>])&#123; <span class="comment">// 注意这里用异或交换的陷阱</span></span><br><span class="line">            nums[low] = nums[low] + nums[(low+high)/<span class="number">2</span>];</span><br><span class="line">            nums[(low+high)/<span class="number">2</span>] = nums[low] - nums[(low+high)/<span class="number">2</span>];</span><br><span class="line">            nums[low] = nums[low] - nums[(low+high)/<span class="number">2</span>];      </span><br><span class="line">        &#125; <span class="comment">// 主要是将中将的数字和首位交换, 个人觉得可有可无, 因为时间复杂度是一样的</span></span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&lt;=nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&gt;=nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low&lt;mid ) quickSort(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) quickSort(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//剪枝, 如果当前数字为正, 那么后面就不可能再有符合条件的三元组, 可以提前退出</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] ) <span class="keyword">continue</span>; <span class="comment">//去除重复, 遇到除第一个外相同的三元组最小的数字, 则跳过</span></span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="keyword">if</span>(low&gt;i+<span class="number">1</span> &amp;&amp; nums[low] == nums[low<span class="number">-1</span>])&#123; <span class="comment">// 仍然是去除重复,</span></span><br><span class="line">                    low++; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[low] + nums[i] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;<span class="number">0</span>) high--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) low++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp&#123;nums[low], nums[i], nums[high]&#125;;</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                    low++;  <span class="comment">// 这一点千万别漏了, 要继续判断, 因为以当前数字开始的三元组可能不止一个</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更好的写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">2</span>)<span class="keyword">return</span> result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; a == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> j = i + <span class="number">1</span>, k = nums.size() - <span class="number">1</span>; j &lt; k;) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="keyword">int</span> c = nums[k];</span><br><span class="line">                <span class="keyword">int</span> value = a + b + c;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">                    result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;a, b, c&#125;));</span><br><span class="line">                    <span class="keyword">while</span> (j&lt;k &amp;&amp; b == nums[++j]); <span class="comment">// 主要是这里的写法很优雅, 其他地方和上面差不多</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp;c == nums[--k]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="017-Letter-Combinations-of-a-Phone-Number"><a href="#017-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="017. Letter Combinations of a Phone Number"></a>017. Letter Combinations of a Phone Number</h1><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h3><p>时间复杂度: $O(n*4^n)$</p><p>空间复杂度: $O(4^n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_tracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; digit_letters, <span class="built_in">string</span>&amp; tmp,<span class="built_in">string</span> digits, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.size())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;digit_letters[digits[index]-<span class="string">'0'</span>].size(); i++)&#123;</span><br><span class="line">                tmp.push_back(digit_letters[digits[index]-<span class="string">'0'</span>][i]);</span><br><span class="line">                back_tracking(res, digit_letters, tmp, digits, index+<span class="number">1</span>);</span><br><span class="line">                tmp.pop_back();<span class="comment">// 移除当前末尾元素, 以便可以加下一个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() &lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//res.push_back(""); //对res向量初始化,以便开始, 如果不初始化, 则size为0,后面的循环无法进行</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digit_letters&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,</span><br><span class="line">                      <span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">        back_tracking(res, digit_letters, tmp, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二-非递归"><a href="#解法二-非递归" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h3><p>时间复杂度: $O(n*4^n)$</p><p>空间复杂度: $O(4^n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() &lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(<span class="string">""</span>); <span class="comment">//对res向量初始化,以便开始, 如果不初始化, 则size为0,后面的循环无法进行</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digit_letters&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,</span><br><span class="line">                                          <span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;digits.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = digits[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(digit_letters[num] == <span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp; <span class="comment">// 申请一个临时vector, 用于存放加上当前数字字符的string集合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; digit_letters[num].size(); k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l =<span class="number">0</span>; l &lt; res.size(); l++)&#123;</span><br><span class="line">                    tmp.push_back(res[l]+digit_letters[num][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.swap(tmp); <span class="comment">// 将res于tmp交换, swap仅仅是改变指针, 比'='更快, 因为'='包含了复制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="解法一-利用reduce实现"><a href="#解法一-利用reduce实现" class="headerlink" title="解法一: 利用reduce实现"></a>解法一: 利用reduce实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> digits==<span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        digit_letters = &#123;<span class="string">'0'</span>:<span class="string">""</span>, <span class="string">'1'</span>:<span class="string">""</span>, <span class="string">'2'</span>:<span class="string">"abc"</span>,</span><br><span class="line">                        <span class="string">'3'</span>:<span class="string">"def"</span>, <span class="string">'4'</span>:<span class="string">"ghi"</span>, <span class="string">'5'</span>:<span class="string">"jkl"</span>,</span><br><span class="line">                        <span class="string">'6'</span>:<span class="string">"mno"</span>, <span class="string">'7'</span>:<span class="string">"pqrs"</span>, <span class="string">'8'</span>:<span class="string">"tuv"</span>, <span class="string">'9'</span>:<span class="string">"wxyz"</span>&#125;</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="comment"># 在python3中, reduce()函数已经从全局命名空间移除, 现在存在于functools模块中,使用时需要导入</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> res,digit:[x+y <span class="keyword">for</span> x <span class="keyword">in</span> res <span class="keyword">for</span> y <span class="keyword">in</span> digit_letters[digit]], digits, [<span class="string">""</span>])</span><br></pre></td></tr></table></figure><h1 id="019-Remove-Nth-Node-From-End-of-List"><a href="#019-Remove-Nth-Node-From-End-of-List" class="headerlink" title="019. Remove Nth Node From End of List"></a>019. Remove Nth Node From End of List</h1><h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, remove the n-th node from the end of list and return its head.</p><p>Example:</p><p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p><p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p><h2 id="解法一-遍历两次"><a href="#解法一-遍历两次" class="headerlink" title="解法一: 遍历两次"></a>解法一: 遍历两次</h2><p>第一次遍历求出链表长度, 第二次遍历在对应位置删除节点</p><h2 id="只遍历一次"><a href="#只遍历一次" class="headerlink" title="只遍历一次"></a>只遍历一次</h2><p>时间复杂度: $O(n)$ 且只遍历一次</p><p>空间复杂度: $O(1)$</p><p>维护两个指针, 两指针之间的距离刚好相差n, 当第二个指针到达链表尾部时, 第一个指针刚好指向倒数第n个节点, 直接删除该节点即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">//链表为空, 或者n&lt;=0时, 直接返回head</span></span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(second == <span class="literal">nullptr</span>)&#123; <span class="comment">//对于 n&gt;=链表长度时的特殊判断和处理</span></span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是有一种写法, 新申请了一个节点空间, 用于指向head节点, 可以使代码看起来更容易理解, 对边界条件的判断也更加方便</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">//链表为空, 或者n&lt;=0时, 直接返回head</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* first = dummy;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(second == <span class="literal">nullptr</span>) <span class="keyword">return</span> dummy-&gt;next;<span class="comment">// n超出了链表的长度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="022-Generate-Parentheses"><a href="#022-Generate-Parentheses" class="headerlink" title="022. Generate Parentheses"></a>022. Generate Parentheses</h1><h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-暴力-2"><a href="#解法一-暴力-2" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p>先求出所有可能性, 然后验证每一种可能性是否正确</p><h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><p>有关递归的时间空间复杂度分析起来都不太容易, 这里只上答案(//TODO 具体怎么来没搞懂)</p><p>时间复杂度: $O(\frac{4^n}{\sqrt n}$</p><p>空间复杂度: $O(\frac{4^n}{\sqrt n}$ 以及 $O(n)$ 的空间来存储组合序列</p><p>考虑合法括号组合的规律: 必须首先出现左括号, 然后才能出现右括号, 如果当前的string里面的右括号数量大于左括号数量, 那么就一定会出现<code>)(</code>这种不匹配的情况.</p><p>核心思路: 从头开始构建组合, 每次接入一个字符, 接入的字符只有两种可能性, 即左括号或者右括号, 而一旦接入的字符使得当前字符中右括号数量大于左括号, 就会变得不合法组合,其它均为合法. 根据此性质, 进行如下递归:</p><p>维护两个变量left_rest, right_rest分别代表 <strong>剩余</strong> 可以添加的括号的 <strong>数量</strong>. 采用递归算法, 每次添加一个 ‘(‘ 或者一个 ‘)’, 添加时需要考虑下面几种情况:</p><ul><li>为了保证当前string内左括号数量多于右括号数量, left_rest一定要小于right_rest</li><li>如果<code>left_rest = right_rest = 0</code>, 则说明此时没有可以添加的括号了,</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="built_in">string</span> out, <span class="keyword">int</span> left_rest, <span class="keyword">int</span> right_rest)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if(left_rest &gt; right_rest) return;</span></span><br><span class="line">        <span class="keyword">if</span>(left_rest == <span class="number">0</span> &amp;&amp; right_rest ==<span class="number">0</span>) res.push_back(out);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left_rest&gt;<span class="number">0</span>) helper(res, out+<span class="string">'('</span>, left_rest<span class="number">-1</span>, right_rest);</span><br><span class="line">            <span class="keyword">if</span>(right_rest&gt;<span class="number">0</span> &amp;&amp; right_rest &gt; left_rest) helper(res, out+<span class="string">')'</span>, left_rest, right_rest<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-用栈来模拟递归"><a href="#解法三-用栈来模拟递归" class="headerlink" title="解法三: 用栈来模拟递归"></a>解法三: 用栈来模拟递归</h2><p>首先是最厚的括号包裹状态，即一开始左边是连续的左括号，右边是连续的右括号，然后执行以下逻辑：<br>1、右括号不能比左括号多；<br>2、弹出右括号，直到遇到第一个左括号，如果左括号改成右括号仍然合法，则把它改成右括号；否则，左括号继续弹出；<br>3、改完之后一个劲加左括号，直到所有可以用的左括号都加完为止。<br>4、循环一直执行到不能弹出括号为止, 即直到栈为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> par_s;</span><br><span class="line">        <span class="keyword">int</span> left_rest = n, right_rest = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意, 这里如果把'left_rest--' 写在while判断里</span></span><br><span class="line">        <span class="comment">//会导致循环结束后的left_rest值为-1, 后面的同理</span></span><br><span class="line">        <span class="comment">//while(left_rest--) par_s.push_back('(');</span></span><br><span class="line">        <span class="keyword">while</span>(left_rest)&#123;</span><br><span class="line">            par_s.push_back(<span class="string">'('</span>);</span><br><span class="line">            left_rest--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right_rest) &#123;</span><br><span class="line">            par_s.push_back(<span class="string">')'</span>);</span><br><span class="line">            right_rest--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(par_s);</span><br><span class="line">        <span class="keyword">while</span>(par_s.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur_c = par_s.back(); par_s.pop_back();</span><br><span class="line">            <span class="keyword">if</span>(cur_c == <span class="string">')'</span>)&#123;</span><br><span class="line">                right_rest++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left_rest++;</span><br><span class="line">            <span class="keyword">if</span>(left_rest &lt; right_rest)&#123;</span><br><span class="line">                par_s.push_back(<span class="string">')'</span>);</span><br><span class="line">                right_rest--;</span><br><span class="line">                <span class="keyword">while</span>(left_rest)&#123;</span><br><span class="line">                    par_s.push_back(<span class="string">'('</span>);</span><br><span class="line">                    left_rest--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(right_rest) &#123;</span><br><span class="line">                    par_s.push_back(<span class="string">')'</span>);</span><br><span class="line">                    right_rest--;</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(par_s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="029-Divide-Two-Integers"><a href="#029-Divide-Two-Integers" class="headerlink" title="029. Divide Two Integers"></a>029. Divide Two Integers</h1><h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-循环加法"><a href="#解法一-循环加法" class="headerlink" title="解法一: 循环加法"></a>解法一: 循环加法</h2><p><strong>时间复杂度:</strong> $O(dividend)$</p><p>这种方法很容易时间超限: 当被除数很大(INT_MAX), 除数很小(1), 则需要循环INT_MAX次才能完成计算.</p><h2 id="解法二-左移法"><a href="#解法二-左移法" class="headerlink" title="解法二: 左移法"></a>解法二: 左移法</h2><p><strong>时间复杂度:</strong> $O(log(dividend))$</p><p>对除数进行左移, 相当于每次乘以2, 直到左移后大于被除数, 用被除数减去左移后的数字, 记录左移对应除数的倍数, 然后再次将从除数开始左移, 直到被除数小于除数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">0</span> || (dividend==INT_MIN&amp;&amp;divisor==<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend&lt;<span class="number">0</span>) ^ (divisor&lt;<span class="number">0</span>)) ? <span class="number">-1</span>:<span class="number">1</span>;<span class="comment">// 用异或来获取符号</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> did = <span class="built_in">labs</span>(dividend); <span class="comment">// long与int在有些环境中字节中一样, 所以最好用long long</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dis = <span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">while</span>(did &gt;= dis)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> temp = dis, multiple = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( did &gt;= temp&lt;&lt;<span class="number">1</span> )&#123;</span><br><span class="line">                temp = temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                multiple = multiple&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            did -= temp;</span><br><span class="line">            res+= multiple;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扩展-这道题如果不允许使用long-或者long-long-怎么解"><a href="#扩展-这道题如果不允许使用long-或者long-long-怎么解" class="headerlink" title="扩展: 这道题如果不允许使用long 或者long long 怎么解?"></a>扩展: 这道题如果不允许使用long 或者long long 怎么解?</h2><h1 id="033-Search-in-Rotated-Sorted-Array"><a href="#033-Search-in-Rotated-Sorted-Array" class="headerlink" title="033. Search in Rotated Sorted Array"></a>033. Search in Rotated Sorted Array</h1><h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>Example 1:</p><p>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4<br>Example 2:</p><p>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</p><h2 id="解法一-二分查找"><a href="#解法一-二分查找" class="headerlink" title="解法一: 二分查找"></a>解法一: 二分查找</h2><p>对于数组[4,5,6,7,0,1,2], 可以将其看成是两段: [4,5,6,7] 和 [0,1,2], 可以看出, 前一段中的任意一个数字都大于后一段中的数字, 于是, 令low=0, high=size()-1, 进行二分查找, 其中 mid 对应的数字要么落在前半段(<code>nums[low] &lt;= nums[mid]</code>), 要么落在后半段.</p><p>如果落在的前半段, 则看 target 的值是否在 low与mid之间. 是则 <code>high = mid-1</code>, 否则 <code>low = mid+1</code></p><p>反之, 如果落在后半段, 则看 <code>target</code> 的值是否在 <code>mid</code> 与 <code>high</code> 之间, 是则 <code>low=mid+1</code> , 否则<code>high = mid-1</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        //数组前半段的数字永远大于后半段的数字</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123; //当low==high时, mid=low=high, 如果不等于target, 则之后会退出循环</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] &lt;= nums[mid])&#123; //说明当前mid落在数组的前半段(), 这里等于号必须带, 否则会漏解</span><br><span class="line">                //判断target是否在low与mid之间, 这里low需要带等于号,</span><br><span class="line">                //因为target有可能=nums[low], mid无需带等于号</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; // 只有当nums[low]完全小于nums[mid]时, mid才落在后半段</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high])</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-二分查找"><a href="#解法二-二分查找" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p>该方法同样是二分查找, 只不过与上面有一点不同, 对于数组<code>nums</code>=[4,5,6,7,0,1,2]来说, 如果 <code>target &lt; nums[0]</code>, 说明 <code>target</code> 位于数组的后半段, 那么可以将数组看做是<code>nums</code>=[INT_MIN,INT_MIN,INT_MIN,INT_MIN,0,1,2] , 这样一来, 就变成了最常规的有序数组, 反之, 如果 <code>target</code> 位于数组的前半段, 那么可以将数组看做是<code>nums</code>=[4,5,6,7,INT_MAX,INT_MAX,INT_MAX].</p><p>注意, 这里并不会改变数组内部的值, 我们只是利用一个临时变量<code>num</code>来代替当前的nums[mid]的值, 然后利用 <code>num</code> 与 <code>target</code> 比较进行二分查找.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            int num;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>])&#123; //target在后半段, 所以将前半段都看做INT_MIN</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>])  num = nums[mid]; // nums[mid]在后半段</span><br><span class="line">                <span class="keyword">else</span> num = INT_MIN; // nums[mid]在前半段,</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; //target在前半段, 所以将后半段都看作是INT_MAX</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) num = INT_MAX;  // nums[mid]在后半段</span><br><span class="line">                <span class="keyword">else</span> num = nums[mid]; // nums[mid]在前半段</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; num) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="034-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#034-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="034. Find First and Last Position of Element in Sorted Array"></a>034. Find First and Last Position of Element in Sorted Array</h1><h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>If the target is not found in the array, return [-1, -1].</p><p>Example 1:</p><p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]<br>Example 2:</p><p>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p><h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>时间复杂度: $O(logn)$<br>空间复杂度: $O(1)$</p><p>先用常规的二分查找找到target, 然后分别用二分查找找到最左边的target和最右边的target下标.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;int&gt; res&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        int mid=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123; //正常的二分查找, 先找到target</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid==<span class="number">-1</span> || nums[mid] != target) <span class="keyword">return</span> res; // 数组为空或者数组内没有target</span><br><span class="line">        //以mid为中心, 分别查找下标最小的target和下标最大的target</span><br><span class="line">        int llow=low, lhigh=mid; // 左边的二分查找low,high初始化</span><br><span class="line">        int rlow=mid, rhigh=high; // 右边的二分查找low,high初始化</span><br><span class="line">        <span class="keyword">while</span>(llow&lt;=lhigh)&#123;</span><br><span class="line">            int mid = (llow+lhigh)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==llow || nums[mid<span class="number">-1</span>] != target)&#123; //关键: 只有当等于target并且左边没有元素或者左边元素不等于target时, 当前mid才是最左边的target</span><br><span class="line">                    res[<span class="number">0</span>] = mid; <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    lhigh = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                llow = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lhigh = mid<span class="number">-1</span>;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rlow&lt;=rhigh)&#123;</span><br><span class="line">            int mid = (rlow+rhigh)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==rhigh || nums[mid+<span class="number">1</span>] != target)&#123; //同理, 找最右边的target</span><br><span class="line">                    res[<span class="number">1</span>] = mid; <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    rlow = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                rlow = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rhigh = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-二分查找-1"><a href="#解法二-二分查找-1" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p>同样是二分查找, 更加精炼, 先找到最左边的target, 然后以最左边为low, 开始找最右边的target, 需要注意的是不能在<code>nums[mid] == target</code>时就退出循环.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;int&gt; res&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>; //偏向左边, 很重要, 否则会死循环</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid; //注意, 这里不是mid<span class="number">-1</span>, 因为现在是在找最左边的target, 故不能在=target时退出, 因此也不能直接令high=mid<span class="number">-1</span>, 否则会丢失mid=target的情况</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span> || nums[low] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>]=low;</span><br><span class="line">        high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            int mid = (low+high+<span class="number">1</span>)/<span class="number">2</span>; //使mid偏向右边, 这很重要</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>]=high;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36 Valid Sudoku"></a>36 Valid Sudoku</h1><p>验证一个矩阵是否是数独数据 (注意, 验证和)</p><h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p><p>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p><h2 id="解法一-利用flag数组存储判断矩阵"><a href="#解法一-利用flag数组存储判断矩阵" class="headerlink" title="解法一: 利用flag数组存储判断矩阵"></a>解法一: 利用flag数组存储判断矩阵</h2><p><strong>时间复杂度:</strong> $O(9^2)$</p><p><strong>空间复杂度:</strong> $O(3*9^2)$  虽然要申请三个二维数组, 但都是常数级.</p><p>用三个 9×9 大小的矩阵, 分别储存每一行上, 每一列上, 每一个子块上1-9数字是否出现.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        // 下面三个矩阵分别存储了 行上<span class="number">1</span><span class="number">-9</span>是否出现, 列上<span class="number">1</span><span class="number">-9</span>是否出现, sub-box上<span class="number">1</span><span class="number">-9</span>是否出现的bool值</span><br><span class="line">        // 如果row_flag[<span class="number">1</span>][<span class="number">3</span>] 为真, 则说明第<span class="number">1</span>行(从第<span class="number">0</span>行算起)上已经具有数字<span class="number">4</span>(数字比下标大<span class="number">1</span>)了</span><br><span class="line">        bool row_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;, col_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;, sub_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span> ; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>; // 如果为 <span class="string">'.'</span> 则可以直接跳过此次判断</span><br><span class="line">                int num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>; //这里<span class="number">-1</span>主要是为了能够直接将num作为下标使用</span><br><span class="line">                int k = i/<span class="number">3</span>*<span class="number">3</span> + j/<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(row_flag[i][num] || col_flag[j][num] || sub_flag[k][num])</span><br><span class="line">                    <span class="keyword">return</span> false;</span><br><span class="line">                row_flag[i][num]=col_flag[j][num]=sub_flag[k][num]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46 Permutations"></a>46 Permutations</h1><p>全排列</p><h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of distinct integers, return all possible permutations.</p><p>Example:</p><p>Input: [1,2,3]<br>Output:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p><h2 id="解法一-递归-1"><a href="#解法一-递归-1" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(A^n_n)$ , 每一种情况都是 $O(1)$ , 共有 $O(A^n_n)$ 种情况. (对吗?)</p><p>用一个变量pos指向nums的第一个位置, 然后将pos与后面所有位置上的数字交换(包括自己), 最终会得到n种可能性, 这n种可能性就是出现在第一位置上的所有可能字符的情况集合, 然后将第一位固定, 并将pos指向下一位, 此时问题转换成了n-1个字符的全排列, 按照这种想法一致递归下去, 就可以找到所有位置上的所有组合情况(用pos==nums.size()判断)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute_helper(res, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">            res.push_back(nums);  <span class="comment">// 当pos走到最后时, 说明一种情况诞生, 将其添加到res中</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt;nums.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[pos], nums[i]);</span><br><span class="line">                permute_helper(res, pos+<span class="number">1</span>, nums);</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[pos], nums[i]); <span class="comment">//这一行可以注释掉, 输出个结果仍然是全排列, 因为我们只需要找到在这一位置上的所有可能出现的字符, 所以就算不归位, 也能找到所有的可能性, 只不过顺序很变乱(因为交换后没有归位).</span></span><br><span class="line">                <span class="comment">//在面对含有重复字符的情况时, 最好加上这句话</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="048-Rotate-Image"><a href="#048-Rotate-Image" class="headerlink" title="048. Rotate Image"></a>048. Rotate Image</h1><p>将二维矩阵顺时针旋转90度.</p><h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>You are given an n x n 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p>Note:</p><p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p><p>Example 1:</p><p>Given input matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p><p>rotate the input matrix in-place such that it becomes:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>Example 2:</p><p>Given input matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>],</p><p>rotate the input matrix in-place such that it becomes:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p><h2 id="解法一-逆置-转置"><a href="#解法一-逆置-转置" class="headerlink" title="解法一: 逆置+转置"></a>解法一: 逆置+转置</h2><p>对行向量使用逆置, 然后对整个矩阵转置</p><p>clockwise rotate<br>first reverse up to down, then swap the symmetry<br>1 2 3     7 8 9     7 4 1<br>4 5 6  =&gt; 4 5 6  =&gt; 8 5 2<br>7 8 9     1 2 3     9 6 3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::reverse(matrix.begin(), matrix.end()); <span class="comment">//逆置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;matrix[i].size();j++) <span class="comment">// 转置, 注意j=i+1</span></span><br><span class="line">                <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-转置-列向量逆置"><a href="#解法二-转置-列向量逆置" class="headerlink" title="解法二: 转置+列向量逆置"></a>解法二: 转置+列向量逆置</h2><p>先求转置, 再对行向量逆置:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;matrix[i].size();j++)</span><br><span class="line">                <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;vec_i : matrix) <span class="built_in">std</span>::reverse(vec_i.begin(), vec_i.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充-逆时针旋转90度"><a href="#补充-逆时针旋转90度" class="headerlink" title="补充: 逆时针旋转90度"></a>补充: 逆时针旋转90度</h2><p>对列向量使用逆置(reverse), 然后对矩阵使用转置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;vec_i:matrix) <span class="built_in">std</span>::swap(vec_i.begin(), vec_i.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; i&lt;matrix[i].size(); j++)</span><br><span class="line">        <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="049-Group-Anagrams"><a href="#049-Group-Anagrams" class="headerlink" title="049. Group Anagrams"></a>049. Group Anagrams</h1><p>找到具有相同字符的各个字符串, 并按字符分组输出</p><h2 id="Description-15"><a href="#Description-15" class="headerlink" title="Description"></a>Description</h2><p>Given an array of strings, group anagrams together.</p><p>Example:</p><p>Input: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Output:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:</p><p>All inputs will be in lowercase.<br>The order of your output does not matter.</p><h2 id="解法一-哈希表-sort"><a href="#解法一-哈希表-sort" class="headerlink" title="解法一: 哈希表+sort"></a>解法一: 哈希表+sort</h2><p>用哈希表来存, 键为有序的字符序列, 值为string数组, 里面存着各个与有序字符序列包含字符相同的其他序列</p><p><strong>时间复杂度:</strong> $O(nmlogm)$ , 其中, n为输入字符串数组的长度, m为每个字符串的长度, 对于n个字符串, 要进行n次哈希表的插入, 同时每次插入时, 需要对字符串进行排序, 排序复杂度为 $O(mlogm)$.</p><p><strong>空间复杂度:</strong> $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> str_value = str;</span><br><span class="line">            <span class="built_in">std</span>::sort(str.begin(), str.end());</span><br><span class="line">            res_map[str].push_back(str_value); <span class="comment">//key 为字母有序string, value为含有这些字母的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_map)</span><br><span class="line">            res_vec.push_back(str.second); <span class="comment">//将map中的所有的string转移到vec返回结果中</span></span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="解法二-哈希表-不使用sort"><a href="#解法二-哈希表-不使用sort" class="headerlink" title="解法二: 哈希表(不使用sort)"></a>解法二: 哈希表(不使用sort)</h1><p><strong>时间复杂度:</strong> $O(nm)$ , 其中, n为string个数, m为每个string的字母数.</p><p>由于上面的解法二需要使用排序, 故而时间上不够优化, 因此, 这里我们可以设计新的键来代替sort, 基本思想是对26个字母, 分别赋予一个素数值, 然后, 计算键的时候, 将对应字母的素数相乘即可, 这样一来, 每一种字符串的key都是唯一的(因为最终的乘积可以唯一的表示成素数相乘的序列).</p><p><strong>空间复杂度:</strong> $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> primer[<span class="number">26</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> ,<span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum_id</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">            sum * = primer[(<span class="keyword">int</span>)(c-<span class="string">'a'</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">            res_map[get_sum_id(str)].push_back(str); <span class="comment">//key 为字母有序string, value为含有这些字母的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_map)</span><br><span class="line">            res_vec.push_back(str.second); <span class="comment">//将map中的所有的string转移到vec返回结果中</span></span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="050-Pow-x-n"><a href="#050-Pow-x-n" class="headerlink" title="050. Pow(x, n)"></a>050. Pow(x, n)</h1><p>实现幂乘操作</p><h2 id="Descriptin"><a href="#Descriptin" class="headerlink" title="Descriptin"></a>Descriptin</h2><p>Implement pow(x, n), which calculates x raised to the power n (x^n).</p><p>Example 1:</p><p>Input: 2.00000, 10<br>Output: 1024.00000<br>Example 2:</p><p>Input: 2.10000, 3<br>Output: 9.26100<br>Example 3:</p><p>Input: 2.00000, -2<br>Output: 0.25000<br>Explanation: 2-2 = 1/22 = 1/4 = 0.25<br>Note:</p><p>-100.0 &lt; x &lt; 100.0<br>n is a 32-bit signed integer, within the range $[−2^{31}, 2^{31} − 1]$</p><h2 id="解法一-递归-2"><a href="#解法一-递归-2" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>当n为偶数时: $x^n = x^{n/2} \times x^{n/2}$<br>当n为奇数时: $x^n = x\times x^{n/2} \times x^{n/2}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">return</span> (un%<span class="number">2</span>==<span class="number">0</span>) ? myPow(x*x, un/<span class="number">2</span>) : x*myPow(x*x, un/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-非递归-1"><a href="#解法二-非递归-1" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>n要么为偶数, 要么为奇数, 就算为奇数, 也可以拆分成 $x\times x^{n-1}$ 的形式, 对于偶数n, 可以写成 $x^{n/2} \times x{n/2}$ 的形式, 对于 $x^{n/2}$, 可以继续按奇数偶数进行拆分. 举例来说, 对于x=2, n=10 , 可以写成 $2^{10} = 2^{5} \times 2^{5}$ 对于 $2^5$ , 可以写成, $2 \times 2^2 \times 2^2$, 可以看出, x每次与自身相乘后, n的次数就会变成原来二分之一, 这样, 可以用循环实现幂乘的操作, 如下所示.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">double</span> res =<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(un&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(un%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                res * = x;</span><br><span class="line">            &#125;</span><br><span class="line">            x * =x;</span><br><span class="line">            un /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="054-Spiral-Matrix"><a href="#054-Spiral-Matrix" class="headerlink" title="054. Spiral Matrix"></a>054. Spiral Matrix</h1><p>以顺时针螺旋顺序返回矩阵元素, 顺时针打印矩阵</p><h2 id="Description-16"><a href="#Description-16" class="headerlink" title="Description"></a>Description</h2><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p><p>Example 1:</p><p>Input:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>Output: [1,2,3,6,9,8,7,4,5]<br>Example 2:</p><p>Input:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>Output: [1,2,3,4,8,12,11,10,9,5,6,7]</p><h2 id="解法-按层次输出-由外而内"><a href="#解法-按层次输出-由外而内" class="headerlink" title="解法: 按层次输出(由外而内)"></a>解法: 按层次输出(由外而内)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p><p>输出形式如下(按层次编码, 以4×6的矩阵为例), 需要注意边界控制条件:</p><script type="math/tex; mode=display">\begin{matrix} 1_{top}&1_{top}&1_{top}&1_{top}&1_{top}&1_{top} \\ 1_{left}&2_{top}&2_{top}&2_{top}&2_{top}&1_{right} \\ 1_{left}&2_{bottom}&2_{bottom}&2_{bottom}&2_{bottom}&1_{right} \\ 1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}  \end{matrix}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size() ==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row_layer = (matrix.size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> col_layer = (matrix[<span class="number">0</span>].size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> layer = min( row_layer, col_layer); <span class="comment">// 计算总共的层数</span></span><br><span class="line">        <span class="keyword">int</span> cur_layer =<span class="number">0</span>; <span class="comment">// 用于记录当前所处哪一层</span></span><br><span class="line">        <span class="keyword">int</span> len_row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> len_col = matrix[<span class="number">0</span>].size(); <span class="comment">//分别为行和列的size</span></span><br><span class="line">        <span class="keyword">while</span>(cur_layer &lt; layer)&#123;</span><br><span class="line">            <span class="comment">//top 输出上边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =cur_layer; j&lt;len_col-cur_layer; j++)</span><br><span class="line">                res.push_back(matrix[cur_layer][j]);</span><br><span class="line">            <span class="comment">//right 输出右边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_layer+<span class="number">1</span>; i&lt;len_row<span class="number">-1</span>-cur_layer; i++)</span><br><span class="line">                res.push_back(matrix[i][len_col - <span class="number">1</span> - cur_layer]);</span><br><span class="line">            <span class="comment">//bottom  输出下边, 这里注意为了防止重复输出, 需要确保上边和下边的行数不同,即:</span></span><br><span class="line">            <span class="comment">// cur_layer!=len_row-1-cur_layer</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= len_col - <span class="number">1</span> -cur_layer; cur_layer!=len_row<span class="number">-1</span>-cur_layer &amp;&amp; j &gt;=cur_layer  ;j--)</span><br><span class="line">                res.push_back(matrix[len_row - <span class="number">1</span> -cur_layer][j]);</span><br><span class="line">            <span class="comment">//left 输出左边, 同样, 要确保左边和右边的列数不同, 即: cur_layer!=len_col-1-cur_layer</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = len_row<span class="number">-2</span>-cur_layer; cur_layer!=len_col<span class="number">-1</span>-cur_layer &amp;&amp; i&gt;cur_layer; i--)</span><br><span class="line">                res.push_back(matrix[i][cur_layer]);</span><br><span class="line">            cur_layer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="055-Jump-Game"><a href="#055-Jump-Game" class="headerlink" title="055. Jump Game"></a>055. Jump Game</h1><p>数组的数字为最大的跳跃步数, 根据数组判断是否能跳到最后一位上</p><h2 id="Description-17"><a href="#Description-17" class="headerlink" title="Description"></a>Description</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>Example 1:</p><p>Input: [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Example 2:</p><p>Input: [3,2,1,0,4]<br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum<br>             jump length is 0, which makes it impossible to reach the last index.</p><h2 id="解法一-回溯"><a href="#解法一-回溯" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong> $O(2^n)$  总共有 $2^n$ 种跳法来跳到最后一个位置上(对于任意一个位置, 有经过和不经过两个种可能性)<br><strong>空间复杂度:</strong> $O(n)$</p><p>试遍所有的可能性, 正常来说会超时, 并且也肯定不是最佳答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(position == final_position) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(position+nums[position], final_position);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = position+<span class="number">1</span>; i&lt;=furthest; i++)&#123;</span><br><span class="line">            <span class="comment">//这里有个小小的优化, 就是令i从最大步长开始, i--, 这种优化虽然最坏情况时一样的</span></span><br><span class="line">            <span class="comment">//但在实际使用中, 会比从position+1开始要快一点(但是依然超时)</span></span><br><span class="line">            <span class="keyword">if</span>(helper(nums, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-top-down-动态规划-递归"><a href="#解法二-top-down-动态规划-递归" class="headerlink" title="解法二: top-down 动态规划(递归)"></a>解法二: top-down 动态规划(递归)</h2><p><strong>时间复杂度:</strong> $O(n^2)$ , 对于每个点来说, 都是要找到下一个<code>good_position</code>, 则需要进行 $(O)$ 的查找, 又因为总共有 $O(n)$个元素, 所以复杂度为 $O(n^2)$.<br><strong>空间复杂度:</strong> $O(2n)$, 递归需要 $O(n)$ , <code>memo</code>需要 $O(n)$.</p><p>设计一个数组, 用来记录当前下标对应位置是否可又达到终点, 如果能, 则该位置为<code>good position</code>, 如果不能, 则为<code>bad position</code>, 刚开始的时候都是<code>unknown position</code>(除了最后一个位置为<code>good</code>).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>&#123;</span>GOOD, BAD, UNKNOWN&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Status&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            memo.push_back(Status::UNKNOWN);</span><br><span class="line">        memo.push_back(Status::GOOD);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, memo, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;Status&gt; &amp;memo, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[position] != Status::UNKNOWN) <span class="keyword">return</span> memo[position]==Status::GOOD ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(position+nums[position], final_position);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = furthest; i&gt;position; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper(nums, memo, i))&#123;</span><br><span class="line">                memo[position] = Status::GOOD; <span class="comment">//注意是position, 不是i</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[position] = Status::BAD;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-down-top-动态规划-非递归"><a href="#解法三-down-top-动态规划-非递归" class="headerlink" title="解法三: down-top 动态规划(非递归)"></a>解法三: down-top 动态规划(非递归)</h2><p><strong>时间复杂度:</strong> $O(n^2)$ , 对于每个点来说, 都是要找到下一个<code>good_position</code>, 则需要进行 $(O)$ 的查找, 又因为总共有 $O(n)$个元素, 所以复杂度为 $O(n^2)$.<br><strong>空间复杂度:</strong> $O(n)$, 无需递归 , 只需要<code>memo</code>, $O(n)$.</p><p>动态规划的非递归版本.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>&#123;</span>GOOD, BAD, UNKNOWN&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums.size() ==0) return false;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Status&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            memo.push_back(Status::UNKNOWN);</span><br><span class="line">        memo.push_back(Status::GOOD);</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(i+nums[i], final_position);</span><br><span class="line">            <span class="comment">//for(int j = i+1; j&lt;=furthest; j++)&#123;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = furthest; j&gt;i;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(memo[j] == Status::GOOD)&#123; <span class="comment">// 只要有一个GOOD, 当前i位置就为GOOD, 而无需考虑BAD的情况</span></span><br><span class="line">                    memo[i] = memo[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>] == Status::GOOD ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法四-贪心"><a href="#解法四-贪心" class="headerlink" title="解法四: 贪心"></a>解法四: 贪心</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p><p>由上面的down-top递归可以看出, 当前下标位置的点是否为good点, 实际上只取决于当前点是否能够达到右边坐标中(从右往左走)最左边的good(可以看上面的break语句), 如果能够达到, 则当前点一定为good点, 因此, 我们只需要用一个变量<code>left_most_good</code>来维护当前点右边的最左good点下标即可, 无需任何其他空间和操作.(速度极快)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left_most_good = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+nums[i] &gt;= left_most_good)&#123;</span><br><span class="line">                left_most_good = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left_most_good==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>另一种贪心的形式:</strong> 记录当前能够达到的最大位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> reach=<span class="number">0</span>; i&lt;nums.size() &amp;&amp; i&lt;=reach; i++ )</span><br><span class="line">            reach = max(i+nums[i], reach);</span><br><span class="line">        <span class="keyword">return</span> i==nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="056-Merge-Intervals"><a href="#056-Merge-Intervals" class="headerlink" title="056. Merge Intervals"></a>056. Merge Intervals</h1><p>融合区间</p><h2 id="Description-18"><a href="#Description-18" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].<br>Example 2:</p><p>Input: [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considerred overlapping.</p><h2 id="解法一-sort-O-n"><a href="#解法一-sort-O-n" class="headerlink" title="解法一: sort+O(n)"></a>解法一: sort+O(n)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 主要是排序<br><strong>空间复杂度:</strong> $O(n)$</p><p>最简单的实现方法, 先按照interval.start用sort排序, 排好序以后, 能够融合的interval都会聚到一起, 这个时候, 因为start是呈递增的, 只需要看end的大小关系就可以.</p><p>最简单的实现方法就是sort之后, 通过额外申请空间来存储融合后的interval, 最后返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iv : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.back().end &lt; iv.start) res.push_back(iv);</span><br><span class="line">            <span class="keyword">else</span> res.back().end = <span class="built_in">std</span>::max(res.back().end, iv.end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-sort-O-1"><a href="#解法二-sort-O-1" class="headerlink" title="解法二: sort+O(1)"></a>解法二: sort+O(1)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$ , 主要是排序<br><strong>空间复杂度:</strong> $O(1)$</p><p>上面的方法在逻辑上不够好, 因为既然已经申请了额外的内存来存储放回结果, 说明我们不希望改变原vector内部的数据, 但是sort之后, 数据顺序已经被破坏了, 既然已经破坏了, 那最好就是直接使用原地融合的办法, 来减少内存的开销<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="comment">//vector&lt;Interval&gt; res; 既然决定使用sort, 就说明已经改变了intervals, 此时不应该在额外申请空间, 而应该进行原地融合.</span></span><br><span class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        <span class="keyword">auto</span> cur_iv = intervals.begin();</span><br><span class="line">        <span class="keyword">auto</span> next_iv = intervals.begin()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; next_iv!=intervals.end(); next_iv++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (*cur_iv).end &lt; (*next_iv).start )&#123;</span><br><span class="line">                cur_iv++;</span><br><span class="line">                (*cur_iv) = (*next_iv);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                (*cur_iv).end = <span class="built_in">std</span>::max( (*cur_iv).end, (*next_iv).end );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.erase(cur_iv+<span class="number">1</span>, intervals.end());</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法三-不使用sort"><a href="#解法三-不使用sort" class="headerlink" title="解法三: 不使用sort"></a>解法三: 不使用sort</h2><p>有时, 我们要求不能改变原向量intervals的内容, 此时, 就不能使用sort (除非牺牲大量空间留副本,但单肯定不推荐).</p><p>//TODO, 未细看, 但时间复杂度应该会高于 O(nlogn)<br><a href="https://leetcode.com/problems/merge-intervals/discuss/153979/Elegant-c++-solutions.-One-without-modifying-intervals-and-one-inplace" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/discuss/153979/Elegant-c++-solutions.-One-without-modifying-intervals-and-one-inplace</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Without modifying intervals</span><br><span class="line">Since we can't sort interval, we want to instead ensure our destination <span class="built_in">vector</span> is sorted. A insertion sort is required then. Insertion should be done as follows;</span><br><span class="line"></span><br><span class="line">Find first destination interval that ends after the incoming interval starts. Called it</span><br><span class="line">If no such interval is found <span class="keyword">or</span> the incoming interval end is less than found intervals start then we can just insert <span class="keyword">and</span> be done.</span><br><span class="line">Otherwise there must be an overlap, but it could be more than one. Do another search, <span class="keyword">this</span> time <span class="keyword">for</span> the first interval whose start is greater than incoming interval end. Called last</span><br><span class="line">Everything from [it, last) can be merged together with incoming interval into a single interval</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Interval&gt; ret;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">std</span>::lower_bound(ret.begin(), ret.end(), interval.start, [](<span class="keyword">const</span> Interval&amp; l, <span class="keyword">int</span> r) &#123; <span class="keyword">return</span> l.end &lt; r; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it == ret.end() || interval.end &lt; it-&gt;start)</span><br><span class="line">          <span class="comment">// No overlap, insert as is</span></span><br><span class="line">          ret.insert(it, interval);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// There is an overlap, there might be more, so find the upper bound too</span></span><br><span class="line">          it-&gt;start = <span class="built_in">std</span>::min(it-&gt;start, interval.start);</span><br><span class="line">          <span class="keyword">auto</span> last = <span class="built_in">std</span>::upper_bound(it, ret.end(), interval.end, [](<span class="keyword">int</span> l, <span class="keyword">const</span> Interval&amp; r) &#123; <span class="keyword">return</span> l &lt; r.start; &#125;);</span><br><span class="line">          it-&gt;end = <span class="built_in">std</span>::max((last - <span class="number">1</span>)-&gt;end, interval.end);</span><br><span class="line">          ret.erase(it + <span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="062-Unique-Paths"><a href="#062-Unique-Paths" class="headerlink" title="062. Unique Paths"></a>062. Unique Paths</h1><h2 id="Description-19"><a href="#Description-19" class="headerlink" title="Description"></a>Description</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><h2 id="解法一-DP"><a href="#解法一-DP" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(mn)$<br><strong>空间复杂度:</strong> $O(mn)$</p><p>这是一道经典的DP问题, 当机器人处于某一点时, 它只能从上面或者左边到达该点, 因此很容易得出<code>path[i][j] = path[i-1][j] + path[i][j-1];</code>, 其中 <code>path[i][j]</code>指到达 $(i,j)$ 点的可能路径数量.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span> ; j&lt;n; j++)&#123;</span><br><span class="line">                path[i][j] = path[i<span class="number">-1</span>][j] + path[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-优化的DP"><a href="#解法二-优化的DP" class="headerlink" title="解法二: 优化的DP"></a>解法二: 优化的DP</h2><p><strong>时间复杂度:</strong> $O(mn)$<br><strong>空间复杂度:</strong> $O(n)$</p><p>通过分析指导, 当前点的可能路径数量只与上面点和左边点的值有关, 在上面的方法中, 我们用一个 $m\times n$ 的数组来存储当前点上面和左边的值, 实际上, 我们只需要用一行数组就可以完成这个功能, 首先, 求出第一行的所有点的值, 这里只会用每个点左边的值,  然后, 对于第二行的第一个点来说, 它只会用到上面的值, 也就是第一行的第一个值, 因此可以通过行数组直接得到, 然后, 对于第二行的第二个值, 它可以从第二行的第一个值, 以及第二行的第二个值得到, 这些值都是已知的, 所以可以直接求的, 由于在求得以后, 我们就再也不需要第一行的第二个值了, 所以我们可以用这个存储空间来存储第二行的第二个值, 如此递归执行, 我们只需要 $O(n)$ 的空间即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                path[j] = path[j] + path[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-排列组合-最优"><a href="#解法三-排列组合-最优" class="headerlink" title="解法三: 排列组合(最优)"></a>解法三: 排列组合(最优)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p><p>实际上, 仔细分析该问题, 可以把该问题看成是一个典型的排列组合问题. 首先, 将机器人向右走记为 1, 将机器人向下走记为 0. 题目问有多少种不同的走法, 实际上就是在问1/0序列的不同排列有多少种, 并且, 1/0 的长度必须为 $(m -1 + n - 1)$. 因此, 这个问题可以看做是从 $(m-1+n-1)$ 个空槽位上选择 $(m-1)$ 个槽位, 将其置为1, 并将剩余的 $n-1$ 个槽位置为0, 故而就是组合问题: $C_{m-1+n-1}^{m-1}$ . 又因为 $C_{m-1+n-1}^{m-1} = C_{m-1+n-1}^{n-1}$ , 所以为了防止溢出, 我们可以选择小的进行计算</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long res = <span class="number">1</span>; //需要注意的是, 由于下面的计算操作是会有先乘一个数, 再初以一个数的操作, 因此很有可能乘完后超过int上限, 所以需要声明为long整型</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i&lt; std::min(m,n); i++)&#123;</span><br><span class="line">            res = res * (m<span class="number">-1</span>+n<span class="number">-1</span> - i+<span class="number">1</span>) / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="073-Set-Matrix-Zeroes"><a href="#073-Set-Matrix-Zeroes" class="headerlink" title="073. Set Matrix Zeroes"></a>073. Set Matrix Zeroes</h1><h2 id="Description-20"><a href="#Description-20" class="headerlink" title="Description"></a>Description</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.</p><p>Example 1:</p><p>Input:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>Output:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br>Example 2:</p><p>Input:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>Output:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]<br>Follow up:</p><p>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p><h2 id="解法一-穷举"><a href="#解法一-穷举" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(nm)$</p><p>记录所有出现0的位置, 然后根据这些位置坐标将对应的行和列上的值置为0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    rows.push_back(i);</span><br><span class="line">                    cols.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:rows)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:cols)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-穷举-减少空间复杂度"><a href="#解法二-穷举-减少空间复杂度" class="headerlink" title="解法二: 穷举(减少空间复杂度)"></a>解法二: 穷举(减少空间复杂度)</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(n+m)$</p><p>上面在记录位置坐标时没有进行重复检查, 实际上, 对于已经记录过的行或列, 可以不用再记录, 此时, 空间复杂度可以降为 $O(m+n)$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 记录行或列坐标之前先进行重复检查</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">std</span>::count(rows.begin(), rows.end(), i)==<span class="number">0</span>) rows.push_back(i);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">std</span>::count(cols.begin(), cols.end(), j)==<span class="number">0</span>) cols.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:rows)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:cols)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-穷举-空间复杂度-O-1"><a href="#解法三-穷举-空间复杂度-O-1" class="headerlink" title="解法三: 穷举(空间复杂度 $O(1)$ )"></a>解法三: 穷举(空间复杂度 $O(1)$ )</h2><p><strong>时间复杂度:</strong> $O(nm\times (m+n))$<br><strong>空间复杂度:</strong> $O(1)$</p><p>遍历矩阵时, 如果遇到 $(i,j)$ 上的值为0, 那么就将对应的行和列上的所有非0值全部置为一个矩阵范围外的值NAN(解答里面用的是-100000, 实际上这种解法存在问题, 因为理论上矩阵中的元素可以是表示范围内的任何值).</p><p>之后将所有的NAN值置为0, 就可以完成置0任务, 并且没有使用额外的空间. 由于每次找到一个0时, 都要遍历这个位置上的行和列, 因此时间复杂度较高</p><h2 id="解法四-用第一行和第一列记录"><a href="#解法四-用第一行和第一列记录" class="headerlink" title="解法四: 用第一行和第一列记录"></a>解法四: 用第一行和第一列记录</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(1)$</p><p>用第一行和第一列的值记录是否应该将对应的行和列置为0, 此时由于第一行和第一列被用作了标记数组, 因此第一行和第一列的0不能用来判断是否应该置为全0, 所以需要额外设置两个变量记录.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> is_row=<span class="literal">false</span>, is_col = <span class="literal">false</span>; <span class="comment">// 用第一行和第一列的值来做标记, 因此需要额外的记录第一行和第一列本身是有应该全0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) is_row=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>) is_col=<span class="literal">true</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_row)&#123; <span class="comment">//需要特别判断第一行和第一列是否应该置为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;matrix[<span class="number">0</span>].size();j++)  matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_col)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; matrix.size(); i++) matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="075-Sort-Colors"><a href="#075-Sort-Colors" class="headerlink" title="075. Sort Colors"></a>075. Sort Colors</h1><p>对0,1,2 (颜色: RGB) 进行排序</p><h2 id="Description-21"><a href="#Description-21" class="headerlink" title="Description"></a>Description</h2><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p>Note: You are not suppose to use the library’s sort function for this problem.</p><p>Example:</p><p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p><p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p><h2 id="解法一-两次遍历"><a href="#解法一-两次遍历" class="headerlink" title="解法一: 两次遍历"></a>解法一: 两次遍历</h2><p><strong>时间复杂度: $O(n)$</strong><br><strong>空间复杂度: $O(1)$</strong></p><p>第一次遍历统计0,1,2的个数, 第二次遍历根据0,1,2的个数覆盖数组原有值</p><h2 id="解法二-一次遍历"><a href="#解法二-一次遍历" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> 大于 $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p><p>设置mid, low, high三个指示变量, 如果mid==0, 则将其与low交换, 如果mid==2, 则将其与high交换, 直到mid&gt;high为止.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, mid=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(mid&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[mid], nums[high--]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[mid++], nums[low++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mid++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="078-Subsets"><a href="#078-Subsets" class="headerlink" title="078. Subsets"></a>078. Subsets</h1><p>返回给定数字序列的子集, 序列中每个元素都不同(这是一个很重要的条件!!)</p><h2 id="Description-22"><a href="#Description-22" class="headerlink" title="Description"></a>Description</h2><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:</p><p>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p><h2 id="解法一-迭代直接求出子集"><a href="#解法一-迭代直接求出子集" class="headerlink" title="解法一: 迭代直接求出子集"></a>解法一: 迭代直接求出子集</h2><p><strong>时间复杂度:</strong> $O(2^n)$ , 对于任意一个元素, 有包含和不包含两种情况<br><strong>空间复杂度:</strong> $O(2^n)$</p><p><strong>由于序列中的每个元素都不同</strong>, 因此, 对于任意一个元素, 只需要将其添加都前面序列所组成的子集的每一个子序列的末尾即可, 无需考虑是否包含重复元素的情况.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res &#123;vector&lt;int&gt;&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(auto n : nums)&#123;</span><br><span class="line">            int len = res.size();</span><br><span class="line">            <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                vector&lt;int&gt; sub_item = res[i]; // c++中, =为复制赋值, move函数为移动赋值</span><br><span class="line">                sub_item.push_back(n);</span><br><span class="line">                res.push_back(sub_item);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-回溯"><a href="#解法二-回溯" class="headerlink" title="解法二: 回溯"></a>解法二: 回溯</h2><p><a href="https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning</a>)<br>回溯法可以解决一系列相关问题, 先看Subsets的求解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item;</span><br><span class="line">        back_track(res, sub_item, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        res.push_back(sub_item);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            sub_item.push_back(nums[i]);</span><br><span class="line">            back_track(res, sub_item, i+<span class="number">1</span>, nums);</span><br><span class="line">            sub_item.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>其他问题:</strong></p><p>Subsets II (contains duplicates) : <a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets-ii/</a><br>悠悠  11:05:53<br>Permutations : <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><br>悠悠  11:06:01<br>Permutations II (contains duplicates) : <a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a><br>悠悠  11:06:09<br>Combination Sum : <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/</a><br>悠悠  11:06:16<br>Combination Sum II (can’t reuse same element) : <a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-ii/</a><br>悠悠  11:06:23<br>Palindrome Partitioning : <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p><h2 id="解法三-bit控制"><a href="#解法三-bit控制" class="headerlink" title="解法三: bit控制"></a>解法三: bit控制</h2><p><strong>时间复杂度:</strong> $O(n\times 2^n)$ , 最慢的方法.<br><strong>空间复杂度:</strong> $O(2^n)$<br>因为对于任意一个数只有两种可能性, 出现在子序列中, 或者不出现在子序列中, 因此对于长度为 n 的(无相同元素的)序列来说, 共有 $2^n$ 个子序列, 我们先为这些子序列申请空间, 然后根据位操作(刚好有0,1两种情况)来决定对应位置上的字符出现还是不出现.</p><p>在实现时, 观察到, 第一个元素每隔两个子序列出现一次, 第二个元素每隔四个子序列出现两次, 第三个元素每隔八个子序列出现四次…</p><p>依次类推, 我们可以根据当前元素的位置来决定当前元素是否出现(间隔的前一半出现, 后一半不出现)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len_subsets = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>,nums.size());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(len_subsets, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len_subsets; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;&gt;i &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res[j].push_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="079-Word-Search"><a href="#079-Word-Search" class="headerlink" title="079. Word Search"></a>079. Word Search</h1><p>判断指定单词是否存在于字符数组中(可以通过上下左右邻接字符相连的才算是一个单词)</p><h2 id="Description-23"><a href="#Description-23" class="headerlink" title="Description"></a>Description</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:</p><p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p><p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.</p><h2 id="解法一-dfs-回溯"><a href="#解法一-dfs-回溯" class="headerlink" title="解法一: dfs+回溯"></a>解法一: dfs+回溯</h2><p><strong>时间复杂度:</strong> 暴力<br><strong>空间复杂度:</strong> $O(1)$ , 回溯时, 用<code>#</code>来记录已经遍历过的点, 无需申请额外空间来记录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word, <span class="keyword">int</span> start, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> cur_c = board[x][y];</span><br><span class="line">        <span class="keyword">if</span>(cur_c != word[start]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == word.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[x][y]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">bool</span> res=<span class="literal">false</span>, b_down=<span class="literal">false</span>, b_left=<span class="literal">false</span>, b_right=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>) res = dfs(board, word, start+<span class="number">1</span>, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; x&lt;board.size()<span class="number">-1</span>) res = dfs(board, word, start+<span class="number">1</span>, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; y&gt;<span class="number">0</span>) res = dfs(board, word, start+<span class="number">1</span>, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; y&lt;board[<span class="number">0</span>].size()<span class="number">-1</span>) res = dfs(board, word, start+<span class="number">1</span>, x, y+<span class="number">1</span>);</span><br><span class="line">        board[x][y]=cur_c;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="091-Decode-Ways"><a href="#091-Decode-Ways" class="headerlink" title="091. Decode Ways"></a>091. Decode Ways</h1><h1 id="094-Binary-Tree-Inorder-Traversal"><a href="#094-Binary-Tree-Inorder-Traversal" class="headerlink" title="094. Binary Tree Inorder Traversal"></a>094. Binary Tree Inorder Traversal</h1><p>中序遍历二叉树</p><h2 id="Description-24"><a href="#Description-24" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>Example:</p><p>Input: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3</p><p>Output: [1,3,2]<br>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h2 id="解法一-递归-3"><a href="#解法一-递归-3" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>/**</p><ul><li>Definition for a binary tree node.</li><li>struct TreeNode {</li><li>int val;</li><li>TreeNode *left;</li><li>TreeNode *right;</li><li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li><li>};<br><em>/<br>class Solution {<br>public:<br> vector<int> inorderTraversal(TreeNode</int></em> root) {<pre><code> vector&lt;int&gt; res; if(root==nullptr) return res; inorder(root, res); return res;</code></pre> }<br> void inorder(TreeNode* root, vector<int> &amp;res){<pre><code> if(root-&gt;left!=nullptr) inorder(root-&gt;left, res); res.push_back(root-&gt;val); if(root-&gt;right!=nullptr) inorder(root-&gt;right, res);</code></pre> }<br>};</int></li></ul><h2 id="解法二-非递归-2"><a href="#解法二-非递归-2" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>标准的中序非递归遍历算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s_tree;</span><br><span class="line">        <span class="keyword">while</span>(!s_tree.empty() || root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s_tree.push(root);</span><br><span class="line">                root= root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s_tree.empty())&#123;</span><br><span class="line">                root = s_tree.top(); s_tree.pop();</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="150-evaluate-reverse-polish-notation"><a href="#150-evaluate-reverse-polish-notation" class="headerlink" title="150. evaluate reverse polish notation"></a>150. evaluate reverse polish notation</h1><h2 id="Description-25"><a href="#Description-25" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-2"><a href="#解法一-2" class="headerlink" title="解法一:"></a>解法一:</h2><p>用栈来实现, 从到开始扫描字符串vector, 如果当前字符串不为运算符, 则直接入栈, 如果为运算符 , 则取栈顶两个元素进行运算然后将计算结果入栈. 最终, 栈中只剩一个结果值</p><p>需要注意的是: 首先要确保输入的逆波兰表达式是没有问题的, 其次还有要进行零除判断, 这几点本题没有考查, 但仍需注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; rpn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;tokens.size() ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i] == <span class="string">"+"</span> ||</span><br><span class="line">               tokens[i] == <span class="string">"-"</span> ||</span><br><span class="line">               tokens[i] == <span class="string">"*"</span> ||</span><br><span class="line">               tokens[i] == <span class="string">"/"</span> )&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = stoi(rpn.top()); rpn.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = stoi(rpn.top()); rpn.pop();</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">"+"</span>) rpn.push(to_string(num2+num1));</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">"-"</span>) rpn.push(to_string(num2-num1));</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">"*"</span>) rpn.push(to_string(num2*num1));</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">"/"</span>) rpn.push(to_string(num2/num1)); <span class="comment">// 这里其实还应该进行0除判断</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                rpn.push(tokens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rpn.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> stoi(rpn.top());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果输入的polish表达式有问题, 那么输出0(其实这里应该用一个全局量来标识错误情况)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h1><p>解法与上面相同, 不同借助了异常, 显得更加简洁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rpn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;tokens.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                rpn.push(stoi(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (exception e)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = rpn.top(); rpn.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = rpn.top(); rpn.pop();</span><br><span class="line">                <span class="keyword">switch</span>(tokens[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: rpn.push(num2+num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: rpn.push(num2-num1);<span class="keyword">break</span>;</span><br><span class="line">                    case '* ': rpn.push(num2*num1);break;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: rpn.push(num2/num1);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rpn.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> rpn.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode算法题(Easy)</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-LeetCode-1/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-LeetCode-1/</url>
      
        <content type="html"><![CDATA[<h1 id="001-Two-Sum"><a href="#001-Two-Sum" class="headerlink" title="001. Two Sum"></a>001. Two Sum</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:</p><p>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p><h2 id="解法一-穷举"><a href="#解法一-穷举" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p>时间复杂度: $O(n^2)$<br>空间复杂度: $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;nums.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res =&#123;i,j&#125;;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-哈希表-两次遍历"><a href="#解法二-哈希表-两次遍历" class="headerlink" title="解法二 : 哈希表, 两次遍历"></a>解法二 : 哈希表, 两次遍历</h2><p>这里要特别注意: 同一个元素不能使用两次, 但是数组中的元素是可以重复的, 重复的元素看作是两个元素. hash表中最终存储的将会是重复元素的最后一个下标, 因此, 在进行比较时, 使用 <code>i!= nums_map[target-nums[i]]</code> 来判断它们是否为同一个元素, 而不能使用<code>nums_map[nums[i]] != nums_map[target-nums[i]]</code></p><p>时间复杂度: $O(n)$  遍历两次<br>空间复杂度: $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            nums_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_map.count(target-nums[i]) == <span class="number">1</span> &amp;&amp; i!= nums_map[target-nums[i]])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i, nums_map[target-nums[i]]&#125;; <span class="comment">//这里一定要用i,而不能用nums_map[nums[i]] , 上面也同理</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-哈希表-一次遍历"><a href="#解法三-哈希表-一次遍历" class="headerlink" title="解法三: 哈希表 一次遍历"></a>解法三: 哈希表 一次遍历</h2><p>事实上, 可以将hash表的插入和查找对应元素的操作放在 一个循环里, 这样就只需要进行一次遍历</p><p>时间复杂度: $O(n)$  遍历一次<br>空间复杂度: $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_map.count(target-nums[i]) == <span class="number">1</span> &amp;&amp; i!= nums_map[target-nums[i]])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i, nums_map[target-nums[i]]&#125;;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            nums_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>How would you approach the problem if the input array is very large (but limited range) and cannot fit in the memory ? This is a follow-up question for this problem.</p><h1 id="007"><a href="#007" class="headerlink" title="007."></a>007.</h1><h2 id="解法一-取余数"><a href="#解法一-取余数" class="headerlink" title="解法一: 取余数"></a>解法一: 取余数</h2><p>这道题本身不难, 只要不断对x的绝对值取余数, 就可以得到反转的整数, 但是, 该题的核心考察点在于边界条件的判断, 稍不注意, 很容易漏解(如果不进行边界判断, 即使写出了解决方法, 面试官也很不满意)</p><ul><li>x为0</li><li>x反转后的值,超过了int型数据的表示范围, 检查方法是先用long存储, 然后看</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> abs_x = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="keyword">int</span> sign_x = x&gt;<span class="number">0</span>? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>; <span class="comment">// 为了看int是否越界,特意将res声明为long型</span></span><br><span class="line">        <span class="keyword">while</span>( abs_x!=<span class="number">0</span> )&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + abs_x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX || res &lt; INT_MIN) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//这一句就是最主要的考察点,看int是否越界</span></span><br><span class="line">            abs_x = abs_x/<span class="number">10</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sign_x ==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>-res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="013-Roman-to-Integer"><a href="#013-Roman-to-Integer" class="headerlink" title="013. Roman to Integer"></a>013. Roman to Integer</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><p>Example 1:</p><p>Input: “III”<br>Output: 3<br>Example 2:</p><p>Input: “IV”<br>Output: 4<br>Example 3:</p><p>Input: “IX”<br>Output: 9<br>Example 4:</p><p>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.<br>Example 5:</p><p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p><h2 id="解法一-顺序扫描"><a href="#解法一-顺序扫描" class="headerlink" title="解法一: 顺序扫描"></a>解法一: 顺序扫描</h2><p>时间复杂度: $O(n)$</p><p>顺序扫描, 如果当前字符比下一个字符小, 说明是 ‘4’ 或 ‘9’ 的情况, 用下一个字符的值减去当前字符的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; roman_char;</span><br><span class="line">        roman_char[<span class="string">'I'</span>] = <span class="number">1</span>;</span><br><span class="line">        roman_char[<span class="string">'V'</span>] = <span class="number">5</span>;</span><br><span class="line">        roman_char[<span class="string">'X'</span>] = <span class="number">10</span>;</span><br><span class="line">        roman_char[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        roman_char[<span class="string">'C'</span>] = <span class="number">100</span>;</span><br><span class="line">        roman_char[<span class="string">'D'</span>] = <span class="number">500</span>;</span><br><span class="line">        roman_char[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size() ; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( i&lt;s.size()<span class="number">-1</span> &amp;&amp; roman_char[s[i]] &lt; roman_char[s[i+<span class="number">1</span>]])&#123;</span><br><span class="line">                res += roman_char[s[i+<span class="number">1</span>]]-roman_char[s[i]];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += roman_char[s[i]];       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扩展问题-异常检测"><a href="#扩展问题-异常检测" class="headerlink" title="扩展问题: 异常检测"></a>扩展问题: 异常检测</h2><p>上面的解法虽然可以通过OJ, 但是此题还需要进行特别的异常诊断, 即要能够判断出当前输入的罗马输出是否合法! 如 “IVIV” 就是典型的不合法输入, 对于此输入, 上面的程序会输出 , 这显然不正确</p><h1 id="014"><a href="#014" class="headerlink" title="014."></a>014.</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-顺序比较"><a href="#解法一-顺序比较" class="headerlink" title="解法一: 顺序比较"></a>解法一: 顺序比较</h2><p>顺序比较所有字符串的值, 直到遇到第一次不相等的位置, 然后输出前面的公共前缀, 需要额外注意处理以下几种特殊情况:<br>输入</p><ul><li>输入为: [] 或 [“”]  应该直接返回””</li><li>输入为: [“abc”]   应该直接返回”abc”</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() ==<span class="number">0</span> || strs[<span class="number">0</span>]==<span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() ==<span class="number">1</span> ) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;strs.size(); k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[k][i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,i);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="020-Valid-Parentheses"><a href="#020-Valid-Parentheses" class="headerlink" title="020. Valid Parentheses"></a>020. Valid Parentheses</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><p>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</p><p>Example 1:</p><p>Input: “()”<br>Output: true<br>Example 2:</p><p>Input: “()[]{}”<br>Output: true<br>Example 3:</p><p>Input: “(]”<br>Output: false<br>Example 4:</p><p>Input: “([)]”<br>Output: false<br>Example 5:</p><p>Input: “{[]}”<br>Output: true</p><h2 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p>时间复杂度: $O(n)$<br>空间复杂度: $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s_brack;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) c=<span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">']'</span>) c=<span class="string">'['</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'&#125;'</span>) c=<span class="string">'&#123;'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!s_brack.empty() &amp;&amp; c ==  s_brack.top()) s_brack.pop();</span><br><span class="line">            <span class="keyword">else</span> s_brack.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s_brack.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="021-Merge-Two-Sorted-Lists"><a href="#021-Merge-Two-Sorted-Lists" class="headerlink" title="021. Merge Two Sorted Lists"></a>021. Merge Two Sorted Lists</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>Example:</p><p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><h2 id="解法一-遍历融合"><a href="#解法一-遍历融合" class="headerlink" title="解法一: 遍历融合"></a>解法一: 遍历融合</h2><p>时间复杂度: $O(min(m,n))$</p><p>空间复杂度: $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur= cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面开关头结点的过程过于复杂, 可以用<code>dummy</code>指针简化这个过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="026-Remove-Duplicates-from-Sorted-Array"><a href="#026-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="026. Remove Duplicates from Sorted Array"></a>026. Remove Duplicates from Sorted Array</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>遍历,  两种写法, 后者相当精简</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> same = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == same)&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                same = nums[i];</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = !nums.empty();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; nums[length<span class="number">-1</span>])</span><br><span class="line">                nums[length++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a>28. Implement strStr()</h1><p>模式匹配, 判断是否为子串</p><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p>Example 1:</p><p>Input: haystack = “hello”, needle = “ll”<br>Output: 2<br>Example 2:</p><p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1<br>Clarification:</p><p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p><h2 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><h2 id="解法二-KMP"><a href="#解法二-KMP" class="headerlink" title="解法二: KMP"></a>解法二: KMP</h2><p>求解next数组: 求解某个位置 $k$ 的next数组值是一个循环的过程, 需要不断检查以 <strong>位置 $k-1$ 的next值</strong> 为下标的元素的 <strong>下一位元素</strong> 与 <strong>当前位置 $k$ 元素</strong> 是否相等, 如果相等, 则 <strong>next[k] = next[k-1]+1</strong>, 如果不相等, 则</p><h1 id="038-Count-and-Say"><a href="#038-Count-and-Say" class="headerlink" title="038. Count and Say"></a>038. Count and Say</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><ol><li>1</li><li>11</li><li>21</li><li>1211</li><li>111221<br>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</li></ol><p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><h2 id="解法一-依次查看上一次的数字"><a href="#解法一-依次查看上一次的数字" class="headerlink" title="解法一: 依次查看上一次的数字"></a>解法一: 依次查看上一次的数字</h2><p><strong>时间复杂度:</strong> $O(nm)$  m为数字字符串的长度<br><strong>空间复杂度:</strong> $O(m)$</p><p>每次根据上一次的数字更新当前的数字字符串, 如此迭代直到达到指定次数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string res=<span class="string">""</span>;</span><br><span class="line">        string temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) res=<span class="string">"1"</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp =<span class="string">""</span>;</span><br><span class="line">                char cur=res[<span class="number">0</span>];</span><br><span class="line">                int count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(int k=<span class="number">0</span>; k &lt; res.size(); k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>( cur == res[k])</span><br><span class="line">                        count++;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        temp = temp + (to_string(count));</span><br><span class="line">                        temp.push_back(cur);</span><br><span class="line">                        cur = res[k];</span><br><span class="line">                        count = <span class="number">1</span>; //重新计数, 当前已经有一个cur了, 所以是<span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp + (to_string(count)); // 由于最后的一部分相同字符串没有加进来, 所以这里额外加一下</span><br><span class="line">                temp.push_back(cur);</span><br><span class="line">                res.swap(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="053-Maximum-Subarray"><a href="#053-Maximum-Subarray" class="headerlink" title="053. Maximum Subarray"></a>053. Maximum Subarray</h1><p>连续子数组的最大和</p><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p><p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><h2 id="解法-记录当前最大值"><a href="#解法-记录当前最大值" class="headerlink" title="解法: 记录当前最大值"></a>解法: 记录当前最大值</h2><p><strong>时间复杂度:</strong> $O(n)$<br>根据数组性质，设置两个变量，一个记录当前的最大值，一个记录当前的子序列之和。首先，如果当前子序列之和为负，那么就是说，从当前位置开始的子序列，比从之前位置开始的子序列大，那么就可以不考虑从之前位置开始的子序列，之前累计的和也被抛弃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum = INT_MIN;  <span class="comment">//数组有可能全负, 所以不能赋值为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; max_sum) max_sum = num; <span class="comment">//主要是为了预防数组中全是负数的情况</span></span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span>(sum!=<span class="number">0</span> &amp;&amp; sum&gt;max_sum) max_sum = sum; <span class="comment">// sum!=0 , 为了预防数组全负时, 0一定大于sum, 造成的错解</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt;<span class="number">0</span>) sum =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>更简洁的写法:</strong> (貌似用max要比用if语句判断快一点???)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            max_sum = max(max_sum, num);</span><br><span class="line">            sum += num;</span><br><span class="line">            max_sum = max(max_sum, sum);</span><br><span class="line">            sum = max(sum, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="066-Plus-One"><a href="#066-Plus-One" class="headerlink" title="066. Plus One"></a>066. Plus One</h1><p>数组代表一个整数, 模拟整数的加法</p><h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p>Example 1:</p><p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.<br>Example 2:</p><p>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p><h2 id="解法一-直接模拟"><a href="#解法一-直接模拟" class="headerlink" title="解法一: 直接模拟"></a>解法一: 直接模拟</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, last_i = digits.size()<span class="number">-1</span>;</span><br><span class="line">        digits[last_i] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits[last_i] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            digits[last_i] = <span class="number">0</span>;</span><br><span class="line">            carry=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = last_i<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; carry ; i--)&#123;</span><br><span class="line">            digits[i] += carry;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &gt; <span class="number">9</span>)</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-不使用加法-更快更简单-击败100"><a href="#解法二-不使用加法-更快更简单-击败100" class="headerlink" title="解法二: 不使用加法(更快更简单, 击败100%)"></a>解法二: 不使用加法(更快更简单, 击败100%)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;   <span class="comment">//未考虑前缀0的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[i] ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="069-Sqrt-x"><a href="#069-Sqrt-x" class="headerlink" title="069. Sqrt(x)"></a>069. Sqrt(x)</h1><p>实现开方算法</p><h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>Implement int sqrt(int x).</p><p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p><p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p><p>Example 1:</p><p>Input: 4<br>Output: 2<br>Example 2:</p><p>Input: 8<br>Output: 2<br>Explanation: The square root of 8 is 2.82842…, and since<br>             the decimal part is truncated, 2 is returned.</p><h2 id="解法一-二分法"><a href="#解法一-二分法" class="headerlink" title="解法一: 二分法"></a>解法一: 二分法</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> low=<span class="number">0</span>, high=x;</span><br><span class="line">        <span class="keyword">double</span> res = high;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(res*res - x) &gt; <span class="number">0.000001</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(res*res &gt; x)&#123;</span><br><span class="line">                high = res;</span><br><span class="line">                res = (low+high)/<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = res;</span><br><span class="line">                res = (low+high)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-牛顿迭代法"><a href="#解法二-牛顿迭代法" class="headerlink" title="解法二: 牛顿迭代法"></a>解法二: 牛顿迭代法</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p><p>相当于求解 $f(res)=res^2 - x = 0$ 中 $res$ 的解. 则对于任意一点 $(res, f(res))$, 都有切线方程:</p><script type="math/tex; mode=display">f(res) - 0 = f'(res)(res-res')</script><p>其中, $res’$ 是该直线与 $x$ 轴的交点. 令新的 $res$ 为该值, 就可以不断逼近 $f(res)$ 的零点, $res’$ 的值为:</p><script type="math/tex; mode=display">res' = res- \frac{f(res)}{f'(res)} = res- \frac{res^2-x}{2\times res} = \frac{res^2 + x}{2\times res}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = x;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(res*res - x) &gt; <span class="number">0.000001</span> )&#123;</span><br><span class="line">            res = (res*res+x) / (<span class="number">2</span>*res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-按位检索"><a href="#解法三-按位检索" class="headerlink" title="解法三: 按位检索"></a>解法三: 按位检索</h2><p><strong>时间复杂度:</strong> $O(1)$<br><strong>空间复杂度:</strong> $O(1)$</p><p>由于本题要返回的是整数, 而上面的两种方法都是针对double类型的精确开根方法, 时间复杂度为 $O(logn)$, 实际上, 当只需要返回整数时, 我们可以按整数的位进行检索, 而整数总共只有32位(传入的x位int型, 所以开根后不可能超过int), 因此时间复杂度只有 $O(32)$ , 也就是 $O(1)$.</p><p><strong>注意:</strong> 由于该方法是首先找到比 x 大的那一位, 因此有可能超过int上限, 所以要换成long整型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( <span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;h) * <span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;h) &lt;= x) h++;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">1</span>&lt;&lt;(h<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>( b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (res+b) * (res+b) &lt;= x)</span><br><span class="line">                res += b;</span><br><span class="line">            b = b/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="070-Climbing-Stairs"><a href="#070-Climbing-Stairs" class="headerlink" title="070. Climbing Stairs"></a>070. Climbing Stairs</h1><p>实际上就是斐波那契数列, 更具体分析可看牛客的跳台阶</p><h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><p>Example 1:</p><p>Input: 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.</p><ol><li>1 step + 1 step</li><li>2 steps<br>Example 2:</li></ol><p>Input: 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.</p><ol><li>1 step + 1 step + 1 step</li><li>1 step + 2 steps</li><li>2 steps + 1 step</li></ol><h2 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n2;</span><br><span class="line">            n2 = n1+n2;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="088-Merge-Sorted-Array"><a href="#088-Merge-Sorted-Array" class="headerlink" title="088. Merge Sorted Array"></a>088. Merge Sorted Array</h1><p>融合两个有序数组, 其中第一个数组的元素长度为n, 第二个为m, 题目假设第一个数组的空间为n+m.</p><h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-后移-插入融合"><a href="#解法一-后移-插入融合" class="headerlink" title="解法一: 后移+插入融合"></a>解法一: 后移+插入融合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =n+m<span class="number">-1</span>; i&gt;=n; i--)</span><br><span class="line">            nums1[i]=nums1[i-n];</span><br><span class="line">        <span class="comment">//for(int i =n; i&lt;n+m; i++) 注意, 这样写是有问题的, 例如对于 [1,2,3,4,0], 这种情况, 从前往后的复制方法会造成元素覆盖</span></span><br><span class="line">          <span class="comment">//  nums1[i]=nums1[i-n];</span></span><br><span class="line">        <span class="keyword">int</span> i =n, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n+m &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                k++; i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                k++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n+m)</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)</span><br><span class="line">            nums1[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="104-minimum-depth-of-binary-tree"><a href="#104-minimum-depth-of-binary-tree" class="headerlink" title="104. minimum depth of binary tree"></a>104. minimum depth of binary tree</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="　题目描述"></a>　题目描述</h2><p>Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>层次优先遍历,遇到的首个叶子结点(左右子树为空)即为最短的深度</p><p>注意:</p><p>利用while内嵌for循环的方式, 可以省去对每个结点depth的维护, 只需要每次进入for循环之前, depth++即可(因为一个for循环会将当前层所有的结点都入队列, for循环结束后, 意味着进入了下一层, 所以depth++即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int run(TreeNode *root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q_node;</span><br><span class="line">        if(root==nullptr) return 0;</span><br><span class="line">        q_node.push(root);</span><br><span class="line">        int depth = 0;</span><br><span class="line">        while(!q_node.empty())&#123;</span><br><span class="line">            const int size = q_node.size();</span><br><span class="line">            depth++;</span><br><span class="line">            for(int i = 0; i&lt; size; i++)&#123;</span><br><span class="line">                TreeNode* node = q_node.front(); q_node.pop();</span><br><span class="line">                if(node-&gt;left!=nullptr) q_node.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right!=nullptr) q_node.push(node-&gt;right);</span><br><span class="line">                if(node-&gt;left==nullptr &amp;&amp; node-&gt;right == nullptr) return depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二(递归):"></a>解法二(递归):</h2><p>让当前结点为空, 则当前结点深度为0, 若当前结点左子树为空, 则当前结点深度等于左子树深度, 反之 ,等于右子树深度. 若当前结点左右子树均不为空, 则当前结点的 <strong>最小深度</strong> 等于左右子树深度 <strong>较小者</strong> 加1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right ==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> depth1=run(root-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> depth2=run(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> depth1&lt;depth2 ? depth1+<span class="number">1</span> : depth2+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习经典算法之SVM深入解析</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%B9%8BSVM%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%B9%8BSVM%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>起初让我最头疼的是拉格朗日对偶和SMO，后来逐渐明白拉格朗日对偶的重要作用是将w的计算提前并消除w，使得优化函数变为拉格朗日乘子的单一参数优化问题。而SMO里面迭代公式的推导也着实让我花费了不少时间。</p><p>对比这么复杂的推导过程，SVM的思想确实那么简单。它不再像logistic回归一样企图去拟合样本点（中间加了一层sigmoid函数变换），而是就在样本中去找分隔线，为了评判哪条分界线更好，引入了几何间隔最大化的目标。</p><p>之后所有的推导都是去解决目标函数的最优化上了。在解决最优化的过程中，发现了w可以由特征向量内积来表示，进而发现了核函数，仅需要调整核函数就可以将特征进行低维到高维的变换，在低维上进行计算，实质结果表现在高维上。由于并不是所有的样本都可分，为了保证SVM的通用性，进行了软间隔的处理，导致的结果就是将优化问题变得更加复杂，然而惊奇的是松弛变量没有出现在最后的目标函数中。最后的优化求解问题，也被拉格朗日对偶和SMO算法化解，使SVM趋向于完美。</p><h1 id="1-支持向量机基本概念及原理"><a href="#1-支持向量机基本概念及原理" class="headerlink" title="1. 支持向量机基本概念及原理"></a>1. 支持向量机基本概念及原理</h1><h2 id="1-1-间隔与支持向量"><a href="#1-1-间隔与支持向量" class="headerlink" title="1.1 间隔与支持向量"></a>1.1 间隔与支持向量</h2><p>给定训练样本集 $D = {(\vec x^{(1)}, y^{(1)}), (\vec x^{(2)},y^{(2)}),..,(\vec x^{(m)},y^{(m)})}, y_i \in \\{-1, +1\\} (二分类问题) , \vec x^{(i)} =(x^{(i)}_1;x^{(i)}_2;…;x^{(i)}_d )$ (注意,这里用的是分号, 表示这是一个列向量), SVM做的事情就是试图把一根”木棍”放在最佳位置, 好让”木棍”的两边都有尽可能大的”间隔”.</p><p>这个”木棍”就叫做”划分超平面”, 可以用下面的线性方程来描述:</p><script type="math/tex; mode=display">\vec w^T\vec x + b = 0</script><p>, 其中 $\vec w =(w_1; w_2;…;  w_d)$ 为 $d$ 维法向量(注意,这里用的是分号, 表示这是一个列向量), $\vec x$ 为”木棍”上的点的坐标, $b$ 为位移项.</p><p>根据点到”直线”的距离公式,我们可以得到样本空间中任意点 $\vec x$ 到超平面 $(\vec w,b)$ 的距离为:</p><script type="math/tex; mode=display">r = \frac{|\vec w^T\vec x+b|}{\|\vec w \|}</script><p>$|\vec w| = \sqrt{w_1^2 + w_2^2 + … + w_d^2}$ 为向量长度(也即向量的L2范式)</p><p><strong>首先假设</strong> 当前的超平面可以将所有的训练样本正确分类, 那么就有如下式子:</p><script type="math/tex; mode=display">\begin{cases} \vec w^T\vec x^{(i)} + b \geq 0, & y^{(i)} = +1 \\ \vec w^T\vec x^{(i)} + b \leq 0, & y_{(i)} = -1 \end{cases}</script><p>上式可以统一写成如下的约束不等式:()</p><script type="math/tex; mode=display">y^{(i)}(\vec w^T\vec x^{(i)} + b) \geq 0</script><p>上面的式子其实是冗余的, 因为假设样本点不在超平面上, 所以不可能出现等于0的情况, 又因为超平面方程两边都乘一个不等于0的数,还是 <strong>同一个超平面</strong>, 因此为了简化问题的表述, 我们对 $\vec w$ 和 $b$ 加上如下约束(这里的1没有什么特别的含义, 可以是任意的常数, 因为这里的点 $\vec x^{(i)}$ 不是超平面上的点, 所以所得值不为0):</p><script type="math/tex; mode=display">\min_i|\vec w^T\vec x^{(i)} +b| = 1</script><p>即离超平面最近的正, 负样本距离超平面的距离为: $\frac{1}{|\vec w|}$ , 我们将这些距离超平面最近的几个训练样本点为定义”支持向量”, 那么, 两个异类支持向量到超平面的距离之和就为 $\gamma = \frac{2}{|\vec w|}$ , 我们将这称为”间隔”.</p><p>同时, 根据此约束, 我们可以消除超分类平面约束的冗余, 得到新的超分类平面约束如下:</p><script type="math/tex; mode=display">y^{(i)}(\vec w^T\vec x^{(i)} + b) \geq 1</script><p>SVM的目的就是找到具有”最大间隔”的划分超平面, 也就是要找到满足约束$y^{(i)}(\vec w^T\vec x^{(i)} + b) \geq 1$中的参数 $\vec w, b$ , 使得其具有最大的间隔 $\gamma$ , 也就:</p><script type="math/tex; mode=display">\arg\max_{\vec w,b}\frac{2}{\|\vec w\|}</script><script type="math/tex; mode=display">s.t. y^{(i)}(\vec w^T \vec x{(i)} +b) \geq 1, i=1,...,m</script><p>显然, 为了最大化间隔 $\gamma$ , 我们仅需要最大化 $|\vec w|^{-1}$ , 这就等于最小化 $|\vec w|^2$, 于是上式等价为:</p><script type="math/tex; mode=display">\arg\min_{\vec w,b} \frac{1}{2}\|\vec w\|^2 = \arg\min_{\vec w,b} \frac{1}{2}\vec w^T\vec w  \tag 1</script><script type="math/tex; mode=display">s.t. y^{(i)}(\vec w^T \vec x{(i)} +b) \geq 1, i=1,...,m</script><p>下图即为SVM示意图, 注意,图中的1可以被任意常数替换(只要前面乘上对应的系数即可, =0说明在超分类平面上, !=0说明在两侧)</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvrusa33dkj20hx0dnmxr.jpg" alt=""></p><p>以上就是线性可分时的SVM基本型(现实中大多数问题是线性不可分的, 所以线性可分的SVM没有太多实用价值)</p><h2 id="1-2-对偶问题求解-vec-w-和-b"><a href="#1-2-对偶问题求解-vec-w-和-b" class="headerlink" title="1.2 对偶问题求解 $\vec w$ 和 $b$"></a>1.2 对偶问题求解 $\vec w$ 和 $b$</h2><h3 id="1-2-1-问题说明"><a href="#1-2-1-问题说明" class="headerlink" title="1.2.1 问题说明"></a>1.2.1 问题说明</h3><p>凸二次规划问题(convex quadratix programming): 目标函数是变量的二次函数, 约束条件是变量的线性不等式</p><p>对偶问题(dual problem):在求出一个问题解的同时, 也给出了另一个问题的解</p><p>我们希望通过求解式(1)来得到具有最大间隔的划分超平面的模型参数,由于该式是一个凸二次规划问题 因此,对该式使用拉格朗日乘子法得到其”对偶问题”</p><p>对于式(1)的每条样本点约束添加拉格朗日乘子 $\alpha^{(i)} \geq 0$, 则该问题的拉格朗日函数为:</p><script type="math/tex; mode=display">L(\vec w,b,\alpha) = \frac{1}{2}\|\vec w\|^2 +\sum_{i=1}^{m}\alpha^{(i)} (1-y^{(i)}(\vec w^T \vec x^{(i)} +b))\tag 2</script><p>其中, $\vec \alpha = (\alpha^{(1)}, \alpha^{(2)},…,\alpha^{(m)}) ,每一个\alpha^{(i)}均为标量$ .接着对 $L(\vec w,b,\vec \alpha)$ 对 $\vec w$ 和 $b$ 求偏导, 并令其为0, 可得:</p><script type="math/tex; mode=display">\frac{\partial L(\vec w,b,\vec \alpha)}{\partial \vec w} = \vec w - \sum_{i=1}^{m} \alpha^{(i)}y^{(i)}\vec x^{(i)} = 0 \tag 3</script><script type="math/tex; mode=display">\frac{\partial L(\vec w,b,\vec \alpha)}{\partial b} = -\sum_{i=1}^{m}\alpha^{(i)} y^{(i)} = 0 \tag 4</script><p>将(3)和(4)代入(2)式中, 消去 $\vec w$ 和 $b$ ( 注意, 这里 $\sum_{i=1}^{m}\alpha^{(i)} y^{(i)} = 0$, 但是不代表 $\alpha^{(i)} y^{(i)} = 0$ ), 可得:</p><script type="math/tex; mode=display">L(\vec w, b, \vec \alpha) = \frac{1}{2}\bigg( \sum_{i=1}^{m}\alpha^{(i)} y^{(i)}\vec x^{(i)} \bigg)^2 + \sum_{i=1}^{m} \alpha^{(i)} - \sum_{i=1}^{m}\alpha^{(i)} y^{(i)} \Big( \sum_{j=1}^{m}\alpha^{(j)} y^{(j)} \vec x^{(j)} \Big)^T \vec x^{(i)} - \sum_{i=1}^{m} \alpha^{(i)} y^{(i)}b</script><script type="math/tex; mode=display">= \sum_{i=1}^{m}\alpha^{(i)} - \frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha^{(i)} y^{(i)} \alpha^{(i)} y^{(j)} \vec x^{(i)T} \vec x^{(j)}</script><p>这里 $\vec x^{(i)},\vec x^{(j)}$ 位置可互换, 为了好看,我将 $\vec x^{(i)}$ 写在了前面. 到此, 我们就得到了式(2)的对偶问题:</p><script type="math/tex; mode=display">\arg\max_{\vec \alpha}  \bigg( \sum_{i=1}^{m}\alpha^{(i)} - \frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha^{(i)} \alpha^{(j)} y^{(i)}  y^{(j)} \vec x^{(i)T} \vec x^{(j)} \bigg) \tag 5</script><script type="math/tex; mode=display">s.t. \sum_{i=1}^{m} \alpha^{(i)} y{(i)} = 0, 其中 \alpha^{(i)} \geq 0</script><p>为了满足原始问题(1) 和对偶问题(5)之间的充分必要条件, 上述推导过程还需要满足KKT(Karush-Kuhn-Tucker)条件(其中前两条已经在上述推导过程中满足) , 即要求:</p><script type="math/tex; mode=display">\begin{cases} \alpha^{(i)} \geq 0 ; \\ y^{(i)} f(\vec x^{(i)}) - 1 \geq 0 ; \\ \alpha^{(i)}(y^{(i)} f(\vec x^{(i)}) - 1 ) = 0. \end{cases}</script><p>当我们解出上式得到 $\vec \alpha$ 后, 就可以通过求得 $\vec w$ 和 $b$ 的值,  进而可得到划分超平面对应的模型:</p><script type="math/tex; mode=display">f(\vec x) = \vec w ^T \vec x +b = \sum_{i=1}^{m} \alpha^{(i)} y^{(i)} \vec x^{(i)T} \vec x +b</script><p>根据KKT条件我们可以轻易得出, 对任意的训练样本 $(\vec x^{(i)} , y^{(i)})$ , 总有 $\alpha^{(i)} = 0$ 或 $y^{(i)} f(\vec x^{(i)}) = 1$ . 若 $\alpha^{(i)} = 0$ , 则该项对应的样本不会出现在求和项中 ; <strong>若 $\alpha^{(i)} &gt; 0$ , 则必有 $y^{(i)} f(\vec x^{(i)}) = 1$ , 这说明该样本点出现在最大间隔边界上, 是一个支持向量. 这显示出支持向量机的一个重要性质: 训练完成后, 大部分的训练样本都不需要保留(该样本对应的系数 $\alpha^{(i)}=0$ ), 最终模型仅与支持向量有关.</strong></p><h3 id="使用SMO算法求对偶问题的解"><a href="#使用SMO算法求对偶问题的解" class="headerlink" title="使用SMO算法求对偶问题的解"></a>使用SMO算法求对偶问题的解</h3><p>从(5)式可以看出, 这仍是一个二次规划问题, 可以使用通用的二次规划法来求解, 但是, 该问题的规模正比于训练样本数量, 在实际任务中使用通用解法会造成很大的开销, 因此, 需要使用更高效的算法—-SMO(Sequential Minimal Optimization, 序列最小算法)</p><p>SMO的基本思路: 先固定 $\alpha^{(i)}$ 之外的所有参数, 然后求 $\alpha^{(i)}$ 上的极值.  但是这里由于 $\alpha^{(i)}$ 之间不是互相独立的, 需要满足约束 $\sum_{i=1}^{m} \alpha^{(i)} y^{(i)} = 0$ , 即一个分量改变, 另一个也要随之改变,因此每次在优化变量中选取两个分量 $\alpha^{(i)}$ 和 $\alpha^{(j)}$ ,并将其他参数固定, 然后在参数初始化后, 不断执行如下两个步骤直至收敛:</p><ul><li>选取一对需要更新的变量 $\alpha^{(i)}$ 和 $\alpha^{(j)}$</li><li>固定 $\alpha^{(i)}$ 和 $\alpha^{(j)}$ 以外的参数, 求解(5)式更新后的 $\alpha^{(i)}$ 和 $\alpha^{(j)}$</li></ul><p>具体的求解过程如下:</p><p>首先假设需要优化的参数是 $\alpha^{(i)}$ 和 $\alpha^{(j)}$ , 于是我们将剩下的分量 $\sum_{k=1,k\neq i,j}^{m} \alpha^{(k)} y^{(k)}$ 固定, 作为常数处理, 可得下式:</p><script type="math/tex; mode=display">\alpha^{(i)} y^{(i)} + \alpha^{(j)} y^{(j)} = -\sum_{k=1,k\neq i,j}^{m} \alpha^{(k)} y^{(k)} = C</script><p>对上式两边同乘以 $y^{(j)}$ ,由于 $y^{(j)}\times y^{(j)} = 1$ 可得:</p><script type="math/tex; mode=display">\alpha^{(j)} = Cy^{(j)} - \alpha^{(i)} y^{(i)} y^{(j)} = y^{(j)}(C - \alpha^{(i)} y^{(i)})</script><p>将上式代入(5)式, 消去变量 $\alpha^{(j)}$ , 得到一个关于 $\alpha^{(i)}$ 的单变量二次规划问题, 所有的常数项用 $C$ 表示, (5)式被转换成如下,:</p><script type="math/tex; mode=display">F(\alpha^{(i)}) = \alpha^{(i)} + \Big( y^{(j)}(C - \alpha^{(i)} y^{(i)}) \Big) - \frac{1}{2}\alpha^{(i)} \alpha^{(i)} y^{(i)}y^{(i)}\vec x^{(i)T}\vec x^{(i)} - \frac{1}{2}\Big( y^{(j)}(C - \alpha^{(i)} y^{(i)}) \Big)^2y^{(j)}y^{(j)}\vec x^{(j)T}\vec x^{(j)}</script><script type="math/tex; mode=display">-  \alpha^{(i)} \Big( y^{(j)}(C - \alpha^{(i)} y^{(i)}) \Big) y^{(i)}y^{(j)}\vec x^{(i)T} \vec x^{(j)}</script><script type="math/tex; mode=display">- \alpha^{(i)}y^{(i)}\sum_{k=1,k\neq i,j}^{m}\alpha^{(k)}y^{(k)}\vec x^{(i)T} \vec x^{(k)} - \Big( y^{(j)}(C - \alpha^{(i)} y^{(i)}) \Big) y^{(j)}\sum_{k=1,k\neq i,j}^{m}\alpha^{(k)}y^{(k)}\vec x^{(j)T}\vec x^{(k)}</script><script type="math/tex; mode=display">= \alpha^{(i)} + \Big( y^{(j)}(C - \alpha^{(i)} y^{(i)}) \Big) - \frac{1}{2}(\alpha^{(i)})^2\vec x^{(i)T}\vec x^{(i)} - \frac{1}{2} \big( C - \alpha^{(i)}y^{(i)} \big)^2 \vec x^{(j)T}\vec x^{(j)} - \alpha^{(i)} \Big( (C - \alpha^{(i)} y^{(i)}) \Big) y^{(i)}\vec x^{(i)T} \vec x^{(j)} - \alpha^{(i)}y^{(i)}v^{(i)} - \big(C- \alpha^{(i)}y^{(i)} \big)v^{(j)} + C</script><script type="math/tex; mode=display">= \alpha^{(i)} + \Big( y^{(j)}(C - \alpha^{(i)} y^{(i)}) \Big) - \frac{1}{2}(\alpha^{(i)})^2K_{i,i} - \frac{1}{2} \big( C - \alpha^{(i)}y^{(i)} \big)^2 K_{j,j} - \alpha^{(i)} \Big( (C - \alpha^{(i)} y^{(i)}) \Big) y^{(i)}K_{i,j} - \alpha^{(i)}y^{(i)}v^{(i)} - \big(C- \alpha^{(i)}y^{(i)} \big)v^{(j)} + C</script><p>上式为了简便, 将 $\vec x^{(i)T}\vec x^{(j)}$ 简记为 $K_{i,j}$ (后文会用K代表核函数, 这里姑且认为此时的核函数 $K$ 为恒等映射),将上式对 $\alpha^{(i)}$ 求导, 并令其等于0, 可得:</p><script type="math/tex; mode=display">\frac{\partial F(\alpha^{(i)})}{\partial \alpha^{(i)}} = 1 - y^{(i)}y^{(j)} - \alpha^{(i)}K_{i,i} + y^{(i)}(C-\alpha^{(i)} y^{(i)})K_{j,j} - \Big( C-\alpha^{(i)}y^{(i)} - \alpha^{(i)} y^{(i)} \Big)y^{(i)}K_{i,j} - y^{(i)}v^{(i)} + y^{(i)}v^{(j)}</script><script type="math/tex; mode=display">=  1-y^{(i)}y^{(j)} -\alpha^{(i)} \Big( K_{i,i} + K_{j,j} - 2K_{i,j}\Big) + Cy^{(i)}K_{j,j} - Cy^{(i)}K_{i,j} - y^{(i)}\big(v^{(i)} -v^{(j)} \big)  = 0</script><p>下面对上式进行变形, 使得可以用 $\alpha_{old}^{(i)}$ 来更新 $\alpha_{new}^{(i)}$ .</p><p>因为SVM对数据点的预测值为: $f(\vec x) = \sum_{i=1}^{m}\alpha^{(i)} y^{(i)} K(\vec x^{(i)},\vec x) + b$, 则 $v^{(i)}$ 以及 $v^{(j)}$ 的值可以表示成:</p><script type="math/tex; mode=display">v^{(i)} = \sum_{k=1,k\neq i,j}^{m} \alpha^{(k)} y^{(k)} K_{i,k} = f(x^{(i)}) - \alpha^{(i)} y^{(i)} K_{i,i} - \alpha^{(j)} y^{(j)} K_{i,j} + b</script><script type="math/tex; mode=display">v^{(j)} = \sum_{k=1,k\neq i,j}^{m} \alpha^{(k)} y^{(k)} K_{j,k} = f(x^{(j)}) - \alpha^{(j)} y^{(j)} K_{j,j} - \alpha^{(i)} y^{(i)} K_{j,i} + b</script><p>将 $\alpha^{(j)} = y^{(j)}(C - \alpha^{(i)} y^{(i)})$ 带到上式, 可得到 $v^{(i)} - v^{(j)}$ 的表达式为:</p><script type="math/tex; mode=display">v^{(i)} - v^{(j)} = f(x^{(i)}) - f(x^{(j)}) - \alpha^{(i)} y^{(i)} K_{i,i} + \Big( y^{(j)}(C - \alpha^{(i)} y^{(i)}) \Big) y^{(j)} K_{j,j} - \Big( y^{(j)}(C - \alpha^{(i)} y^{(i)}) \Big) y^{(j)}K_{i,j} + \alpha^{(i)}y^{(i)}K_{j,i}</script><script type="math/tex; mode=display">= f(x^{(i)}) - f(x^{(j)}) - \alpha^{(i)}y^{(i)}K_{i,i} + CK_{j,j} - \alpha^{(i)}y^{(i)}K_{j,j} - CK_{i,j} + 2\alpha^{(i)}y^{(i)}K_{i,j}</script><script type="math/tex; mode=display">= f(x^{(i)}) - f(x^{(j)}) - \alpha^{(i)}y^{(i)} \Big( K_{i,i} + K_{j,j} -2K_{i,j} \Big)+ CK_{j,j} - CK_{i,j}</script><p><strong>注意 $v^{(i)} - v^{(j)}$ 中 $\alpha^{(i)}$ 是更新前初始化的值, 我们将其记作 $\alpha^{(i)}_{old}$ ,以便与我们期望获得的更新后的分量 $\alpha^{(i)}_{new}$ 相区分</strong> , 将 $v^{(i)} - v^{(j)}$ 的表达式代入 $\frac{\partial F(\alpha^{(i)})}{\partial \alpha^{(i)}_{new}}$ 中 , 可得到:</p><script type="math/tex; mode=display">\frac{\partial F(\alpha^{(i)}_{new})}{\partial \alpha^{(i)}_{new}} = 1-y^{(i)}y^{(j)} -\alpha^{(i)}_{new} \Big( K_{i,i} + K_{j,j} - 2K_{i,j}\Big) + Cy^{(i)}K_{j,j} - Cy^{(i)}K_{i,j} - y^{(i)}\bigg (f(x^{(i)}) - f(x^{(j)}) - \alpha^{(i)}_{old}y^{(i)} \Big( K_{i,i} + K_{j,j} -2K_{i,j} \Big)+ CK_{j,j} - CK_{i,j} \bigg)</script><script type="math/tex; mode=display">= \big( y^{(i)} \big)^2 -y^{(i)}y^{(j)} - y^{(i)}f(x^{(i)}) + y^{(i)}f(x^{(j)}) - \alpha^{(i)}_{new} \Big( K_{i,i} + K_{j,j} - 2K_{i,j}\Big) + \alpha^{(i)}_{old} \Big( K_{i,i} + K_{j,j} - 2K_{i,j}\Big)</script><script type="math/tex; mode=display">=  f(x^{(j)}) - y^{(j)} - \big( f(x^{(i)}) -y^{(i)} \big) - \alpha^{(i)}_{new} \Big( K_{i,i} + K_{j,j} - 2K_{i,j}\Big) + \alpha^{(i)}_{old} \Big( K_{i,i} + K_{j,j} - 2K_{i,j}\Big)</script><p>我们记 $E^{(i)}$ 为SVM预测值与真实值的误差: $E^{(i)} = f(x^{(i)}) - y^{(i)}$ . 并令 $\eta = K_{i,i} + K_{j,j} - 2K_{i,j}$ , 则最终的一阶导数表达式可以简化为:</p><script type="math/tex; mode=display">\frac{\partial F(\alpha^{(i)}_{new})}{\partial \alpha^{(i)}_{new}} = -\eta \alpha^{(i)}_{new} + \eta \alpha^{(i)}_{old} + y^{(i)}\big(E^{(j)} - E^{(i)} \big) = 0</script><p>由此, 我们可以根据当前的参数值, 直接得到更新后的参数值:</p><script type="math/tex; mode=display">\alpha^{(i)}_{new} = \alpha^{(i)}_{old} + \frac{y^{(i)}\big(E^{(j)} - E^{(i)} \big)}{\eta} => \alpha^{(i)}_{new, unclipped} \tag 6</script><p>这里注意, (6)式的推导过程并未考虑下面的约束, 因此, 我们暂且将(6)式中的 $\alpha^{(i)}_{new}$ 记作 $\alpha^{(i)}_{new, unclipped}$, 然后考虑如下约束:</p><script type="math/tex; mode=display">\alpha^{(i)} y^{(i)} + \alpha^{(j)} y^{(j)} = -\sum_{k=1,k\neq i,j}^{m} \alpha^{(k)} y^{(k)} = C</script><script type="math/tex; mode=display">0 \leq \alpha^{(i)} , \alpha^{(j)} \leq C</script><p>我们分别以 $\alpha^{(i)}, \alpha^{(j)}$ 为坐标轴, 于是上述约束可以看作是一个方形约束(Bosk constraint), 在二维平面中我们可以看到这是个限制在方形区域中的直线, 如下图所示, 直线在方形区域内滑动(对应不同的截距), 同时 $\alpha^{(i)}_{new}$ 的上下边界也在改变:</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvsu4x9m5hj20ci0a8wel.jpg" alt=""> <img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvsu4xaa2nj20ca0ae3yn.jpg" alt=""></p><p>当 $y^{(i)} \neq y^{(j)}$ 时(如左图), 限制条件可以写成 $\alpha^{(i)} - \alpha^{(j)} = \xi$ ,根据 $\xi$ 的正负可以得到不同的上下界,   因此 $\alpha^{(i)}_{new}$ 的上下界可以统一表示成:</p><ul><li>下界: $L = \max(0, \alpha^{(i)}_{old} - \alpha^{(j)}_{old})$</li><li>上界: $H = \min(C, C + \alpha^{(i)}_{old} - \alpha^{(j)}_{old})$</li></ul><p>当 $y^{(i)} = y^{(j)}$ 时(如右图), 限制条件可以写成 $\alpha^{(i)} + \alpha^{(j)} = \xi$ , 于是 $\alpha^{(i)}_{new}$ 的上下界为:</p><ul><li>下界: $L = \max(0,\alpha^{(i)}_{old} + \alpha^{(j)}_{old} - C)$</li><li>上界: $H = \min(C, \alpha^{(i)}_{old} + \alpha^{(j)}_{old})$</li></ul><p>根据得到的上下界, 我们可以得到”修剪”后的 $\alpha^{(i)}_{new,clipped}$ :</p><script type="math/tex; mode=display">\alpha^{(i)}_{new,clipped} = \begin{cases} H & \alpha^{(i)}_{new,unclipped} > H \\ \alpha^{(i)}_{new,unclipped} & L \leq \alpha^{(i)}_{new,unclipped} \leq H \\ L & \alpha^{(i)}_{new,unclipped} < L \end{cases} \tag 7</script><p>得到了 $\alpha^{(i)}_{new,clipped}$ 以后, 便可以根据 $\alpha^{(i)}_{old} y^{(i)} + \alpha^{(j)}_{old} y^{(j)}= \alpha^{(i)}_{new}y^{(i)} + \alpha^{(j)}_{new}y^{(j)}$ 得到 $\alpha^{(j)}_{new}$ :</p><script type="math/tex; mode=display">\alpha^{(j)}_{new,clipped} = \alpha^{(j)}_{old} + y^{(i)}y^{(j)}\big( \alpha^{(i)}_{old} - \alpha^{(i)}_{new,clipped}  \big) \tag 8</script><p>通过(7)(8)式, 我们便可以高效的计算出更新后的 $\alpha^{(i)}$ 和 $\alpha^{(j)}$ .</p><p>当更新了一对 $\alpha^{(i)}$ 和 $\alpha^{(j)}$ 之后, 我们需要计算偏移项 $b$ 注意到, 对于任意支持向量 $(\vec x^{(s)} , y^{(s)})$ , 都有 $y^{(s)} f(x^{(s)}) = 1$ , 即:</p><script type="math/tex; mode=display">y^{(s)} \Big( \sum_{i \in S} \alpha^{(i)} y^{(i)} \vec x^{(i)T} \vec x^{(s)} + b\Big) = 1</script><p>式中 $S$ 为所有支持向量的下标集. 理论上, 可以选取任意支持向量来获得 $b$ , 但现实中我们采取更加鲁棒的做法: 使用所有支持向量求解的平均值(式中所有量均已知, $\vec \alpha$ 使用的是支持向量对应的系数):</p><script type="math/tex; mode=display">b = \frac{1}{|S|} \sum_{s\in S} \bigg( \frac{1}{y^{(s)}} - \sum_{i \in S} \alpha^{(i)} y^{(i)}\vec x^{(i)T} \vec x^{(s)} \bigg)</script><p>还有另一种更新 $b$ 的方式是, 只使用当前更新的变量 $\alpha^{(i)}_{new}$ 和 $\alpha^{(j)}_{new}$ 来对 $b$ 进行更新,如此一来, 为了满足KKT条件, 就有以下几种情况:</p><ul><li>如果 $\alpha^{(i)}_{new}$ 在界内(即此时 $0 &lt; \alpha^{(i)}_{new} &lt; C$ , 当前对应样本为支持向量), 则 $b = b^{(i)}_{new}$</li><li>如果 $\alpha^{(j)}_{new}$ 在界内(即此时 $0 &lt; \alpha^{(j)}_{new} &lt; C$ , 当前对应样本为支持向量), 则 $b = b^{(j)}_{new}$</li><li>如果 $\alpha^{(i)}_{new}$ 和 $\alpha^{(j)}_{new}$ 都在界上,且 $L \neq H$时, 则 $b^{(i)}_{new}$ 和 $b^{(j)}_{new}$ 之间的所有的值都符合KKT条件, SMO一般选择终点作为新的偏移量: $b_{new} = \frac{b^{(i)}_{new} + b^{(j)}_{new}}{2}$</li></ul><p>以上讨论中, $b^{(i)}_{new}$ 的推导过程为, 当 $\alpha^{(i)}_{new}$ 在界内时, 对应的样本为支持向量 (根据KKT条件得出) , 此时 $y^{(i)}(\vec w^T \vec x^{(i)} +b) = 1$ , 两边同时乘上 $y^{(i)}$ ,得到 $\sum_{k=1}^{m}\alpha^{(k)}y^{(k)}K_{k,i} + b = y^{(i)}$, 将该式展开, 得到:</p><script type="math/tex; mode=display">b^{(i)}_{new} = y^{(i)} - \sum_{k=1,k\neq i,j}^{m} \alpha^{(k)} y^{(k)}K_{k,i} - \alpha^{(i)}_{new}y^{(i)}K_{i,i} - \alpha^{(j)}_{new}y^{(j)}K_{j,i}</script><p>其中前两项可以写成:</p><script type="math/tex; mode=display">y^{(i)} - \sum_{k=1,k\neq i,j}^{m} \alpha^{(k)} y^{(k)}K_{k,i} = -E^{(i)} + \alpha^{(i)}_{old}y^{(i)}K_{i,i} + \alpha^{(j)}_{old}y^{(j)}K_{j,i} + b_{old}</script><p>于是有:</p><script type="math/tex; mode=display">b^{(i)}_{new} = -E^{(i)} - \big( \alpha^{(i)}_{new} - \alpha^{(i)}_{old} \big)y^{(i)}  K_{i,i} - \big(\alpha^{(j)}_{new} - \alpha^{(j)}_{old}   \big)y^{(j)}K_{j,i} + b_{old}</script><p>同理有:</p><script type="math/tex; mode=display">b^{(j)}_{new} = -E^{(j)} - \big( \alpha^{(j)}_{new} - \alpha^{(j)}_{old} \big)y^{(j)}  K_{j,j} - \big(\alpha^{(i)}_{new} - \alpha^{(i)}_{old}   \big)y^{(j)}K_{i,j} + b_{old}</script><h3 id="如何恰当的选取需要更新的变量-alpha-i-和-alpha-j"><a href="#如何恰当的选取需要更新的变量-alpha-i-和-alpha-j" class="headerlink" title="如何恰当的选取需要更新的变量 $\alpha^{(i)}$ 和 $\alpha^{(j)}$"></a>如何恰当的选取需要更新的变量 $\alpha^{(i)}$ 和 $\alpha^{(j)}$</h3><p>采用启发式的规则来选取, 直觉上我们知道, 我们应该首先优化那些违反KKT条件最严重的样本, 因此我们首先首先遍历所有满足约束条件 $0 &lt; \alpha^{(i)} &lt; C$ 的样本点, 即位于间隔边界上的支持向量点(直觉上也能发现这些点最有可能分类错误), 检验它们是否满足KKT条件. 如果这些样本都满足KKT条件，则遍历整个训练样本集，判断它们是否满足KKT条件，直到找到一个违反KKT条件的变量 $\alpha^{(i)}$ (即使 $\alpha^{(i)}$ 位于边界上,也有可能违反KKT条件).</p><p>当找到了第一个分量 $\alpha^{(i)}$ 后, 接下来寻找第二个分类 $\alpha^{(j)}$, 而选取的标准是使得它有足够大的变化, 也就是说使选取的两变量所对应的样本之间的间隔最大, 一种直观的解释是, 这样的两个变量有很大的差别, 与对两个相似的变量进行更新相比(相似说明有可能属于同一类, 更新意义不大), 对它们进行更新会带给目标函数值更大的变化. 第二个乘子的迭代步长正比于 $|E^{(i)} - E^{(j)}|$ , 因此, 我们希望选择的乘子能够具有最大的 $|E^{(i)} - E^{(j)}|$. 即当 $E^{(i)}$ 为正时选择绝对值最大的赋值 $E^{(j)}$ , 反之, 选择正值最大的 $E^{(i)}$</p><h2 id="1-3-核函数"><a href="#1-3-核函数" class="headerlink" title="1.3 核函数"></a>1.3 核函数</h2><p>在之前的讨论中,我们假设 <strong>训练样本</strong> 是线性可分的, 然而在现实任务中, 原始样本空间内也许并不存在一个能正确划分两类样本的超平面, 对于这样的问题, <strong>可将一样本从原始空间映射到一个更高维的特征空间, 使得样本在这个特征空间内线性可分</strong> .</p><p><strong>需要知道, 如果原始空间是有限维, 即属性数有限, 那么一定存在一个高维特征空间使样本可分</strong></p><p>令 $\phi(\vec x)$ 表示将 $\vec x$ 映射后的特征向量, 于是, 在特征空间中划分超平面所对应的模型可表示为:</p><script type="math/tex; mode=display">f(\vec x) = \vec w^T \phi(\vec x) + b</script><p>类似式(1), 有:</p><script type="math/tex; mode=display">\arg\min_{\vec w,b} \frac{1}{2} \|w\|^2</script><script type="math/tex; mode=display">s.t. y^{(i)}\big( \vec w^T \phi (\vec x^{(i)}) + b \big), i=1,2,..,m</script><p>其对偶问题为:</p><script type="math/tex; mode=display">\arg\max_{\vec \alpha} = \sum_{i=1}^{m}\alpha^{(i)} - \frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha^{(i)} \alpha^{(j)} y^{(i)} y^{(j)} \phi(\vec x^{(i)})^T \phi(\vec x^{(j)}) \tag 9</script><script type="math/tex; mode=display">s.t. \sum_{i=1}^{m} \alpha^{(i)} y^{(i)} = 0, \alpha^{(i)} \geq 0 , i = 1,2,...,m</script><p>求解上式涉及到计算 $\phi(\vec x^{(i)})^T \phi(\vec x^{(j)}$ , 这是样本 $\vec x^{(i)}$ 与 $\vec x^{(j)}$ 映射到特征空间之后的内积, 由于特征空间维数可能很高, 甚至是无穷维, 因此直接计算 $\phi(\vec x^{(i)})^T \phi(\vec x^{(j)}$ 是很困难的, 为了避开这个障碍, 可以设想这样一个函数:</p><script type="math/tex; mode=display">K \big(\vec x^{(i)}, \vec x^{(j)} \big) = \phi(\vec x^{(i)})^T \phi(\vec x^{(j)}</script><p><strong>即 $x^{(i)}$ 与 $x^{(j)}$ 在特征空间的内积等于它们在原始样本空间中通过函数 $K(\cdot, \cdot)$ 计算的结果.</strong> (有可能是先内积再函数映射, 也有可能是求范式再函数映射). 于是(9)式可重写为:</p><script type="math/tex; mode=display">\arg\max_{\vec \alpha} \sum_{i=1}^{m}\alpha^{(i)} - \frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m}\alpha^{(i)} \alpha^{(j)} y^{(i)} y^{(j)} K\big(\vec x^{(i)}, \vec x^{(j)} \big)</script><script type="math/tex; mode=display">s.t. \sum_{i=1}^{m} \alpha^{(i)} y^{(i)} = 0</script><script type="math/tex; mode=display">\alpha^{(i)} \geq 0, i=1,2,...,m</script><p>注意, 前面几个小节的推导过程也用了符号 $K$ , 但是就像前面所说的, 前几个小节的 $K$ 是为了方便书写而使用的, 你可以把它看作是一个恒等映射的核函数</p><p>当我们解出上式得到 $\vec \alpha$ 后, 就可以得到划分超平面对应的模型(式中 $\vec x$ 为样本点, $f(\vec x)$ 为该样本点的预测结果):</p><script type="math/tex; mode=display">f(\vec x) = \vec w ^T \vec x +b = \sum_{i=1}^{m} \alpha^{(i)} y^{(i)} K\big(\vec x, \vec x^{(j)}\big) +b</script><p><strong>核函数定理:</strong> 令 $\chi$ 为输入空间 $K(\cdot, \cdot)$　是定义在　$\chi \times \chi$ 上的对称函数, 则 $K(\cdot, \cdot)$ 是核函数 当且仅当 对于任意数据  $D =  \\{\vec x^{(1)}, \vec x^{(2)},…,\vec x ^{(m)} \\}$ , 核矩阵 $K$ 总是半正定的</p><p>从以上分析可知, 核函数的选择决定了特征空间的好坏, 因此, 一个合适的核函数,就成为了支持向量机的最大变数.</p><p>下面是几种常用的核函数:</p><div class="table-container"><table><thead><tr><th>名称</th><th>表达式</th><th>参数</th></tr></thead><tbody><tr><td>线性核</td><td></td><td></td></tr><tr><td>高斯核</td><td></td><td></td></tr><tr><td>拉普拉斯核</td><td></td><td></td></tr><tr><td>Sigoid核</td><td></td></tr></tbody></table></div><p>此外,还可以通过函数组合得到:</p><ul><li>若 $K_1$ 和 $K_2$ 都是核函数 ,则对任意的正数 $\gamma_1, \gamma_2$ , 其线性组合 $\gamma_1 K_1 + \gamma_2 K_2$ 也是核函数</li><li>若 $K_1$ 和 $K_2$ 为核函数, 则函数的直积 $K_1 \otimes K_2 (\vec x , \vec z) = K_1(\vec x, \vec z) K_2(\vec x, \vec z)$</li><li>若 $K_1$ 是核函数, 则对任意函数 $g(\vec x)$, $K(\vec x, \vec z) = g(\vec x) K_1(\vec x, \vec z) g(\vec z)$ 也是核函数</li></ul><h2 id="1-4-软间隔与正则化"><a href="#1-4-软间隔与正则化" class="headerlink" title="1.4 软间隔与正则化"></a>1.4 软间隔与正则化</h2><p>在实现任务中, 往往很难确定合适的核函数, 使得训练样本在特征空间中线性可分, 即便是找到了, 也无法断定是否是由于过拟合造成的 , 因此, 我们需要 <strong>允许支持向量机在一些样本上出错</strong> , 以缓解上面的问题.</p><p>硬间隔(hard margin)与软间隔(soft margin)的区分:</p><ul><li>硬间隔: 所有样本都必须分类正确</li><li>软间隔: 允许某些样本不满足约束(11)式(即,预测结果和真实结果符号相反,分类错误,或预测结果绝对值小于1,相当于越过了支持向量划定的边界)</li></ul><p>我们要在最大化间隔的同时, 使得不满足约束的样本应尽可能的少, 于是, 优化目标可写为:</p><script type="math/tex; mode=display">\min_{\vec w,b} \frac{1}{2} \|w\|^2 + C\sum_{i=1}^{m} l_{0/1} \big( y^{(i)} (\vec w^T x^{(i)}+b) - 1\big) \tag {10}</script><script type="math/tex; mode=display">y^{(i)} (\vec w^T \vec x^{(i)} +b) \geq 1 \tag {11}</script><p>其中, $C&gt;0$ 是一个常数(注意与前几节推导SVM时的常数区分), $l_{0/1}$ 是 “0/1 损失函数”:</p><script type="math/tex; mode=display">l_{0/1} (z) = \begin{cases}  1, & \text{if } z < 0 ; \\ 0, & \text{otherwise}. \end{cases}</script><p>当C无穷大时, (10)式就会迫使所有样本均满足约束, 也就是令所有训练样本都分类正确(容易产生过拟合), 当C取有限值时, 则允许有一些样本不满足约束(11)式.</p><p>但是, $l_{0/1}$ 非凸, 不连续, 数学性质不好, 因此, 通常使用其他函数来替代, 称为” 替代损失”,  下面为三种常用的替代损失:</p><ul><li>hinge损失: $l_{hinge}(z) = max(0,1-z)$</li><li>指数损失(exponential loss): $l_{exp}(z) = exp(-z)$</li><li>对率损失(logistic loss): $l_{log}(z) = log(1+ exp(-z))$</li></ul><p>假设采用hinge损失损失, 然后可以引入”松弛变量”(slack variables) $\xi^{(i)} \geq 0$ ,每一个样本都有一个对应的松弛变量, 用以表征该样本不满足约束(11)的程度 则可将(10)式重写为:</p><script type="math/tex; mode=display">\min_{\vec w, b, \xi^{(i)}} \frac{1}{2} \|\vec w\|^2 + C \sum_{i=1}^{m} \xi^{(i)} \tag {12}</script><script type="math/tex; mode=display">s.t. y^{(i)} (\vec w^T x^{(i)} + b) \geq 1- \xi ^{(i)}</script><script type="math/tex; mode=display">\xi^{(i)} \geq , i=1,2,...,m.</script><p>可以看出, 上式是与之前推导相似的二次规划问题,  只不过是约束条件变的宽松了(为了允许一些样本犯错), 因此,同样利用拉格朗日乘子法求解, 首先得到上式的拉格朗日函数:</p><script type="math/tex; mode=display">L(\vec w, b, \vec \alpha, \vec \xi, \vec \mu) = \frac{1}{2} \|w\|^2 + C \sum_{i=1}^{m} \xi^{(i)} + \sum_{i=1}^{m}\alpha^{(i)}\big(1- \xi^{(i)} - y^{(i)}(\vec w^T\vec x^{(i)} +b)  \big) - \sum_{i=1}^{m} \mu^{(i)} \xi^{(i)}</script><p>其中, $\alpha^{(i)} \geq 0, \mu^{(i)} \geq 0$ 是拉格朗日乘子, 令 $L(\vec w, b, \vec \alpha, \vec \xi, \vec \mu)$ 对 $\vec w, b, \vec \alpha, \vec \xi$ 求偏导, 并令其为0 , 可得:</p><script type="math/tex; mode=display">\vec w =\sum_{i=1}^{m} \alpha^{(i)} y^{(i)} \vec x^{(i)}</script><script type="math/tex; mode=display">0 = \sum_{i=1}^{m} \alpha^{(i)} y^{(i)}</script><script type="math/tex; mode=display">C = \alpha^{(i)} + \mu^{(i)}</script><p> 得到(12)式对应的对偶问题如下:</p><script type="math/tex; mode=display">\max_{\alpha} \sum_{i=1}^{m} \alpha^{(i)} - \frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha^{(i)} \alpha^{(j)} y^{(i)} y^{(j)} K_{i,j}</script><script type="math/tex; mode=display">s.t. \sum_{i=1}^{m} \alpha^{(i)} y^{(i)} = 0</script><script type="math/tex; mode=display">0 \leq \alpha^{(i)} \leq C , i=1,2,...,m</script><p>可以看到, 此时, $\alpha^{(i)}$ 的约束条件变成了 $0 \leq \alpha^{(i)} \leq C$ , 上式的KKT条件要求为:</p><script type="math/tex; mode=display">\begin{cases} \alpha^{(i)} \geq 0,  \mu^{(i)} \geq 0 \\ y^{(i)}f(\vec x^{(i)}) -1 +\xi^{(i)} \geq 0,  \\ \alpha^{(i)} \big( y^{(i)}f(\vec x^{(i)}) - 1 + \xi^{(i)} \big) = 0, \\ \xi^{(i)} \geq 0, \mu^{(i)} \xi^{(i)} = 0 \end{cases}</script><p>于是, 从KKT条件中我们可以看出, 对任意的训练样本 $(\vec x^{(i)}, y^{(i)})$, 总有 $\alpha^{(i)} = 0$ 或 $y^{(i)} f(\vec x^{(i)}) = 1 - \xi^{(i)}$.</p><ul><li>若 $\alpha^{(i)} = 0$, 则该样本不会对 $f(\vec x)$ 产生影响.</li><li>若 $\alpha^{(i)} &gt; 0$, 则必有 $y^{(i)} f(\vec x^{(i)}) = 1 - \xi^{(i)}$, 即该样本是支持向量</li><li>因为 $C = \alpha^{(i)} + \mu^{(i)}$ , 所以, 若 $\alpha^{(i)} &lt; C$ , 则有 $\mu^{(i)} &gt; 0$ , 进而有 $\xi^{(i)} = 0$, 即该样本在最大间隔边界上(是否也就是支持向量?)</li><li>若 $\alpha^{(i)} = C$ , 则有 $\mu^{(i)} = 0$, 此时若 $\xi^{(i)} \leq 1$, 则该样本落在最大间隔内部, 若 $\xi^{(i)} &gt; 1$, 则该样本被错误分类.</li></ul><p>以上讨论, 我们可以看出, 最终的模型依然只与支持向量有关, 保持了稀疏性(hinge损失有一块平坦的零区域,这使得SVM的解具有稀疏性)</p><p>以上是对使用hinge损失时讨论的情况, 还可以将其替换成别的损失函数以得到其他学习模型, 这些模型的性质与所用的替代函数直接相关, 但它们具有一个共性: 优化目标中的第一项用来描述划分超平面的”间隔”大小, 另一项用来表示训练集上的误差, 可写为更一般的形式:</p><script type="math/tex; mode=display">\min_{f} \Omega(f) + C\sum_{i=1}^{m} l(f(\vec x^{(i)}) , y^{(i)})</script><p>其中, $\Omega(f)$ 称为”结构风险”(structural risk), 用于描述模型 $f$ 自身的性质; 第二项 $C\sum_{i=1}^{m} l(f(\vec x^{(i)})$ 称为”经验风险”(empirical risk), 用于描述模型与训练数据的契合程度. $C$ 用于对二者进行折衷.</p><p>从预测误差的角度来看, 第二项相当于模型误差, 第一项相当于正则化项, 表述了模型本身的性质, 一方面, 这为引入领域知识和用户意图提供了途径, 另一方面, 该信息有助于消减假设空间, 降低过拟合风险</p><h1 id="3-问答"><a href="#3-问答" class="headerlink" title="3. 问答"></a>3. 问答</h1><h2 id="为什么SVM的分类结果仅依赖于支持向量"><a href="#为什么SVM的分类结果仅依赖于支持向量" class="headerlink" title="为什么SVM的分类结果仅依赖于支持向量?"></a>为什么SVM的分类结果仅依赖于支持向量?</h2><p>百机p53</p><h2 id="核函数中不同参数的影响"><a href="#核函数中不同参数的影响" class="headerlink" title="核函数中不同参数的影响"></a>核函数中不同参数的影响</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484495&amp;idx=1&amp;sn=4f3a6ce21cdd1a048e402ed05c9ead91&amp;chksm=fdb699d8cac110ce53f4fc5e417e107f839059cb76d3cbf640c6f56620f90f8fb4e7f6ee02f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484495&amp;idx=1&amp;sn=4f3a6ce21cdd1a048e402ed05c9ead91&amp;chksm=fdb699d8cac110ce53f4fc5e417e107f839059cb76d3cbf640c6f56620f90f8fb4e7f6ee02f9&amp;scene=21#wechat_redirect</a></p><h2 id="既然深度学习技术性能表现以及全面超越SVM-SVM还有存在的必要吗"><a href="#既然深度学习技术性能表现以及全面超越SVM-SVM还有存在的必要吗" class="headerlink" title="既然深度学习技术性能表现以及全面超越SVM, SVM还有存在的必要吗?"></a>既然深度学习技术性能表现以及全面超越SVM, SVM还有存在的必要吗?</h2><h1 id="6-Reference"><a href="#6-Reference" class="headerlink" title="6.Reference"></a>6.Reference</h1><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483937&amp;idx=1&amp;sn=84a5acf12e96727b13fd7d456c414c12&amp;chksm=fdb69fb6cac116a02dc68d948958ee731a4ae2b6c3d81196822b665224d9dab21d0f2fccb329&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483937&amp;idx=1&amp;sn=84a5acf12e96727b13fd7d456c414c12&amp;chksm=fdb69fb6cac116a02dc68d948958ee731a4ae2b6c3d81196822b665224d9dab21d0f2fccb329&amp;scene=21#wechat_redirect</a></p><p>[2] 西瓜书</p><p>[3] <a href="http://www.cnblogs.com/jerrylead/archive/2011/03/18/1988419.html" target="_blank" rel="noopener">http://www.cnblogs.com/jerrylead/archive/2011/03/18/1988419.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/29212107" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29212107</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVM </tag>
            
            <tag> 核函数 </tag>
            
            <tag> SMO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的动态数组</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>反向传播算法完整推导</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E5%AE%8C%E6%95%B4%E6%8E%A8%E5%AF%BC/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E5%AE%8C%E6%95%B4%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h1><h1 id="神经网络计算过程"><a href="#神经网络计算过程" class="headerlink" title="神经网络计算过程"></a>神经网络计算过程</h1><p><strong>对于神经网络中的单个神经元来说</strong>,</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvqptyzt2aj206a05h3yg.jpg" alt=""></p><p>若输入信号为向量 $\vec x=(x_1, x_2, x_3, x_4, x_5)$ , 该层的权重为 $\vec w = (w_1, w_2, w_3, w_4, w_5)$, 偏置项为 $b$ , 那么该层的输出就为(其中$f$为激活函数):</p><script type="math/tex; mode=display">y= f(\sum_{i=1}^{n}w_i x_i +b)</script><p>化简成向量形式($\vec w , \vec x$均为列向量)为:</p><script type="math/tex; mode=display">y = f(\vec w ^T \vec x +b)</script><p>对于多层网络来说, 如下图所示</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvqcl7rwfcj209505omx9.jpg" alt=""></p><p>第一层为输入层, 神经元数量对应原始数据维数, 这一层不对数据进行输出, 直接输出</p><p>第二层为隐藏层, 可以有多个隐藏层, 每层神经元数量为中间特征维数(一般自定), 每层都具有一个权重矩阵, 将输入信号与权重矩阵做点乘运算, 加上偏置量以后按激活函数输出</p><p>第三层为输出层, 同样有一个权重矩阵, 若用于分类, 则神经元数量等于要分类的类别数</p><p>如果激活函数使用sigmoid函数, 则第二层和第三层的输出分别为(第一层输出为原始数据):</p><h1 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明:"></a>符号说明:</h1><ul><li>$x$ : 向量 $x$</li><li>$x_i$ : 向量 $x$ 的第 $i$ 项</li><li>$x^{(i)}$ : 第 $i$ 个样本向量</li><li>$x_j^{(i)} : 第 $i$ 个样本向量中的 第 $j$ 项</li></ul><h1 id="几个重要结论"><a href="#几个重要结论" class="headerlink" title="几个重要结论"></a>几个重要结论</h1><div class="table-container"><table><thead><tr><th>条件说明</th><th>说明及问题</th><th>结论</th></tr></thead><tbody><tr><td>给定如下线性映射函数: <br> $u = W x$ <br> 其中 $x$ 是 $n$ 维向量, $W$ 是 $m\times n$ 的矩阵, $u$ 是 $m$维向量, <br></td><td>假设存在函数 $f(u)$ , 试求 $\nabla _w f$ 及 $\nabla _x f$</td><td>因为 $w_{ij}$ 只与 $u_i, x_j$ 有关(画出矩阵相乘示意图即可), 所以有: <br><br> $\frac{\partial f}{\partial w_{ij}} = \sum_{k=1}^{m}  \frac{\partial f}{\partial u_k} \frac{\partial u_k}{\partial w_{ij}} = \sum_{k=1}^{m} \Big( \frac{\partial f}{\partial u_k} \frac{\partial \sum_{l=1}^{n} (w_{kl} x_l)}{\partial w_{ij}}\Big) = \frac{\partial f}{\partial u_i} \frac{\partial \sum_{l=1}^{n}(w_{il} x_l)} {\partial w_{ij}} = \frac {\partial f}{\partial u_i} x_j$ <br><br> 上式写成矩阵形式为: $\nabla _W f = (\nabla _u f) x^T$ <br><br> 因为 $x_i$与每一个 $u_k$ 都有关, 所以可得:  <br><br> $\frac{\partial f}{x_i} = \sum_{k=1}^{m} \frac{\partial f}{\partial u_k} \frac{\partial u_k}{\partial x_i} = \sum_{k=1}^{m} \Big( \frac{\partial f}{u_k} \frac{\partial \sum_{l=1}^{n} w_{kl} x_l}{\partial x_i} \Big)= \sum_{k=1}^{m} \Big( \frac{\partial f}{u_k} w_{ki} \Big) = [w_{1i}, w_{2i},…, w_{mi}]\left[ \begin{matrix} \frac{\partial f}{u_1} \\ \frac{\partial f}{u_2} \\ … \\ \frac{\partial f}{u_2}  \end{matrix} \right]$ <br><br> 上式写成矩阵形式为: $\nabla _x f = W^T \nabla _u f$</td></tr><tr><td>给定如下向量到向量的映射: <br><br> $z=g(u)$ <br><br> 写成分量形式为: <br><br> $z_i = g(u_i)$ <br><br> 在这里, 每个 $z_i$ 只和 $x_i$ 有关, 且每个分量采用了相同的映射函数$g$</td><td>假设存在函数 $f(z)$, 试求 $\nabla _u f$</td><td>$\frac{\partial f}{\partial u_i} = \frac{\partial f}{\partial z_i} \frac{\partial z_i}{\partial u_i} = \frac{\partial f}{\partial z_i} g’(u_i)$ <br><br> $\nabla _u f = \nabla _z f \odot g’(u)$</td></tr><tr><td>给定下面的复合函数</td><td></td></tr></tbody></table></div><p>#</p><div class="table-container"><table><thead><tr><th>推导过程说明</th><th>详细推导</th><th>简洁推导</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><h1 id="反向传播中的一些特殊环节"><a href="#反向传播中的一些特殊环节" class="headerlink" title="反向传播中的一些特殊环节"></a>反向传播中的一些特殊环节</h1><h2 id="RuLe激活函数的导数"><a href="#RuLe激活函数的导数" class="headerlink" title="RuLe激活函数的导数"></a>RuLe激活函数的导数</h2><p>ReLU 激活函数的公式定义如下:</p><script type="math/tex; mode=display">ReLu(x) = \begin{cases} x, & x > 0 \\ 0, & x\le 0 \end{cases}</script><p>可以看出, RuLu函数在 $x=0$ 处是不可微的, 为了解决这个问题, 在深度学习框架中, 往往会将其在 $x=0$ 处的导数置为0, 如下所示:</p><script type="math/tex; mode=display">ReLu'(x) = \begin{cases} 1, & x > 0 \\ 0, & x\le 0 \end{cases}</script><h2 id="Pooling池化层的反向梯度传播"><a href="#Pooling池化层的反向梯度传播" class="headerlink" title="Pooling池化层的反向梯度传播"></a>Pooling池化层的反向梯度传播</h2><p>CNN网络中另外一个不可导的环节就是Pooling层的池化操作, 因为Pooling操作会使得feature map的尺寸发生变化. 解决这个问题的方法就是把一个该层某个位置的梯度反向传播到前一层所有与这个位置相关联的位置. 这是需要 <strong>保证传递的梯度总和不变.</strong></p><h3 id="max-pooling"><a href="#max-pooling" class="headerlink" title="max pooling"></a>max pooling</h3><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fw9pql38u3j20e205cjrl.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw9pugvbazj20e2058mxh.jpg" alt=""></p><h3 id="mean-pooling"><a href="#mean-pooling" class="headerlink" title="mean pooling"></a>mean pooling</h3><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fw9pud49frj20dl04nglt.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw9pund35ej20e7060aae.jpg" alt=""></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zhuanlan.zhihu.com/p/39195266" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39195266</a></p><p><a href="https://zhuanlan.zhihu.com/pytlab" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/pytlab</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则化技巧总结</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%AD%A3%E5%88%99%E5%8C%96%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%AD%A3%E5%88%99%E5%8C%96%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>为了解决过拟合问题，通常有两种办法，第一是减少样本的特征（即维度），第二就是我们这里要说的”正则化”.</p><p>下面是一些可以帮助缓解过拟合现象的正则化技巧</p><h1 id="使用正则项-Regularization"><a href="#使用正则项-Regularization" class="headerlink" title="使用正则项(Regularization)"></a>使用正则项(Regularization)</h1><h2 id="L1-Regularization"><a href="#L1-Regularization" class="headerlink" title="L1 Regularization"></a>L1 Regularization</h2><p>L1范数为:</p><script type="math/tex; mode=display">\|w\|_1 = |w_1| + |w_2| + ... + |w_n|</script><p>L1正则项如下所示, 其中 $L_0$ 代表原始的不加正则项的损失函数, $L$ 代表加了正则项以后的损失函数, <del>$m$ 则代表训练batch的样本大小</del> :</p><script type="math/tex; mode=display">L = L_0 + \lambda\|w\|_1 = L_0 + \lambda \sum_{w}|w|</script><p>将上式对参数 $w$ 求导如下(由于正则项与 $b$ 无关, 因此参数 $b$ 的导数不变):</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w} = \frac{\partial L_0}{\partial w} + \lambda sign(w)</script><p>上式中 $sign(w)$ 表示 $w$ 的符号, 当 $w&gt;0$ 时, $sign(w)=1$ , 当 $w&lt;0$ 时, $sign(w)=-1$, 为了实现方便, 我们特意规定, 当 $w=0$ 时,  $sign(w) = 0$ , 相当于去掉了正则项.</p><p>因此, 权重 $w$ 的更新表达式可如下表示:</p><script type="math/tex; mode=display">w \to w' = w - \eta \frac{\partial L_0}{\partial w} - \eta \lambda sign(w)</script><h3 id="L1正则化使模型参数稀疏的原理是什么"><a href="#L1正则化使模型参数稀疏的原理是什么" class="headerlink" title="L1正则化使模型参数稀疏的原理是什么?"></a>L1正则化使模型参数稀疏的原理是什么?</h3><h4 id="角度一-解空间性状"><a href="#角度一-解空间性状" class="headerlink" title="角度一: 解空间性状"></a>角度一: 解空间性状</h4><p>“百面机器学习”</p><h4 id="角度二-函数叠加-梯度下降更新公式"><a href="#角度二-函数叠加-梯度下降更新公式" class="headerlink" title="角度二: 函数叠加(梯度下降更新公式)"></a>角度二: 函数叠加(梯度下降更新公式)</h4><p>从以上的更新表达式我们可以看出, 当 $w$ 为正时, L1正则化会将更新后的 $w$ 变的再小一点, 而当 $w$ 为负时, L1正则化会将其变的更大一点—-<strong>因此L1的正则化效果就是让 $w$ 尽可能的向 $0$ 靠近, 即最终的 $w$ 参数矩阵会变的更加稀疏</strong></p><h4 id="角度三-贝叶斯先验"><a href="#角度三-贝叶斯先验" class="headerlink" title="角度三: 贝叶斯先验"></a>角度三: 贝叶斯先验</h4><p>“百面机器学习”</p><h5 id="补充-为什么-L1-和-L2-分别对应拉普拉斯先验和高斯先验"><a href="#补充-为什么-L1-和-L2-分别对应拉普拉斯先验和高斯先验" class="headerlink" title="补充: 为什么 L1 和 L2 分别对应拉普拉斯先验和高斯先验?"></a>补充: 为什么 L1 和 L2 分别对应拉普拉斯先验和高斯先验?</h5><h3 id="为什么权重矩阵稀疏可以防止过拟合"><a href="#为什么权重矩阵稀疏可以防止过拟合" class="headerlink" title="为什么权重矩阵稀疏可以防止过拟合?"></a>为什么权重矩阵稀疏可以防止过拟合?</h3><p>可以从两个方面来理解:</p><p>1）特征选择(Feature Selection)：</p><p>大家对稀疏规则化趋之若鹜的一个关键原因在于它能实现特征的自动选择。一般来说，xi的大部分元素（也就是特征）都是和最终的输出yi没有关系或者不提供任何信息的，在最小化目标函数的时候考虑xi这些额外的特征，虽然可以获得更小的训练误差，但在预测新的样本时，这些没用的信息反而会被考虑，从而干扰了对正确yi的预测。稀疏规则化算子的引入就是为了完成特征自动选择的光荣使命，它会学习地去掉这些没有信息的特征，也就是把这些特征对应的权重置为0。</p><p>2）可解释性(Interpretability)：</p><p>另一个青睐于稀疏的理由是，模型更容易解释。例如患某种病的概率是y，然后我们收集到的数据x是1000维的，也就是我们需要寻找这1000种因素到底是怎么影响患上这种病的概率的。假设我们这个是个回归模型： $y=w1<em>x1+w2</em>x2+…+w1000*x1000+b$ （当然了，为了让 $y$ 限定在 $[0,1]$ 的范围，一般还得加个Logistic函数）。通过学习，如果最后学习到的 $w$ 就只有很少的非零元素，例如只有 5 个非零的 $wi$ ，那么我们就有理由相信，这些对应的特征在患病分析上面提供的信息是巨大的，决策性的。也就是说，患不患这种病只和这5个因素有关，那医生就好分析多了。但如果 1000 个 $wi$ 都非 0，医生面对这 1000 种因素，累觉不爱.</p><h3 id="L0-范式和-L1-范式都能实现稀疏-为什么不选择用-L0-而要用-L1"><a href="#L0-范式和-L1-范式都能实现稀疏-为什么不选择用-L0-而要用-L1" class="headerlink" title="$L0$ 范式和 $L1$ 范式都能实现稀疏, 为什么不选择用 $L0$ 而要用 $L1$?"></a>$L0$ 范式和 $L1$ 范式都能实现稀疏, 为什么不选择用 $L0$ 而要用 $L1$?</h3><p>一是因为L0范数很难优化求解（NP难问题），二是L1范数是L0范数的最优凸近似，而且它比L0范数要容易优化求解</p><h2 id="L2-Regulation-权重衰减-岭回归"><a href="#L2-Regulation-权重衰减-岭回归" class="headerlink" title="L2 Regulation(权重衰减/岭回归)"></a>L2 Regulation(权重衰减/岭回归)</h2><p>L2范数为:</p><script type="math/tex; mode=display">\|w\|_1 = \sqrt {w_1^2 + w_2^2 + ... + w_n^2 }</script><p>L2正则项如下所示, 其中 $L_0$ 代表原始的不加正则项的损失函数, $L$ 代表加了正则项以后的损失函数, <del>式中的系数 $\frac{1}{2}$ 主要是为了消去求导后产生的常数 $2$, 方便表示 (因为可以根据 $\lambda$ 的值来替代这些常数)</del>:</p><script type="math/tex; mode=display">L = L_0 + \lambda\|w\|^2_2 =L_0 + \lambda \sum_{w}w^2</script><p>将上式对参数 $w$ 求导如下:</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w} = \frac{\partial L_0}{\partial w} + 2\lambda w</script><p>则, 权重 $w$ 的更新表达式可如下表示:</p><script type="math/tex; mode=display">w \to w' = w - \eta \frac{\partial L_0}{\partial w} - \eta 2\lambda w</script><p>由于, $\eta, \lambda, m$ 三个值都是正的, 因此, 加上 $L2$ 正则化以后, 权重整体减小了, 这也是”权重衰减”的由来.</p><h3 id="为何权重参数-w-减小就可以防止过拟合"><a href="#为何权重参数-w-减小就可以防止过拟合" class="headerlink" title="为何权重参数 $w$ 减小就可以防止过拟合?"></a>为何权重参数 $w$ 减小就可以防止过拟合?</h3><p>直观解释:</p><p>更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好（这个法则也叫做奥卡姆剃刀），而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果</p><p>“数学一点”的解释:</p><p>过拟合的时候，拟合函数的系数往往非常大，为什么？如下图所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大. 而正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvu4qp7cdwj2067060jri.jpg" alt=""></p><h3 id="L2-范式的好处是什么"><a href="#L2-范式的好处是什么" class="headerlink" title="L2 范式的好处是什么?"></a>L2 范式的好处是什么?</h3><p><strong>防止过拟合:</strong></p><p>最基本的好处是可以提高模型泛化能力, 防止过拟合</p><p><strong>优化计算:</strong></p><p>从优化或者数值计算的角度来说, L2正则化有利于提高模型训练速度, 加快计算</p><p>原因: <a href="https://www.cnblogs.com/callyblog/p/8094745.html" target="_blank" rel="noopener">https://www.cnblogs.com/callyblog/p/8094745.html</a></p><h2 id="L1-和-L2-的区别"><a href="#L1-和-L2-的区别" class="headerlink" title="L1 和 L2 的区别"></a>L1 和 L2 的区别</h2><h3 id="1-L1相对于L2能够产生更加稀疏的模型"><a href="#1-L1相对于L2能够产生更加稀疏的模型" class="headerlink" title="1. L1相对于L2能够产生更加稀疏的模型:"></a>1. L1相对于L2能够产生更加稀疏的模型:</h3><p>原因见上面L1稀疏性的原理</p><h3 id="2-二者梯度下降速度不同"><a href="#2-二者梯度下降速度不同" class="headerlink" title="2. 二者梯度下降速度不同:"></a>2. 二者梯度下降速度不同:</h3><p>根据L1和L2的函数图像可以看出, L1是按照线性函数进行梯度下降的, 而L2则是按照二次函数, 因此, L1在下降时的速度是恒定的, 在接近于0的时候会很快就将参数更新成0 , 而L2在接近于0 时, 权重的更新速度放缓, 使得不那么容易更新为0 :</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvxnikras2j20em0byjsh.jpg" alt=""></p><h3 id="3-二者解空间性状不同"><a href="#3-二者解空间性状不同" class="headerlink" title="3. 二者解空间性状不同:"></a>3. 二者解空间性状不同:</h3><p>这一点也可以解释为什么L1相比于L2更加稀疏的原因</p><h1 id="数据增广-Data-Augmentation"><a href="#数据增广-Data-Augmentation" class="headerlink" title="数据增广(Data Augmentation)"></a>数据增广(Data Augmentation)</h1><p>水平或垂直翻转图像、裁剪、色彩变换、扩展和旋转等等, 也可利用GAN辅助生成(不常用)</p><h1 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h1><p>Dropout是指在深度网络的训练中, 以一定的概率随机的”临时丢弃”一部分神经元节点.  具体来讲, Dropout作用于每份小批量训练数据, 由于其随机丢弃部分神经元的机制, 相当于每次迭代都在训练不同结构的神经网络, 可以被认为是一种实用的大规模深度神经网络的模型继承算法.</p><p>对于包含 $N$ 个神经元节点的网络, 在Dropout的作用下可以看作为 $2^N$ 个模型的集成, 这 $2^N$ 个模型可认为是原始网络的子网络, 它们共享部分权值, 并且拥有相同的网络层数, 而模型整个的参数数目不变, 大大简化了运算.</p><p>对于任意神经元来说, 每次训练中都与一组随机挑选的不同的神经元集合共同进行优化, 这个过程会减弱全体神经元之间的联合适应性, 减少过拟合的风险, 增强泛化能力.</p><p>工作原理和实现:</p><p>应用Dropout包括训练和预测两个阶段, 在训练阶段中, 每个神经元节点需要增加一个概率系数, 在前向传播时, 会以这个概率选择是否丢弃当前的神经元</p><p>在测试阶段的前向传播计算时, 每个神经元的参数都会预先乘以概率系数p, 以恢复在训练中该神经元只有p的概率被用于整个神经网络的前向传播计算</p><h1 id="Drop-Connect"><a href="#Drop-Connect" class="headerlink" title="Drop Connect"></a>Drop Connect</h1><p>Drop Connect 是另一种减少算法过拟合的正则化策略，是 Dropout 的一般化。在 Drop Connect 的过程中需要将网络架构权重的一个随机选择子集设置为零，取代了在 Dropout 中对每个层随机选择激活函数的子集设置为零的做法。由于每个单元接收来自过去层单元的随机子集的输入，Drop Connect 和 Dropout 都可以获得有限的泛化性能 [22]。Drop Connect 和 Dropout 相似的地方在于它涉及在模型中引入稀疏性，不同之处在于它引入的是权重的稀疏性而不是层的输出向量的稀疏性。</p><h1 id="早停"><a href="#早停" class="headerlink" title="早停"></a>早停</h1><p>早停法可以限制模型最小化代价函数所需的训练迭代次数。早停法通常用于防止训练中过度表达的模型泛化性能差。如果迭代次数太少，算法容易欠拟合（方差较小，偏差较大），而迭代次数太多，算法容易过拟合（方差较大，偏差较小）。早停法通过确定迭代次数解决这个问题，不需要对特定值进行手动设置。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/callyblog/p/8094745.html" target="_blank" rel="noopener">https://www.cnblogs.com/callyblog/p/8094745.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种损失函数深入解析</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E5%90%84%E7%A7%8D%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E5%90%84%E7%A7%8D%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="常用损失函数及其形式"><a href="#常用损失函数及其形式" class="headerlink" title="常用损失函数及其形式"></a>常用损失函数及其形式</h1><div class="table-container"><table><thead><tr><th>损失函数</th><th>形式</th></tr></thead><tbody><tr><td>评分损失</td></tr></tbody></table></div><h1 id="各个损失函数详细解析"><a href="#各个损失函数详细解析" class="headerlink" title="各个损失函数详细解析"></a>各个损失函数详细解析</h1><h2 id="绝对值损失"><a href="#绝对值损失" class="headerlink" title="绝对值损失"></a>绝对值损失</h2><p>别名 $L_1$ 损失</p><h2 id="平方损失"><a href="#平方损失" class="headerlink" title="平方损失:"></a>平方损失:</h2><p>平方损失的别名是 $L_2$ 损失</p><p>平方损失函数是由线性模型引出的. 对于最简单的线性模型, 可以用房屋面积和房屋价格来举例子, 假设我们已经知道了一些面积和价格的数据:</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvp6z84393j20bp06kaaa.jpg" alt=""></p><p>将其描绘出来如下图所示:</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvp6z83ngnj20gw0bxgll.jpg" alt=""></p><p>那么, 如果新来了一个面积, 我们能否根据已有的数据来预测它的价格, 这就是线性回归问题. 我们利用一条直线来拟合这些数据, 从而可以得到预测的价格, 如下图所示:</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvp6z83ygvj20gv0bj74d.jpg" alt=""></p><p>将这种最简单的线性回归一般化, 使其成为具有多个变量的线性模型, 就可以用向量的形式来表达, 如下所示:</p><script type="math/tex; mode=display">h_\theta (x) = \theta ^Tx</script><p>对于上面的公式, 我们就可以求出多个不同的 $\theta$, 来得到不同的模型, 但是我们需要知道到底哪些模型是好的, 哪些是不好的, 因此, 就需要引入了评价机制来判断当前的参数 $\theta$ 是好还是坏, 这就引出了平方误差损失函数, 如下所示:</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2} \sum_{i=1}^{m}{(h_\theta(x^{(i)}) - y^{(i)})^2}</script><p>这个公式本身非常好理解, 就是希望我们当前模型的参数 $\theta$ 可以让模型的输出结果与真实结果无限逼近. 但是问题是:</p><p><strong>为什么是平方形式? 对此,数学解释如下:</strong></p><p>一句话说明: <strong>平方损失函数就是对theta的极大似然估计</strong></p><p>首先, 预测结果和真实结果之间肯定是有误差的, 我们假设这个误差是 $\epsilon ^{(i)}$ , 那么就有如下公式:</p><script type="math/tex; mode=display">y^{(i)} = \theta ^T x^{(i)} + \epsilon ^{(i)}</script><p>而一般在实际使用中, 我们的训练数据是海量的, 根据中心极限定力, 我们可以假定误差满足均值为0, 方差为 $\sigma ^2$ 的正态分布, 即 $\epsilon^{(i)} \sim N(0, \sigma ^2)$ :</p><script type="math/tex; mode=display">p(\epsilon^{(i)}) = \frac{1}{\sqrt {2 \pi } \sigma }exp(-\frac{(\epsilon^{(i)})^2}{2 \sigma ^2})</script><p> 这也就是说:</p><script type="math/tex; mode=display">p(y^{(i)} | x^{(i)};\theta) = \frac{1}{\sqrt {2 \pi } \sigma }exp(-\frac{(y^{(i)} - \theta ^T x^{(i)})^2}{2 \sigma ^2})</script><p> $p(y^{(i)} | x^{(i)};\theta)$ 代表在给定的 $x^{(i)}$ 和参数 $\theta$ 下, $y^{(i)}$的分布概率, 这可以看做是在给定的 $\theta$　一个关于 $y$ 和$x$ 的函数. 与之相对的,我们也可以将其视为是关于参数 $\theta$ 的函数,如下所示:</p><script type="math/tex; mode=display">L(\theta) = L(\theta ; X, \vec y) = p(\vec y | X; \theta)</script><p>注意到, $\epsilon^{(i)} , y^{(i)} , x^{(i)}$ 都是独立同分布的, 因此, 根据极大似然定理, 我们希望下面的式子能够取得最大值(也就是在给定数据的情况下, 我们希望找到一组参数 $\theta$ , 来使这些数据出现的概率最大, 也就是概率积最大)</p><script type="math/tex; mode=display">L(\theta) = \prod_{i=1}^{m}{p(y^{(i)} | x{(i)} ; \theta)} = \prod_{i=1}^{m}{\frac{1}{\sqrt{2\pi} \sigma} exp\Big( -\frac{ (y^{(i)} - \theta ^T x^{(i)})^2}{2\sigma ^2} \Big)}</script><p>为方便计算, 对上式取对数, 可得:</p><script type="math/tex; mode=display">l(\theta) = log L(\theta) = log\prod_{i=1}^{m}{\frac{1}{\sqrt{2\pi} \sigma} exp\Big( -\frac{ (y^{(i)} - \theta ^T x^{(i)})^2}{2\sigma ^2} \Big)} = \sum_{i=1}^{m} log \frac{1}{sqrt{2\pi} \sigma} exp\Big( -\frac{(y^{(i)} - \theta ^T x^{(i)})^2}{2\sigma ^2} \Big) = mlog\frac{1}{\sqrt{2\pi} \sigma} - \frac{1}{\sigma ^2}\times \frac{1}{2}\sum_{i=1}^{m}(y^{(i)} - \theta ^T x^{(i)})^2</script><p>为了让上面的式子取值最大, 那我们就只需要令下面的式子取值最小即可:</p><script type="math/tex; mode=display">\frac{1}{2} \sum_{i=1}^{m} ( y^{(i)} - \theta ^T x^{(i)}) ^2</script><p>上面的形式恰好就是我们的平方误差损失函数(通常还需要对上面的损失函数做归一化, 也就是乘上 $\frac{1}{m}$ ), 这也是平方误差损失函数的来源. (但实际上, 要知道, 基于概率假设来说, 不一定非要是平方项, 另外, 无需在意 $\sigma$ 的具体值是什么)</p><h2 id="softmax-交叉熵损失"><a href="#softmax-交叉熵损失" class="headerlink" title="softmax 交叉熵损失"></a>softmax 交叉熵损失</h2><script type="math/tex; mode=display">y_i = softmax(z_j) = \frac{e^{z_j}}{\sum_j e^{z_j}}</script><script type="math/tex; mode=display">E(t,y) = -\sum_j t_j log y_j</script><p>上式中, $t$ 和 $y$ 分别表示神经网络的真实标签和预测输出, 第一个公式代表 softmax 激活函数.</p><h2 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h2><p>首先定义符号说明:</p><ul><li>$p^{(i)}$: 第i个样本类别为1的真实概率(如第i个样本真实类别为1, 则概率为1, 否则为0)</li><li>$o^{(i)}$: 第i个样本预测类别为1的概率</li><li>$p_k^{(i)}$: 第i个样本类别为k的真实概率(如第i个样本真实类别为k, 则概率为1, 否则为0)</li><li>$o_k^{(i)}$: 第i个样本预测类别为k的概率</li></ul><p>面对二分类问题, 损失函数形式为:</p><script type="math/tex; mode=display">J(W,b) = -\Big[\frac{1}{m} \sum_{i=1}{m}\big(y^{(i)}logo^{(i)} + (1-y^{(i)})log(1-o^{(i)})  \big) \Big]</script><p>面对多分类问题, 损失函数形式为:</p><script type="math/tex; mode=display">J(W,b) = -\Big[\frac{1}{m} \sum_{i=1}^{m} \sum_{k=1}^{n} y_k^{(i)} log o_k^{(i)}  \Big]</script><p>交叉熵衡量了两个分布之间的差异性, 当概率相等时, 交叉熵最大, 则损失函数达到最小(因为加了负号)</p><h1 id="损失函数之间的区别和联系"><a href="#损失函数之间的区别和联系" class="headerlink" title="损失函数之间的区别和联系"></a>损失函数之间的区别和联系</h1><h2 id="为什么分类问题要使用交叉熵损失而不用平方损失"><a href="#为什么分类问题要使用交叉熵损失而不用平方损失" class="headerlink" title="为什么分类问题要使用交叉熵损失而不用平方损失?"></a>为什么分类问题要使用交叉熵损失而不用平方损失?</h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ResNet-CVPR2016</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ResNet-CVPR2016/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ResNet-CVPR2016/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/malefactor/article/details/67637785" target="_blank" rel="noopener">https://blog.csdn.net/malefactor/article/details/67637785</a></p><p><strong>文章:</strong> Deep Residual Learning for Image Recognition</p><p><strong>作者:</strong> Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="提出动机"><a href="#提出动机" class="headerlink" title="提出动机"></a>提出动机</h2><p>首先文章提出了一个假设:<br>有一个L层的深度神经网络, 如果我们在上面加入一层, 直观来讲得到的L+1层深度神经网络的效果应该至少不会比L层的差. 因为可以简单的设最后一层为前一层的恒等映射, 并且其它层参数设置不变.</p><p>但是, 通过实验发现, 当网络层数加深时, 网络的性能会下降, 也就是所谓的”模型退化”问题.</p><p>为了解决模型退化问题, 作者在基于以上假设, 作者认为,提出产生模型退化的根本原因很大程度上也许不在于过拟合, 而在于梯度消失问题.</p><p>对比到ResNet结构上就是说, 假设现有一个比较浅的网络（Shallow Net），这时在它后面再加上几个恒等映射层（Identity mapping），这样虽然增加了网络的深度，但理论上来说其性能表现不应该更差，也即更深的网络不应该带来训练集上误差的上升。</p><h2 id="核心理论"><a href="#核心理论" class="headerlink" title="核心理论"></a>核心理论</h2><p><strong>恒等短接(identity shortcut connection):</strong></p><p>ResNet提出的恒等短接模块用于直接跳过一个或多隔层, 以便让离输入层近的网络更加靠近输出层, 残差块的结构如下图所示:</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvo53kxcb0j20q00dsdhq.jpg" alt=""></p><p>他有两层, 每层的函数表达式可如下表示, 其中 $\sigma$ 代表激活函数ReLU:</p><script type="math/tex; mode=display">F(x) = \sigma(W_1 x)</script><script type="math/tex; mode=display">H(x) = F(x) + x()</script><p>首先, 这里的 $H(x)$ 就是这个一块网络模型原始的拟合目标, 而x是这一段网络块的输入, 我们的最终目的是让网络学习从x 到 $H(x)$ 的映射, 也就是说, 我们希望能够让这一块网络学习到 $H(x) = x$ 的恒等映射.  同时, 为了加速计算, 我们不直接学习$H(x) = x$, 而是转而学习$H(x)$ 和 $x$ 之间的残差: $F(x)$.  也就是说, 现在的学习目的变成了 $F(x) = H(x) - x = 0$ . 并且, 由于残差结构学习的是一个恒等映射, 恒等映射在反向传播是, 可以将后一层网络的梯度值直接返回给前一层网络, 并且不会引起梯度消失问题, 因此, 即使网络变深了, 但是该网络的性能至少应该不会降低.</p><p><strong>所以说, ResNet模块学习的只是一个恒等映射, 它可以在增加网络网络深度的同时, 不会降低它们的性能, 由此, 网络模型甚至可以打到上千层同时维持较高的模型性能</strong> (注意,虽然,残差块内部学习的是一个恒等映射, 但是残差块之间并不是恒等映射)</p><p>下图展示了一个34层的深度残差网络结构图, 其中实线部分代表层间的维度不变, 虚线代表需要改变层间维度:</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvo5krsospj20bt0moq5x.jpg" alt=""></p><p>F(x)和x的通道相同，则可直接相加,如果不同,则x需要变维</p><ul><li>实线的Connection部分，表示通道相同，假如都是3x3x64的特征图，由于通道相同，所以采用计算方式为H(x)=F(x)+x</li><li>虚线的的Connection部分，表示通道不同，假如分别是3x3x64和3x3x128的特征图，则应采用相应的方案来变换维度(0填充或者线性变换$W_s x$)</li></ul><p>对于shortcut连接的方式, 作者给出了三个选项:</p><ol><li>使用恒等映射, 如果需要改变输出维度时, 对增加的维度用0来填充, 不会增加任何参数</li><li>在输入输出维度一致时使用恒等映射, 不一致时使用线性投影以保证维度一致, 增加部分参数</li><li>对有所的block均使用线性投影, 大量增加参数</li></ol><p>对这三个选项都进行了实验，发现虽然在效果上 C&gt;B&gt;A，但是差距很小，由于线性变换需要引进额外的参数, 因此不推荐使用C策略，而使用0填充时，可以保证模型的复杂度最低，这对于更深的网络是更加有利的。</p><p><strong>卷积分解简化计算</strong>:</p><p>bottleneck 结构, 如下图所示:</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvo5qezmtkj20fi06vgm3.jpg" alt=""></p><p>在ResNet34中, 采用的是左图的残差结构, 而在ResNet50以上中, 采用的是右图的残差结构, 通过1×1卷积先降维再升维的方式, 来降低参数的数量, 从而减少计算量.</p><h2 id="ResNet架构的一些特点"><a href="#ResNet架构的一些特点" class="headerlink" title="ResNet架构的一些特点"></a>ResNet架构的一些特点</h2><p>224crop</p><p>horizaontal flip</p><p>per-pixel mean subtracted</p><p>标准color augmentation</p><p>在每一层卷积层之后, 激活层之前, 都是用了BN</p><p>使用了msra初始化方法</p><p>使用了SGD</p><p>batch size = 256</p><p>lr 从0.1开始,每当error plateaus(停滞)时, 缩小1/10</p><p><strong>没有使用dropout</strong></p><h2 id="要点提问"><a href="#要点提问" class="headerlink" title="要点提问"></a>要点提问</h2><h3 id="怎样理解所谓的残差-F-x-要比原始目标-H-x-更容易优化呢"><a href="#怎样理解所谓的残差-F-x-要比原始目标-H-x-更容易优化呢" class="headerlink" title="怎样理解所谓的残差 $F(x)$ 要比原始目标 $H(x)$ 更容易优化呢?"></a>怎样理解所谓的残差 $F(x)$ 要比原始目标 $H(x)$ 更容易优化呢?</h3><p>假设我们要学习一种从输入x到输出H(x)的mapping, 最简单的例子, 假设解空间里的函数只有两个，就是在这两个可能的mapping 函数里面选择一个更好的。</p><p>如果是非resnet的情况，那么给定H(5)＝5.1 和H(5)＝5.2 这两个函数映射, 其对应权重参数分别是 $H(x) = w<em>x = 5.1/5 </em> x$  和 $H(x) =w <em> x = 5.2/5 </em> x$ ，这两个函数的w近似的都近似等于1, 或者说一个w是另一个w的1.04/1.02＝1.0196倍. 也就是说，如果用sgd来选择参数w的话，是容易认为两个w很像的(导致训练慢，学错，对数据不敏感)。</p><p>但是resnet就不同了，在resnet下，原输入输出数据相当于变成了H(5)=0.1 H(5)=0.2, 这两个对应的潜在函数变成了 $F(x)=w<em>x = 0.1/5 </em> x$ 和 $H(x) = w<em>x = 0.2/5 </em> x$ , 两个w的关系变成了一个w 是另一个w的0.2／0.1 ＝ 2倍，所以w的选取对于数据集非常敏感了。 这是基于这个原因，resnet里面的参数 w会更加”准确”反映数据的细微变化。</p><h3 id="为什么恒等映射x之前的系数是1-而不是其他的值-比如0-5"><a href="#为什么恒等映射x之前的系数是1-而不是其他的值-比如0-5" class="headerlink" title="为什么恒等映射x之前的系数是1,而不是其他的值, 比如0.5?"></a>为什么恒等映射x之前的系数是1,而不是其他的值, 比如0.5?</h3><p>关于为什么是 $x$　而不是 $\lambda_i x$,<br>主要是因为如果是 $\lambda_i x$ 的话,梯度里面  就会有一项 $\prod_{i=1}^{L-1}{\lambda_i}$，就是从输出到当前层之间经过的 shortcut上的所有$\lambda_i$相乘，假如$\lambda_i$都大于1那经过多层之后就会爆炸，都小于1就会趋向0而引发梯度消失.</p><p>具体公式分析可见下面关于”用简单缩放来替代恒等连接”的讨论</p><h2 id="Identity-Mappings"><a href="#Identity-Mappings" class="headerlink" title="Identity Mappings"></a>Identity Mappings</h2><p>在第一篇ResNet论文中提到, 1202层的ResNet出现了性能退化的问题.  本文主要是对residual block的一个改进, 也就是将BN和ReLU放到计算权重之前进行, 称为”预激活” , 如下图所示:</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvoavon0q5j20rp0dvac3.jpg" alt=""></p><h2 id="关于Deep-ResNet的分析"><a href="#关于Deep-ResNet的分析" class="headerlink" title="关于Deep ResNet的分析"></a>关于Deep ResNet的分析</h2><p><a href="https://blog.csdn.net/wspba/article/details/60750007" target="_blank" rel="noopener">https://blog.csdn.net/wspba/article/details/60750007</a></p><h2 id="用简单缩放来代替恒等连接"><a href="#用简单缩放来代替恒等连接" class="headerlink" title="用简单缩放来代替恒等连接"></a>用简单缩放来代替恒等连接</h2><p>设计一个简单的缩放: $h(x_l) = \lambda_l x_l$ 来代替恒等连接:</p><script type="math/tex; mode=display">x_{l+1} = \lambda_l x_l + F(x_l, W_l)</script><p>于是,继续通过递归我们可以得到:</p><script type="math/tex; mode=display">x_L = (\prod_{i=l}^{L-1}) x_l + \sum_{i=l}^{L-1}{\hat F(x_i, W_i)}</script><p>对上面的式子求导, 可以得到:</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvod04no6qj20da035weh.jpg" alt=""></p><p>可以看到, 在该式子中, 由于 $\lambda$ 连乘项的存在, 可能会使这个因子变的很大或者消失, 从而阻断从短接反向传来的信号, 进而对优化造成困难</p><h2 id="关于Skip-Connections的其他实验"><a href="#关于Skip-Connections的其他实验" class="headerlink" title="关于Skip Connections的其他实验"></a>关于Skip Connections的其他实验</h2><h3 id="Constant-scaling"><a href="#Constant-scaling" class="headerlink" title="Constant scaling"></a>Constant scaling</h3><p>考虑对 $F$ 的缩放, 训练结果显式优化变的更加困难,  因此不建议缩放</p><p>因为 $F$ 对应的是连加项, 不会出现连乘项, 所以不能说因子很指数增长或消失</p><h3 id="Exclusive-gating"><a href="#Exclusive-gating" class="headerlink" title="Exclusive gating"></a>Exclusive gating</h3><h3 id="Shortcut-only-gating"><a href="#Shortcut-only-gating" class="headerlink" title="Shortcut-only gating"></a>Shortcut-only gating</h3><h3 id="1×1-卷积shortcut"><a href="#1×1-卷积shortcut" class="headerlink" title="1×1 卷积shortcut"></a>1×1 卷积shortcut</h3><p>在ResNet34的时候, 使用了1×1的卷积(即方案C),  并且取得了较好的结果,  表明1×1卷尺短接还是有效果的.  但是当残差单元变多时, 并不能起到很好的效果</p><p>值得注意的是1××\times1的卷积捷径连接引入了更多的参数，本应该比恒等捷径连接具有更加强大的表达能力。事实上，shortcut-only gating 和1××\times1的卷积涵盖了恒等捷径连接的解空间(即，他们能够以恒等捷径连接的形式进行优化)。然而，它们的训练误差比恒等捷径连接的训练误差要高得多，这表明了这些模型退化问题的原因是优化问题，而不是表达能力的问题</p><h3 id="Dropout-shortcut"><a href="#Dropout-shortcut" class="headerlink" title="Dropout shortcut"></a>Dropout shortcut</h3><p>这个在统计学上相当于给短接强加了一个 $\lambda=0.5$ 的缩放, 这和constant scaling很类似, 同样阻碍了信号的传播</p><h2 id="激活函数的使用"><a href="#激活函数的使用" class="headerlink" title="激活函数的使用"></a>激活函数的使用</h2><p>通过重新安排激活函数(ReLU和/或BN)来使得 $f$ 成为一个恒等映射. 最原始的残差连接如下图a所示, b~e展示了其他形式. 图中所有单元的组成成分相同, 只是顺序不同, e形式取得了最后的结果, 也就是full pre-activation形式</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvodw0dpnmj20sr0p2433.jpg" alt=""></p><p>对以上形式讨论如下:</p><p><strong>BN after addition:</strong> 图b, 此种做法正好反其道而行之, 此时 $f$ 不仅包含了 ReLU, 还包含了BN, 最终导致的结果就是阻碍了信息的传递, 是性能下降</p><p><strong>ReLU before addition:</strong>  图c, 这是一种很直接的做法, 也很天真,  直接将ReLU移动到加法之前, 这导致了F的输出非负, 然我们我们希望残差函数的值是在政府无穷区间内的</p><p><strong>Post-activation or Pre-activation:</strong> 如图c和d, 图d通过一种非对称的转换, 使得当前块的激活函数成为一个块的预激活项, 具体转换如下图所示:</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvoe4wy57wj20su0iatbc.jpg" alt=""></p><p>对上图的解释就是, 在原始的设计中, 激活函数会对两条路径的下一个残差单元造成影响:</p><script type="math/tex; mode=display">y_{l+1} = f(y_l) + F(f(y_l), W_{l+1})</script><p>而通过这种非对称的转换, 能够让激活函数 $\hat f$ 对于任意的　$l$ , 都只对$F$ 路径造成影响:</p><script type="math/tex; mode=display">y_{l+1} = y_l + F(\hat f(y_l), W_{l+1})</script><p>于是, 新的激活函数就变成了一个恒等映射.</p><p>后激活与预激活的区别是有元素级加法的存在而造成的,一个含有N层的平铺网络，包含有N−1个激活层(BN/ReLU)，而我们如何考虑它们是否是后激活或者预激活都不要紧。但是对附加的分支层来说，激活函数的位置就变得很重要了。只使用ReLU预激活的结果与原始ResNet-110/164的已经很接近。</p><p><strong>只是用ReLU的预激活vs完全预激活</strong></p><p>从图d中, 我们可以看到, ReLU层不与BN层连接使用，因此无法共享BN所带来的好处, 因此, 很自然的,我们将BN层移到ReLU的前面, 最终, 性能获得了较大的提升, 超过了原始ResNet-110/164</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>文章发现预激活的影响具有两个方面:</p><ul><li>由于$f$变成了恒等映射,优化变的更加简单</li><li>在预激活中使用BN能提高模型的正则化能力</li></ul><h1 id="3-ResNet的其它变体"><a href="#3-ResNet的其它变体" class="headerlink" title="3. ResNet的其它变体"></a>3. ResNet的其它变体</h1><h3 id="ResNeXt"><a href="#ResNeXt" class="headerlink" title="ResNeXt"></a>ResNeXt</h3><h3 id="DenseNet"><a href="#DenseNet" class="headerlink" title="DenseNet"></a>DenseNet</h3><p>详见<a href="">DenseNet</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>梯度消失和梯度爆炸问题详解</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E9%97%AE%E9%A2%98%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E9%97%AE%E9%A2%98%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么使用梯度下降来优化神经网络参数？"><a href="#1-为什么使用梯度下降来优化神经网络参数？" class="headerlink" title="1.为什么使用梯度下降来优化神经网络参数？"></a>1.为什么使用梯度下降来优化神经网络参数？</h2><p>反向传播（用于优化神网参数）：根据损失函数计算的误差通过反向传播的方式，指导深度网络参数的更新优化。</p><p>采取反向传播的原因：首先，深层网络由许多线性层和非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数$f(x)$(非线性来自于非线性激活函数），因此整个深度网络可以视为是一个复合的非线性多元函数。</p><p>我们最终的目的是希望这个非线性函数很好的完成输入到输出之间的映射，也就是找到让损失函数取得极小值。所以最终的问题就变成了一个寻找函数最小值的问题，在数学上，很自然的就会想到使用梯度下降来解决。</p><h2 id="2-梯度消失、爆炸会带来哪些影响"><a href="#2-梯度消失、爆炸会带来哪些影响" class="headerlink" title="2.梯度消失、爆炸会带来哪些影响"></a>2.梯度消失、爆炸会带来哪些影响</h2><p>举个例子，对于一个含有三层隐藏层的简单神经网络来说，当梯度消失发生时，接近于输出层的隐藏层由于其梯度相对正常，所以权值更新时也就相对正常，但是当越靠近输入层时，由于梯度消失现象，会导致靠近输入层的隐藏层权值更新缓慢或者更新停滞。这就导致在训练时，只等价于后面几层的浅层网络的学习。</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvmzpstploj20ga08hgpk.jpg" alt=""></p><h2 id="3-产生的原因"><a href="#3-产生的原因" class="headerlink" title="3.产生的原因"></a>3.产生的原因</h2><p>以最简单的网络结构为例，加入有三个隐藏层，每层的神经元个数都是1，且对应的非线性函数为$y_i = \sigma(z_i)=\sigma(w_i x_i + b_i)$（其中 $\sigma$ 为某个激活函数）如下图：</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvmzpsntjdj20cm01qa9y.jpg" alt=""></p><p>现在假设我们需要更新参数 $b_1$ ，那么我们就要求出损失函数对参数 $b_1$ 的导数，根据链式法则，可以写成下面这样：</p><p>而对于激活函数，之前一直使用Sigmoid函数，其函数图像成一个S型，如下所示，它会将正无穷到负无穷的数映射到0~1之间：</p><script type="math/tex; mode=display">S(x) = \frac{1}{1+e^{-x}} = \frac{e^x}{e^x+1}</script><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvmzpspaejj20go0bojrg.jpg" alt=""></p><p>当我们对Sigmoid函数求导时，得到其结果如下：</p><script type="math/tex; mode=display">S(x) = S(x)(1-S(x))</script><p>由此可以得到它Sigmoid函数图像，呈现一个驼峰状（很像高斯函数），从求导结果可以看出，Sigmoid导数的取值范围在0~0.25之间，而我们初始化的网络权值$|w|$通常都小于1，因此，当层数增多时，小于0的值不断相乘，最后就导致梯度消失的情况出现。同理，梯度爆炸的问题也就很明显了，就是当权值$|w|$过大时，导致 $|\sigma’(z)w| &gt; 1$，最后大于1的值不断相乘，就会产生梯度爆炸。</p><p>Sigmoid函数求导图像<br><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvmzpsox2oj20ai06kq39.jpg" alt=""></p><h2 id="4-解决办法"><a href="#4-解决办法" class="headerlink" title="4.解决办法"></a>4.解决办法</h2><p>梯度消失和梯度爆炸本质上是一样的，都是因为网络层数太深而引发的梯度反向传播中的连乘效应。</p><p>解决梯度消失、爆炸主要有以下几种方案：</p><h3 id="4-1-换用Relu、LeakyRelu、Elu等激活函数"><a href="#4-1-换用Relu、LeakyRelu、Elu等激活函数" class="headerlink" title="4.1 换用Relu、LeakyRelu、Elu等激活函数"></a>4.1 换用Relu、LeakyRelu、Elu等激活函数</h3><p>ReLu：让激活函数的导数为1</p><p>LeakyReLu：包含了ReLu的几乎所有有点，同时解决了ReLu中0区间带来的影响</p><p>ELU：和LeakyReLu一样，都是为了解决0区间问题，相对于来，elu计算更耗时一些（为什么）</p><p>具体可以看<a href="#activation">关于各种激活函数的解析与讨论</a></p><h3 id="4-2-BatchNormalization"><a href="#4-2-BatchNormalization" class="headerlink" title="4.2 BatchNormalization"></a>4.2 BatchNormalization</h3><p>BN本质上是解决传播过程中的梯度问题，具体待补充完善，查看<a href="...">BN</a></p><h3 id="4-3-ResNet残差结构"><a href="#4-3-ResNet残差结构" class="headerlink" title="4.3 ResNet残差结构"></a>4.3 ResNet残差结构</h3><p>具体待补充完善，查看<a href="...">ResNet</a></p><h3 id="4-4-LSTM结构"><a href="#4-4-LSTM结构" class="headerlink" title="4.4 LSTM结构"></a>4.4 LSTM结构</h3><p>LSTM不太容易发生梯度消失，主要原因在于LSTM内部复杂的“门（gates）”，具体看<a href="...">LSTM基本原理解析</a></p><h3 id="4-4-预训练加finetunning"><a href="#4-4-预训练加finetunning" class="headerlink" title="4.4 预训练加finetunning"></a>4.4 预训练加finetunning</h3><p>此方法来自Hinton在06年发表的论文上，其基本思想是每次训练一层隐藏层节点，将上一层隐藏层的输出作为输入，而本层的输出作为下一层的输入，这就是逐层预训练。</p><p>训练完成后，再对整个网络进行“微调（fine-tunning）”。</p><p>此方法相当于是找全局最优，然后整合起来寻找全局最优，但是现在基本都是直接拿imagenet的预训练模型直接进行finetunning。</p><h3 id="4-5-梯度剪切、正则"><a href="#4-5-梯度剪切、正则" class="headerlink" title="4.5 梯度剪切、正则"></a>4.5 梯度剪切、正则</h3><p>这个方案主要是针对梯度爆炸提出的，其思想是设值一个剪切阈值，如果更新梯度时，梯度超过了这个阈值，那么就将其强制限制在这个范围之内。这样可以防止梯度爆炸。</p><p>另一种防止梯度爆炸的手段是采用权重正则化，正则化主要是通过对网络权重做正则来限制过拟合，但是根据正则项在损失函数中的形式：</p><p>可以看出，如果发生梯度爆炸，那么权值的范数就会变的非常大，反过来，通过限制正则化项的大小，也可以在一定程度上限制梯度爆炸的发生。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种激活函数整理总结</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="常用激活函数及其导数"><a href="#常用激活函数及其导数" class="headerlink" title="常用激活函数及其导数"></a>常用激活函数及其导数</h1><div class="table-container"><table><thead><tr><th>激活函数</th><th>形式</th><th>导数形式</th></tr></thead><tbody><tr><td>Sigmoid</td><td>$f(x) =\frac{1}{1+e^{-x}}$</td><td>$f’(x)(1-f(x))$</td></tr><tr><td>Tanh</td><td>$f(x) = tanh(x)= \frac{e^x-e^{-x}}{e^x+e^{-x}}$</td><td>$f’(x) = 1-(f(z))^2$</td></tr><tr><td>ReLU</td><td>$f(x)=max(0,x)=\begin{cases} 0 &amp; x \leq 0 \\ x &amp; x&gt;0 \end{cases}$</td><td>$f’(x)=\begin{cases} 0 &amp; x\leq 0 \\ 1 &amp; x&gt;0 \end{cases}$</td></tr><tr><td>Leaky ReLU</td><td>$f(x)=max(0.001 x,x)=\begin{cases} 0.001x &amp; x \leq 0 \\ x &amp; x&gt;0 \end{cases}a$</td><td>$f(x)=max(0.001 x,x)=\begin{cases} 0.001  &amp; x \leq 0 \\ 1 &amp; x&gt;0 \end{cases}$</td></tr><tr><td>PReLU</td><td>$f(x)=max(\alpha x,x)=\begin{cases} \alpha x &amp; x \leq 0 \\ x &amp; x&gt;0 \end{cases}$</td><td>$f(x)=max(\alpha x,x)=\begin{cases} \alpha  &amp; x \leq 0 \\ 1 &amp; x&gt;0 \end{cases}$</td></tr><tr><td>RReLU</td><td>PReLU中的 $\alpha$ 随机取值</td><td></td></tr><tr><td>ELU</td><td>$f(x) = \begin{cases} x &amp; x \geq 0 \\ \alpha(e^x - 1) &amp; x&lt;0 \end{cases}$</td><td>$f(x) = \begin{cases} 1 &amp; x \geq 0 \\ \alpha e^x &amp; x&lt;0 \end{cases}$</td></tr><tr><td>Maxout</td><td>$f(x) = max(w_1^T x + b_1, w_2^T x + b_2)$</td><td>$f(x) = max(w_1, w_2)$</td></tr></tbody></table></div><h1 id="常用激活函数及其导数的图像"><a href="#常用激活函数及其导数的图像" class="headerlink" title="常用激活函数及其导数的图像"></a>常用激活函数及其导数的图像</h1><p>Sigmoid</p><p><img src="https://wx1.sinaimg.cn/mw1024/d7b90c85ly1fvogxnqyyaj20pk0fdt9w.jpg" alt=""></p><p>Tanh</p><p><img src="https://wx1.sinaimg.cn/mw1024/d7b90c85ly1fvogum5rp4j20r20e8dh3.jpg" alt=""></p><p>ReLU</p><p><img src="https://wx1.sinaimg.cn/mw1024/d7b90c85ly1fvogxnqp8rj20q50fmdh1.jpg" alt=""></p><p>LeakyReLU</p><p><img src="https://wx4.sinaimg.cn/mw1024/d7b90c85ly1fvogum6rpej20qq0gt3zu.jpg" alt=""></p><p>PReLU</p><p><img src="https://wx2.sinaimg.cn/mw1024/d7b90c85ly1fvogum6ou5j20qp0htwfv.jpg" alt=""></p><p>RReLU</p><p><img src="https://wx3.sinaimg.cn/mw1024/d7b90c85ly1fvogum8mbfj20qw0gagn1.jpg" alt=""></p><p>ELU</p><p><img src="https://wx3.sinaimg.cn/mw1024/d7b90c85ly1fvogum93q2j20pt0hfmyl.jpg" alt=""></p><h1 id="为什么需要激活函数"><a href="#为什么需要激活函数" class="headerlink" title="为什么需要激活函数"></a>为什么需要激活函数</h1><h2 id="标准说法"><a href="#标准说法" class="headerlink" title="标准说法"></a>标准说法</h2><p>这是由激活函数的性质所决定来, 一般来说, 激活函数都具有以下性质:</p><ul><li><strong>非线性:</strong> 首先,线性函数可以高效可靠对数据进行拟合, 但是现实生活中往往存在一些非线性的问题(如XOR), 这个时候, 我们就需要借助激活函数的非线性来对数据的分布进行重新映射, 从而获得更强大的拟合能力. (这个是最主要的原因, 其他还有下面这些性质也使得我们选择激活函数作为网络常用层)</li><li><strong>可微性:</strong> 这一点有助于我们使用梯度下降发来对网络进行优化</li><li><strong>单调性:</strong> 激活函数的单调性在可以使单层网络保证网络是凸优化的</li><li><strong>$f(x) \approx x:$</strong> 当激活满足这个性质的时候, 如果参数初值是很小的值, 那么神经网络的训练将会很高效(参考ResNet训练残差模块的恒等映射); 如果不满足这个性质, 那么就需要用心的设值初始值( <strong>这一条有待商榷</strong> )</li></ul><p>如果不使用激活函数, 多层线性网络的叠加就会退化成单层网络,因为经过多层神经网络的加权计算，都可以展开成一次的加权计算</p><h2 id="更形象的解释"><a href="#更形象的解释" class="headerlink" title="更形象的解释"></a>更形象的解释</h2><p>对于一些线性不可分的情况, 比如XOR, 没有办法直接画出一条直线来将数据区分开, 这个时候, 一般有两个选择.</p><p>如果已知数据分布规律, 那么可以对数据做线性变换, 将其投影到合适的坐标轴上, 然后在新的坐标轴上进行线性分类</p><p>而另一种更常用的办法, 就是使用激活函数, 以XOR问题为例, XOR问题本身不是线性可分的,</p><p><a href="https://www.zhihu.com/question/22334626" target="_blank" rel="noopener">https://www.zhihu.com/question/22334626</a></p><h2 id="用ReLU解决XOR问题"><a href="#用ReLU解决XOR问题" class="headerlink" title="用ReLU解决XOR问题."></a>用ReLU解决XOR问题.</h2><p>首先, XOR问题如下所示:</p><div class="table-container"><table><thead><tr><th>$x_1$</th><th>$x_2$</th><th>y</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>首先构造一个简单的神经网络来尝试解决XOR问题, 网络结构如下图所示:</p><p><img src="https://wx4.sinaimg.cn/mw1024/d7b90c85ly1fvp2xuesrjj208706v0st.jpg" alt=""></p><p>先来看看不使用激活函数时的情况, 当不使用激活函数时, 整个网络的函数表达式如下所示:</p><script type="math/tex; mode=display">y = f(x_1, x_2; W, c, w ,b) = [w_1, w_2] \bigg( \bigg[\begin{matrix} W_{11} & W_{12} \\ W_{21} & W_{22} \end{matrix} \bigg] \Big[\begin{matrix} x_1 \\ x_2 \end{matrix} \Big]+ \Big[\begin{matrix} c_1 \\ c_2 \end{matrix} \Big] \bigg) + b = (w^TW^T)x + (w^Tc+b) = w'^Tx+b'</script><p>可以看到, 多层无激活函数的网络叠加, 首先是会退化成单层网络, 而对于单层网络, 求解出来的参数 $w’$ 和 $b’$ 无法对非线性的数据进行分类.</p><p>再来看看进入ReLU以后, 是如何解决XOR问题的, 首先, 引入后的公式如下所示:</p><script type="math/tex; mode=display">y = f(x_1, x_2; W, c, w ,b) = [w_1, w_2] max \bigg(0 , \bigg[\begin{matrix} W_{11} & W_{12} \\ W_{21} & W_{22} \end{matrix} \bigg] \Big[\begin{matrix} x_1 \\ x_2 \end{matrix} \Big]+ \Big[\begin{matrix} c_1 \\ c_2 \end{matrix} \Big] \bigg) + b</script><p>可以看到, 此时函数是无法化简, 因为此时引入了非线性的ReLU函数, 于是 ,就可以求得一个参数组合${w,W,c,b}$ 使得对于特定的输入$x_1, x_2$ ,能够得到正确的分类结果 $y$. 至于这个参数组合具体是什么, 这是需要通过梯度下降来不断学习的, 假如我们现在找到了一组参数如下(当然不一定是最优的), 来看看这组参数具体是如何解决XOR问题的:</p><script type="math/tex; mode=display">W=\bigg[ \begin{matrix} 1 & 1 \\ 1 & 1 \end{matrix} \bigg]</script><script type="math/tex; mode=display">c =\Big[ \begin{matrix} 0 \\ -1 \end{matrix}  \Big]</script><script type="math/tex; mode=display">w =\Big[ \begin{matrix} 1 \\ -1 \end{matrix} \Big]</script><script type="math/tex; mode=display">b = 0</script><p>然后, 分别将4种 $x_1, x_2$的值代入上式, 可以得到, y的值如下:</p><div class="table-container"><table><thead><tr><th>$x_1$</th><th>$x_2$</th><th>计算过程</th><th>y</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>$[1, -2] max \bigg(0 , \bigg[\begin{matrix} 1 &amp; 1 \\ 1 &amp; 1 \end{matrix} \bigg] \Big[\begin{matrix} 1 \\ 0 \end{matrix} \Big]+ \Big[\begin{matrix} 0 \\ -1 \end{matrix} \Big] \bigg) + 0$</td><td>1</td></tr><tr><td>0</td><td>1</td><td>$[1, -2] max \bigg(0 , \bigg[\begin{matrix} 1 &amp; 1 \\ 1 &amp; 1 \end{matrix} \bigg] \Big[\begin{matrix} 0 \\ 1 \end{matrix} \Big]+ \Big[\begin{matrix} 0 \\ -1 \end{matrix} \Big] \bigg) + 0$</td><td>1</td></tr><tr><td>1</td><td>1</td><td>$[1, -2] max \bigg(0 , \bigg[\begin{matrix} 1 &amp; 1 \\ 1 &amp; 1 \end{matrix} \bigg] \Big[\begin{matrix} 1 \\ 1 \end{matrix} \Big]+ \Big[\begin{matrix} 0 \\ -1 \end{matrix} \Big] \bigg) + 0$</td><td>0</td></tr><tr><td>0</td><td>0</td><td>$[1, -2] max \bigg(0 , \bigg[\begin{matrix} 1 &amp; 1 \\ 1 &amp; 1 \end{matrix} \bigg] \Big[\begin{matrix} 0 \\ 0 \end{matrix} \Big]+ \Big[\begin{matrix} 0 \\ -1 \end{matrix} \Big] \bigg) + 0$</td><td>0</td></tr></tbody></table></div><h1 id="关于各个激活函数的比较和适用场景"><a href="#关于各个激活函数的比较和适用场景" class="headerlink" title="关于各个激活函数的比较和适用场景"></a>关于各个激活函数的比较和适用场景</h1><p><strong>神经元饱和问题:</strong> 当输入值很大或者很小时, 其梯度值接近于0, 此时, 不管从深层网络中传来何种梯度值, 它向浅层网络中传过去的, 都是趋近于0的数, 进而引发梯度消失问题</p><p><strong>zero-centered:</strong> 如果数据分布不是zero-centered的话就会导致后一层的神经元接受的输入永远为正或者永远为负, 因为 $\frac{\partial f}{\partial w} = x$ , 所以如果x的符号固定,那么 $\frac{\partial f}{\partial w}$ 的符号也就固定了, 这样在训练时, weight的更新只会沿着一个方向更新, 但是我们希望的是类似于zig-zag形式的更新路径 (关于非0均值问题, 由于通常训练时是按batch训练的, 所以每个batch会得到不同的信号, 这在一定程度上可以缓解非0均值问题带来的影响, 这也是ReLU虽然不是非0 均值, 但是却称为主流激活函数的原因之一)</p><div class="table-container"><table><thead><tr><th>激活函数</th><th>优势</th><th>劣势</th><th>适用场景</th></tr></thead><tbody><tr><td>Sigmoid</td><td>可以将数据值压缩到[0,1]区间内</td><td>1. 神经元饱和问题  <br> 2.sigmoid的输出值域不是zero-centered的  <br> 3. 指数计算在计算机中相对来说比较复杂</td><td>在logistic回归中有重要地位</td></tr><tr><td>Tanh</td><td>1. zero-centered: 可以将 $(-\infty, +\infty)$ 的数据压缩到 $[-1,1]$ 区间内 <br> 2.完全可微分的，反对称，对称中心在原点</td><td>1. 神经元饱和问题 <br> 2. 计算复杂</td><td>在分类任务中，双曲正切函数（Tanh）逐渐取代 Sigmoid 函数作为标准的激活函数</td></tr><tr><td>ReLU</td><td>1. 在 $(0,+\infty)$ ,梯度始终为1, 没有神经元饱和问题 <br> 2. 不论是函数形式本身,还是其导数, 计算起来都十分高效 3. 可以让训练过程更快收敛(实验结果表明比sigmoid收敛速度快6倍) <br> 4. 从生物神经理论角度来看, 比sigmoid更加合理</td><td>1. 非zero-centered   <br> 2. 如果输入值为负值, ReLU由于导数为0, 权重无法更新, 其学习速度可能会变的很慢,很容易就会”死”掉(为了克服这个问题, 在实际中, 人们常常在初始化ReLU神经元时, 会倾向于给它附加一个正数偏好,如0.01)</td><td>在卷积神经网络中比较主流</td></tr><tr><td>LeakyReLU</td><td>1. 没有神经元饱和问题 <br> 2. 计算高效 <br> 3. 收敛迅速(继承了ReLU的优点) <br> 4. 神经元不会”死”掉(因为在负值时, 输出不为0, 而是x的系数0.001)</td><td></td><td></td></tr><tr><td>PReLU</td><td>1. 没有神经元饱和问题 <br> 2. 计算高效 <br> 3. 收敛迅速(继承了ReLU的优点) <br> 4. 神经元不会”死”掉(因为在负值时, 输出不为0, 而是x的系数 $\alpha$ ) <br> 5. 相对于Leaky ReLU需要通过先验知识人工赋值, PReLU通过迭代优化来自动找到一个较好的值, 更加科学合理, 同时省去人工调参的麻烦</td><td></td><td></td></tr><tr><td>ELU</td><td>1. 拥有ReLU所有的优点 <br> 2. 形式上更接近于zero-centered <br> 3. 在面对负值输入时,更加健壮</td><td>1. 引入了指数计算, 使计算变的复杂</td><td></td></tr><tr><td>Maxout</td><td>1. 跳出了点乘的基本形式 <br> 2. 可以看作是ReLU和Leaky ReLU 的一般化形式 3. linear Regime(啥意思?)! <br> 4. 在所有输入范围上都没有神经元饱和问题 <br> 5. 神经元永远不会”死”掉 <br> 6. 拟合能力非常强，它可以拟合任意的的凸函数。作者从数学的角度上也证明了这个结论，即只需2个maxout节点就可以拟合任意的凸函数了(相减)，前提是”隐含层”节点的个数可以任意多</td><td>1. 使得神经元个数和参数个数加倍, 导致优化困难</td></tr></tbody></table></div><h1 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h1><h2 id="sigmoid-和softmax区别"><a href="#sigmoid-和softmax区别" class="headerlink" title="sigmoid 和softmax区别"></a>sigmoid 和softmax区别</h2><p>sigoid是将一个正负无穷区间的值映射到(0,1)区间, 通常用作二分类问题,而softmax把一个k维的实值向量映射成一个$(b_1,b_2,…,b_k)$ ,其中$b_i$为一个0~1的常数, 且它们的和为1, 可以看作是属于每一类的概览,通常用作多分类问题. 在二分类问题中, sigmoid和softmax是差不多的, 都是求交叉熵损失函数, softmax可以看作是sigmoid的扩展, 当类别k为2时, 根据softmax回归参冗余的特点, 可以将softmax函数推导成sigmoid函数</p><p><a href="https://www.jianshu.com/p/22d9720dbf1a" target="_blank" rel="noopener">https://www.jianshu.com/p/22d9720dbf1a</a></p><h2 id="其他更多激活函数"><a href="#其他更多激活函数" class="headerlink" title="其他更多激活函数"></a>其他更多激活函数</h2><p><a href="https://www.jiqizhixin.com/articles/2017-10-10-3" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2017-10-10-3</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>优先使用ReLU, 同时要谨慎设置初值和学习率 ( 实际操作中，如果你的learning rate 很大，那么很有可能你网络中的40%的神经元都”dead”了。 当然，如果你设置了一个合适的较小的learning rate，这个问题发生的情况其实也不会太频繁 )</li><li>尝试使用LeakyReLU/PReLU/Maxout/ELU等激活函数</li><li>可以试下tanh, 但是一般不会有太好的结果</li><li><strong>不要使用sigmoid</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Batch-Normalization深入解析</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Batch-Normalization%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Batch-Normalization%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>BN:总的来说，BN通过将每一层网络的输入进行normalization，保证输入分布的均值与方差固定在一定范围内，减少了网络中的Internal Covariate Shift问题，并在一定程度上缓解了梯度消失，加速了模型收敛；并且BN使得网络对参数、激活函数更加具有鲁棒性，降低了神经网络模型训练和调参的复杂度；最后BN训练过程中由于使用mini-batch的mean/variance每次都不同，引入了随机噪声，在一定程度上对模型起到了正则化的效果。</p><h1 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h1><p>字面上意思就是标准化,也就是对输入的数据做标准化,可以用下面的公式表示(这里 $x_i$ 代表输入数据, n代表训练集大小):</p><script type="math/tex; mode=display">\mu = \frac{1}{n}\sum_{i=1}^{n}{x_i}</script><script type="math/tex; mode=display">\sigma^2 = \frac{1}{n} \sum_{i=1}^{n}{(x_i - \mu)}</script><script type="math/tex; mode=display">\hat x_i = \frac{x_i - \mu}{\sqrt{\sigma^2}+\varepsilon}</script><p>以上可以看出, 标准化以后的数据服从均值为0,方差为1的正态分布</p><h1 id="为什么要进行Normalization"><a href="#为什么要进行Normalization" class="headerlink" title="为什么要进行Normalization?"></a>为什么要进行Normalization?</h1><p>在介绍BN之前,先说说为什么要进行Normalization</p><p><img src="https://morvanzhou.github.io/static/results/ML-intro/NB2.png" alt=""></p><p>在神经网络中, 数据分布对训练会产生影响. 比如某个神经元 x 的值为1, 某个 Weights 的初始值为 0.1, 这样后一层神经元计算结果就是 Wx = 0.1; 又或者 x = 20, 这样 Wx 的结果就为 2. 现在还不能看出什么问题, 但是, 当我们加上一层激励函数, 激活这个 Wx 值的时候, 问题就来了. 如果使用 像 tanh 的激励函数, Wx 的激活值就变成了 ~0.1 和 ~1, 接近于 1 的部已经处在了 激励函数的饱和阶段, 也就是如果 x 无论再怎么扩大, tanh 激励函数输出值也还是接近1. 换句话说, 神经网络在初始阶段已经不对那些比较大的 x 特征范围 敏感了. 这样很糟糕, 想象我轻轻拍自己的感觉和重重打自己的感觉居然没什么差别, 这就证明我的感官系统失效了. 当然我们是可以用之前提到的对数据做 normalization 预处理, 使得输入的 x 变化范围不会太大, 让输入值经过激励函数的敏感部分. 但刚刚这个不敏感问题不仅仅发生在神经网络的输入层, 而且在隐藏层中也经常会发生.</p><p><strong>Normalization的效果:</strong></p><p><img src="https://morvanzhou.github.io/static/results/ML-intro/NB5.png" alt=""><br>如上图,当没有进行normalizatin时,数据的分布是任意的,那么就会有大量的数据处在激活函数的敏感区域外, 对这样的数据分布进行激活后, 大部分的值都会变成1或-1,造成激活后的数据分布不均衡,而如果进行了Normallizatin,  那么相对来说数据的分布比较均衡,如下图所示:</p><p><img src="https://morvanzhou.github.io/static/results/ML-intro/NB6.png" alt=""></p><p><strong>一句话总结就是: 通过Normalization让数据的分布始终处在激活函数敏感的区域</strong></p><h1 id="BN的提出背景"><a href="#BN的提出背景" class="headerlink" title="BN的提出背景"></a>BN的提出背景</h1><p><a href="https://zhuanlan.zhihu.com/p/34879333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34879333</a></p><h2 id="Internal-Covariate-Shift"><a href="#Internal-Covariate-Shift" class="headerlink" title="Internal Covariate Shift"></a>Internal Covariate Shift</h2><p>Covariate [kʌ’veərɪrt]</p><p><strong>什么是Internal Covariate Shift:</strong></p><p>在深层网络训练的过程中，由于网络中参数变化而引起内部结点数据分布发生变化的这一过程被称作Internal Covariate Shift。</p><p><strong>带来了什么问题:</strong></p><ul><li>上层网络需要不停调整来适应输入数据分布的变化，导致网络学习速度的降低</li><li>网络的训练过程容易陷入梯度饱和区,减缓网络收敛速度</li></ul><p><strong>如何减缓Internal Covariate Shift:</strong></p><p>(1)白化(PCA白化和ZCA白化):</p><ul><li>使得输入特征分布具有相同的均值与方差</li><li>取出特征之间的相关性</li><li>通过白化操作，我们可以减缓ICS的问题，进而固定了每一层网络输入分布，加速网络训练过程的收敛</li></ul><p>白化缺点:</p><ul><li><strong>白化过程计算成本太高</strong>，并且在每一轮训练中的每一层我们都需要做如此高成本计算的白化操作；</li><li><strong>白化过程由于改变了网络每一层的分布</strong>，因而改变了网络层中本身数据的表达能力。底层网络学习到的参数信息会被白化操作丢失掉。</li></ul><p>于是就提出了BN</p><h1 id="什么是Batch-Normalization"><a href="#什么是Batch-Normalization" class="headerlink" title="什么是Batch Normalization"></a>什么是Batch Normalization</h1><p>传统的Normalization使用的均值和方差是整个训练集的均值和方差, 并且只对输入层的数据做归一化, 而Batch Normalization按字面意思就是对每一批数据进行归一化, 同时会对每一层输入做归一化, 所以, 首先要将传统的标准化中的n改为m, m表示一个batch的大小,如下所示:</p><script type="math/tex; mode=display">\mu = \frac{1}{m}\sum_{i=1}^{m}{x_i}</script><script type="math/tex; mode=display">\sigma^2 = \frac{1}{m} \sum_{i=1}^{m}{(x_i - \mu)}</script><script type="math/tex; mode=display">\hat x_i = \frac{x_i - \mu}{\sqrt{\sigma^2}+\varepsilon}</script><p>传统的Normalization直接使用了减均值除方差的方式来进行标准化, 但是, 这样一概而全的方法未必对所有数据来说就是最优的, 比如数据本身就不对称, 或者激活函数未必对方差为1的数据有最好的效果, 所以, BN的想法是在传统标准化之后再加上一个线性变换,如下所示:</p><script type="math/tex; mode=display">\hat y_i = \gamma \hat x_i + \beta</script><p>其中,$\gamma$ 和 $\beta$ 是两个需要学习的参数, <strong> 可以看出, BN的本质就是利用参数优化来改变一下数据分布的方差大小和均值的位置. </strong></p><h1 id="BN的优点"><a href="#BN的优点" class="headerlink" title="BN的优点"></a>BN的优点</h1><p>（1）BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</p><p>（2）BN使得模型对初始化方法和网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</p><p>（3）BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</p><p>（4）BN具有一定的正则化效果</p><p>原因如下:</p><p><strong>（1）BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</strong></p><p>BN通过规范化与线性变换使得每一层网络的输入数据的均值与方差都在一定范围内，使得后一层网络不必不断去适应底层网络中输入的变化，从而实现了网络中层与层之间的解耦，更加有利于优化的过程,提高整个神经网络的学习速度。</p><p><strong>（2）BN使得模型对初始化方法和网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</strong></p><p>在神经网络中，我们经常会谨慎地采用一些权重初始化方法（例如Xavier）或者合适的学习率来保证网络稳定训练。当学习率设置太高时，会使得参数更新步伐过大，容易出现震荡和不收敛…<br><a href="https://zhuanlan.zhihu.com/p/34879333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34879333</a></p><p><strong>（3）BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</strong></p><p>在不使用BN层的时候，由于网络的深度与复杂性，很容易使得底层网络变化累积到上层网络中，导致模型的训练很容易进入到激活函数的梯度饱和区；通过normalize操作可以让激活函数的输入数据落在梯度非饱和区，缓解梯度消失的问题；另外通过自适应学习 $\gamma$ 与 $\beta$ 又让数据保留更多的原始信息。</p><p><strong>（4）BN具有一定的正则化效果</strong></p><p>在Batch Normalization中，由于我们使用mini-batch的均值与方差作为对整体训练样本均值与方差的估计，尽管每一个batch中的数据都是从总体样本中抽样得到，但不同mini-batch的均值与方差会有所不同，这就为网络的学习过程中增加了随机噪音，与Dropout通过关闭神经元给网络训练带来噪音类似，在一定程度上对模型起到了正则化的效果。</p><p><strong>另外，原作者也证明了网络加入BN后，可以丢弃Dropout，模型也同样具有很好的泛化效果。</strong></p><h1 id="BN的具体实现及其反向传播"><a href="#BN的具体实现及其反向传播" class="headerlink" title="BN的具体实现及其反向传播"></a>BN的具体实现及其反向传播</h1><p><a href="https://www.jianshu.com/p/4270f5acc066" target="_blank" rel="noopener">https://www.jianshu.com/p/4270f5acc066</a><br><a href="https://zhuanlan.zhihu.com/p/27938792" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27938792</a></p><p>在Caffe2实现中, BN层需要和Scale层配合使用, 其中, BN专门用于做归一化操作, 而后续的线性变换层, 会交给Scale层去做.</p><p>训练阶段:<br>在训练时利用当前batch的mean和variance来进行BN处理, 同时使用滑动平均的方式不断的更新global 的mean和variance, 并将其存储起来.</p><p>测试阶段:<br>在预测阶段, 直接使用模型存储好的均值和方差进行计算</p><h1 id="使用BN时应注意的问题"><a href="#使用BN时应注意的问题" class="headerlink" title="使用BN时应注意的问题"></a>使用BN时应注意的问题</h1><ol><li>训练/测试阶段的使用</li></ol><p>在实际应用中, 均值和方差是通过滑动平均方法在训练数据集上得到的, 如果换了其他的任务或数据集, 建议先finetune之后再使用BN层存储的均值和方差.  同时, 注意训练时的均值和方差是来自于当前batch的.</p><ol><li>隐藏层中BN的数据大小</li></ol><p><del>在卷积网络隐藏层中, BN的大小不单单是batch, 而是batch和特征相应图大小的乘积. 也就是说, 在隐藏层, 层的输入是上一层的输出, 也就是上一层的神经元个数, 而对于上一层来说, 如果输出的特征相应图大小为 $w\times h$ , 那么上一层的神经元个数就应该是 $b\times w \times h$, 其中,b是指batch的大小</del></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种初始化方法整理总结</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化方法概览"><a href="#初始化方法概览" class="headerlink" title="初始化方法概览"></a>初始化方法概览</h1><div class="table-container"><table><thead><tr><th>初始化方法</th><th>说明</th></tr></thead><tbody><tr><td>均匀分布</td><td></td></tr><tr><td>高斯分布</td><td>初始化为服从 $N(\mu, \sigma ^2)$ 的高斯分布</td></tr><tr><td>xavier</td><td></td></tr><tr><td>msra</td><td></td></tr><tr><td>双线性初始化</td></tr></tbody></table></div><h1 id="初始化方法详细说明"><a href="#初始化方法详细说明" class="headerlink" title="初始化方法详细说明"></a>初始化方法详细说明</h1><h2 id="Xavier-‘zeiviə’"><a href="#Xavier-‘zeiviə’" class="headerlink" title="Xavier(‘zeiviə’)"></a>Xavier(‘zeiviə’)</h2><p><strong>核心理念是: 优秀的初始化方法应该使得各层的激活值和状态梯度在传播过程中的方差保持一致</strong></p><p>也就是说, 假如网络某一层函数表示如下:</p><script type="math/tex; mode=display">z^{(i)} = W^{(i)} x^{(i-1)}</script><script type="math/tex; mode=display">x^{(i)} = f(z^{(i)}), i=1,2,..</script><p>那么, 好的初始化应该可以满足下面的条件:</p><script type="math/tex; mode=display">\forall (i,j), Var(x^i) = Var(x^j)</script><script type="math/tex; mode=display">\forall (i,j), Var(\frac{\partial Loss}{\partial z^i}) = Var(\frac{\partial Loss}{\partial z^j})</script><p>再继续推导之前, 需要先提出以下假设:</p><ul><li>首先,输入数据来说,其均值和方差应满足: $E(x)=0, Var(x)=1$ (通过BN,较容易满足)</li><li>权重矩阵 $W$ 和 网络输入 $x$ 互相独立</li><li>每层输入的每个特征方差一样</li><li>激活函数对称: 这主要是为了满足均值为0的假设</li><li>激活函数是线性的, 也就是说其导数为1</li><li>初始时, 状态值落在激活函数的线性区域, 即此时导数为1</li></ul><p>根据状态梯度和参数的梯度公式($l$ 代表层数):</p><script type="math/tex; mode=display">\frac{\partial Loss}{\partial z_k^i} = f'(z_k^i)(W_{.,k}^{i+1})^T \frac{\partial Loss}{\partial z^{i+1}}</script><script type="math/tex; mode=display">\frac{\partial Loss}{\partial w_{l,k}^i} = h_l^{i-1} \frac{\partial Loss}{\partial z_k^i}</script><p>// TODO 推导之后, 有:</p><p>为了保证前向传播和反向传播时每一层的方差一致, 则有下面的公式成立:</p><script type="math/tex; mode=display">\forall i, n_i Var[W^i] = 1</script><script type="math/tex; mode=display">\forall i, n_{i+1} Var[W^i] =1</script><p>式中, $n_i, n_{i+1}$ 分别为当前第i层和i+1层的输入节点个数, 但是, 在实际当中, 每一层的输入个数往往不相等, 于是为了均衡考量, 最终给出的权重方差为:</p><script type="math/tex; mode=display">\forall, Var[W^i] = \frac {2}{n_i + n_{i+1}}</script><p>再由概率统计中均匀分布方差的性质反推,可以得到Xavier最终的初始化分布如下:</p><script type="math/tex; mode=display">W \sim U\Big[-\frac{\sqrt{6}}{\sqrt{n_j+n_{j+1}}},\frac{\sqrt{6}}{\sqrt{n_j+n_{j+1}}}  \Big]</script><p><strong>Xavier在Caffe中的具体实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XavierFiller</span> :</span> <span class="keyword">public</span> Filler&lt;Dtype&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">XavierFiller</span><span class="params">(<span class="keyword">const</span> FillerParameter&amp; param)</span></span></span><br><span class="line">      : Filler&lt;Dtype&gt;(param) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fill</span><span class="params">(Blob&lt;Dtype&gt;* blob)</span> </span>&#123;</span><br><span class="line">    CHECK(blob-&gt;count());</span><br><span class="line">    <span class="keyword">int</span> fan_in = blob-&gt;count() / blob-&gt;num();</span><br><span class="line">    <span class="keyword">int</span> fan_out = blob-&gt;count() / blob-&gt;channels();</span><br><span class="line">    Dtype n = fan_in;  <span class="comment">// default to fan_in</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;filler_param_.variance_norm() ==</span><br><span class="line">        FillerParameter_VarianceNorm_AVERAGE) &#123;</span><br><span class="line">      n = (fan_in + fan_out) / Dtype(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;filler_param_.variance_norm() ==</span><br><span class="line">        FillerParameter_VarianceNorm_FAN_OUT) &#123;</span><br><span class="line">      n = fan_out;</span><br><span class="line">    &#125;</span><br><span class="line">    Dtype scale = <span class="built_in">sqrt</span>(Dtype(<span class="number">3</span>) / n);</span><br><span class="line">    caffe_rng_uniform&lt;Dtype&gt;(blob-&gt;count(), -scale, scale,</span><br><span class="line">        blob-&gt;mutable_cpu_data());</span><br><span class="line">    CHECK_EQ(<span class="keyword">this</span>-&gt;filler_param_.sparse(), <span class="number">-1</span>)</span><br><span class="line">         &lt;&lt; <span class="string">"Sparsity not supported by this Filler."</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出, Caffe的Xavier实现有三种选择:</p><p>(1)</p><h1 id="初始化方法讨论"><a href="#初始化方法讨论" class="headerlink" title="初始化方法讨论"></a>初始化方法讨论</h1><h2 id="为什么不能全0初始化"><a href="#为什么不能全0初始化" class="headerlink" title="为什么不能全0初始化"></a>为什么不能全0初始化</h2><p>首先, 在神经网络中, 每一层中的任意神经元都是同构的, 它们拥有相同的输入, 如果再将参数全部初始化为同样的值(如0), 那么输出也就是相同的,  反过来它们的梯度也都是相同的.  那么无论是前向传播还是反向传播的取值都是完全相同的, 那么每一个神经元都是基于input做相同的事情, 这样一来, 不同的神经元根本无法学到不同的特征, 这样就失去网络学习特征的意义了</p><p>高斯</p><p>msra</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>被忽视的Patition算法</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84Patition%E7%AE%97%E6%B3%95/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84Patition%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>如果你学习过算法，那么肯定听说过快速排序的大名，但是对于快速排序中用到的 <code>partition</code> 算法，你了解的够多吗？或许是快速排序太过于光芒四射，使得我们往往会忽视掉同样重要的 <code>partition</code> 算法。</p><p><strong>Partition 可不只用在快速排序中，还可以用于Selection algorithm（在无序数组中寻找第K大的值）中。</strong></p><h1 id="Partition实现"><a href="#Partition实现" class="headerlink" title="Partition实现"></a>Partition实现</h1><p>用 Two Pointers 的思想，保持头尾两个指针向中间扫描，每次在头部找到大于pivot的值，同时在尾部找到小于pivot的值，然后将它们做一个交换，就可以一次把这两个数字放到最终的位置。一种比较明智的写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">  <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">    <span class="comment">//比较时如果少了等于号,就有可能会陷入死循环,两个重复的数不断交换</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high &amp;&amp; arr[low]&lt;=pivot) low++;</span><br><span class="line">    arr[high] = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high &amp;&amp; arr[high]&gt;=pivot) high--;</span><br><span class="line">    arr[low] = arr[high];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[low] = pivot;</span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的算法虽然没有显式用的swap,但实际上也相当于进行了swap操作,如下图所示:<br><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvnu8fb6y7j20y40l8aai.jpg" alt=""></p><h1 id="Partition应用"><a href="#Partition应用" class="headerlink" title="Partition应用"></a>Partition应用</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">  mid = partition(arr,low,high);</span><br><span class="line">  <span class="keyword">if</span>(mid&gt;low) quick_sort(arr, low,mid<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span>(mid&lt;high) quick_sort(arr,mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度:$O(nlogn)$</p><h2 id="寻找无序数组中第K大的值"><a href="#寻找无序数组中第K大的值" class="headerlink" title="寻找无序数组中第K大的值"></a>寻找无序数组中第K大的值</h2><p>首先用 partition 将数组分为两部分，得到分界点下标 pos，然后分三种情况：</p><ul><li>pos == k-1，则找到第 K 大的值，arr[pos]；</li><li>pos &gt; k-1，则第 K 大的值在左边部分的数组。</li><li>pos &lt; k-1，则第 K 大的值在右边部分的数组。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_kth_number</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>; <span class="keyword">int</span> high = arr.size()<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(low&lt; high)&#123;</span><br><span class="line">    pos = partition(arr,low,high);</span><br><span class="line">    <span class="keyword">if</span>(pos==k<span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> arr[k<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; k<span class="number">-1</span>)</span><br><span class="line">      low = pos+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      high = pos<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(n)$</p><p>分析:<br>考虑最坏情况下，每次 partition 将数组分为长度为 N-1 和 1 的两部分，然后在长的一边继续寻找第 K 大，此时时间复杂度为 O(N^2 )。不过如果在开始之前将数组进行随机打乱，那么可以尽量避免最坏情况的出现。而在最好情况下，每次将数组均分为长度相同的两半，运行时间 T(N) = N + T(N/2)，时间复杂度是 O(N)。</p><h1 id="Partition-进阶"><a href="#Partition-进阶" class="headerlink" title="Partition 进阶"></a>Partition 进阶</h1><p>接下来先考虑这样一个问题，给定红、白、蓝三种颜色的小球若干个，将其排成一列，使相同颜色的小球相邻，三种颜色先后顺序为红，白，蓝。这就是经典的 Dutch national flag problem。</p><p>我们可以针对红，蓝，白三种颜色的球分别计数，然后根据计数结果来重新放球。不过如果我们将问题进一步抽象，也就是说将一个数组按照某个target值分为三部分，使得左边部分的值小于 target，中间部分等于 target，右边部分大于 target，这样就不能再用简单的计数来确定排序后的结果。这时候，就可以用到另一种 partition 算法： <strong>three-way-partition</strong> 。它的思路稍微复杂一点，用三个指针将数组分为四个部分，通过一次扫描最终将数组分为 &lt;，=，&gt; 的三部分，如下图所示:</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvnu99voilj210i0ki0sv.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《深度学习轻松学》</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BD%BB%E6%9D%BE%E5%AD%A6/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BD%BB%E6%9D%BE%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-网络结构"><a href="#第七章-网络结构" class="headerlink" title="第七章 网络结构"></a>第七章 网络结构</h1><h2 id="7-1-关于网络结构，我们更关心什么"><a href="#7-1-关于网络结构，我们更关心什么" class="headerlink" title="7.1 关于网络结构，我们更关心什么"></a>7.1 关于网络结构，我们更关心什么</h2><p>模型结构的关注点有以下几个：</p><ul><li>模型的总深度：代表了模型潜在的学习能力和模型的复杂度。</li><li>模型的参数总量：同样代表了模型的学习能力和复杂的复杂度。</li><li>模型前向计算所需的内存量：模型的大小</li></ul><h2 id="7-2-网络结构的演化"><a href="#7-2-网络结构的演化" class="headerlink" title="7.2 网络结构的演化"></a>7.2 网络结构的演化</h2><h3 id="7-2-1-VGG哲学"><a href="#7-2-1-VGG哲学" class="headerlink" title="7.2.1 VGG哲学"></a>7.2.1 VGG哲学</h3><p>AlexNet：采用类7*7的卷积核</p><p>VGGNet：用3个3×3个卷积核代替了7×7的卷积核，效果差不多，但是参数量降低了。同时增加了非线性层，过去一个卷积层加一个非线性，现在替换成了三个卷积核加三个非线性。另外，在VGG中，卷积层的操作不会改变输入数据的维度，通常会通过padding来维持输出的大小。而只通过pooling层来改变输出的大小。</p><p>提问： 卷积的时候为什么要进行padding？</p><p>回答：对于一些通过卷积减小维度的模型来说，对于不同的输入尺度，卷积后的输出维度各不一样，所以模型不容易适配更多的场景，而如果只用pooling层改变场长宽维度，整体模型的维度计算就方便了许多。</p><h3 id="7-2-2-GooLeNet：丰富模型层的内部结构"><a href="#7-2-2-GooLeNet：丰富模型层的内部结构" class="headerlink" title="7.2.2 GooLeNet：丰富模型层的内部结构"></a>7.2.2 GooLeNet：丰富模型层的内部结构</h3><p>NIN网络和Inception Module这类结构非常看中模型在局部区域的拟合能力。它们认为：一张图像通常具有总体特征和细节特征这两类特征，一般小卷积核能够更好的捕捉一些细节特征，随着深层网络的小卷积不断计算下去，总体特征也会慢慢的被提炼出来，但是这样存在一个问题，那就是在如果只采用小卷积，那么网络结构的前段一般只有细节特征，后段才慢慢有一些总体特征，而我们希望这两方面的特征总是能够一起发挥作用，因此，上面的两种模型考虑采用更多不同尺寸的卷积核来提取特征，并把这些特征连接起来，一起送到后面的网络中去计算，使得网络可以获取到更多的特征信息。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《百面机器学习》</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-特征工程"><a href="#第一章-特征工程" class="headerlink" title="第一章 特征工程"></a>第一章 特征工程</h1><h2 id="1-特征归一化"><a href="#1-特征归一化" class="headerlink" title="1. 特征归一化"></a>1. 特征归一化</h2><h2 id="7-图像数据不足时的处理方法"><a href="#7-图像数据不足时的处理方法" class="headerlink" title="7. 图像数据不足时的处理方法"></a>7. 图像数据不足时的处理方法</h2><h3 id="在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带来的问题？"><a href="#在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带来的问题？" class="headerlink" title="在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带来的问题？"></a>在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带来的问题？</h3><p>一个模型的信息来源主要有两个方面：</p><ul><li>训练数据中蕴含的信息</li><li>模型形成过程中（包括构造、学习、推理等），人们提供的先验信息</li></ul><p><strong>当训练数据不足时，说明模型从原始数据中获取的信息比较少，这种情况下要想保证模型的效果，就需要更多的先验信息</strong></p><ul><li>先验信息可以作用在模型上，例如让模型采用特定的内在结构、条件假设或添加其他一些约束条件</li><li>先验信息也可以直接施加在数据集上，让其展现处更多的、更有用的信息、以利于后续模型的训练和学习。</li></ul><p>具体到图像分类任务上，训练数据不足带来的问题主要表现在 <strong>过拟合方面</strong>。所以，对应的处理方法大致分为两类：</p><ul><li>基于模型的方法：采用降低过拟合风险的措施，包括简化模型（如将非线性简化成线性）、添加约束项以缩小假设空间（如L1和L2正则化）、集成学习、Dropout超参数等</li><li>基于数据的方法，主要通过数据扩充（Data Augmentation），即根据一些先验知识，在保持特定信息的前提下，对原始数据进行适合变换以达到扩充数据集的效果。</li></ul><p>在图像分类任务中，在保持图像类别不变的前提下，可以对训练集中的每幅图像进行以下变换：</p><ul><li>观察角度：一定程度内的随机旋转、平移、缩放、裁剪、填充、左右翻转等</li><li>噪声扰动：椒盐噪声、高斯白噪声</li><li>颜色变换：在RGB颜色空间上进行主成分分析</li><li>其他：亮度、清晰度、对比度、锐度</li></ul><p>其他扩充数据方法：特征提取——&gt;在图像的特征空间内进行变换：数据扩充or上采样技术，如SMOTE（Synthetic Minority Over-sampling Technique)。</p><p>最后，迁移学习或者用GAN合成一些新样本也可帮助解决数据不足问题。</p><h1 id="第三章-经典算法"><a href="#第三章-经典算法" class="headerlink" title="第三章 经典算法"></a>第三章 经典算法</h1><h2 id="1-支持向量机"><a href="#1-支持向量机" class="headerlink" title="1. 支持向量机"></a>1. 支持向量机</h2><p>知识点: SVM模型推导, 核函数, SMO(Sequential Minimal Optimizaiton)算法</p><h3 id="问题1-在空间上线性可分的两类点-分别向SVM分类的超平面上做投降-这些点在超平面上的投影仍然是线性可分的吗"><a href="#问题1-在空间上线性可分的两类点-分别向SVM分类的超平面上做投降-这些点在超平面上的投影仍然是线性可分的吗" class="headerlink" title="问题1: 在空间上线性可分的两类点, 分别向SVM分类的超平面上做投降, 这些点在超平面上的投影仍然是线性可分的吗"></a>问题1: 在空间上线性可分的两类点, 分别向SVM分类的超平面上做投降, 这些点在超平面上的投影仍然是线性可分的吗</h3><p>首先明确下题目概念: 当前的空间已经是线性可分的空间,有可能是样本空间,也有可能是映射后的特征空间. 题目问的是将当前空间中的点全部投影都当前的分类超平面上, 提问在分类超平面上投影的点是否仍然线性可分.</p><p>先说结论: <strong>对于任意线性可分的两组点, 它们在SVM分类的超平面上的投影都是线性不可分的</strong></p><p>解释一(反证法直观推导):</p><p>首先根据拉格朗日对偶优化问题的公式和KKT条件要求,可以知道, SVM的分类结果仅仅依赖于支持向量, 那么此时我们假设存在一个SVM分类超平面使所有支持向量在该超平面上的投影依然线性可分, 那么根据初等几何只是我们可以知道, 两个类别中距离最近的两个点, 它们连线的中垂线所组成的新的超平面是相较于当前超平面更优的解.  这与我们的假设相矛盾, 故线性可分的两组点, 投影到超平面上以后是线性不可分的.(具体可画图或看p53)</p><p>解释二(超平面分离定理,Separatin Hyperplane Theorem, SHT):</p><p>STH定理描述: 对于不想交的两个凸集, 存在一个超平面, 将两个凸集分离. 对于二维的情况, 两个凸集间的距离最短两点连线的中垂线就是一个将它们分离的超平面</p><p>根据此定理, 我们先对线性可分的这两组点求格子的凸包, 而SVM求得的超平面就是这两个凸包上距离最短的两点连线的中垂线,根据凸包的性质容易知道, 凸包上的点要么是样本点, 要么是两个样本点之间连线上的点, 那么, 两个凸包之间距离最短的两个点可以分为三个情况: 1)两边都是样本点, 2)两边都不是样本点, 3)一边是一边不是. 不论对于哪种情况, 当对中垂线(超平面)投影后, 两类点都是线性不可分的(具体可画图或者看p54)</p><h3 id="问题2-是否存在一组参数使SVM训练误差为0"><a href="#问题2-是否存在一组参数使SVM训练误差为0" class="headerlink" title="问题2: 是否存在一组参数使SVM训练误差为0?"></a>问题2: 是否存在一组参数使SVM训练误差为0?</h3><p>问题详细描述: 一个使用高斯核( $K(x,z) = e^{-| x- z|^2/\gamma^2})$ 训练的SVM中, 试证明若给定训练集中 <strong>不存在两个点在同一个位置</strong> (如果在同一个位置,则这两个点不可分), 则存在一组参数 $\vec \alpha$ 和参数 $\gamma$, 使得SVM的训练误差为0.</p><p><strong>结论:存在(可想象成是过拟合)</strong></p><p>公式证明:</p><p>//TODO</p><p>以上推导证明可以看出, 对于任意样本的预测结果 $f(\vec x^{(i)})$, 与样本真实标签 $y^{(i)}$ 的距离都小于1 , 因此, 当训练样本为正例时, 由于 $y^{(i)}=1$, 则必有 $f(\vec x^{(i)}) &gt;0 $, 样本被预测为正例. 负例也是同理. 因此所有样本的类别都被正确预测, 训练误差为0.</p><h3 id="问题3-训练误差为0的SVM分类器一定存在吗"><a href="#问题3-训练误差为0的SVM分类器一定存在吗" class="headerlink" title="问题3: 训练误差为0的SVM分类器一定存在吗"></a>问题3: 训练误差为0的SVM分类器一定存在吗</h3><p>问题详细描述: 虽然在问题2中找到了一组参数使得SVM的训练误差为0, 但是这组参数不一定是满足SVM条件的一个解, 在实际训练一个 <strong>不加入松弛变量</strong> 的SVM模型时, 是否能保证得到的SVM分类器满足训练误差为0呢?</p><p><strong>结论: 存在</strong></p><p>上一题找到了一组参数使得SVM的分类器训练误差为0, 但是训练误差为0的参数并不一定是SVM模型的一个解, 它还需要满足限制条件 $y^{(i)} f(x^{(i)}) \geq 1$ .</p><p>因为SVM模型中解的限制条件为 $y^{(i)} f(x^{(i)}) \geq 1$ (等号为支持向量样本点) , 而上题我们只得到了   $y^{(i)} f(x^{(i)}) &gt; 0$, 因此需要找到另一组参数满足更强的条件</p><p>// TODO公式推导</p><p>根据以上推导过程, 可以找到一个SVM的解, 同时一定使模型分类误差为0</p><h3 id="问题4-加入松弛变量的SVM的训练误差可以为0吗"><a href="#问题4-加入松弛变量的SVM的训练误差可以为0吗" class="headerlink" title="问题4: 加入松弛变量的SVM的训练误差可以为0吗"></a>问题4: 加入松弛变量的SVM的训练误差可以为0吗</h3><p><strong>结论: 不一定能得到训练误差为0的模型(但不是一定不能, 具体看问题)</strong></p><p>这是由于加入松弛变量后, 优化目标变成了 $\min_{\vec w, b, x_i^{(i)}} \frac{1}{2} |\vec w |^2_2 + C \sum_{i=1}^{m} x_i^{(i)}$  ,并不再是仅仅使训练误差最小, 同时还会考虑后面的惩罚项, 而当C的取值较小时, 一个带有训练误差, 但参数项较小的点将会称为更优的结果.</p><h1 id="第七章-优化算法"><a href="#第七章-优化算法" class="headerlink" title="第七章 优化算法"></a>第七章 优化算法</h1><h2 id="1-有监督学习的损失函数"><a href="#1-有监督学习的损失函数" class="headerlink" title="1. 有监督学习的损失函数"></a>1. 有监督学习的损失函数</h2><p>损失函数定义了模型的评估指标. 不同的损失函数优化难度不同, 最终得到的模型参数也不同, 针对具体的问题需要选取合适的损失函数.</p><h3 id="问题-有监督学习涉及的损失函数有哪些-请列举并简述它们的特点"><a href="#问题-有监督学习涉及的损失函数有哪些-请列举并简述它们的特点" class="headerlink" title="问题: 有监督学习涉及的损失函数有哪些? 请列举并简述它们的特点"></a>问题: 有监督学习涉及的损失函数有哪些? 请列举并简述它们的特点</h3><p><strong>Hinge损失:</strong></p><script type="math/tex; mode=display">L_{hinge}(f,y) = max{0, 1-fy}</script><p>在 $fy=1$ 处不可导, 因此不能用梯度下降法优化</p><p>Logistic损失</p><p>平方损失</p><p>交叉熵损失</p><p>其他更多: <a href="">各种损失函数深入解析</a></p><h2 id="2-机器学习中的优化问题"><a href="#2-机器学习中的优化问题" class="headerlink" title="2. 机器学习中的优化问题"></a>2. 机器学习中的优化问题</h2><h3 id="问题-机器学习中的优化问题-哪些是凸优化问题-哪些是非凸优化问题-请各举一个例子"><a href="#问题-机器学习中的优化问题-哪些是凸优化问题-哪些是非凸优化问题-请各举一个例子" class="headerlink" title="问题: 机器学习中的优化问题, 哪些是凸优化问题, 哪些是非凸优化问题? 请各举一个例子"></a>问题: 机器学习中的优化问题, 哪些是凸优化问题, 哪些是非凸优化问题? 请各举一个例子</h3><p>凸函数的定义: 函数 $L(\dot)$ 是凸函数当且仅当对定义域中的任意两点 $x,y$ 和任意实数 $\lambda \in [0,1]$ , 总有:</p><script type="math/tex; mode=display">L(\lambda x +(1-\lambda) y) \leq \lambda L(x) + (1-\lambda)L(y)</script><p>上面不等式的一个直观解释是, 凸函数曲面上任意两点连接而成的线段, 其上的任意一点都不会处于该函数曲面的下方</p><p>凸优化问题举例:  逻辑回归问题</p><p>证明: …</p><p>非凸优化问题举例: 主成分分析</p><p>证明: …</p><h2 id="3-经典优化算法"><a href="#3-经典优化算法" class="headerlink" title="3. 经典优化算法"></a>3. 经典优化算法</h2><h2 id="4-梯度验证"><a href="#4-梯度验证" class="headerlink" title="4. 梯度验证"></a>4. 梯度验证</h2><h2 id="5-随机梯度下降法"><a href="#5-随机梯度下降法" class="headerlink" title="5. 随机梯度下降法"></a>5. 随机梯度下降法</h2><p>经典的梯度下降法: 在每次迭代时需要使用所有的训练数据, 求完所有训练数据的损失后, 取平均值进行更新</p><h3 id="问题-当训练数据量特别大时-经典的梯度下降法存在什么问题-需要做如何改进"><a href="#问题-当训练数据量特别大时-经典的梯度下降法存在什么问题-需要做如何改进" class="headerlink" title="问题: 当训练数据量特别大时, 经典的梯度下降法存在什么问题? 需要做如何改进?"></a>问题: 当训练数据量特别大时, 经典的梯度下降法存在什么问题? 需要做如何改进?</h3><p>//TODO 补充缺少的公式</p><p>在机器学习中, 优化问题的目标函数通常可以表示成:</p><script type="math/tex; mode=display">其中...//TODO 因此...//TODO 我们希望能够找到平均损失最小的模型参数, 也就是求解优化问题:</script><p>经典的梯度下降法采用所有训练数据的平均损失来近似目标函数, 即</p><script type="math/tex; mode=display">其中 $M$ 是训练样本的个数, 模型参数的更新公式为:</script><p>因此, 经典的梯度下降法在每次对模型参数进行更新时, 需要遍历所有的训练数据. 当 $M$ 很大时, 这需要很大的计算量, 耗费很长的计算时间, 在实际应用中不可行</p><p><strong>改进:</strong></p><p><strong>随机梯度下降法(SGD):</strong> 每次使用单个训练数据对模型进行更新</p><p>计算速度快, 内存开销小. 但由于每步接受的信息量有限, 随机梯度下降法对梯度的估计常常出现偏差, 造成目标函数曲线收敛的很不稳定, 伴有剧烈波动, 有时甚至出现不收敛的情况.</p><p><strong>小批量梯度下降法(Mini-Batch GD):</strong> 每次选取 $m$ 个训练样本进行更新</p><p>对于小批量梯度下降法的使用, 有以下三点需要注意的地方:</p><ul><li>如何选取参数 $m$ ?  一般挑选2的幂次, 以便充分利用矩阵运算操作</li><li>如何挑选这 $m$ 个训练数据? 为了避免数据的特定顺序给算法收敛带来的影响, 一般会在每次遍历训练数据之前, 先对所有的数据进行随机排序, 然后在每次迭代时按顺序挑选 $m$ 个训练数据直至遍历完所有的数据</li><li>如何选取学习率 $\alpha$ ? 为了加快收敛速率,, 同时提高求解精度, 通常会采用衰减学习速率的方案: 一开始算法采用较大的学习速率, 当误差曲线进入平台期后, 减小学习速率做更精细的调整</li></ul><h2 id="6-随机梯度下降法的加速"><a href="#6-随机梯度下降法的加速" class="headerlink" title="6. 随机梯度下降法的加速"></a>6. 随机梯度下降法的加速</h2><h3 id="问题1-为什么随机梯度下降法偶尔会失效-无法给出满意的训练结果"><a href="#问题1-为什么随机梯度下降法偶尔会失效-无法给出满意的训练结果" class="headerlink" title="问题1: 为什么随机梯度下降法偶尔会失效, 无法给出满意的训练结果?"></a>问题1: 为什么随机梯度下降法偶尔会失效, 无法给出满意的训练结果?</h3><p>对于深度学习中的优化问题来说, 当遇到类似于 “山谷” 和 “鞍点”  两种地形时, 随机梯度下降法往往无法取得好的效果.  </p><p>具体来说, 山谷在三维空间中就像是狭长的山间小道, 左右两边是峭壁, 因此, 在这类地形中, 准确的梯度方向是沿着山道向下, 稍有偏离就会撞向山壁, 而一旦撞向山壁, 粗糙的梯度估计就会使得更新在两山壁之间来回反弹震荡, 不能沿着山道方向迅速下降, 导致收敛不稳定和收敛速度慢.</p><p>而在鞍点处, 三维性状看起来想一个马鞍, 一个方向上两头翘起, 另一个方向上两头垂下, 而中心区域是一片近乎水平的平地, 此处梯度为0, 随机梯度下降法无法准确察觉出梯度的微小变化, 结果就会导致更新停滞</p><h3 id="问题2-为了改进随机梯度下降法-研究者都提出了哪些变种方法"><a href="#问题2-为了改进随机梯度下降法-研究者都提出了哪些变种方法" class="headerlink" title="问题2: 为了改进随机梯度下降法, 研究者都提出了哪些变种方法?"></a>问题2: 为了改进随机梯度下降法, 研究者都提出了哪些变种方法?</h3><p>// TODO 补充完善</p><p><strong>动量方法:</strong></p><p>前进步长 $\nu_t$ 有两部分组成, 一是学习速率 $\eta$ 乘以当前估计的梯度 $g_t$ ; 二是带衰减的前一次步伐 $\nu_{t-1}$. 这里, 惯性就体现在对前一次步伐信息的重利用上, 前一次步伐就好比前一时刻的速度, 当前步伐就好比当前时刻的速度.</p><p><strong>AdaGrad方法:</strong></p><p>AdaGrad是的梯度下降法就有了对周围环境感知的优点(没有动量项): 即根据之前的更新结果, 来动态决定当前每个的步长</p><p>对于深度学习任务, 数据的稀疏性会导致相应参数梯度的稀疏性, 不频繁出现的物体对应的特征参数的梯度在大多数情况下为0, 从而这些参数被更新的频率很低. 在实际中, 我们希望更新频率低的参数可以拥有较大的更新步长, 而更新频率高的参数拥有较小的更新步长.</p><p>采用 “历史梯度平方和” 来衡量不同参数的梯度的稀疏性, 取值越小表明越稀疏, 更新公式如下所示:</p><script type="math/tex; mode=display">从上面公式可以看出, 当更新次数较多时, 历史梯度平方和值较大, 对应的 $g_{t,i}$ 前的约束项值越小, 更新步长就越小.  另外, 这里分母的求和形式还实现了退火过程, 意味着随着时间推移, 约束项肯定会越来越小, 从而保证了算法的最终收敛(更新停止)**Adam方法:**Adam方法将惯性保持和环境感知这两个优点集于一身.- 梯度的一阶矩: 记录了过往梯度与当前梯度的平均, 体现了 "惯性保持"- 梯度的二阶矩: 记录了过往梯度平方与当前梯度平方的平均, 类似于AdaGrad, 体现了 "环境感知", 为不同参数产生自适应的学习速率一阶矩和二阶矩都采用滑动窗口内求平均的思想进行同和, 即当前梯度和近一段时间内梯度的平均值, 时间久远的梯度对当前平均值的贡献呈指数衰减. 具体来说, 一阶矩和二阶矩采用指数衰退平均技术, 计算公式为:</script><script type="math/tex; mode=display">其中...//TODO**对一阶矩和二阶矩的理解:**一阶矩相当于估计 $E[g_t]$ : 由于当前梯度 $g_t$ 是随机采样得到的估计结果, 因此更关注它在统计意义上的期望; 二阶矩相当于估计 $E[g_t^2]$, 这点与AdaGrad不同(后者计算的是 $g_t^2$ 的总和).**一阶矩和二阶矩的物理意义:**| --- | --- | --- || 一阶矩的值   |  二阶矩的值 |  表示的含义 || 大  |  大 | 说明此时的梯度值普遍较大且稳定, 相当于遇到了一个明显的大坡, 权重更新前进方向明确  || 趋于0  | 大  | 说明梯度值极不稳定, 一会正一会负, 表明可能遇到了峡谷, 且处于反弹震荡状态  ||  大 |  趋于0  |  这种情况不可能出现  || 趋于0  | 趋于0  | 此时说明梯度值普遍接近于0, 有可能进入了一个平原或者坡度极缓的地方  |另外, Adam方法还考虑 $m_t,n_t$ 在领初始值情况下的偏执校正(即在分子中加了一个很小的非0项, 防止0除), Adam的更新公式如下:</script><h2 id="7-L1正则化与稀疏性"><a href="#7-L1正则化与稀疏性" class="headerlink" title="7. L1正则化与稀疏性"></a>7. L1正则化与稀疏性</h2><p>此类的相关题目在面试中常被问道, 可以考察面试者对于机器学习模型各个相关环节的了解程度. 在回答时, <strong>不能只给出一些大概的理解, 一定要深入且清晰的回答</strong></p><p><strong>稀疏性的概念:</strong>  说白了就是模型中的参数很多都是0, 这相当于对模型进行了一次特征选择, 只留下一些比较重要的特征, 提高模型的泛化能力.(以免学到过多的个性特征)</p><p><strong>稀疏性的另一个重要性:</strong> 机器学习模型的输入动辄几百上千万维, 要想在线上系统中毫秒级响应要求下完成千万维特征的提取以及模型的预测, 还要在分布式环境下在内存中驻留这样一个大的模型, 往往很难做到.</p><h3 id="问题-L1-正则化使得模型参数具有稀疏性的原理是什么"><a href="#问题-L1-正则化使得模型参数具有稀疏性的原理是什么" class="headerlink" title="问题 L1 正则化使得模型参数具有稀疏性的原理是什么?"></a>问题 L1 正则化使得模型参数具有稀疏性的原理是什么?</h3><h4 id="角度1-解空间性状"><a href="#角度1-解空间性状" class="headerlink" title="角度1: 解空间性状"></a>角度1: 解空间性状</h4><p>源自于西瓜书第11章, 比较权威且直观的解释, 大多数面试者都是从这个角度出发的.</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvxplq8m55j208u089js0.jpg" alt=""><br><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvxplqd0l9j208u089q3l.jpg" alt=""></p><p>首先, 假定输入想了 $\vec x$ 仅仅有两个属性, 那么 L1 和 L2 的 $\vec w$ 也只有两个分量, 分别是 $w_1, w_2$, 将这两个分量作为两个坐标轴, 分别绘制出 “无正则平方误差项” 和 “正则项” 的 “等值线”: 即在 $(w_1, w_2)$ 空间中取值相同的点.</p><p>首先, 根据引入L1和L2范式的损失函数的定义, 我们可以画出上面的解空间图, 其中, 坐标轴上面方形和分别是 L1 和 L2 范式的等值线, 而右上角的”年轮式”椭圆, 就是无正则误差项的等值线. 最终我们的模型需要在误差项和正则项之间折中, 体现在上图中就是误差项与正则项等值线相交的地方.  因此, 可以看到, 采用L1函数时, 误差项与正则项等值线的交点常常出现在坐标轴上, 而采用L2 范式时, 交点常常出现在某个象限中, 所以L1 比L2 范式更易于得到稀疏解.</p><p>扩展问题:</p><p><strong>为什么加入正则项就是定义了一个解空间约束:</strong></p><p>这个可以从优化的角度来理解, 首先把损失函数看做是一个优化问题, 而加入一个正则项就相当于是给该优化问题加入了一个约束, 即参数 $\vec w$ 的 Lp 范式不能大于m, m不是一个具体的值, 就代表了一种限制, 然后利用拉格朗日函数来解这个在范式约束条件下的最优解问题.</p><p><strong>为什么L1和L2的解空间是不是同的:</strong></p><p>他俩的参数运算公式不同, 解空间当然不同</p><h4 id="角度2-函数叠加-梯度下降更新公式"><a href="#角度2-函数叠加-梯度下降更新公式" class="headerlink" title="角度2: 函数叠加(梯度下降更新公式)"></a>角度2: 函数叠加(梯度下降更新公式)</h4><p>根据求导公式解释, L1求导区域将最终的权重向 0 靠拢</p><p>当 $w$ 为正时, L1求导为负, $w$ 为负时, L1求导为正</p><p>而L2求导, 无论 $w$ 的值是什么, 都为负, 因此L2只有减小 $w$ 绝对值的作用, 对解空间的稀疏性没有贡献. (即只会令 $w$ 减小, 但不要求其小到0, 在0附近时就可以)</p><p>公式求导过程见 <a href="">正则化深入解析</a></p><h4 id="角度3-贝叶斯先验"><a href="#角度3-贝叶斯先验" class="headerlink" title="角度3: 贝叶斯先验"></a>角度3: 贝叶斯先验</h4><p>L1 的正则化相当于对模型参数 $w$ 引入了拉普拉斯先验, L2 相当于引入了高斯先验, 而拉普拉斯先验使参数为 0 的可能性更大</p><p>联想高斯分布的图像可知, 高斯分布在极值点(0点)附近取不通知的可能性是很接近的, 也就是高斯先验分布认为 $w$ 在极值点附近取不同值的可能性是接近的, 所有它只会要求 $w$ 接近于0, 而不会要求其等于0.</p><p>相反, 拉普拉斯分布曲线图在极值点(0dm)处是一个尖峰, 所以拉普拉斯先验分布中参数 $w$ 在极值点(0点)取值的可能性更高</p><p><strong>至于为什么 L1 和 L2 分别对应拉普拉斯先验和高斯先验的证明, 可看<a href="">正则化深入解析</a></strong></p><h1 id="第八章-采样"><a href="#第八章-采样" class="headerlink" title="第八章 采样"></a>第八章 采样</h1><h2 id="1-采样的作用"><a href="#1-采样的作用" class="headerlink" title="1. 采样的作用"></a>1. 采样的作用</h2><h1 id="第九章-前向神经网络"><a href="#第九章-前向神经网络" class="headerlink" title="第九章 前向神经网络"></a>第九章 前向神经网络</h1><h2 id="1-多层感知机与布尔函数"><a href="#1-多层感知机与布尔函数" class="headerlink" title="1. 多层感知机与布尔函数"></a>1. 多层感知机与布尔函数</h2><h3 id="问题1-多层感知机表示异或逻辑时最少需要几个隐含层-仅考虑二元输入"><a href="#问题1-多层感知机表示异或逻辑时最少需要几个隐含层-仅考虑二元输入" class="headerlink" title="问题1: 多层感知机表示异或逻辑时最少需要几个隐含层(仅考虑二元输入)?"></a>问题1: 多层感知机表示异或逻辑时最少需要几个隐含层(仅考虑二元输入)?</h3><p><strong>考虑零个隐藏层的情况(等同于逻辑回归):</strong></p><p>逻辑回归公式如下:</p><script type="math/tex; mode=display">Z = sigmoid(AX+BY+C)</script><p>具体的真值表为:</p><p>// TODO表格</p><p>接着考虑下面的情况:</p><p>//TODO</p><p>由上可知, <strong>采用逻辑回归(即不带隐藏层的感知机)无法精确学习出一个输出为异或的模型表示</strong></p><p><strong>考虑具有一个隐藏层的情况:</strong></p><p>如下图, 假设有两个隐藏单元,</p><p>//TODO</p><h3 id="问题2-如果只使用一个隐层-需要多少隐节点能够实现包含n元输入的任意布尔函数"><a href="#问题2-如果只使用一个隐层-需要多少隐节点能够实现包含n元输入的任意布尔函数" class="headerlink" title="问题2: 如果只使用一个隐层, 需要多少隐节点能够实现包含n元输入的任意布尔函数?"></a>问题2: 如果只使用一个隐层, 需要多少隐节点能够实现包含n元输入的任意布尔函数?</h3><p>//TODO 完善</p><p><strong>结论: 在最差情况下, n元布尔函数的析取范式最多包含 $2^{(n-1)}$ 个不可规约的合取范式(异或), 因此对于单隐层的感知机, 需要 $2^{(n-1)}$ 个隐层节点实现</strong></p><h3 id="问题3-考虑多隐层的情况-实现包含n元输入的任意布尔函数最少需要多少个网络节点和网络层"><a href="#问题3-考虑多隐层的情况-实现包含n元输入的任意布尔函数最少需要多少个网络节点和网络层" class="headerlink" title="问题3: 考虑多隐层的情况, 实现包含n元输入的任意布尔函数最少需要多少个网络节点和网络层?"></a>问题3: 考虑多隐层的情况, 实现包含n元输入的任意布尔函数最少需要多少个网络节点和网络层?</h3><p>// TODO</p><h2 id="2-深度神经网络中的激活函数"><a href="#2-深度神经网络中的激活函数" class="headerlink" title="2. 深度神经网络中的激活函数"></a>2. 深度神经网络中的激活函数</h2><p>为什么要使用激活函数: 在现实世界里, 往往会遇到线性不可分问题(如XOR异或函数), 需要非线性变换对数据的分布进行重新映射. 对于深度神经网络, 我们在每一层线性变换后叠加一个非线性激活函数, <strong>以避免多层网络等效于单层线性函数, 从而获得更强大的学习和拟合能力</strong></p><h3 id="问题1-写出常用激活函数及其导数"><a href="#问题1-写出常用激活函数及其导数" class="headerlink" title="问题1: 写出常用激活函数及其导数"></a>问题1: 写出常用激活函数及其导数</h3><div class="table-container"><table><thead><tr><th>激活函数</th><th>形式</th><th>导数形式</th></tr></thead><tbody><tr><td>Sigmoid</td><td>$f(x) =\frac{1}{1+e^{-x}}$</td><td>$f’(x)(1-f(x))$</td></tr><tr><td>Tanh</td><td>$f(x) = tanh(x)= \frac{e^x-e^{-x}}{e^x+e^{-x}}$</td><td>$f’(x) = 1-(f(z))^2$</td></tr><tr><td>ReLU</td><td>$f(x)=max(0,x)=\begin{cases} 0 &amp; x \leq 0 \\ x &amp; x&gt;0 \end{cases}$</td><td>$f’(x)=\begin{cases} 0 &amp; x\leq 0 \\ 1 &amp; x&gt;0 \end{cases}$</td></tr><tr><td>Leaky ReLU</td><td>$f(x)=max(\alpha x,x)=\begin{cases} \alpha x &amp; x \leq 0 \\ x &amp; x&gt;0 \end{cases} \alpha 通常为0.1$</td><td>$f(x)=max(\alpha x,x)=\begin{cases} \alpha  &amp; x \leq 0 \\ 1 &amp; x&gt;0 \end{cases}$</td></tr><tr><td>Maxout</td><td>$f(x) = max(w_1^T x + b_1, w_2^T x + b_2)$</td><td>$f(x) = max(w_1, w_2)$</td></tr><tr><td>ELU</td><td>$f(x) = \begin{cases} x &amp; x \geq 0 \\ \alpha(e^x - 1) &amp; x&lt;0 \end{cases}$</td><td>$f(x) = \begin{cases} 1 &amp; x \geq 0 \\ \alpha e^x &amp; x&lt;0 \end{cases}$</td></tr></tbody></table></div><p>更多关于激活函数的讨论见[这里]</p><h3 id="问题2-为什么Sigmoid和Tanh激活函数会导致梯度消失的现象"><a href="#问题2-为什么Sigmoid和Tanh激活函数会导致梯度消失的现象" class="headerlink" title="问题2: 为什么Sigmoid和Tanh激活函数会导致梯度消失的现象"></a>问题2: 为什么Sigmoid和Tanh激活函数会导致梯度消失的现象</h3><p>主要原因是它们在输入值过大或过小时都具有神经元饱和问题, 也就是说当输入很小或很大时, 其导数趋近于0, 又因为神经网络训练时依赖的是梯度下降法, 而根据链式法则的特点, 导数在趋近于0时就会出现梯度消失现象,导致浅层网络权重更新停滞</p><h3 id="问题3-ReLU系列的激活函数相对于Sigmoid和Tanh激活函数的有点是什么-它们有什么局限性"><a href="#问题3-ReLU系列的激活函数相对于Sigmoid和Tanh激活函数的有点是什么-它们有什么局限性" class="headerlink" title="问题3: ReLU系列的激活函数相对于Sigmoid和Tanh激活函数的有点是什么,它们有什么局限性?"></a>问题3: ReLU系列的激活函数相对于Sigmoid和Tanh激活函数的有点是什么,它们有什么局限性?</h3><p>优点:</p><ul><li>计算上,ReLU只需要一个阈值, 复杂度低</li><li>ReLU在正无穷范围内, 都具有非饱和性, 可以提供相对宽的激活边界, 缓解梯度消失问题</li><li>ReLU的负无穷总是输出0, 通过单侧一直提供了网络的稀疏表达能力, 经过ReLU激活的神经元输出中会有很多的0, 形成了稀疏矩阵, 通过实验发现, 这样的稀疏矩阵可以提高网络的性能.</li></ul><p>局限性: 主要在于其训练过程中会导致神经元死亡.</p><p>这是由于ReLU在遇到负梯度时会将其置为0, 且在之后也不被任何数据激活,即流经该神经元的梯度永远为0, 不对任何数据产生相应. 在实际训练中, 如果学习率设置较大, 会导致超过一定比例的神经元不可逆死亡, 进而参数梯度无法更新, 整个训练过程失败</p><p>解决方法: Leaky ReLU.</p><p>Leaky ReLU的参数 $\alpha$ 通常是一个很小的值, 也就是说可以实现一定程度上的单侧抑制,保证了网络的稀疏表达能力. 同时, 在输入为负时, 保留了部分信息, 避免了神经元死亡问题</p><p>但是LeakyReLU的缺点就是参数 $\alpha$ 的选择需要大量实验和先验知识, 这无疑给训练带来的麻烦, 基于此, PReLU选择将 $\alpha$ 作为网络中一个可学习的参数, 进行反向传播训练.  还有一个就是RReLU, 它令 $\alpha$的选择服从一定的分布, 并进行随机采样, 这在一定程度上能起到正则化的作用</p><h2 id="3-多层感知机的反向传播算法"><a href="#3-多层感知机的反向传播算法" class="headerlink" title="3. 多层感知机的反向传播算法"></a>3. 多层感知机的反向传播算法</h2><p>在网络训练中, 前向传播最终产生一个标量损失函数, 反向传播算法(Back Propagation)则将损失函数的信息沿网络层向后传播用以计算梯度, 打到优化网络参数的目的</p><h3 id="问题1-写出多层感知机的平方误差和交叉熵损失函数"><a href="#问题1-写出多层感知机的平方误差和交叉熵损失函数" class="headerlink" title="问题1: 写出多层感知机的平方误差和交叉熵损失函数"></a>问题1: 写出多层感知机的平方误差和交叉熵损失函数</h3><h3 id="问题2-根据问题1中定义的损失函数-推导各层参数更新的梯度计算公式"><a href="#问题2-根据问题1中定义的损失函数-推导各层参数更新的梯度计算公式" class="headerlink" title="问题2: 根据问题1中定义的损失函数, 推导各层参数更新的梯度计算公式"></a>问题2: 根据问题1中定义的损失函数, 推导各层参数更新的梯度计算公式</h3><h3 id="问题3-平方误差损失函数和交叉熵损失函数分别适合什么场景"><a href="#问题3-平方误差损失函数和交叉熵损失函数分别适合什么场景" class="headerlink" title="问题3: 平方误差损失函数和交叉熵损失函数分别适合什么场景?"></a>问题3: 平方误差损失函数和交叉熵损失函数分别适合什么场景?</h3><p>一般来说, 平方损失更适合输出为连续, 并且最后一层不含Sigmoid或者Softmax激活函数的神经网络; 而交叉熵则更适合二分类或多分类的场景.</p><p><strong>为何平方损失函数不适合最后一层含有Sigmoid或Softmax激活函数的神经网络?</strong></p><p>回顾平方损失函数相对于输出层的导数:</p><script type="math/tex; mode=display">\delta = - (y - a^{(L)})f'(z^{(L)})</script><p>最后一项为激活函数的导数, 当激活函数为Sigmoid或者Softmax时, 其梯度很容易趋于饱和, 使得基于梯度的学习速度非常缓慢. 而交叉熵损失函数相对于输出层的导数是线性的, 因此不会存在学习速度过慢的问题</p><h3 id="扩展问题-多分类为什么选用交叉熵做损失函数-而不用平方损失"><a href="#扩展问题-多分类为什么选用交叉熵做损失函数-而不用平方损失" class="headerlink" title="扩展问题: 多分类为什么选用交叉熵做损失函数, 而不用平方损失?"></a>扩展问题: 多分类为什么选用交叉熵做损失函数, 而不用平方损失?</h3><p>Golik P, Doetsch P, Ney H. Cross-Entropy vs. Squared Error Training: a Theoretical and Experimental Comparison</p><p><a href="https://jamesmccaffrey.wordpress.com/2013/11/05/why-you-should-use-cross-entropy-error-instead-of-classification-error-or-mean-squared-error-for-neural-network-classifier-training/" target="_blank" rel="noopener">https://jamesmccaffrey.wordpress.com/2013/11/05/why-you-should-use-cross-entropy-error-instead-of-classification-error-or-mean-squared-error-for-neural-network-classifier-training/</a></p><p><a href="https://blog.csdn.net/u014313009/article/details/51043064" target="_blank" rel="noopener">https://blog.csdn.net/u014313009/article/details/51043064</a></p><p><a href="https://www.cnblogs.com/daniel-D/p/7931835.html#header-n1247" target="_blank" rel="noopener">https://www.cnblogs.com/daniel-D/p/7931835.html#header-n1247</a></p><h2 id="4-神经网络训练技巧"><a href="#4-神经网络训练技巧" class="headerlink" title="4. 神经网络训练技巧"></a>4. 神经网络训练技巧</h2><p>避免过拟合的办法: 数据增强, 正则化, 模型融合(其中dropout是模型融合方法中最高效和常用的技巧)</p><p>其他更多提升训练效果的还有如: 学习率, 权重衰减系数, dropout比例, 初始化等等</p><h3 id="问题1-神经网络训练时是否可以将全部参数初始化为0"><a href="#问题1-神经网络训练时是否可以将全部参数初始化为0" class="headerlink" title="问题1: 神经网络训练时是否可以将全部参数初始化为0?"></a>问题1: 神经网络训练时是否可以将全部参数初始化为0?</h3><p>首先, 在神经网络中, 每一层中的任意神经元都是同构的, 它们拥有相同的输入, 如果再将参数全部初始化为同样的值(如0), 那么输出也就是相同的,  反过来它们的梯度也都是相同的.  那么无论是前向传播还是反向传播的取值都是完全相同的, 那么每一个神经元都是基于input做相同的事情, 这样一来, 不同的神经元根本无法学到不同的特征, 这样就失去网络学习特征的意义了</p><p>不仅是初始化为0, 只要是初始化为同一个常数, 就会有这样的问题, 如果是常数, 虽然层与层之间的输出不一致 ,但是每一层内部的所有神经元结果一致, 仍然不是我们希望的那样#<br><a href="https://zhuanlan.zhihu.com/p/27190255" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27190255</a></p><h3 id="问题2-为什么Dropout可以抑制过拟合-它的工作原理和实现"><a href="#问题2-为什么Dropout可以抑制过拟合-它的工作原理和实现" class="headerlink" title="问题2: 为什么Dropout可以抑制过拟合? 它的工作原理和实现?"></a>问题2: 为什么Dropout可以抑制过拟合? 它的工作原理和实现?</h3><p>Dropout是指在深度网络的训练中, 以一定的概率随机的”临时丢弃”一部分神经元节点.  具体来讲, Dropout作用于每份小批量训练数据, 由于其随机丢弃部分神经元的机制, 相当于每次迭代都在训练不同结构的神经网络, 可以被认为是一种实用的大规模深度神经网络的模型继承算法.</p><p>对于包含 $N$ 个神经元节点的网络, 在Dropout的作用下可以看作为 $2^N$ 个模型的集成, 这 $2^N$ 个模型可认为是原始网络的子网络, 它们共享部分权值, 并且拥有相同的网络层数, 而模型整个的参数数目不变, 大大简化了运算.</p><p>对于任意神经元来说, 每次训练中都与一组随机挑选的不同的神经元集合共同进行优化, 这个过程会减弱全体神经元之间的联合适应性, 减少过拟合的风险, 增强泛化能力.</p><p>工作原理和实现:</p><p>应用Dropout包括训练和预测两个阶段, 在训练阶段中, 每个神经元节点需要增加一个概率系数, 在前向传播时, 会以这个概率选择是否丢弃当前的神经元</p><p>在测试阶段的前向传播计算时, 每个神经元的参数都会预先乘以概率系数p, 以恢复在训练中该神经元只有p的概率被用于整个神经网络的前向传播计算</p><h3 id="问题3-批量归一化的基本动机与原理是什么-在卷积网络中如何使用"><a href="#问题3-批量归一化的基本动机与原理是什么-在卷积网络中如何使用" class="headerlink" title="问题3: 批量归一化的基本动机与原理是什么? 在卷积网络中如何使用?"></a>问题3: 批量归一化的基本动机与原理是什么? 在卷积网络中如何使用?</h3><p><strong>动机:</strong></p><p>神经网络训练过程的本质是学习数据分布, 如果训练数据与测试数据的分布不同将大大降低网络的繁华能力, 因此需要在训练开始前对所有输入数据进行归一化处理. 然后随着网络训练的进行, 每个隐层的参数变化使得后一层的输入发生变化, 从而每一批训练数据的分布也随之改变, 致使网络在每次迭代中都需要拟合不同的数据分布, 增大训练的复杂度以及过拟合的风险.</p><p><strong>原理:</strong></p><p>批量归一化方法是针对每一批数据, 在网络的每一层输入之前增加归一化处理(均值为0, 标准差为1), 将所有批数据都强制统一到特定的分布下, 这样可以看作是在每一层输入和上一层输出之间加入了新的计算层, 对数据的分布进行了额外的约束,也就是隐含的增加了正则项,  从而增强模型的泛化能力.</p><p>但如果仅仅是这样, 同时也会降低模型的拟合能力, 归一化后的输入分布被强制为0均值和1标准差, 这在一定程度上掩盖了数据本身具有的一些特征, 因此, 为了恢复这些特征, 对归一化后的数据进行线性变换, 引入了两个新的参数 $\gamma$ 和 $\beta$ ,对于每一个卷积核都具有不同的 $\gamma$ 和 $\beta$, 在一定程度了可以保留原始数据中更多的信息,  从而更加有利于优化的过程,  提高模型的泛化能力</p><p><strong>使用时需要注意的问题:</strong></p><p>在卷积网络中应用时, 需要注意卷积神经网络的参数共享机制, 每一个卷积核的参数在不同的位置的神经元当中是共享的, 因此也应该一起被归一化, 如果有 $f$ 个卷积核, 就对应 $f$ 个特征图和 $f$ 组不同的BN参数.</p><h2 id="5-深度卷积神经网络"><a href="#5-深度卷积神经网络" class="headerlink" title="5. 深度卷积神经网络"></a>5. 深度卷积神经网络</h2><p>卷积神经网络的特点是每层的神经元节点只响应前一层局部区域范围内的神经元(全连接会响应前一层的全部节点). 相较于其他网络模型, 卷积操作的参数共享特性使得需要优化的参数数目大大缩减, 提高了模型的训练效率以及可扩展性.</p><h3 id="问题1-卷积操作的本质特性包括稀疏交互和参数共享-具体解释这两种特性及其作用"><a href="#问题1-卷积操作的本质特性包括稀疏交互和参数共享-具体解释这两种特性及其作用" class="headerlink" title="问题1: 卷积操作的本质特性包括稀疏交互和参数共享, 具体解释这两种特性及其作用"></a>问题1: 卷积操作的本质特性包括稀疏交互和参数共享, 具体解释这两种特性及其作用</h3><p><strong>稀疏交互(Sparse Interaction):</strong></p><p>对于全连接网络来说, 任意一个神经元都会与之前层的所有神经元产生交互, 形成稠密的连接结构, 而在卷积神经网络中, 卷积核尺寸远远小于输入数据的维度, 卷积核会在输入数据上进行类型窗口滑动似的扫描, 然后依次计算出输出神经元的值, 这样每个输出神经元仅仅与前一层特定局部区域内的神经元存在连接, 这种特性就成为稀疏交互.</p><p><strong>稀疏交互的作用:</strong></p><p>首先第一个很直观的作用就是大大降低了需要优化的参数数目, 是模型更加精简. 另外, 稀疏交互的实际意义还在于, 对于普通的图像, 文本, 语音等数据, 它们都具有较为明显的局部特征结构, 这样, 我们可以先让神经网络学习局部的特征, 再将局部的特征组合起来形成更复杂和抽象的特征, 进而达到识别目标的目的.</p><p><strong>参数共享(Parameter Sharing):</strong></p><p>参数共享是指在同一个模型的不同模块中使用相同的参数, 它是卷积运算的固有属性. 在卷积神经网络中, 卷积核中的每一个元素将作用于所有局部输入的特定位置上, 根据参数共享的思想, 我们队每个卷积核, 只需要学习一组参数, 而不需要针对不同的输入对每个局部位置的参数都进行优化, 这大大降低了模型的存储需求.</p><p><strong>参数共享的作用:</strong></p><p>参数共享的实际意义在于可以使得卷积层具有平移不变性. 对于图片来说, 不管图片中的物体出现在图片的哪个位置, 卷积层由于参数共享的作用, 它都会将这个物体看做是同一类, 也就是说, 对图片上的某个物体先进行卷积, 然后在将输出平移, 与先将图片中的物体平移, 再对平移后的物体进行卷积, 其输出结果是相等的</p><h3 id="问题2-常用的池化操作有哪些-池化的作用是什么"><a href="#问题2-常用的池化操作有哪些-池化的作用是什么" class="headerlink" title="问题2: 常用的池化操作有哪些? 池化的作用是什么?"></a>问题2: 常用的池化操作有哪些? 池化的作用是什么?</h3><p>常用的池化操作主要针对非重叠区域(即stride的值设置成大于等于pooling窗口的size), 包括均值池化(mean pooling), 最大池化(max pooling)等.</p><p>均值池化: 能够抑制由于邻域大小受限造成估计值方差增大的现象, 特点是对背景的保留效果更好</p><p>最大池化: 能够抑制网络参数误差造成估计值偏移的现象, 特点是更好地提取纹理信息</p><p>其他特殊的池化方式:</p><ul><li>相邻重叠区域的池化: 采用比窗口宽度更小的步长, 使得窗口在每次滑动时存在重叠区域</li><li>空间金字塔池化: 主要考虑了多尺度信息的描述, 例如同时计算1×1, 2×2, 4×4 的矩阵池化, 并将结果拼接在一起作为一下网络层的输入</li></ul><p>池化的本质是降采样. 除了能显著降低参数数量外, 还能保持对平移, 伸缩, 旋转操作的不变性.</p><ul><li>平移不变性: 输入为(1,3,5) 和(5,1,3)时, 最大池化都将取值5</li><li>伸缩(尺度)不变性: 如果原先神经元在最大池化操作之后输出5, 那么经过伸缩(尺度变换)后, 最大池化操作的输出很大概率仍然是5(主要最大值不变)</li><li>旋转不变性: 对于任意角度的输入, 都会有对应的过滤器与之匹配并最终使神经元的输出引起大的激活, 无论哪个神经元获得了激活, 在经过最大池化操作后, 对于此局部特征, 输出都会具有大的激活</li></ul><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw2rqo4zu0j20k00bcaas.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw2rqo4zlbj20k00bfjse.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw2rqo5t7mj20k00bct9r.jpg" alt=""></p><p><strong>综上, 池化主要有以下作用:</strong></p><ul><li>降维, 减少模型参数, 防止过拟合, 提高模型泛化能力</li><li>实现非线性</li><li>扩大感受野</li><li>实现平移, 伸缩, 旋转不变性</li></ul><p>下面的图与降采样有异曲同工之处, 可以帮助理解(<a href="https://www.zhihu.com/question/36686900" target="_blank" rel="noopener">https://www.zhihu.com/question/36686900</a>):</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw2rlw987gj206j085dia.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fw2rlw9q2gj208u07wn0b.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw2rlw8oihj205n06p767.jpg" alt=""></p><h3 id="问题3-卷积神经网络如何用于文本分类任务"><a href="#问题3-卷积神经网络如何用于文本分类任务" class="headerlink" title="问题3: 卷积神经网络如何用于文本分类任务?"></a>问题3: 卷积神经网络如何用于文本分类任务?</h3><p>卷积神经网络的核心思想是捕捉局部特征, 对于文本数据来说, 局部特征就是由若干单词组成的滑动窗口, 类似于 N-gram. 下面分别从输入层, 卷积层, 池化层和输出层来说一下如何将卷积神经网络应用于文本数据.</p><p><strong>输入层:</strong></p><p>输入层通常是一个 $N\times K$ 的矩阵, 其中 $N$ 为单词总数, $K$ 是每个单词对应向量的维度. 每个单词的 $K$ 维向量可以是预先在其他语料库中训练好的, 也可以作为未知的参数由网络训练得到. 这两种方法各有优势:</p><ul><li>预训练的词嵌入: 可以利用其他语料库得到更多的先验知识</li><li>作为未知参数训练: 能够更好的抓住与当前任务相关联的特征</li></ul><p>通常, 输入层会采用两个通道的形式, 即有两个 $N\times K$ 的输入矩阵, 其中一个用预先训练好的词嵌入表达, 并且在训练过程中不再发生变化; 另外一个也由同样的方式初始化, 但是会作为参数, 随着网络的训练过程发生改变.</p><p><strong>卷积层:</strong></p><p>在输入的 $N\times K$ 维的矩阵上, 我们定义不同大小的滑动窗口进行卷积操作:</p><script type="math/tex; mode=display">c_i = f(w \dot x_{i:i+h-1} + b)</script><p>其中 $x_{i:i+h-1}$ 代表由输入矩阵的第 $i$ 行到第 $i+h-1$ 行所组成的一个大小为 $h\times K$ 的滑动窗口, 假设 $h$ 为2, 则每次在 $2\times K$ 的滑动窗口上进行卷积, 并得到 $N-2$ 个结果, 再将这 $N-2$ 个结果拼接起来得到 $N-2$ 维的特征向量, 这样, 通过定义不同的滑动窗口, 就可以提取出不同的特征向量, 构成卷积层的输出</p><p><strong>池化层:</strong></p><p>池化层阶段从每个不同的特征向量筛选出 $K’$ (为了与上文的 $K$ 区分, 此处用 $K’$ ) 个最大的特征, 成为 K-MAX 池化 ( 也可以使用平均池化, 将每个特征向量平均), 最终达到的效果是将不同长度的句子通过池化得到一个定长的向量表示(长度为滑动窗口的个数)</p><p><strong>输出层:</strong></p><p>得到文本的向量表示后, 根据具体任务定义输出层的网络结构, 对于分类任务, 通常是用全连接层和Softmax激活函数输出每个类别的概率.</p><h2 id="6-深度残差网络"><a href="#6-深度残差网络" class="headerlink" title="6. 深度残差网络"></a>6. 深度残差网络</h2><h3 id="问题-ResNet的提出背景和核心理论是什么"><a href="#问题-ResNet的提出背景和核心理论是什么" class="headerlink" title="问题: ResNet的提出背景和核心理论是什么?"></a>问题: ResNet的提出背景和核心理论是什么?</h3><p><strong>提出背景:</strong></p><p>解决或缓解深层的神经网络训练中的梯度消失问题.</p><p><strong>ResNet中的一个重要假设:</strong></p><p>假设有一个L层的深度神经网络, 如果我们在上面加入一层, 直观来讲得到的L+1层深度神经网络的效果应该至少不会比L层的差. 因为可以简单的设最后一层为前一层的拷贝(相当于恒等映射), 并且其它层参数设置不变.</p><p>但是最终实验发现: 层数更深的神经网络反而会具有更大的训练误差, 因此, 作者认为深层网络效果差的原因很大程度上也许不在于过拟合, 而在于梯度消失问题. ( 关于梯度消失问题的讨论可见<a href="">这里</a>)</p><p><strong>解决办法:</strong></p><p>根据梯度消失问题的根本原因所在(链式法则连乘), ResNet通过调整网络结构来解决上述问题.</p><p>ResNet的结构设计思想为: <strong>既然离输入近的神经网络层较难训练, 那么我们可以将它短接到更靠近输出的层</strong></p><p>首先考虑两层神经网络的简单叠加, 在反向传播时,</p><p>有关ResNet更详细的讨论可以看<a href="">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的函数指针和函数对象</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>函数指针：指向函数地址的指针变量。 在C++编译时，每一个函数都有一个入口地址，该地址是存储函数机器语言代码的内存的开始地址。函数指针主要有两方面的用途：调用函数和用作函数参数。函数指针的声明方法如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pam</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> (* pf)(<span class="keyword">int</span>); <span class="comment">//将星号与函数名括起来，表示当前星号修饰的是函数名，而不是类型</span></span><br><span class="line">                    <span class="comment">//可以理解为将pam替换成了(*pf)</span></span><br><span class="line"><span class="comment">//通常，要声明指向特定类型的指针，可以首先编写这种函数的原型，然后用(*pf)替换函数名即可</span></span><br><span class="line">pf = pam; <span class="comment">// 函数名pam本身就是函数地址，所以可直接赋值，无需用取址符，但是要求pam的特征标必须与pf相同</span></span><br><span class="line">pf = &amp;pam; <span class="comment">//但实际上，也可以使用取址符，效果与上面 等价（why？）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下三种方式都是合法且等价的</span></span><br><span class="line"><span class="keyword">double</span> x = pam(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">double</span> y = (*pf)(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">double</span> z = pf(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>从上面的语句可以看出，C++同时允许使用带星号和不带星号的函数指针，最神奇的是效果居然是等价的（对于给函数指针赋值时，函数名带取址符和不带取址符的效果也是等价的！）！</p><p>导致以上“神奇事情”发生的原因是，在C++指定函数指针标准时，出现了两种不同的声音：一种学派认为，由于<code>pf</code>是函数指针，而<code>*pf</code>是函数，因此应将<code>(*pf)()</code>用作函数调用。另一种学派认为，由于函数名是指向该函数的指针，指向函数的指针的行为应该与函数名相似，因此应将<code>pf()</code>用作函数调用使用。C++进行了折衷——这两种方式都是正确的，虽然看上去它们在逻辑上是相冲突的。</p><p>下面的声明语句指出了一个函数指针数组，其中每个指针都指向这样的函数：将<code>const double*</code>和<code>int</code>作为参数，返回一个<code>const double　*</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>* (*pa[<span class="number">3</span>]) (<span class="keyword">const</span> <span class="keyword">double</span> *, <span class="keyword">int</span> ) = &#123; f1,f2,f3&#125;;</span><br></pre></td></tr></table></figure></p><p>这里不能使用<code>auto</code>，因为<code>auto</code>智能用于单值初始化，而不能用于初始化列表，但声明数组<code>pa</code>后，可以使用<code>auto</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pb = pa; <span class="comment">//</span></span><br></pre></td></tr></table></figure></p><p>pa和pb都是指向函数指针的指针，使用时可以用下标法，也可以当做指针使用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *px = pa[<span class="number">0</span>](av,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *py = (*pa[<span class="number">0</span>])(av,<span class="number">3</span>);  <span class="comment">//如果带星号，则不能少括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要获得值，可使用运算符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *x = *pa[<span class="number">0</span>](av,<span class="number">3</span>); <span class="comment">//少了括号以后，会取得返回值地址指向的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *y = *(*pb[<span class="number">1</span>])(av,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>如果继续声明了指向函数指针整个数组的指针，则使用方法又有些不同，见下面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pc = &amp;pa;  <span class="comment">//pc指向pa的地址</span></span><br><span class="line"></span><br><span class="line">*pc[<span class="number">3</span>];   <span class="comment">// 相当于 pa[3],代表一个包含三个指针的指针数组</span></span><br><span class="line">(*pc)[<span class="number">3</span>];  <span class="comment">// 代表pc是一个函数指针，指向含3个元素的指针数组</span></span><br></pre></td></tr></table></figure></p><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>函数对象的实质是对运算符<code>()</code>的重载。</p><p>＃　函数对象与函数指针的比较</p><p>函数对象的优势在于，可以把附加对象保存在函数对象中，也可以存储一些其他的额外信息，甚至可以用来封装类成员函数指针。</p><p>但是，函数对象本身并不是指针，因此在使用函数指针的场合中，往往无能为力。例如，不能将对象传给<code>qsort</code>函数！因为它只接受函数指针。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11新特性enable_if与SFINAE用法解析</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84enable-if%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84enable-if%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h1><p>SDINAE的全称是Substitution failure is not an error。意思是“匹配失败并非错误”</p><p>通常，在使用模板时，编译器会根据传入的参数来推导最适合的模板函数，在这个推导过程中只要有一个可以正确推导出来（但是不能有多个，否则会引起歧义），那么其他几个模板推导就是会产生编译错误，程序也可以正常通过。如下面的代码所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">typename</span> T::foo)</span> </span>&#123;&#125; <span class="comment">// Definition #1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;&#125;               <span class="comment">// Definition #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f&lt;Test&gt;(<span class="number">10</span>); <span class="comment">// Call #1.</span></span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);  <span class="comment">// Call #2. Without error (even though there is no int::foo)</span></span><br><span class="line">    <span class="comment">//thanks to SFINAE.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h1><p>这是一个模板类，该模板可能的实现如下：（也许会有其他版本，但大意都差不多）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">enable_if</span> &#123;</span>&#125;; <span class="comment">//在C++中，struct和class除了默认访问权限不同外，无任何差异</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">enable_if</span>&lt;true, T&gt; &#123;</span> <span class="keyword">typedef</span> T type; &#125;;</span><br></pre></td></tr></table></figure></p><p>以上表示，若B为true，则std::enable_if模板类拥有公开成员typedef type ，等于T；否则，无该成员。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《C++ PrimerPlus》 第十七章～第十八章</title>
      <link href="/z_post/Cpp-Book-CppPrimerPlusChapter17-18/"/>
      <url>/z_post/Cpp-Book-CppPrimerPlusChapter17-18/</url>
      
        <content type="html"><![CDATA[<h2 id="18-3-新的类功能"><a href="#18-3-新的类功能" class="headerlink" title="18.3 新的类功能"></a>18.3 新的类功能</h2><h3 id="18-3-1-特殊的成员函数"><a href="#18-3-1-特殊的成员函数" class="headerlink" title="18.3.1 特殊的成员函数"></a>18.3.1 特殊的成员函数</h3><h3 id="18-3-2-默认的方法和禁用的方法"><a href="#18-3-2-默认的方法和禁用的方法" class="headerlink" title="18.3.2 默认的方法和禁用的方法"></a>18.3.2 默认的方法和禁用的方法</h3><p>在C++中，如果只在程序中提供了移动构造函数，那么编译器将不会自动创建默认的构造函数、复制构造函数和复制赋值构造函数。在这种情况下，可以使用关键字<code>default</code>显式的声明这些方法的默认版本：（即只给出函数头，后接<code>=default</code>，则这些方法的默认版本就会被创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Someclass</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">  Someclass(Someclass &amp;&amp;);</span><br><span class="line">  Someclass() = default;</span><br><span class="line">  Someclass(const Someclass &amp;) = default;</span><br><span class="line">  Someclass&amp; operator=(const Someclass &amp;) = default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一方面，关键字<code>delete</code>可用于禁止编译器使用特定的方法，例如，要禁止复制对象，可禁用复制构造函数和复制赋值运算符（之前是通过将其访问权限设值为private来实现的，现在的实现方法更容易理解，且不易犯错）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>关键字<code>default</code>智能用于6个特殊的成员函数，但<code>delete</code>可用于任何成员函数。<code>delete</code>的一种可能用法是禁止特定的转换。</p><h2 id="18-6-可变参数模板"><a href="#18-6-可变参数模板" class="headerlink" title="18.6 可变参数模板"></a>18.6 可变参数模板</h2>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的mt19937</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84mt19937/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84mt19937/</url>
      
        <content type="html"><![CDATA[<h1 id="std-mersenne-twister-engine"><a href="#std-mersenne-twister-engine" class="headerlink" title="std::mersenne_twister_engine"></a>std::mersenne_twister_engine</h1><p>该类型是一个基于梅森缠绕器算啊费的随机数生成器，可以产生高质量的无符号随机整数</p><h1 id="mt19937-和-mt19937-64"><a href="#mt19937-和-mt19937-64" class="headerlink" title="mt19937 和 mt19937_64"></a>mt19937 和 mt19937_64</h1><p>这两个类型分别是具有预先定义参数的随机数引擎，有松本与西村设计</p><h1 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h1><p>seed、operator、discard、min、max 等等</p><h1 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h1><p>operator==、operator!=、等等</p><h1 id="成员对象"><a href="#成员对象" class="headerlink" title="成员对象"></a>成员对象</h1><p>word_size、state_size等等</p><p>具体见：<a href="https://zh.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine</a></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的pragma和#ifndef组合语句的联系与区别</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84pragma%E5%92%8Cifndef%E7%BB%84%E5%90%88%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84pragma%E5%92%8Cifndef%E7%BB%84%E5%90%88%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>在C++中，为了避免同一个文件被<code>include</code>多次，常常需要在文中加上一些保证，主要有两种方式，二者用法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HEAD__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HEAD__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>通常，在能够支持这两种方式的编译器上，二者没有太大的区别。下面简介说一下二者格子的优缺点：</p><p>对于<code>#ifndef</code>方式来说，不光可以保证同一个文件不会被包含多级，也能保证内容完全相同的两个文件不会被不小心同时包含，但这样就需要编译器每次都扫描头文件内部，因此会使得编译时间相对较长。另外一个缺点就是该方式需要自定义宏名称，当项目很大时，宏名称有“撞车”的风险。</p><p>对于<code>#pragma once</code>方式来说，首先是需要code的代码很少，另外不需要自定义宏名称，避免了“撞车”的风险，但是<code>#pragma once</code>提供的保证仅仅是：同一个物理意义上的文件不会被包含多次。如果两个文件内容完全一样，则该方式仍然会重复包含。</p><p>结合以上分析，我个人倾向于使用<code>#pragma once</code>，因为需要code的代码更少，无需自想宏名称，另外，出现包含多个内容相同的文件的情况也很很少的（除非有意，否则不太可能出现这种情况）。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《OpenCV3编程入门》</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-OpenCV3%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-OpenCV3%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的有关int的各种形式以及为什么要有size_t类型</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E6%9C%89%E5%85%B3int%E7%9A%84%E5%90%84%E7%A7%8D%E5%BD%A2%E5%BC%8F/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E6%9C%89%E5%85%B3int%E7%9A%84%E5%90%84%E7%A7%8D%E5%BD%A2%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>int,int32_t,int64_t</p><p>数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较：</p><p>16位平台</p><p>char         1个字节8位<br>short        2个字节16位<br>int            2个字节16位<br>long         4个字节32位<br>指针         2个字节</p><p>32位平台</p><p>char         1个字节8位<br>short        2个字节16位<br>int            4个字节32位<br>long         4个字节<br>long long 8个字节<br>指针         4个字节</p><p>64位平台</p><p>char         1个字节<br>short        2个字节<br>int            4个字节<br>long         8个字节（区别）<br>long long 8个字节<br>指针        8个字节（区别）</p><p>为了保证平台的通用性，程序中尽量不要使用long数据库型。同时，通过int_32t等形式来明确int型数据所占有的位数。</p><p>另外 还有size_t</p><p>size_t是一些C/C++标准在stddef.h中定义的。这个类型足以用来表示对象的大小。</p><p>size_t的真实类型与操作系统有关，在32位架构中被普遍定义为：</p><p>typedef   unsigned int size_t;</p><p>而在64位架构中被定义为：</p><p>typedef  unsigned long size_t;<br>size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。<br>而int在不同架构下都是4字节，与size_t不同；且int为带符号数，size_t为无符号数。</p><h1 id="size-t-这个类型的意义："><a href="#size-t-这个类型的意义：" class="headerlink" title="size_t 这个类型的意义："></a>size_t 这个类型的意义：</h1><p>size_t和unsigned int有所不同,size_t的取值range是目标平台下最大可能的数组尺寸,一些平台下size_t的范围小于int的正数范围,又或者大于unsigned int.最典型的,在x64下,int还是4,但size_t是8.这意味着你在x64下最大可能开辟的数组尺寸是2^64.如果你使用int或者unsigned int,那么在x64下如果你的代码中全部使用uint作为数组的尺寸标记,那么你就会失去控制2^32尺寸以上的数组的机会.虽然现在在x64上开辟一个大于2^32大小的连续数组依然是个不大可能的事情,但是……….“640K内存对于任何人来说都足够了”——比尔盖茨</p><p>学过计算机组成原理应该不会对此有疑问。int小于等于数据线宽度，size_t大于等于地址线宽度。size_t存在的最大原因可能是因为：地址线宽度历史中经常都是大于数据线宽度的。在数据只有8位的年代，地址率先进入10位，12位，在数据16位的年代，地址也已经进入了20位，24位。目前的int普遍是32位，而size_t在主流平台中都是64位。size_t为什么存在？因为无论int还是unsigned都很可能小于size_t需要的大小，所以必须有个size_t。—补充：据说题主对_t有疑惑。这个问题很简单，仅仅是因为作者选择这样的命名作为编码规范而已。类型名与变量名共享相同的命名空间，所以通常需要在命名方面刻意区分出来。在遥远的 C 时代，发明者很可能是想建议所有的类型名后面加_t，只不过这并没有成为更普遍的编码规范罢了。而现今Java的规范倒比较容易让人接受：大写开头的是类型名，小写开头的是变量名跟函数名，虽然具体细则有不同，但原意都是一样的：变量与类型共享同一个命名空间，因而需要在命名规则上刻意区分开来。</p><h1 id="为什么size-t-重要？"><a href="#为什么size-t-重要？" class="headerlink" title="为什么size_t 重要？"></a>为什么size_t 重要？</h1><p><a href="https://jeremybai.github.io/blog/2014/09/10/size-t" target="_blank" rel="noopener">https://jeremybai.github.io/blog/2014/09/10/size-t</a></p><p>前言：使用size_t可能会提高代码的可移植性、有效性或者可读性，或许同时提高这三者。</p><p>　　在标准C库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如说malloc(n) 函数的参数n指明了需要申请的空间大小，还有memcpy(s1, s2, n)的最后一个参数，表明需要复制的内存大小，strlen(s)函数的返回值表明了以’\0’结尾的字符串的长度（不包括’\0’），其返回值并不是该字符串的实际长度，因为要去掉’\0’。<br>　　或许你会认为这些参数或者返回值应该被申明为int类型（或者long或者unsigned），但是事实上并不是。C标准中将他们定义为size_t。标准中记载malloc的申明应该出现在，定义为：</p><p>void *malloc(size_t n);<br>　　memcpy和strlen的申明应该出现在中：</p><p>void <em>memcpy(void </em>s1, void const <em>s2, size_t n);<br>size_t strlen(char const </em>s);<br>　　size_t还经常出现在C++标准库中，此外，C++库中经常会使用一个相似的类型size_type，用的可能比size_t还要多。<br>　　据我所知，大部分的C和C++程序员害怕这些库使用size_t，因为他们不知道size_t代表什么或者为什么这些库需要使用它，归根结底，原因在于他们什么时候什么地方需要用到它。</p><p>可移植性问题<br>　　早期的C语言（由Brian Kernighan 和 Dennis Ritchie 在The C Programming Language书中所写，Prentice-Hall, 1978）并没有提供size_t类型，C标准委员会为了解决移植性问题将size_t引入，举例如下：<br>　　让我们来写一个可移植的标准memcpy函数，我们将会看到一些不同的申明和它们在不同平台不同大小的地址空间上编译下的情况。<br>　　回忆memcpy(s1, s2, n)函数，它将s2指向地址开始的n个字节拷贝到s2指向的地址，返回s1，这个函数可以拷贝任何数据类型，所以参数和返回值的类型应该为可以指向任何类型的void<em>，同时，源地址不应该被改变，所以第二个参数s2类型应该为const void</em>，这些都不是问题。<br>　　真正的问题在于我们如何申明第三个参数，它代表了源对象的大小，我相信大部分程序员都会选择int：</p><p>void <em>memcpy(void </em>s1, void const *s2, int n);<br>　　使用int类型在大部分情况下都是可以的，但是并不是所有情况下都可以。int是有符号的，它可以表示负数，但是，大小不可能是复数。所以我们可以使用unsigned int代替它让第三个参数表示的范围更大。<br>　　在大部分机器上，unsigned int的最大值要比int的最大值大两倍，比如说再也给16位的机器上，unsigned int的最大值为65535，int的最大值为32767。<br>　　尽管int类型的大小依赖于C编译器的实现，但是在给定的平台上int对象的大小和unsigned int对象的大小是一样的。因此，使用unsigned int修饰第三个参数的代价与int是相同的：</p><p>void <em>memcpy(void </em>s1, void const *s2, unsigned int n);<br>　　这样似乎没有问题了，unsigned int可以表示最大类型的对象大小了，这种情况只有在整形和指针类型具有相同大小的情况下，比如说在IP16中，整形和指针都占2个字节（16位），而在IP32上面，整形和指针都占4个字节（32位）。（参见下面C数据模型表示法）</p><p>C数据模型表示法<br>　　最近，我偶然发现几篇文章，他们使用简明的标记来表述不同目标平台下c语言数据的实现。我还没有找到这个标记的来源，正式的语法，甚至连名字都没有，但他似乎很简单，即使没有正规的定义也可以很容易使用起来。这些标记的一边形式形如：<br>　　I nI L nL LL nLL P nP。<br>　　其中每个大写字母（或成对出现）代表一个C的数据类型，每一个对应的n是这个类型包含的位数。I代表int，L代表long，LL代表long long，以及P代表指针（指向数据，而不是函数）。每个字母和数字都是可选的。<br>　　例如，I16P32架构支持16位int和32位指针类型，没有指明是否支持long或者long long。如果两个连续的类型具有相同的大小，通常省略第一个数字。例如，你可以将I16L32P32写为I16LP32，这是一个支持16位int，32位long，和32位指针的架构。<br>　　标记通常把字母分类在一起，所以可以按照其对应的数字升序排列。例如，IL32LL64P32表示支持32位int，32位long，64位long long和32位指针的架构；然而，通常写作ILP32LL64。<br>　　不幸的是，这种memcpy的申明在I16LP32架构上（整形是16-bit 长整形和指针类型时32-bits）显得不够用了，比如说摩托罗拉第一代处理器68000，在这种情况下，处理器可能拷贝的数据大于65535个字节，但是这个函数第三个参数n不能处理这么大的数据。<br>　　什么？你说很容易就可以改正？只需要把memcpy的第三个参数的类型修改一下：</p><p>void <em>memcpy(void </em>s1, void const *s2, unsigned long  n);<br>　　你可以在I16LP32目标架构上使用这个函数了，它可以处理更大的数据。而且在IP16和IP32平台上效果也还行，说明它确实给出了memcpy的一种移植性较好的申明。但是，在IP16平台上相比于使用unsigned int，你使用unsigned long可能会使你的代码运行效率大打折扣（代码量变大而且运行变慢）。<br>　　在标准C中规定，长整形（无论无符号或者有符号）至少占用32位，因此在IP16平台上支持标准C的话，那么它一定是IP16L32 平台。这些平台通常使用一对16位的字来实现32位的长整形。在这种情况下，移动一个长整形需要两条机器指令，每条移动一个16位的块。事实上，这个平台上的大部分的32位操作都需要至上两条指令。<br>　　因此，以可移植性为名将memcpy的第三个参数申明为unsigned long而降低某些平台的性能是我们所不希望看到的。使用size_t可以有效避免这种情况。<br>　　size_t类型是一个类型定义，通常将一些无符号的整形定义为size_t，比如说unsigned int或者unsigned long，甚至unsigned long long。每一个标准C实现应该选择足够大的无符号整形来代表该平台上最大可能出现的对象大小。</p><p>使用size_t<br>　　size_t的定义在<stddef.h>, <stdio.h>, <stdlib.h>, <string.h>, <time.h>和<wchar.h>这些标准C头文件中，也出现在相应的C++头文件, 等等中，你应该在你的头文件中至少包含一个这样的头文件在使用size_t之前。 　　包含以上任何C头文件（由C或C++编译的程序）表明将size_t作为全局关键字。包含以上任何C++头文件（当你只能在C++中做某种操作时）表明将size_t作为std命名空间的成员。 　　根据定义，size_t是sizeof关键字（注：sizeof是关键字，并非运算符）运算结果的类型。所以，应当通过适当的方式声明n来完成赋值：</wchar.h></time.h></string.h></stdlib.h></stdio.h></stddef.h></p><p>n = sizeof(thing);<br>　　考虑到可移植性和程序效率，n应该被申明为size_t类型。类似的，下面的foo函数的参数也应当被申明为sizeof：</p><p>foo(sizeof(thing));<br>　　参数中带有size_t的函数通常会含有局部变量用来对数组的大小或者索引进行计算，在这种情况下，size_t是个不错的选择。<br>　　适当地使用size_t还会使你的代码变得如同自带文档。当你看到一个对象声明为size_t类型，你马上就知道它代表字节大小或数组索引，而不是错误代码或者是一个普通的算术值。<br>　　在我接下来的一些文章的例子中会使用size_t，敬请期待！</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的aligned_alloc</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84aligned-alloc/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84aligned-alloc/</url>
      
        <content type="html"><![CDATA[<h1 id="std-aligned-alloc"><a href="#std-aligned-alloc" class="headerlink" title="std::aligned_alloc"></a>std::aligned_alloc</h1><p>定义于头文件 <cstdlib></cstdlib></p><p>void* aligned_alloc( std::size_t alignment, std::size_t size );<br>(C++17 起)</p><p>分配 size 字节的未初始化存储，由 alignment 指定其对齐。 size 参数必须是 alignment 的整数倍。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>轻量级深度学习框架ZeroTensor：（二）tensor类的设计与实现</title>
      <link href="/z_post/%E9%A1%B9%E7%9B%AE-ZeroTensor-Tensor%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/z_post/%E9%A1%B9%E7%9B%AE-ZeroTensor-Tensor%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Tensor类"><a href="#Tensor类" class="headerlink" title="Tensor类"></a>Tensor类</h1><p>Tensor类是zerotensor框架的所有数据的基类，它的成员变量和成员函数如下所示：</p><p>有关类内部的具体实现可以在源码中的<code>/src/data/tensor.h</code>中看到。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++中的lambda表达式</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中的lambda与函数对象"><a href="#C-中的lambda与函数对象" class="headerlink" title="C++中的lambda与函数对象"></a>C++中的lambda与函数对象</h1><p><code>lambda</code>表达式是C++11中引入的一项新技术，利用<code>lambda</code>表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。但是从本质上来讲，lambda表达式只是一种语法糖，因为所有其能完成的工作都可以用其它稍微复杂的代码来实现。但是它简便的语法却给C++带来了深远的影响。</p><p>如果从广义上说，<code>lambda</code>表达式产生的是函数对象。函数对象的本质上是一个类而不是一个函数，在类中，对象重载了函数调用运算符()，从而使对象能够项函数一样被调用，我们称这些对象为函数对象（Function Object）或者仿函数（Functor）。相比lambda表达式，函数对象有自己独特的优势。下面我们开始具体讲解这两项黑科技。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>先从一个简单的例子开始，我们定义一个输出字符串的<code>lambda</code>表达式，如下所示，表达式一般都是从方括号<code>[]</code>开始，然后结束于花括号<code>{}</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> basic_lambda = []&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello Lambda"</span>&lt;&lt;<span class="built_in">endl</span>;&#125; <span class="comment">//定义简单的lambda表达式</span></span><br><span class="line">basic_lambda(); <span class="comment">//调用</span></span><br></pre></td></tr></table></figure></p><p>下面分别是包含参数和返回类型的<code>lambda</code>表达式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">int</span> &#123; <span class="keyword">return</span> a+b;&#125; <span class="comment">//返回类型需要用`-&gt;`符号指出</span></span><br><span class="line"><span class="keyword">auto</span> multiply = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a*b;&#125; <span class="comment">//一般可以省略返回类型，通过自动推断就能得到返回类型</span></span><br></pre></td></tr></table></figure></p><p><code>lambda</code>表达式最前面的方括号提供了“闭包”功能。每当定义一个<code>lambda</code>表达式以后，编译器会自动生成一个 <strong>匿名类</strong> ，并且这个类重载了<code>()</code>运算符，我们将其称之为<code>闭包类型（closure type）</code>。在运行时，这个<code>lambda</code>表达式会返回一个匿名的闭包实例，并且该实例是一个右值。闭包的一个强大之处在于其可以通过传值或引用的方式捕捉其封装作用域内的变量，<code>lambda</code>表达式前面的方括号就是用来定义捕捉模式以及变量的<code>lambda</code>捕捉块，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">10</span>; <span class="comment">// 定义作用域内的x，方面下面的lambda捕捉</span></span><br><span class="line">  <span class="keyword">auto</span> add_x = [x](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a+x; &#125; <span class="comment">// 传值捕捉x</span></span><br><span class="line">  <span class="keyword">auto</span> multiply_x = [&amp;x](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a*x;&#125; <span class="comment">//引用捕捉x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当<code>lambda</code>捕捉块为空时，表示没有捕捉任何变量。对于传值方式捕捉的变量x，<code>lambda</code>表达式会在生成的匿名类中添加一个非静态的数据成员，由于闭包类重载<code>()</code>运算符是使用了const属性，所以不能在<code>lambda</code>表达式中修改传值方式捕捉的变量，但是如果把<code>lambda</code>标记为<code>mutable</code>，则可以改变，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_x = [x](<span class="keyword">int</span> a) <span class="keyword">mutable</span>&#123; x * = <span class="number">2</span>; <span class="keyword">return</span> a+x;&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;add_x(<span class="number">10</span>)&lt;&lt;endk; <span class="comment">//输出30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>而对于引用方式捕捉的变量，无论是否标记为<code>mutable</code>，都可以对变量进行修改，至于会不会在匿名类中创建数据成员，需要看不同编译器的具体实现。</p><p><code>lambda</code>表达式只能作为右值，也就是说，它是不能被赋值的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a=[]&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"A"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">auto</span> b=[]&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"B"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">a = b;  <span class="comment">// 非法，lambda表达式变量只能做右值</span></span><br><span class="line"><span class="keyword">auto</span> c = a; <span class="comment">// 合法，生成一个副本</span></span><br></pre></td></tr></table></figure></p><p>造成以上原因是因为禁用了赋值运算符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClosureType&amp; operator=(const ClosureType&amp;) = delete;</span><br></pre></td></tr></table></figure></p><p>但是没有禁用复制构造函数，所以仍然可以用是一个<code>lambda</code>表达式去初始化另一个（通过产生副本）。</p><p>关于<code>lambda</code>的捕捉块，主要有以下用法：</p><ul><li>[]：默认不捕捉变量</li><li>[=]：默认以值捕捉所有变量（最好不要用）</li><li>[&amp;]：默认以引用捕捉所有变量（最好不要用）</li><li>[x]：仅以值捕捉变量x，其他变量不捕捉</li><li>[&amp;x]：仅以引用捕捉x，其他变量不捕捉</li><li>[=, &amp;x]：默认以值捕捉所有变量，但是x是例外，通过引用捕捉</li><li>[&amp;, x]：默认以引用捕捉所有变量，但是x是例外，通过值捕捉</li><li>[this]：通过引用捕捉当前对象（其实是复制指针）</li><li>[* this]：通过传值方式捕捉当前对象</li></ul><p>通过以上的说明，可以看到<code>lambda表达式</code>可以作为返回值，赋值给对应类型的函数指针，但是使用函数指针貌似并不是那么方便，于是STL在头文件<code>&lt;functional&gt;</code>中定义了一个多态的函数对象封装<code>std::function</code>，其功能类似于函数指针。它可以绑定到任何类函数对象，只要参数与返回类型相同。如下面的返回一个bool且接收两个int的函数包装器：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; wrapper = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x&lt;y; &#125;</span><br></pre></td></tr></table></figure></p><p><code>lambda</code>表达式还有一个很重要的应用是其可以作为函数的参数，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count == <span class="built_in">std</span>::count_if(v.begin, v.end(), [value](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x&gt;value;&#125;);</span><br></pre></td></tr></table></figure></p><p>下面给出<code>lambda</code>表达式的完整语法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整语法</span></span><br><span class="line">[ capture-<span class="built_in">list</span> ] ( params ) <span class="keyword">mutable</span>(optional) <span class="keyword">constexpr</span>(optional)(c++<span class="number">17</span>) exception attribute -&gt; ret &#123; body &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选的简化语法</span></span><br><span class="line">[ capture-<span class="built_in">list</span> ] ( params ) -&gt; ret &#123; body &#125;     </span><br><span class="line">[ capture-<span class="built_in">list</span> ] ( params ) &#123; body &#125;    </span><br><span class="line">[ capture-<span class="built_in">list</span> ] &#123; body &#125;</span><br></pre></td></tr></table></figure></p><ul><li>capture-list：捕捉列表，这个不用多说，前面已经讲过，记住它不能省略；</li><li>params：参数列表，可以省略（但是后面必须紧跟函数体）；</li><li>mutable：可选，将lambda表达式标记为mutable后，函数体就可以修改传值方式捕获的变量；</li><li>constexpr：可选，C++17，可以指定lambda表达式是一个常量函数；</li><li>exception：可选，指定lambda表达式可以抛出的异常；</li><li>attribute：可选，指定lambda表达式的特性；</li><li>ret：可选，返回值类型；</li><li>body：函数执行体。</li></ul><h1 id="lambda新特性（C-14）"><a href="#lambda新特性（C-14）" class="headerlink" title="lambda新特性（C++14）"></a>lambda新特性（C++14）</h1><p>在<code>C++14</code>中，<code>lambda</code>又得到了增强，一个是泛型<code>lambda</code>表达式，一个是<code>lambda</code>可以捕捉表达式。</p><h2 id="lambda捕捉表达式"><a href="#lambda捕捉表达式" class="headerlink" title="lambda捕捉表达式"></a>lambda捕捉表达式</h2><p>前面讲过，<code>lambda</code>表达式可以按传值或者引用捕捉在其作用域范围内的变量。而有时候，我们希望捕捉不在其作用域范围内的变量，而且最重要的是我们希望捕捉右值。所以<code>C++14</code>中引入了表达式捕捉，其允许用任何类型的表达式初始化捕捉的变量，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用表达式捕获，可以更灵活地处理作用域内的变量</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> y = [&amp;r = x, x = x + <span class="number">1</span>] &#123; r += <span class="number">2</span>; <span class="keyword">return</span> x * x; &#125;();</span><br><span class="line"><span class="comment">// 此时 x 更新为6，y 为25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接用字面值初始化变量</span></span><br><span class="line"><span class="keyword">auto</span> z = [str = <span class="string">"string"</span>]&#123; <span class="keyword">return</span> str; &#125;();</span><br><span class="line"><span class="comment">// 此时z是const char* 类型，存储字符串 string</span></span><br></pre></td></tr></table></figure></p><p>可以看到捕捉表达式扩大了lambda表达式的捕捉能力，有时候你可以用std::move初始化变量。这对不能复制只能移动的对象很重要，比如std::unique_ptr，因为其不支持复制操作，你无法以值方式捕捉到它。但是利用lambda捕捉表达式，可以通过移动来捕捉它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myPi = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">double</span>&gt;(<span class="number">3.1415</span>);</span><br><span class="line"><span class="keyword">auto</span> circle_area = [pi = <span class="built_in">std</span>::move(myPi)](<span class="keyword">double</span> r) &#123; <span class="keyword">return</span> *pi * r * r; &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; circle_area(<span class="number">1.0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 3.1415</span></span><br></pre></td></tr></table></figure><h2 id="泛型lambda表达式"><a href="#泛型lambda表达式" class="headerlink" title="泛型lambda表达式"></a>泛型lambda表达式</h2><p>从C++14开始，lambda表达式支持泛型：其参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。这就如同函数模板一样，参数要使用类型自动推断功能，只需要将其类型指定为auto，类型推断规则与函数模板一样。这里给出一个简单例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = add(<span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">double</span> y = add(<span class="number">2.5</span>, <span class="number">3.5</span>);  <span class="comment">// 6.0</span></span><br></pre></td></tr></table></figure><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>函数对象是一个广泛的概念，因为所有具有函数行为的对象都可以称为函数对象。这是一个高级抽象，我们不关心对象到底是什么，只要其具有函数行为即可。函数行为是指可以使用<code>()</code>调用并传递参数，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(arg1, arg2, ...); <span class="comment">//函数调用</span></span><br></pre></td></tr></table></figure></p><p>由此，<code>lambda</code>表达式也是一个函数对象。该函数对象实际上是一个匿名类的实例，且这个类实现了函数调用运算符<code>()</code>。</p><p>泛型提供了高级抽象，不论是<code>lambda</code>表达式、函数对象、还是函数指针，都可以传入到STL算法中（如for_each）。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的枚举类</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>p372<br>一、简述<br>  强类型枚举（Strongly-typed enums），号称枚举类型，是C++11中的新语法，用以解决传统C++枚举类型存在的缺陷。传统C++中枚举常量被暴漏在外层作用域中，这样若是同一作用域下有两个不同的枚举类型，但含有相同的枚举常量也是不可的，比如：</p><p>enum Side{Right,Left};<br>enum Thing{Wrong,Right};<br>这是不能一起用的。<br>  另外一个缺陷是传统枚举值总是被隐式转换为整形，用户无法自定义类型。C++11中的强类型枚举解决了这些问题。<br>—————————————————————————</p><p>二、强类型枚举<br>  强类型枚举使用enum class语法来声明，如下：</p><p>enum class Enumeration{<br> VAL1,<br> VAL2,<br> VAL3=100,<br> VAL4<br>};<br>这样，枚举类型时安全的，枚举值也不会被隐式转换为整数，无法和整数数值比较，比如（Enumeration：：VAL4==10会触发编译错误）。<br> 另外枚举类型所使用的类型默认为int类型，也可指定其他类型，比如：</p><p>enum calss Enum:unsigned int{VAL1,VAL2};<br>正如前面所说，强类型枚举能解决传统枚举不同枚举类下同枚举值名的问题，使用枚举类型的枚举名时，必须指明所属范围，比如：Enum::VAL1，而单独的VAL1则不再具有意义。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重写C++中异常类的what方法</title>
      <link href="/z_post/Cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-%E9%87%8D%E5%86%99Cpp%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84what%E6%96%B9%E6%B3%95/"/>
      <url>/z_post/Cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-%E9%87%8D%E5%86%99Cpp%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84what%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="待补充完善：错误原因以及为什么这么修改"><a href="#待补充完善：错误原因以及为什么这么修改" class="headerlink" title="待补充完善：错误原因以及为什么这么修改"></a>待补充完善：错误原因以及为什么这么修改</h1><h1 id="坑源"><a href="#坑源" class="headerlink" title="坑源"></a>坑源</h1><p>在实现项目ZeroTensor的专属异常类时，需要实现<code>exception</code>类的<code>what</code>方法。</p><h1 id="出现问题及解决办法"><a href="#出现问题及解决办法" class="headerlink" title="出现问题及解决办法"></a>出现问题及解决办法</h1><p>首先需要看一下<code>exception</code>基类中关于<code>what</code>方法的原始定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是正确的重写方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> error_msg_.c_str(); &#125;</span><br></pre></td></tr></table></figure><p>如果去掉throw() ， 则会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">looser <span class="keyword">throw</span> specifier <span class="keyword">for</span> ‘<span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* zerotensor::ZerotensorError::what() <span class="keyword">const</span>’</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *what() <span class="keyword">const</span> override &#123; <span class="keyword">return</span> error_msg_.c_str(); &#125;</span><br></pre></td></tr></table></figure><p>如果将char * 改为 string，则会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: ‘<span class="keyword">const</span> <span class="built_in">string</span> zerotensor::ZerotensorError::what() <span class="keyword">const</span>’ cannot be overloaded</span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> error_msg_; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的mutable关键字</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84mutable%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84mutable%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。</p><p>mutable在类中只能够修饰非静态数据成员。mutable 数据成员的使用看上去像是骗术，因为它能够使const函数修改对象的数据成员。然而，明智地使用 mutable 关键字可以提高代码质量，因为它能够让你向用户隐藏实现细节，而无须使用不确定的东西。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="number">2</span>;<span class="comment">//错误，不能在const成员函数中修改普通变量</span></span><br><span class="line">b = <span class="number">5</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a: %d, b: %d\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//结构体变量为const，其mutable成员也可以被修改</span></span><br><span class="line"><span class="keyword">const</span> tagData dat = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">dat.a = <span class="number">8</span>;<span class="comment">//编译错误</span></span><br><span class="line">dat.b = <span class="number">9</span>;<span class="comment">//编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类对象为const，其mutable成员也可以被修改</span></span><br><span class="line">clsData cls;</span><br><span class="line">cls.show();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const承诺的是一旦某个变量被其修饰，那么只要不使用强制转换(const_cast)，在任何情况下该变量的值都不会被改变，无论有意还是无意，而被const修饰的函数也一样，一旦某个函数被const修饰，那么它便不能直接或间接改变任何函数体以外的变量的值，即使是调用一个可能造成这种改变的函数都不行。这种承诺在语法上也作出严格的保证，任何可能违反这种承诺的行为都会被编译器检查出来。</p><p>mutable的承诺是如果某个变量被其修饰，那么这个变量将永远处于可变的状态，即使在一个const函数中。这与const形成了一个对称的定义，一个永远不变，而另外一个是永远可变。</p><p>看一个变量或函数是否应该是const，只需看它是否应该是constant或invariant，而看一个变量是否应该是mutable，也只需看它是否是forever mutative。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用CUDA进行一维数组的矢量求和</title>
      <link href="/z_post/CUDA-CUDA%E7%A4%BA%E4%BE%8B%E5%AD%A6%E4%B9%A0-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E7%9F%A2%E9%87%8F%E6%B1%82%E5%92%8C/"/>
      <url>/z_post/CUDA-CUDA%E7%A4%BA%E4%BE%8B%E5%AD%A6%E4%B9%A0-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E7%9F%A2%E9%87%8F%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>基于GPU的一维数组的矢量求和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="comment">//如果忘记写global，会报错：error: a host function call cannot be configured</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x;</span><br><span class="line">    <span class="keyword">if</span>(tid&lt; N)&#123;</span><br><span class="line">c[tid] = a[tid] + b[tid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> b[N];</span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="keyword">int</span> *dev_a, *dev_b, *dev_c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*cudaMalloc((void**)&amp;dev_a, N*sizeof(int));*/</span></span><br><span class="line">    <span class="comment">/*cudaMalloc((void**)&amp;dev_b, N*sizeof(int));*/</span></span><br><span class="line">    <span class="comment">/*cudaMalloc((void**)&amp;dev_c, N*sizeof(int));*/</span></span><br><span class="line"></span><br><span class="line">    cudaMalloc(&amp;dev_a, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    cudaMalloc(&amp;dev_b, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    cudaMalloc(&amp;dev_c, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;N; i++)&#123;</span><br><span class="line">a[i] = i;</span><br><span class="line">b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(dev_a, a, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(dev_b, b, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    add&lt;&lt;&lt;N,<span class="number">1</span>&gt;&gt;&gt;(dev_a,dev_b,dev_c);</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(c, dev_c, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    cudaFree(dev_a);</span><br><span class="line">    cudaFree(dev_b);</span><br><span class="line">    cudaFree(dev_c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;N; i++)&#123;</span><br><span class="line">      <span class="comment">//如果错误的访问量dev_c[i]，会报告段错误</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;c[i]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA示例学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《C++ PrimerPlus》 第十六章</title>
      <link href="/z_post/Cpp-Book-CppPrimerPlusChapter16/"/>
      <url>/z_post/Cpp-Book-CppPrimerPlusChapter16/</url>
      
        <content type="html"><![CDATA[<h1 id="第十六章-string类和标准模板库"><a href="#第十六章-string类和标准模板库" class="headerlink" title="第十六章 string类和标准模板库"></a>第十六章 string类和标准模板库</h1><h2 id="16-1-string-类"><a href="#16-1-string-类" class="headerlink" title="16.1 string 类"></a>16.1 string 类</h2><p>头文件：</p><ul><li>string：支持的是string类</li><li>string.h / cstring：　支持的是C-风格字符串的C库字符串函数</li></ul><h3 id="16-1-1-构造字符串"><a href="#16-1-1-构造字符串" class="headerlink" title="16.1.1 构造字符串"></a>16.1.1 构造字符串</h3><p>string类的构造函数如下（用<code>ctor</code>标识，这是传统C++中构造函数的缩写，表中的NBTS（null-terminated string）标识以空字符结束的字符串——传统的C字符串，<code>size_type</code> 是一个依赖于实现的整型，在头文件<code>string</code>中定义）：</p><div class="table-container"><table><thead><tr><th>构造函数</th><th>描述</th></tr></thead><tbody><tr><td>string(const char *s)</td><td>将<code>string</code>对象初始化为s指向的NBTS</td></tr><tr><td>string(size_type n, char c)</td><td>创建一个包含n个元素的string对象，其中每个元素都被初始化为字符c</td></tr><tr><td>string(const string &amp;str)</td><td>将一个<code>string</code>对象初始化为<code>string</code>对象<code>str</code>（复制构造函数）</td></tr><tr><td>string()</td><td>创建一个默认的<code>string</code>对象，长度为0（默认构造函数）</td></tr><tr><td>string(const char *, size_type n)</td><td>将<code>string</code>对象初始化为s指向的NBTS的前n个字符，即使超过了NBTS的结尾</td></tr><tr><td>template<class iter\=""> <br> string(Iter begin, Iter end)</class></td><td>将<code>string</code>对象初始化为区间<code>[begin,end)</code>内的字符，其中<code>begin</code>和<code>end</code>的行为就像指针，用于指定位置，范围包括<code>begin</code>在内，但不包括<code>end</code></td></tr><tr><td>string(const string &amp;str,  size_type pos = 0, size_type n = npos)</td><td>将一个<code>stirng</code>对象初始化为对象<code>str</code>从位置<code>pos</code>开始到结尾的字符，或从<code>pos</code>开始的n个字符</td></tr><tr><td>string(string &amp;&amp; str) noexcept</td><td>C++11新增，它将一个<code>string</code>对象初始化为对象<code>str</code>，并可能修改<code>str</code>（移动构造函数）</td></tr><tr><td>string(initializer_list<char> il)</char></td><td>C++11新增，它将一个<code>string</code>对象初始化为初始化列表<code>il</code>中的字符</td></tr></tbody></table></div><p>在使用构造函数时都进行了简化，即隐藏了这样一个事实：string实际上是模板具体化<code>basic_string&lt;char&gt;</code>的一个<code>typedef</code>，同时省略了与内存管理相关的参数</p><h3 id="16-1-2-string类输入"><a href="#16-1-2-string类输入" class="headerlink" title="16.1.2 string类输入"></a>16.1.2 string类输入</h3><p>对于C-风格字符串，有3种方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span> info[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; info; <span class="comment">//read a word 遇到空格换行停止</span></span><br><span class="line"><span class="built_in">cin</span>.getline(info, <span class="number">100</span>); <span class="comment">// read a line, discard \n</span></span><br><span class="line"><span class="built_in">cin</span>.get(info, <span class="number">100</span>); <span class="comment">// read a line, leave \n in queue</span></span><br></pre></td></tr></table></figure></p><p>对于string对象，有两种方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> stuff;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; stuff;  <span class="comment">// read a word</span></span><br><span class="line">getline(<span class="built_in">cin</span>, stuff);  <span class="comment">// read a line, discard \n</span></span><br></pre></td></tr></table></figure></p><p>两个版本的<code>getline</code>都有一个可选参数，用于指定使用哪个字符来确定输入的边界。在功能上，它们之间主要的区别在于，<code>string</code>版本的<code>getline()</code>将自动调整目标<code>string</code>对象的大小，使之刚好能够存储输入的字符。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span> fname[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">string</span> lname;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; fname; <span class="comment">// could be a problem if input size &gt; 9 ch</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; lname; <span class="comment">// can read a very,very long word</span></span><br><span class="line"><span class="built_in">cin</span>.getline(fname,<span class="number">10</span>); <span class="comment">// may truncate input</span></span><br><span class="line">getline(<span class="built_in">cin</span>, fname);  <span class="comment">// no truncation</span></span><br></pre></td></tr></table></figure></p><p>在设计方面的一个区别是，读取C-风格字符串的函数是<code>istream</code>类的方法，而<code>string</code>版本是独立的函数。这就是对于C-风格字符串输入，cin是调用对象；而对于<code>string</code>对象输入，<code>cin</code>是一个函数参数的原因。这种规则也适用于<code>&lt;&lt;</code>形式：1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.<span class="keyword">operator</span>&gt;&gt;(fname);</span><br><span class="line"><span class="keyword">operator</span>&gt;&gt;(<span class="built_in">cin</span>, lname);</span><br></pre></td></tr></table></figure></p><p><code>string</code>类可以自动调整对象的大小，使之与输入匹配，但也存在一些限制：</p><ul><li>string对象的最大允许长度： 由常量<code>string::npos</code> 指定，通常是最大的<code>unsigned int</code>值</li><li>程序可以使用的内存量</li></ul><p><code>string</code>版本的<code>getline()</code>函数从输入中读取字符，并将其存储到目标<code>string</code>中，知道发生下列三种情况之一：</p><ul><li>到达文件尾，在这种情况下，输入流的<code>eofbit</code>将被设置，这意味着方法<code>fail()</code>和<code>eof()</code>都将返回<code>true</code>；</li><li>遇到分界字符（默认为<code>\n</code>），在这种情况下，将把分解字符从输入流中删除，但不存储它</li><li>读取的字符数打到最大允许值（<code>string::npos</code>与可供分配的内存字节数中较小的一个），在这种情况下，将设置输入流的<code>failbit</code>，这意味着方法<code>fail()</code>返回<code>true</code>。</li></ul><h3 id="16-1-3-使用字符串"><a href="#16-1-3-使用字符串" class="headerlink" title="16.1.3 使用字符串"></a>16.1.3 使用字符串</h3><p>C++对每个关系运算符进行了重载，以便能够将<code>string</code>对象与另一个<code>string</code>对象或C-风格字符穿进行比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator&lt;(const string &amp;, const string &amp;);</span><br><span class="line">operator==(const string &amp;, const char *);</span><br><span class="line">operator!=(const char *, const string &amp;);</span><br></pre></td></tr></table></figure></p><p><code>size()</code>和<code>length()</code>方法都返回字符串中的字符数，二者没有区别，前者是为提供STL兼容性添加的，后者是较早版本的<code>string</code>类使用的方法名。</p><p>可以以多种不同的方式在字符串中搜索给定的子字符串或字符。下表描述是了<code>find()</code>方法的4个版本。</p><div class="table-container"><table><thead><tr><th>方法原型</th><th>描述　</th></tr></thead><tbody><tr><td>size_type find(const string &amp;st ,size_type pos=0)  const</td><td>从字符串的<code>pos</code>位置开始，查找子字符串<code>str</code>。如果找到，则返回该字符串首次出现时其首字符的索引；否则，返回<code>string::npos</code></td></tr><tr><td>size_type find(const char* s, size_type pos=0) const</td><td>从字符串的<code>pos</code>位置开始，查找子字符串<code>s</code>。如果找到，则返回该字符串首次出现时其首字符的索引；否则，返回<code>string::npos</code></td></tr><tr><td>size_type find(const char *s, size_type pos=0,size_type n)</td><td>从字符串的<code>pos</code>位置开始，查找<code>s</code>的前n个字符组成的子字符串。如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回<code>string::npos</code></td></tr><tr><td>size_type find(char ch, size_type pos = 0) const</td><td>从字符串的<code>pos</code>位置开始，查找字符<code>ch</code>。如果找到，则返回该字符首次出现的位置；否则，返回<code>string::npos</code></td></tr></tbody></table></div><p>除此之外，<code>string</code>库还提供了其他相关的方法：<code>rfind()</code> ,<code>find_first_of()</code>, <code>find_last_of()</code>, <code>find_first_not_of()</code>, <code>find_last_not_of()</code>等等。</p><h3 id="16-1-4-stirng类还提供了哪些功能"><a href="#16-1-4-stirng类还提供了哪些功能" class="headerlink" title="16.1.4 stirng类还提供了哪些功能"></a>16.1.4 stirng类还提供了哪些功能</h3><p>还有很多功能，具体可看p665或者附录F。</p><h3 id="16-1-5-字符串种类"><a href="#16-1-5-字符串种类" class="headerlink" title="16.1.5 字符串种类"></a>16.1.5 字符串种类</h3><p>表面上看起来<code>string</code>类是基于<code>char</code>类型的，但是，实际上，<code>string</code>库是基于一个模板类的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CharT</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Traits</span> = <span class="title">std</span>:</span>:char_traits&lt;CharT&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt;CharT&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">basic_string</span>;</span></span><br></pre></td></tr></table></figure></p><p>模板<code>basic_string</code>有多个具体化，每个具体化都有一个<code>typedef</code>名称，如<code>string</code>、<code>wstring</code>、<code>u16string</code>等等。</p><h2 id="16-2-智能指针模板类"><a href="#16-2-智能指针模板类" class="headerlink" title="16.2 智能指针模板类"></a>16.2 智能指针模板类</h2><p>智能指针是行为类似于指针的 <strong>类对象</strong> 。共有三种可以帮助管理动态内存分配的智能指针模板：</p><ul><li>auto_ptr</li><li>unique_ptr</li><li>shared_ptr</li></ul><p>模板<code>auto_ptr</code>是C++98提供的解决方案，C++11已将其摒弃，并提供了后两种解决方案。</p><h3 id="16-2-1-使用智能指针"><a href="#16-2-1-使用智能指针" class="headerlink" title="16.2.1 使用智能指针"></a>16.2.1 使用智能指针</h3><p>以上三个智能指针模板（auto_prt,unique_ptr,shared_ptr)都定义了类似指针的对象，可以将<code>new</code>获得的地址赋给这种对象。</p><p>当智能指针过期时，其析构函数将使用delete来释放内存，因此，如果将<code>new</code>返回的地址赋给这种对象，将无需记住稍后释放这些内存。（要创建智能指针，需包含头文件<code>memory</code>）</p><h3 id="16-2-2-有关智能指针的注意事项"><a href="#16-2-2-有关智能指针的注意事项" class="headerlink" title="16.2.2 有关智能指针的注意事项"></a>16.2.2 有关智能指针的注意事项</h3><p>当多个指针对象指向同一个对象时，三种智能指针的区别：</p><ul><li>auto_ptr：调用多次析构函数，执行多次delete，报错</li><li>unique_ptr：建立所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，在删除后，会将所有权转让</li><li>shared_ptr：利用引用计数（reference counting），仅当最后一个指针过期时，才调用<code>delete</code>。</li></ul><h3 id="16-2-3-unique-ptr为何优于auto-prt"><a href="#16-2-3-unique-ptr为何优于auto-prt" class="headerlink" title="16.2.3 unique_ptr为何优于auto_prt"></a>16.2.3 unique_ptr为何优于auto_prt</h3><p><code>unique_ptr</code>更安全： 它使用了C++11新增的移动构造函数和右值引用<br><code>unique_ptr</code>可以用于数组的变体：<code>auto_ptr</code>智能使用<code>new</code>和<code>delete</code>，而<code>unique_ptr</code>可以还可以使用<code>new []</code>和<code>delete []</code>。</p><p>警告：</p><ul><li>使用<code>new</code>分配内存时，才能使用<code>auto_ptr</code>和<code>shared_ptr</code>，使用<code>new[]</code>分配内存时，不能使用它们</li><li>不使用<code>new</code>分配内存时，不能使用<code>auto_ptr</code>和<code>shared_ptr</code></li><li>不使用<code>new</code>和<code>new[]</code>分配内存时，不能使用<code>unique_ptr</code></li></ul><h3 id="16-2-4-选择智能指针"><a href="#16-2-4-选择智能指针" class="headerlink" title="16.2.4 选择智能指针"></a>16.2.4 选择智能指针</h3><p>如果程序要使用多个指向同一个对象的指针，应选择<code>shared_ptr</code>。</p><h2 id="16-3-标准模板库"><a href="#16-3-标准模板库" class="headerlink" title="16.3 标准模板库"></a>16.3 标准模板库</h2><p>STL提供了一组表示容器、迭代器、函数对象和算法的模板。</p><ul><li>容器：是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即存储的值的类型相同</li><li>迭代器：能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针</li><li>函数对象：类似于函数的对象，可以是类对象或函数指针</li><li>算法：完成特定任务（如find，verse等）。</li></ul><p><strong>STL不是面对对象的变成，而是一种不同的编程模式——泛型编程（generic programming）</strong></p><p>关于更多个STL方法和函数可以看附录G</p><h3 id="16-3-1-模板类vector"><a href="#16-3-1-模板类vector" class="headerlink" title="16.3.1 模板类vector"></a>16.3.1 模板类vector</h3><p>分配器：与<code>string</code>类相似，各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存。如果省略了该模板参数的值，则容器类模板将默认使用<code>allocator&lt;T&gt;</code>类，这个类使用<code>new</code>和<code>delete</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span>...&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-2-可对矢量执行的操作"><a href="#16-3-2-可对矢量执行的操作" class="headerlink" title="16.3.2 可对矢量执行的操作"></a>16.3.2 可对矢量执行的操作</h3><p>每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为<code>iterator</code>的<code>typedef</code>，其作用域为整个类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator pd; <span class="comment">// pd an iterator</span></span><br></pre></td></tr></table></figure><p>超尾(past-the-end) ：一种迭代器，指向容器的最后一个元素的后面，就像是C-风格字符串最后一个字符后面的空字符一样，由<code>end()</code>成员函数标识。</p><h3 id="16-3-3-对矢量可执行的其他操作"><a href="#16-3-3-对矢量可执行的其他操作" class="headerlink" title="16.3.3 对矢量可执行的其他操作"></a>16.3.3 对矢量可执行的其他操作</h3><p>对于搜索、排序、随机排序等等很常见的操作，矢量模板类并没有包含！！ <strong>但是</strong> ，STL从更广泛的角度定义了非成员（non-member）函数来执行这些操作，即不是为每个容器类定义<code>find()</code>函数，而是定义了一个适用于所有容器类的非成员函数<code>find()</code>。这种设计理念省去了大量重复的工作。</p><p>另一方面，STL有时也会定义一个功能相同的成员函数。这是因为对有些操作来说，类特定算法的效率比同于算法高，比如，vector的成员函数<code>swap()</code>的效率比非成员函数<code>swap()</code>高，但非成员函数可以交换冷儿类型不同的容器的内容。</p><h3 id="16-3-4-基于范围的for循环（C-11）"><a href="#16-3-4-基于范围的for循环（C-11）" class="headerlink" title="16.3.4 基于范围的for循环（C++11）"></a>16.3.4 基于范围的for循环（C++11）</h3><p>第五章的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.48</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> x : prices)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>在这种for循环中，先声明一个类型与容器内容类型相同的变量，然后写明容器名称，接下来就可以访问，如下面的代码可以写的更加精简：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for_each(books.begin(), books.end(), ShowReview); <span class="comment">//for_each形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> x:books) ShowReview(x)); <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>注意，<code>for_each</code>不能修改容器的容器，而基于范围的for循环可以通过指定一个引用参数来修改内容。例如，假设有如下函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InflateReview</span><span class="params">(Review &amp;r)</span> </span>&#123;r.rating++;&#125;</span><br></pre></td></tr></table></figure></p><p>可使用如下循环的books的每个元素执行该函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:books) InflateReview(x);</span><br></pre></td></tr></table></figure></p><h2 id="16-4-泛型编程"><a href="#16-4-泛型编程" class="headerlink" title="16.4 泛型编程"></a>16.4 泛型编程</h2><p>面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念决然不同。泛型编程旨在编写独立于数据类型的代码。</p><h3 id="16-4-1-为何使用迭代器"><a href="#16-4-1-为何使用迭代器" class="headerlink" title="16.4.1 为何使用迭代器"></a>16.4.1 为何使用迭代器</h3><p>模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。</p><p>例如，在使用<code>find</code>函数时，可以用迭代器来实现不依赖于具体类型的查找。</p><p>实际上，作为一种编程风格，最好避免直接使用迭代器，而应尽可能使用STL函数(如<code>for_each()</code>）来处理细节。也可以使用C++11新增的基于范围的for循环。</p><h3 id="16-4-2-迭代器类型"><a href="#16-4-2-迭代器类型" class="headerlink" title="16.4.2 迭代器类型"></a>16.4.2 迭代器类型</h3><p>不同的算头对迭代器要求不同，有的只要求可读，有的要求可随机访问等等。STL定义了5种不迭代器，并根据所需的迭代器类型对算法进行了描述：</p><ul><li>输入迭代器</li><li>输出迭代器</li><li>正向迭代器</li><li>双向迭代器</li><li>随机访问迭代器</li></ul><p>对于不同的算法，需要的迭代器不同，如下面两种算法分别需要输入迭代器和随机访问迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这5种迭代器，都可以执行解除引用操作（即*运算符），也可进行比较，看其是相等还是不相等（==，！=运算符）。如果两个迭代器相同，则对它们执行解除引用操作得到的值将相同。</p><ol><li>输入迭代器</li></ol><p>&emsp;&emsp;术语“输入”是从程序的角度出发的，即来自容器的信息被视为输入（从迭代器传到程序中），因此，输入迭代器可被程序用来读取容器中的信息。需要输入迭代器的算法将不会修改容器中的值</p><p>&emsp;&emsp;输入迭代器必须能做访问容器中所有的值，这是通过支持<code>++</code>运算符（前缀格式<code>operator++</code>和后缀格式<code>operator++(int)</code>）来实现的。</p><p>&emsp;&emsp; <strong>注意：</strong> 并不能保证输入迭代器第二次遍历容器时，顺序不变。另外，输入迭代器被递增后，也不能保证其先前的值仍然可以被解除引用。基于输入迭代器的任何算法都应当是单通行（single-pass）的，不依赖于前一次便利时的迭代器值，也不依赖于本次遍历中前面的迭代器值。—— <strong>输入迭代器是单向迭代器，可以递增，但不能倒退</strong></p><ol><li>输出迭代器</li></ol><p>&emsp;&emsp;同理，“输出”指用于将信息从程序传输给容器的迭代器（从程序输出到迭代器中），输出迭代器智能解除引用让程序修改容器值，而不能读取容器内的值。输出迭代器也是单通行的，只能写不能读。</p><ol><li>正向迭代器</li></ol><p>&emsp;&emsp; 只是用<code>++</code>运算符遍历容器，每次沿容器向前移动一个元素。<strong>与输入和输出迭代器不同的是，它总是按相同的顺序遍历一系列值，另外，将正向迭代器递增后，仍然可以对前面的迭代器值解除引用，并得到对应的值</strong> 。这些特征使得正向迭代器是多通行的（可以多次通行容器）。</p><ol><li>双向迭代器</li></ol><p>&emsp;&emsp;双向迭代器具有正向迭代器的所有特性，且同时支持两种（前缀和后缀）递减运算符。</p><ol><li>随机访问迭代器</li></ol><p>&emsp;&emsp;有些算法（如排序和二分检索）要求能够直接跳到容器中的任何一个元素（将想数组下标访问一样），因此就有了随机访问迭代器。该迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作和用于对元素进行排序的关系运算符。</p><h3 id="16-4-3-迭代器层次结构"><a href="#16-4-3-迭代器层次结构" class="headerlink" title="16.4.3 迭代器层次结构"></a>16.4.3 迭代器层次结构</h3><p>可以看出，迭代器类型形成了一个层次结构。后面的迭代器不仅拥有之前迭代器的所有功能，同时还有自己的功能。</p><p>每个容器类都定义了一个类级typedef名称——iterator。（实际上这使用指针实现的，并不是一种新的类型）。</p><h3 id="16-4-4-概念、改进和模型"><a href="#16-4-4-概念、改进和模型" class="headerlink" title="16.4.4 概念、改进和模型"></a>16.4.4 概念、改进和模型</h3><p>STL有若干个用C++语言无法表达的特性，如迭代器种类。正向迭代器是一系列要求，而不是类型。（迭代器通常可以用常规指针实现，所以迭代器本身并不是一种类型）。</p><p>STL使用术语“概念（concept）”来描述一系列的要求。</p><p>概念可以具有类似继承的关系，就像双向迭代器继承了正向迭代器的功能。然而，不能将C++继承机制用于迭代器，但从概念上看，它确实能够继承，有些STL文献使用属于改进（refinement）来表示这种概念上的继承，因此，双向迭代器是对正向迭代器概念的一种改进。</p><p>概念的具体实现被称为模型（model）。因此，指向int的常规指针是一个随机访问迭代器模型，同时也是一个正向迭代器模型。</p><ol><li>将指针用作迭代器</li></ol><p>&emsp;&emsp;迭代器是广义上的指针，其本身就是一种指针，因此，STL算法可以使用指针来对基于指针的非STL容器进行操作。例如，可将STL算法用于数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> Receipts[SIZE];</span><br><span class="line">sort(Receipts,Receipts+SIZE); <span class="comment">//用STL的sort算法对数组进行排序</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;STL提供了一些预定义迭代器，如ostream_iterator和istream_iterator模板等，都定义在iterator头文件中。</p><ol><li>其他有用的迭代器</li></ol><p>&emsp;&emsp;头文件iterator还提供了其他一些专用的预定义迭代器类型，它们是reverse_iterator, back_insert_iterator, front_insert_iterator和insert_iterator等。</p><h3 id="16-4-5-容器种类"><a href="#16-4-5-容器种类" class="headerlink" title="16.4.5 容器种类"></a>16.4.5 容器种类</h3><ul><li>容器概念：概念是具有名称（如容器、序列容器、关联容器等）的通用类别</li><li>容器类型：是可用于创建具体容器对象的模板。以前的11个容器类型为：deque, list, queue, priority_queue, stack, vector, map, multimap, set, multiset和bitset。 C++11新增了：forward_list, unordered_map, unordered_multimap, unordered_set和unordered_multiset，且不再将bitset视为容器，而将其视为一种独立的类别。</li></ul><ol><li>容器概念</li></ol><p>&emsp;&emsp;没有与基本容器概念对应的类型，但概念描述了所有容器类都通用的元素。存储在容器中的类型必须是可复制构造和可赋值的。STL特定操作的时间复杂度有三种，分别是：编译时间、固定时间和线性时间。</p><ol><li>C++11新增的容器要求</li></ol><p>&emsp;&emsp;下表列出了C++11新增的通用容器要求，其中，复制赋值和移动赋值之间的差别在于，复制操作保留源对象，而移动操作可修改源对象，还可能转让所有权，而不做任何复制。如果源对象是临时的，移动操作的效率将高于常规复制。</p><div class="table-container"><table><thead><tr><th>表达式</th><th>返回类型</th><th>说明</th><th>复杂度</th></tr></thead><tbody><tr><td><code>X u(rv);</code></td><td></td><td>调用移动构造函数后，u和值和rv的原始值相同</td><td>线性</td></tr><tr><td><code>X u = rv;</code></td><td></td><td>作用同上</td><td></td></tr><tr><td><code>a = rv;</code></td><td>X&amp;</td><td>调用移动赋值运算符后，u的值和rv的原始值相同</td><td>线性</td></tr><tr><td><code>a.cbegin()</code></td><td>const_iterator</td><td>返回指向容器第一个元素的const迭代器</td><td>固定</td></tr><tr><td><code>a.cend()</code></td><td>const_iterator</td><td>返回超尾值的const迭代器</td><td>固定</td></tr></tbody></table></div><ol><li>序列</li></ol><h3 id="16-4-6-关联容器"><a href="#16-4-6-关联容器" class="headerlink" title="16.4.6 关联容器"></a>16.4.6 关联容器</h3><h3 id="16-4-7-无序关联容器"><a href="#16-4-7-无序关联容器" class="headerlink" title="16.4.7 无序关联容器"></a>16.4.7 无序关联容器</h3><h2 id="16-5-函数对象"><a href="#16-5-函数对象" class="headerlink" title="16.5 函数对象"></a>16.5 函数对象</h2><p>函数对象也叫做仿函数 (funtor). 仿函数是可以以函数方式与<code>()</code>运算符结合使用的任意对象. 重载后的<code>()</code>运算符将使得能够响函数那样使用类对象.</p><h3 id="16-5-1-仿函数概念"><a href="#16-5-1-仿函数概念" class="headerlink" title="16.5.1 仿函数概念"></a>16.5.1 仿函数概念</h3><h3 id="16-5-2-预定义的仿函数"><a href="#16-5-2-预定义的仿函数" class="headerlink" title="16.5.2 预定义的仿函数"></a>16.5.2 预定义的仿函数</h3><h3 id="16-5-3-自适应仿函数"><a href="#16-5-3-自适应仿函数" class="headerlink" title="16.5.3 自适应仿函数"></a>16.5.3 自适应仿函数</h3><h3 id="16-7-3-使用initializer-list"><a href="#16-7-3-使用initializer-list" class="headerlink" title="16.7.3 使用initializer_list"></a>16.7.3 使用initializer_list</h3>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11新特性-初始化列表</title>
      <link href="/z_post/Cpp-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
      <url>/z_post/Cpp-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="统一的初始化过程"><a href="#统一的初始化过程" class="headerlink" title="统一的初始化过程"></a>统一的初始化过程</h1><p>在 C++98/03 中, 我们只能对普通数组和POD( plain old data, 简单来说就是可以用memcpy复制的对象) 类型使用初始化列表, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int arr[3] = &#123;1,2,3&#125;;</span><br><span class="line"></span><br><span class="line">struct A&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;a = &#123;1,2&#125;;</span><br></pre></td></tr></table></figure></p><p>但是在C++11中, 初始化列表的适用性被放大, 可以作用于任何类型对象的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T test&#123;&#125;;</span><br><span class="line"><span class="comment">//如:</span></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">2</span>&#125;; <span class="comment">// 与 int a=2;  int a(2); 等价</span></span><br><span class="line"><span class="built_in">std</span>:<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; pyments &#123;<span class="number">35.99</span>, <span class="number">129.22</span>&#125;;</span><br><span class="line">Foo fool&#123;<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>&#125;; <span class="comment">//Foo为一个类或结构体</span></span><br></pre></td></tr></table></figure><h1 id="C-的类对象创建过程"><a href="#C-的类对象创建过程" class="headerlink" title="C++的类对象创建过程"></a>C++的类对象创建过程</h1><p>C++ 在创建类时需要经过两个阶段：分配空间（Allocation）和初始化（Initialization）</p><h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><p>创建C++类对象的第一步就是为其分配内存空间。对于全局对象，静态对象以及分配在栈区域内的对象，对它们的内存分配是在编译阶段就完成了，而对于分配在堆区域内的对象，它们的分配是在运行是动态进行的。内存空间的分配过程涉及到两个关键的问题：需要分配空间的大小以及是否有足够的内存空间来满足分配。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先需要区分两个概念：初始化（Initialization）和赋值（Assignment）。初始化早于赋值，它是随着对象的诞生一起进行的。而赋值是在对象诞生以后又给予它一个新的值。</p><p>在C++中，提供了类成员的初始化列表，并且初始化列表是先于构造函数体内的代码执行的。</p><h2 id="关于成员初始化列表"><a href="#关于成员初始化列表" class="headerlink" title="关于成员初始化列表"></a>关于成员初始化列表</h2><p>对于以下三种情况，必须使用成员初始化列表</p><ul><li>需要初始化的数据成员是对象的情况（包含继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化）</li><li>需要初始化const修饰的类成员</li><li>需要初始化引用成员数据</li><li>子类初始化父类的私有成员，需要在（并且只能在）参数初始化列表中显示调用父类的构造函数。（这种其实可以并到第一种情况，因为初始化私有成员，就以为着初始化对象）</li></ul><p>类对象是默认使用初始化列表的，当没有无参构造函数时，就必须显式使用初始化列表（所以不论如何，都会使用到初始化列表）。</p><p>当类成员中含有一个const对象时，或者一个引用时，必须经过成员初始化列表进行初始化，因为const对象或者引用在声明的同时必须初始化，<strong>而在构造函数中，做的是对它们的赋值，并不是初始化。</strong></p><h2 id="构造函数与初始化列表"><a href="#构造函数与初始化列表" class="headerlink" title="构造函数与初始化列表"></a>构造函数与初始化列表</h2><p><strong>成员初始化列表只能用于构造函数</strong></p><p>在类的实现中，构造函数体内“初始化”的实际上是赋值而不是初始化。也就是说，当代码运行到构造函数内部时，初始化列表已经执行完了，因此相当于是先初始化了一遍，然后又赋值了一遍，重复计算，浪费效率，因此应该优先使用初始化列表。同时，当没有默认的无参构造函数时，就一定会使用初始化列表。(即使自己没有在含参构造函数中都是基本数据类型, 不强制显式使用初始化列表, 也会自动调用初始化列表, 而在构造函数内部执行的仅仅是赋值)</p><p>创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类构造函数总是需要调用一个基类构造函数。当基类没有默认的构造函数时，就必须显式指明调用哪一个构造函数。<br>在继承关系中, 必须显式的在初始化列表中对基类初始化, 因为只有基类初始化完成后, 才能进行子类初始化, 而当进入子类构造函数内部时, 子类初始化已经完成.</p><p>注意：除了虚基类以外，类只能将值传递会相邻的基类，但后者可以使用相同的机制将信息传递给上层相邻的基类，以此类推。</p><h2 id="初始化列表的顺序"><a href="#初始化列表的顺序" class="headerlink" title="初始化列表的顺序"></a>初始化列表的顺序</h2><p>构造函数需要初始化的数据成员，不论是否显式的出现在构造函数的成员初始化列表中，都会在该处完成初始化，<strong>并且初始化的顺序和变量声明时的顺序是一致的，与列表中的先后顺序无关</strong></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中类的对象和对象指针之间的区别</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>很关键的一点：定义对象实例时，分配了内存，指针变量则未分配类对象所需内存。</p><p>类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).<br>对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).   </p><p>指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。<br>直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。</p><p>类的对象:用的是内存栈,是个局部的临时变量.<br>类的指针:用的是内存堆,是个永久变量,除非你释放它.   </p><p>1.在类的声明尚未完成的情况下，可以声明指向该类的指针，但是不可声明该类的对象… 例如：含有纯虚成员函数的抽象类。<br>2.父类的指针可以指向子类的对象..</p><p>在应用时:<br>        1.引用成员:   对象用”   .   “操作符;   指针用”   -&gt;   “操作符.<br>        2.生命期:     若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete   在相应的地方释放分配的内存块.<br>        注意:用new   ,一定要delete..</p><p>C++的精髓之一就是多态性，只有指针或者引用可以达到多态。对象不行<br>类指针的优点：<br>第一实现多态。<br>第二，在函数调用，传指针参数。不管你的对象或结构参数多么庞大，你用指针，传过去的就是4个字节。如果用对象，参数传递占用的资源就太大了</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的const关键字</title>
      <link href="/z_post/Cpp-const%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/z_post/Cpp-const%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="const与-define相比-有何优点"><a href="#const与-define相比-有何优点" class="headerlink" title="const与#define相比, 有何优点?"></a>const与#define相比, 有何优点?</h1><ol><li><code>const</code>常量具有数据类型, 而宏常量没有数据类型. 编译器可以对前者进行类型安全检查, 而对后者只会进行字符替换, 没有类型安全检查, 容易发生意想不到的错误.</li><li>有些集成化的调试工具可以对const常量进行调试, 但是不能对宏常量进行调试</li></ol><h1 id="const常用形式及代表含义"><a href="#const常用形式及代表含义" class="headerlink" title="const常用形式及代表含义"></a>const常用形式及代表含义</h1><div class="table-container"><table><thead><tr><th>含义</th><th>使用形式 及 作用</th></tr></thead><tbody><tr><td>const常量</td><td><code>const int Max = 100; int const Max =100</code> const与int的位置可互换，二者等价</td></tr><tr><td></td><td>修饰后的变量在程序的任意位置将不能再被修改，就如同常数一样，任何修改该变量的尝试都会导致编译错误（由于常量在定义以后就不能再被修改，所以定义时必须初始化）。 <strong>对于类中的const成员变量必须通过初始化列表进行初始化</strong></td></tr><tr><td>const引用</td><td><code>const int i = 1024； const int &amp;ref_i = i;  int const &amp;ref2_i = i</code>后两句等价<br><code>int &amp;const ref3_i = i</code>这种方式未定义，会报错：‘const’ qualifiers cannot be applied to ‘int&amp;’</td></tr><tr><td></td><td>cosnt引用是指向const对象或者普通对象的引用，该引用<code>ref_i</code>可以读取对象<code>i</code>的值，但是，<strong>不能修改</strong> <code>i</code>的值，任何对<code>ref_i</code>的赋值都是非法的。 并且 <strong>不能用普通引用指向const常量</strong>（<code>int &amp;ref4_i = i; // 非法</code>）。（注意，一旦引用被定义，它就不能再指向其它对象，这是引用本身的性质，这也是为什么引用必须进行初始化的原因）。 <strong>总结来说就是const引用只是表明：保证不会通过此引用间接的改变被引用的对象！</strong></td></tr><tr><td>const指针</td><td>1）<code>int age = 39; const int *ptr = &amp;age;</code> <br>2）<code>const int age = 98; const int *ptr = &amp;age;</code><br>3）<code>const int age = 32; int *ptr = &amp;age;</code><br>4）<code>int age = 90; int * const ptr = &amp;age;</code></td></tr><tr><td></td><td>对于1），<code>const</code>修饰的是<code>int</code>，表明<code>ptr</code>指向一个<code>const int</code>，但是<code>ptr</code>和<code>age</code>本身都不是<code>const</code>，不能使用<code>ptr</code>来修改<code>age</code>的值，但是<code>age</code>自身可以修改自己的值，同时，<code>ptr</code>也可以转而指向其它变量；<br> 对于2），<code>const</code>修饰的是<code>int</code>，表明<code>ptr</code>指向一个<code>const int</code>，同时<code>age</code>本身就是const，说明既不能通过<code>ptr</code>，也不能通过<code>age</code>来修改变量age的值，但是<code>ptr</code>本身仍然不是<code>const</code>，因此可以转而指向其它变量；<br>对于3），C++禁止将<code>const</code>变量的地址赋给非<code>const</code>指针（除非使用强制类型转换）；<br>对于4），<code>const</code>修饰的是<code>*</code>，表明<code>ptr</code>本身是一个常量指针，这使得<code>ptr</code>自身的值不能改变，也就是只能指向<code>age</code>，不能指向其它变量</td></tr><tr><td>const函数参数</td><td><code>void fun(const int * i);</code> <br> <code>void fun(const int &amp; i);</code></td></tr><tr><td></td><td>不能在函数体内修改指针或引用指向的值，但是这里指针可以转而指向其他值（其实没多大用，因为指针本身就是值传递，即使改变指向，也不会影响实参的指向，除非用二级指针）</td></tr><tr><td>const函数返回值</td><td><code>const int fun( int i);</code></td></tr><tr><td></td><td>阻止用户修改返回值，返回值必须要相应的赋给一个具有const属性的变量</td></tr><tr><td>const成员函数</td><td><code>&lt;类型说明符&gt; &lt;函数名&gt; ( &lt;参数表&gt; ) const;</code></td></tr><tr><td></td><td>不会修改类的成员数据，也不能调用其它非const成员函数。 <strong>可以利用const限定符实现函数重载</strong>。 const对象默认会调用const成员函数</td></tr></tbody></table></div><h1 id="const限定符和static的区别"><a href="#const限定符和static的区别" class="headerlink" title="const限定符和static的区别"></a>const限定符和static的区别</h1><ol><li>静态变量的值虽然只能进行一次初始化，但是它的值是可变的。而const的值是不可变的。</li><li>const定义的变量在超出其作用域后空间就会被释放，而static定义的静态变量不会释放空间，而是一直存在，知道程序结束</li><li>static表示静态，类的静态成员函数、静态成员变量都是和类相关的，而不是和具体的对象相关，即使没有具体对象，也能调用静态成员函数和静态成员变量。而类则是和具体的对象相关的，不同的对象独占一个const变量</li><li>static静态成员变量不能在类的内部进行初始化，智能在类的外部进行初始化，并且初始化时不能加<code>static</code>关键字。之后，无需创建对象也能通过类使用该静态变量，同时</li><li>由于const变量只是针对于某个类的对象而言的，类可以创建多个不同的对象，每个对象都有自己的const变量，又因为const变量值只能进行一次初始化而不仅再次赋值，因此， <strong>const变量也不能在类的内部初始化，而只能在类构造函数的初始化列表中进行</strong> 。</li><li>如果想要创建整个类的恒定变量，那么应用使用<code>static const</code>来声明（const枚举量也可以）</li></ol><h1 id="关于const的其它注意事项"><a href="#关于const的其它注意事项" class="headerlink" title="关于const的其它注意事项"></a>关于const的其它注意事项</h1><h2 id="将非const指针赋给const指针（两级间接关系）"><a href="#将非const指针赋给const指针（两级间接关系）" class="headerlink" title="将非const指针赋给const指针（两级间接关系）"></a>将非const指针赋给const指针（两级间接关系）</h2><p>p222</p><h2 id="const引用与不可寻址值"><a href="#const引用与不可寻址值" class="headerlink" title="const引用与不可寻址值"></a>const引用与不可寻址值</h2><p>const引用可以用不同类型的对象初始化（主要能从一种类型转换到另一种类型即可），也可以用字面常量初始化，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">//下3行仅对const引用才是合法的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ir = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ir2 = dval; <span class="comment">//隐式类型转换，生成临时变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> &amp;dr = dval + <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure><p><strong>首先要知道，上面的初始化对于非cosnt引用是不合法的，将导致编译错误！</strong></p><p>原因：引用在内部存放的是一个对象的地址，它是该对象的别名。对于不可寻址的值，如文字常量，以及不同类型的对象，编译器为了实现引用，必须生成一个临时对象，将该对象的值置入临时对象中，引用实际上指向该对象（对该引用的操作就是对该临时对象的操作），但用户不能访问它。因此，C++为了不让用户通过引用修改该临时变量，强制要求必须使用const引用。</p><h2 id="const引用与临时变量"><a href="#const引用与临时变量" class="headerlink" title="const引用与临时变量"></a>const引用与临时变量</h2><p>由于上面提到的原因， <strong>C++引用类型在面对会产生临时变量的语句时，必须使用const引用来指向！！切记！！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *&amp;p_i = &amp;i;<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> &amp;p_i = &amp;i; <span class="comment">//正确写法，const修饰int *</span></span><br><span class="line"><span class="comment">//&amp;代表p_i是一个引用（别名），*代表这个引用（别名）是一个指向int类型的指针，</span></span><br><span class="line"><span class="comment">//而后面的&amp;i代表取i的地址，注意，这里会生成一个存储地址的临时变量，因此，指向该临时变量的引用（别名）必须为const，</span></span><br><span class="line"><span class="comment">//也就是说，这个指向int的指针本身必须是const的，因为不能修改临时变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *&amp;p_i = &amp;i;<span class="comment">// 错误，有临时变量生成，引用必须是const</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> &amp;p_i = &amp;i; <span class="comment">//错误，由于i本身就是cosnt，因此指针必须是一个指向cosnt int的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> &amp;p_i = i;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="const引用与非const引用在内存中的对比"><a href="#const引用与非const引用在内存中的对比" class="headerlink" title="const引用与非const引用在内存中的对比"></a>const引用与非const引用在内存中的对比</h2><p><strong>内存地址都是一样的，网上有的写不一样，是错误的！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> t = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;k = t;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;k&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//  0012FF74</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;t&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//  0012FF74</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;k = t;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;m = t;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;k&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//  0012FF74</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;m&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//  0012FF74</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;t&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//  0012FF74</span></span><br></pre></td></tr></table></figure><h2 id="不允许非const引用指向需要临时对象的对象或值，即，编译器产生临时变量的时候引用必须为const-切记！！"><a href="#不允许非const引用指向需要临时对象的对象或值，即，编译器产生临时变量的时候引用必须为const-切记！！" class="headerlink" title="不允许非const引用指向需要临时对象的对象或值，即，编译器产生临时变量的时候引用必须为const!!!!切记！！"></a>不允许非const引用指向需要临时对象的对象或值，即，编译器产生临时变量的时候引用必须为const!!!!切记！！</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iv = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> * &amp;pir = &amp;iv;<span class="comment">//错误，非const引用对需要临时对象的引用</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> &amp;pir = &amp;iv;<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *&amp;pi_ref = &amp;ival;    <span class="comment">//错误，非const引用是非法的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *&amp;pi_ref = &amp;ival;   <span class="comment">//错误，需要临时变量，且引用的是指针，而pi_ref是一个非常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> &amp;pi_ref = &amp;ival;  <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//补充</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;ival;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *&amp;pi_ref = p;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="const变量的生存期、作用域和链接性"><a href="#const变量的生存期、作用域和链接性" class="headerlink" title="const变量的生存期、作用域和链接性"></a>const变量的生存期、作用域和链接性</h2><p>临时变量一般会在语句块的末尾自动释放，但是有两个例外：</p><ul><li>将临时对象作为初始化因子，例如<code>string s = string(&quot;hello world&quot;);</code></li><li>将一个常量引用变量绑定到这个临时对象上。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在全局作用域中声明的const变量，只能在当前文件中访问，如果要在其他文件中使用，则必须用<code>extern</code>显式的声明const变量全局变量。（在C中，可以不用extern？）</p><h2 id="用const修饰函数参数"><a href="#用const修饰函数参数" class="headerlink" title="用const修饰函数参数"></a>用const修饰函数参数</h2><p>是否应将void Func(int x) 改写为void Func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。<br>问题是如此的缠绵，我只好将“const &amp;”修饰输入参数的用法总结一下。<br>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。</p><p>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为<code>void Func(const int &amp;x)</code>。</p><h2 id="用const修饰函数的返回值"><a href="#用const修饰函数的返回值" class="headerlink" title="用const修饰函数的返回值"></a>用const修饰函数的返回值</h2><p> 如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。</p><p> 如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。</p><h2 id="const-成员函数-const的作用：说明其不会修改数据成员"><a href="#const-成员函数-const的作用：说明其不会修改数据成员" class="headerlink" title="const 成员函数(const的作用：说明其不会修改数据成员)"></a>const 成员函数(const的作用：说明其不会修改数据成员)</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// const 成员函数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的virtual关键字</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84virutal%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84virutal%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="虚函数与运行多态"><a href="#虚函数与运行多态" class="headerlink" title="虚函数与运行多态"></a>虚函数与运行多态</h1><p><strong>多态：</strong><br>多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><p>先看最简单的情况，也就是最普通形式的继承，且父类和子类的方法都是一般成员方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Car()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Car consstructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~Car()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Car destructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="comment">//  若将成员成员函数声明为const，则该函数不允许修改类的数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"car start"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"cat stop"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Benz类，单一继承自Car</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Benz()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Benz constructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~Benz()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Benz destructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Benz start"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Benz stop"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Baoma类，单一继承自Car</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baoma</span>:</span><span class="keyword">public</span> Car&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     Baoma()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Baoma constructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">     ~Baoma()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Baoma destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Baoma constructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Baoma destructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以上三个类均具有start和stop的同名成员函数</span></span><br><span class="line"><span class="comment">//调用成员函数start和stop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">carFunction</span><span class="params">(Car *car)</span></span>&#123;</span><br><span class="line">  car-&gt;start();</span><br><span class="line">  car-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  Car *benz = <span class="keyword">new</span> Benz();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Benz)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  carFunction(benz);</span><br><span class="line"></span><br><span class="line">  Car *baoma = <span class="keyword">new</span> Baoma();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Baoma)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  carFunction(baoma);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> benz;</span><br><span class="line">  <span class="keyword">delete</span> baoma;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Car consstructor</span><br><span class="line">Benz constructor</span><br><span class="line"><span class="number">1</span>  <span class="comment">//内部没有成员变量,因此只有一个字节的空间</span></span><br><span class="line">car start</span><br><span class="line">cat stop</span><br><span class="line">Car consstructor</span><br><span class="line">Baoma constructor</span><br><span class="line"><span class="number">4</span>  <span class="comment">//函数是不占用内存的,baoma中有一个int类型.所以sizeof为4</span></span><br><span class="line">car start</span><br><span class="line">cat stop</span><br><span class="line">Car destructor</span><br><span class="line">Car destructor</span><br></pre></td></tr></table></figure></p><p>首先，为什么Benz类内部明明没有任何变量，还具有一个字节的大小？这是因为C++编译器不允许对象为零长度（试想一个长度为0的对象在内存中怎么存放？怎么获取它的地址？）。为了避免这种情况，C++强制给这种类插入一个缺省成员，长度为1。如果有自定义的变量，那么变量将取代这个缺省成员。</p><p>其次，Benz和Baoma都是继承自Car类，根据 <strong>里氏替换原则</strong> ，父类能够出现的地方，那么子类也一定能出现。依赖抽象而不去依赖具体,在上述的函数调用过程中,我们传进去的是benz和baoma指针.但是在调用函数的时候,它并没有去调用子类的方法,这也就是一般成员函数的局限性,就是在编译的时候,一般性的函数已经被静态的编译进去,所以在调用的时候不能去选择动态调用.</p><p>里氏替换原则：派生类（子类）对象可以在程式中代替其基类（超类）对象</p><p><strong>加入vitural关键字修饰的函数,将父类函数变为虚函数,看看变化：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和上面几乎一样，都是一般的成员方法，只不过加上了virtual关键字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::<span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Car()&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"Car consstructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Car()&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"Car destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"car start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"cat stop"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Benz()&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"Benz constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Benz()&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"Benz destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类继承父类,如果是虚函数,可以写上vitural也可以不写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"Benz start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"Benz stop"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baoma</span>:</span><span class="keyword">public</span> Car&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     Baoma()&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Baoma constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ~Baoma()&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Baoma destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Baoma start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Baoma stop"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">carFunction</span><span class="params">(Car *car)</span></span>&#123;</span><br><span class="line">  car-&gt;start();</span><br><span class="line">  car-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  Car *benz = <span class="keyword">new</span> Benz();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Benz)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  carFunction(benz);</span><br><span class="line"></span><br><span class="line">  Car *baoma = <span class="keyword">new</span> Baoma();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Baoma)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  carFunction(baoma);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> benz;</span><br><span class="line">  <span class="keyword">delete</span> baoma;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Car consstructor</span><br><span class="line">Benz constructor</span><br><span class="line"><span class="number">8</span></span><br><span class="line">Benz start</span><br><span class="line">Benz stop</span><br><span class="line">Car consstructor</span><br><span class="line">Baoma constructor</span><br><span class="line"><span class="number">16</span></span><br><span class="line">Baoma start</span><br><span class="line">Baoma stop</span><br><span class="line">Car destructor</span><br><span class="line">Car destructor</span><br></pre></td></tr></table></figure><p>从上面的输出结果中可以看到,加入了虚函数之后,调用不同指针对象指定函数的时候,这个时候都是去自动调用当前对象类中的具体函数形式,而不是像一般函数的调用一样,只是去调用父类的函数.这就是virtural关键字的作用,因为一般函数调用编译的时候是静态编译的时候就已经决定了,加入了virtural的函数,一个类中函数的调用并不是在编译的时候决定下来的,而是在运行时候被确定的,这也就是虚函数.</p><p>虚函数就是由于在由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被 为“虚”函数。 <strong>虚函数只能借助于指针或者引用来达到多态的效果， 直接声明的类对象无法达到多态目的。</strong></p><p><strong>总结： 虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型。</strong></p><p>注意:</p><ol><li>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。</li><li>对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数</li><li>带有虚函数的对象自身确实插入了一些指针信息，而且这个指针信息并不随着虚函数的增加而增大,这也就是为什么上述增加了虚函数后,出现了size变大的现象</li></ol><h1 id="虚函数控制下的运行多态有什么用？"><a href="#虚函数控制下的运行多态有什么用？" class="headerlink" title="虚函数控制下的运行多态有什么用？"></a>虚函数控制下的运行多态有什么用？</h1><p>假如我们在公司的人事管理系统中定义了一个基类 Employee(员工)，里面包含了升职、加薪等虚函数。 由于Manager(管理人员)和Engineer(工程人员)的加薪和晋升流程是不一样的，因此我们需要实现一些继承类并重写这些函数。</p><p>有了上面这些以后，到了一年一度每个人都要加薪的时候，我们只需要一个简单的操作就可以完成，如下所示<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">globalRaiseSalary</span><span class="params">(Employee *emp[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    emp[i]-&gt;raiseSalary();  <span class="comment">// 会根据emp具体指向的对象类型，来选择合适的函数行为</span></span><br><span class="line">    <span class="comment">// Polymorphic Call: Calls raiseSalary()</span></span><br><span class="line">    <span class="comment">// according to the actual object, not according to the type of pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>虚函数使得我们可以创建一个统一的基类指针，并且调用不同子类的函数而无需知道子类对象究竟是什么</strong></p><h1 id="虚函数表与虚函数表指针"><a href="#虚函数表与虚函数表指针" class="headerlink" title="虚函数表与虚函数表指针"></a>虚函数表与虚函数表指针</h1><p>C++中虚函数这种多态的性质是通过虚函数指针和一张虚函数表来实现的：</p><ul><li>vtable（虚函数表）：每一个含有虚函数的类都会维护一个虚函数表，里面按照声明顺序记录了虚函数的地址</li><li>vptr（虚函数表指针）：一个指向虚函数表的指针，每个对象都会拥有这样的一个指针</li></ul><p>先看看下面这个简单的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(A) &gt; <span class="keyword">sizeof</span>(B) <span class="comment">// true，因为A比B多了一个虚函数指针</span></span><br></pre></td></tr></table></figure></p><p>下面再来看看刚刚那个加薪的例子，其多态调用的形式如下图：</p><p><img src="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/VirtualFunction.png" alt=""></p><p>通常情况下，编译器在下面两处地方添加额外的代码来维护和使用vptr：</p><ol><li>在每个构造函数中。此处添加的代码会设置被创建对象的虚函数表指针指向对应类的虚函数表</li><li>在每次进行多态函数调用时。 无论合适调用了多态函数，编译器都会首先查找vptr指向的地址（也就是指向对象对应的类的虚函数表），一旦找到后，就会使用该地址内存储的函数（而不是基类的函数）。</li></ol><h1 id="虚函数中的默认参数"><a href="#虚函数中的默认参数" class="headerlink" title="虚函数中的默认参数"></a>虚函数中的默认参数</h1><p>先看下面的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span> <span class="params">( <span class="keyword">int</span> x = <span class="number">0</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun(), x = "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里的virtual关键字可以省略，因为只要基类里面被声明为虚函数，那么在子类中默认都是虚的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span> <span class="params">( <span class="keyword">int</span> x )</span><span class="comment">// 或者定义为 virtual void fun ( int x = 10)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::fun(), x = "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d1;</span><br><span class="line">    Base *bp = &amp;d1;</span><br><span class="line">    bp-&gt;fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码输出始终为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived::fun(), x = <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p><strong>解释：</strong></p><ul><li>首先，参数的默认值是不算做函数签名的，因此，即使基类有默认值，子类没有，这两个函数的函数签名仍然被认为是相同的，所以在调用<code>bp-&gt;fun();</code>，仍然调用了子类的<code>fun</code>函数，但是因为没有给出<code>x</code>的值，所以采用了基类函数给出的默认值<code>0</code>.</li><li>当基类给出默认值0，子类给出默认值10时，返回结果仍然是默认值<code>0</code>，这是因为，参数的默认值是静态绑定的，而虚函数是动态绑定的，因此， 默认参数的使用需要看指针或者引用本身的类型，而不是指向对象的类型。<br>-<br><strong>小结：根据上面的分析，在虚函数中最好不要使用默认参数，否则很容易引起误会！</strong></li></ul><h1 id="静态函数可以被声明为虚函数吗"><a href="#静态函数可以被声明为虚函数吗" class="headerlink" title="静态函数可以被声明为虚函数吗"></a>静态函数可以被声明为虚函数吗</h1><p>静态函数不可以声明为虚函数，同时也不能被const和volatile关键字修饰。如下面的声明都是错误的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">// 函数不能被const修饰，但是返回值可以</span></span><br></pre></td></tr></table></figure></p><p>原因主要有两个方面：</p><ul><li>static成员函数不属于任何类对象或类实例，所以即使给此函数加上virtual也是没有意义的</li><li>虚函数依靠vptr和vtable来处理，vptr是一个指针，在类的构造函数中创建生成，并且智能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。</li></ul><h1 id="构造函数可以为虚函数吗"><a href="#构造函数可以为虚函数吗" class="headerlink" title="构造函数可以为虚函数吗"></a>构造函数可以为虚函数吗</h1><p>构造函数不可以声明为虚函数。同时除了<code>inline</code>之外，构造函数不允许使用其他任何关键字，原因如下：</p><ul><li>尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。 如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。 问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。</li><li>我们之所以使用虚函数，是因为需要在信息不全的情况下进行多态运行。而构造函数是用来初始化实例的，实例的类型必须是明确的。 因此，构造函数没有必要被声明为虚函数。</li></ul><h1 id="析构函数可以为虚函数吗"><a href="#析构函数可以为虚函数吗" class="headerlink" title="析构函数可以为虚函数吗"></a>析构函数可以为虚函数吗</h1><p>析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。事实上，只要一个类有可能会被其他类所继承，就应该声明虚析构函数（哪怕该析构函数不执行任何操作）。原因可以见先秒的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    base()     </span><br><span class="line">    &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Constructing base \n"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtual ~base()</span></span><br><span class="line">    ~base()</span><br><span class="line">    &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructing base \n"</span>; &#125;     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    derived()     </span><br><span class="line">    &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Constructing derived \n"</span>; &#125;</span><br><span class="line">    ~derived()</span><br><span class="line">    &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructing derived \n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  derived *d = <span class="keyword">new</span> derived();  </span><br><span class="line">  base *b = d;</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructing base</span><br><span class="line">Constructing derived</span><br><span class="line">Destructing base</span><br></pre></td></tr></table></figure></p><p>可见，继承类的析构函数没有被调用，delete时只根据指针类型调用了基类的析构函数。 正确的操作是，基类和继承类的析构函数都应该被调用，解决方法是将基类的析构函数声明为虚函数。</p><h1 id="虚函数可以为私有函数吗"><a href="#虚函数可以为私有函数吗" class="headerlink" title="虚函数可以为私有函数吗"></a>虚函数可以为私有函数吗</h1><p>虚函数可以被私有化，但有一些细节需要注意<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base Fun"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived Fun"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Base *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">   ptr-&gt;fun();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Derived <span class="title">fun</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><ul><li>基类指针指向继承类对象，则调用继承类对象的函数</li><li>int main()必须声明为Base类的友元，否则编译失败。编译器报错：ptr无法访问私有函数。当然，把基类声明为public，继承类为private，该问题就不存在了。</li></ul><h1 id="虚函数可以被内联吗"><a href="#虚函数可以被内联吗" class="headerlink" title="虚函数可以被内联吗"></a>虚函数可以被内联吗</h1><p>通常类成员函数都会被编译器考虑是否进行内联。但通过基类指针或者引用调用的虚函数必定不能被内联。当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。</p><h1 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h1><p>纯虚函数：在基类中只声明不定义的虚函数，同时要求任何派生类都要实现该虚函数。在基类中实现纯虚函数的方法是在函数原型后加“=0”。</p><p>抽象类：含有纯虚函数的类为抽象类</p><p>纯虚函数的特点以及用途总结如下：</p><ul><li>如果不在继承类中实现该函数，则继承类仍为抽象类；</li><li>派生类仅仅只是继承纯虚函数的接口，因此使用纯虚函数可以规范接口形式</li><li>抽象类无法实例化对象</li><li>抽象类可以有构造函数</li><li>析构函数被声明为纯虚函数是一种特例，允许其有具体实现。（有些时候，想要使一个类称为抽象类，但刚好有没有任何合适的纯虚函数，最简单的方法就是声明一个纯虚的析构函数）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的static关键字</title>
      <link href="/z_post/Cpp-static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/z_post/Cpp-static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="static关键字常用方法"><a href="#static关键字常用方法" class="headerlink" title="static关键字常用方法"></a>static关键字常用方法</h1><div class="table-container"><table><thead><tr><th>用法</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>在局部变量前使用static</td><td><code>int main(){ static int a;}</code></td><td>该变量具有静态持续性, 但是无链接性</td></tr></tbody></table></div><p>首先：在类中声明的静态变量，一定要进行初始化，并且，如果不const static类型的静态变量，则需要在类外初始化，同时初始化的时候一定要带上类名和作用域解析符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sum</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">        sum()&#123;i++; s+=i;&#125;;</span><br><span class="line">        ~sum()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123; <span class="comment">//静态函数只能使用静态变量</span></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            s = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">int</span> sum::i =<span class="number">0</span>; <span class="comment">//  非const static类型，要在类外初始化</span></span><br><span class="line"><span class="keyword">int</span> sum::s = <span class="number">0</span>; <span class="comment">// 且必须带上类名sum和作用域解析符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sum::<span class="built_in">set</span>();  <span class="comment">// 直接用类名调用函数，则该函数必须是静态的</span></span><br><span class="line">        sum a[n];</span><br><span class="line">        <span class="keyword">return</span> sum::s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h2><p>C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于 <strong>数据保留在内存中的时间</strong> ：(Primer p304)</p><ul><li>自动存储持续性: 在程序开始执行其所在的函数或者代码块时被创建, 在执行完函数或代码块时, 其内存会被自动释放.</li><li>静态存储持续性: 在整个程序运行过程当中都存在</li><li>线程存储持续性（C++11）</li><li>动态存储持续性: 用new运算符分配的内存将一直存在(堆中), 直到使用delete运算符将其释放或者 <strong>程序结束</strong> 为止.</li></ul><h2 id="作用域和链接性"><a href="#作用域和链接性" class="headerlink" title="作用域和链接性"></a>作用域和链接性</h2><ul><li>和C语言一样，C++也为 <strong>静态</strong> 存储持续性变量提供了3种链接性(其他类型的持续性变量均是无链接性的)，这三种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。(Primer p309)<ul><li>外部链接性（可在其他文件中访问）</li><li>内部链接性（只能在当前文件中访问）</li><li>无链接性（只能在当前函数或代码块中访问，与自动变量不同的是，就算不在函数中，变量也存在，只是不能访问）</li></ul></li><li>由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们, 而是将它们放在全局数据区。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地初始化静态变量，编译器将把它设置为0。在默认情况下，<strong>静态</strong> 数组和结构将每个元素或成员的所有位都设置为0。p309</li><li><p>创建三种链接性的静态持续变量：p309</p><ul><li>外部链接性：必须在代码块的外面声明</li><li>内部链接性：必须在代码块的外面声明，并使用static限定符</li><li>无链接性：必须在代码块内部声明，并使用static限定符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int global = 1000; //静态持续变量，外部链接性，作用域为整个文件</span><br><span class="line">static int one_file = 50; //静态持续变量，内部链接性，作用域为整个文件</span><br><span class="line">int main()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">void funct1(int n)&#123;</span><br><span class="line">  static int count = 0; //静态持续变量，无链接性，作用域为局部</span><br><span class="line">  int llama = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>五种变量存储方式：p310</p><ul><li>自动</li><li>寄存器</li><li>静态，无链接</li><li>静态，外部链接</li><li>静态，内部链接</li></ul></li><li><strong>关键字重载：</strong> 关键字的含义取决于上下文，static用于局部声明，以指出变量是无链接性的静态变量时，表示的是存储持续性。而用于代码块外的声明时，static表示内部链接性，因为位于代码块外的变量已经是静态持续性了。p310</li><li><strong>静态变量的初始化：</strong> 静态变量有三种初始化方式：零初始化（变量设为零）、常量表达式初始化和动态初始化。 零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件时初始化变量，动态初始化意味着变量将在编译后初始化。p310</li><li><strong>静态变量的初始化过程：</strong> 首先，所有静态变量都被零初始化，而不管程序员是否显式地初始化了它。接下来，如果使用常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可计算表达式，编译器将执行常量表达式初始化。必要时，编译器将执行简单计算。最后，剩下的变量将被动态初始化。 常量表达式并非只能是使用字面常量的算术表达式。（sizeof运算符也可以）p310</li><li>链接性为外部的变量通常简称为外部变量，也称全局变量，它们的存储持续性为静态，作用域为整个文件。p310</li></ul><h2 id="静态持续性、外部链接性"><a href="#静态持续性、外部链接性" class="headerlink" title="静态持续性、外部链接性"></a>静态持续性、外部链接性</h2><ul><li><p><strong>单定义规则（One Definition Rule，ODR）：</strong> 变量只能定义一次。为满足这种需求，C++提供了两种变量声明：p311</p><ul><li>定义声明（简称定义）：为变量分配存储空间。</li><li>引用声明（简称声明）：不给变量分配存储空间，引用已有的变量。使用关键字extern<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double up; //定义声明</span><br><span class="line">exterm int blem; //blem在别处定义</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字extern声明它。p311</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//file01.cpp</span><br><span class="line">extern int cats = 20; // 由于初始化，所以这里是定义而非声明</span><br><span class="line">int dogs = 22;  //定义</span><br><span class="line">//即使去掉file01.cpp文件中的extern也无妨，效果相同。</span><br><span class="line">//file02.cpp</span><br><span class="line">extern int cats;  //使用extern且无初始化，说明使用的是其他文件的cats</span><br><span class="line">extern int dogs;  //同上</span><br></pre></td></tr></table></figure></li></ul><h2 id="静态持续性、内部链接性"><a href="#静态持续性、内部链接性" class="headerlink" title="静态持续性、内部链接性"></a>静态持续性、内部链接性</h2><ul><li>将作用域为整个文件的变量声明为静态外部变量（内部链接性），就不必担心其名称与其他文件中的外部变量发生冲突.</li></ul><p>通常, 当在函数体内定义一个变量时, 该变量是一个自动存储变量, 每当运行到该语句时都会给该局部变量分配 <strong>栈内存</strong>, 而随着程序退出函数体, 系统就会自动收回这一部分内存. 但有时候我们需要在两次调用之间对变量的值进行保存. 通常的想法是定义一个全局变量来实现, 但是这样一来, 变量就不再属于该函数本身了. 因此, 可以使用静态局部变量来解决, 静态局部变量保存在全局数据区, 而不是保存在栈中, 每次的值保持到下一次调用, 知道下次赋新值.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//file1</span><br><span class="line">int errors = 20;</span><br><span class="line"></span><br><span class="line">//file2</span><br><span class="line">int errors = 5;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cout&lt;&lt;errors; //报错，errors与file1中的外部变量重定义</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解决方法：file2</span><br><span class="line">static int errors = 5;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cout&lt;&lt;errors; // 输出5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态存储持续性、无链接性"><a href="#静态存储持续性、无链接性" class="headerlink" title="静态存储持续性、无链接性"></a>静态存储持续性、无链接性</h2><ul><li>局部静态变量：虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。因此在两次函数调用之间，静态局部变量的值将 <strong>保持不变</strong> 。</li></ul><p>另外，如果初始化了静态局部变量，则程序 <strong>只在启动时进行一次初始化</strong> 。以后再调用函数时，将不会被再次初始化。p315</p><h2 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h2><ul><li>存储说明符（storage class specifier）：p317<ul><li>auto（在C++11中不再是说明符）</li><li>register</li><li>static</li><li>extern</li><li>thread_local（C++11新增的）</li><li>mutable：即使结构（或类）变量为const，其某个成员也可以被修改</li></ul></li><li>cv-限定符（cv-qualifer）：p317<ul><li>const：内存被初始化后，程序便不能再对它进行修改</li><li>volatile：即使程序代码没有对内存单元进行修改，其值也可能发生变化</li></ul></li><li>在默认情况下 <strong>全局变量的链接性为外部</strong>，但 <strong>const全局常量的链接性为内部 (因为是全局的, 所以默认已经具有静态持续性)</strong> 。因此，将一组常量放在头文件中，其他引用该头文件的文件都相当于自己定义了私有的常量，这就是能够将常量定义放在头文件中而不会重定义的原因。p318</li><li>如果处于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性，<code>extern const int states = 50;</code>，在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它。同时这种情况下就不能将该常量放在头文件中了, 因为链接性已经变成外部, 这样会引起重复定义. p318</li></ul><h2 id="函数的链接性和static关键字"><a href="#函数的链接性和static关键字" class="headerlink" title="函数的链接性和static关键字"></a>函数的链接性和static关键字</h2><p><strong>当static关键字作用于函数时, 它改变的只是函数的链接性, 函数的持续性永远为静态</strong></p><ul><li>C++不允许在一个函数中定义另一个函数，因此 <strong>所有函数的存储持续性都自动为静态，即在整个程序执行期间都一直存在</strong> 。p318</li><li><strong>在默认情况下，函数的链接性为外部</strong>。即可以在文件间共享，使用extern来指出函数实在另一个文件中定义的（可选）。p318</li><li><strong>可以使用关键字static将函数的链接性设置为内部</strong> ，使之只能在一个文件中使用，必须同时在原型和函数定义中使用该关键字。p318</li><li><strong>内联函数不受单定义规则的约束，这允许程序员能够将内联函数的定义放在头文件中。但是C++要求同一个函数的所有内联定义都必须相同。</strong> p319</li><li>C++查找函数顺序：静态（在本文件中找）——外部（在所有的程序文件中找）——在库函数中找。因此如果定义了一个与库函数同名的函数，编译器优先使用程序员定义的版本（C++不推荐这样做）。p319</li></ul><h2 id="语言链接性"><a href="#语言链接性" class="headerlink" title="语言链接性"></a>语言链接性</h2><ul><li>不同的语言采用了不同的链接性，为了解决这种问题，需要特别指定函数采用的链接性（默认为C++链接性）。p319</li></ul><h1 id="面向对象的static关键字-类中的static关键字"><a href="#面向对象的static关键字-类中的static关键字" class="headerlink" title="面向对象的static关键字(类中的static关键字)"></a>面向对象的static关键字(类中的static关键字)</h1><h2 id="静态成员数据"><a href="#静态成员数据" class="headerlink" title="静态成员数据"></a>静态成员数据</h2><p>在类内的数据成员的声明前加上关键字static, 该数据成员就是类内的静态数据成员, 具有以下特点:</p><ul><li>静态数据成员被当作是 <strong>类的成员 (注意与具体对象无关)</strong>, 无论这个类的对象被定义了多少个, 静态数据成员在程序中也只有一份拷贝(只分配一次内存), 由该类型的所有对象共同持有.</li><li><p>静态数据成员存储在全局数据区. 由于静态数据成员在定义时必须分配空间, 所以只能在类中对静态数据成员声明, 而不能在类中对静态数据成员进行定义, 需要放到类外定义, 且定义时不要加<code>static</code>关键字, 但是必须指明命名空间. 如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> get</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> Sum; <span class="comment">// 不能再类内部声明时定义或初始化静态变量, 因为声明只是描述了如何分配内存, 但实际上并不真正分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> Myclass::Sum = <span class="number">0</span>; <span class="comment">// 只能在类外部定义并初始化静态成员变量</span></span><br></pre></td></tr></table></figure></li><li><p>静态数据成员和普通数据成员一样要遵从public, protected, private等访问规则.</p></li><li>因为静态数据成员是独立于具体对象的, 因此, 即使没有产生任何类的实例, 我们仍然可以对其进行访问.</li><li>如果静态数据成员的访问权限允许的话(public), 可以通过下面两种方式来直接访问:<ul><li>&lt;类对象名&gt;.&lt;静态数据成员名&gt;</li><li>&lt;类名&gt;::&lt;静态数据成员名&gt;</li></ul></li><li>同全局变量相比(静态持续性, 外部链接性), 使用静态数据成员有两个优势:<ul><li>静态数据成员没有进入程序的全局命名空间, 因此不存在与程序中其他全局变量名冲突的可能性</li><li>可以实现信息隐藏, 静态数据成员可以是private成员, 而全局变量不能.</li></ul></li></ul><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>与静态数据成员一样, 也可以创建一个静态成员函数, 它为类的全部对象服务, 而不是为某一个具体的对象服务 ,具有以下特点:</p><ul><li>在定义(实现)静态成员函数时, 同样不能带有关键字<code>static</code></li><li>静态成员之间可以互相访问, 包括静态成员函数访问静态数据成员和静态成员函数</li><li>非静态成员函数可以任意的访问静态成员和非静态成员.</li><li>静态成员函数不能访问任何非静态成员</li><li>由于没有<code>this</code>指针上的开销, 因此静态成员函数在速度上会小优于类的全局函数</li><li>类对象或对象指针可以像调用普通函数一样使用<code>.</code>或<code>-&gt;</code>来调用静态成员函数, 也可以使用<code>&lt;类名&gt;::&lt;静态成员函数名&gt;()</code>的方式来调用</li></ul><h3 id="静态成员函数与this指针"><a href="#静态成员函数与this指针" class="headerlink" title="静态成员函数与this指针"></a>静态成员函数与<code>this</code>指针</h3><p>普通的成员函数一般都隐含了一个<code>this</code>指针, <code>this</code>指针指向类的对象本身, 因为普通成员函数总是属于类的某个具体对象, 通常情况下, <code>this</code>指针是缺省的, 如函数 <code>func()</code> 实际上是<code>this-&gt;func()</code>, 但是与普通函数相比, 静态成员函数由于不与任何对象相联系, 因此它不具有<code>this</code>指针, 从这个意义上讲, 它就 <strong>无法访问属于类对象的非静态数据成员, 也无法访问非静态成员函数</strong>, 只能访问或调用静态的数据或函数.</p><h2 id="const与static"><a href="#const与static" class="headerlink" title="const与static"></a>const与static</h2><p><code>const</code> 只是对于单个类对象来说是常量, 而对于整个类来说实际上是变量, 如果要维护一个对于整个类来说的常量, 应该使用<code>const static</code>或者<code>static cosnt</code>(二者等价)来声明, 与普通<code>static</code>成员数据不太一样的是, <strong><code>const static</code>成员数据需要在类中声明的同时就进行初始化(因为const数据在定义是必须初始化, 而static又是的该变量独立于具体对象, 所以必须在声明时初始化或者在类外部初始化, 也不能在构造函数初始化列表中初始化)</strong> :<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">3</span>; <span class="comment">// 声明并初始化</span></span><br><span class="line">    cosnt <span class="keyword">int</span> b = <span class="number">4</span>; <span class="comment">//这样是可以的, 但是这样所有变量的b都为4,且不能改变, 还不如声明为const static</span></span><br><span class="line">    <span class="comment">//所以最好还是在构造函数的初始化列表中对非静态const进行初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Myclass::c = <span class="number">5</span>; <span class="comment">//在类外部初始化. 不要带static关键字</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双流手语识别系统：（一）框架设计</title>
      <link href="/z_post/%E9%A1%B9%E7%9B%AE-%E5%8F%8C%E6%B5%81%E6%89%8B%E8%AF%AD%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E2%80%94-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/z_post/%E9%A1%B9%E7%9B%AE-%E5%8F%8C%E6%B5%81%E6%89%8B%E8%AF%AD%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E2%80%94-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vector数据的内存分配问题</title>
      <link href="/z_post/Cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-Vector%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/"/>
      <url>/z_post/Cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-Vector%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="有问题-待修改"><a href="#有问题-待修改" class="headerlink" title="有问题 待修改"></a>有问题 待修改</h1><p>首先，要知道，程序所拥有的栈资源是及其有限的（Linux下用<code>ulimit -a</code>或者<code>ulimit -s</code>可查当前栈的大小。  因此在写程序时，绝对不能肆意使用占空间，否则就会报出<code>Segmentation fault</code>。</p><p>在用vector实现三维数据时，以下的代码就会产生段错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> HEIGHT=<span class="number">2</span>,WIDTH=<span class="number">3</span>,DEPTH=<span class="number">5</span>;</span><br><span class="line">    <span class="comment">// construct array3D[HEIGHT][WIDTH][DEPTH]</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &gt; &gt; array3D;</span><br><span class="line"></span><br><span class="line">    array3D.resize(HEIGHT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; HEIGHT; ++i) &#123;</span><br><span class="line">        array3D[i].resize(WIDTH);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; WIDTH; ++j)</span><br><span class="line">            array3D[i][j].resize(DEPTH);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上出现段错误的原因在于申请了过多的vecotr，导致占空间不够用，从而出现段错误，现在来看以下vector在内存中具体是如何存储的，首先看一下以下三种方式的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; vec;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;* Vec = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T*&gt; vec;</span><br></pre></td></tr></table></figure><p>假设<code>T</code>是一个类型或者一个定义好的类，则以上三种情况的内存分配情况如下：</p><ul><li>对于<code>std::vector&lt;T&gt; vec</code>；<code>vec</code>在栈上（stack），而其中的元素<code>T</code>保存在堆上（heap）；</li><li>对于<code>std::vector&lt;T&gt;* Vec = new std::vector&lt;T&gt;()</code>；<code>vec</code>和其中的元素<code>T</code>都保存在堆上；</li><li>对于<code>std::vector&lt;T*&gt; vec</code>；<code>vec</code>在栈上（stack），而其中的元素<code>T</code>保存在堆上（heap）；和第一种情况类似。</li></ul><p>存储在栈上的元素，往往无需手动管理内存空间，通常会自动释放，而在堆上的空间，则需要手动管理。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gcc/g++的编译链接原理及注意事项</title>
      <link href="/z_post/Cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-%E5%85%B3%E4%BA%8Egcc%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"/>
      <url>/z_post/Cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-%E5%85%B3%E4%BA%8Egcc%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="LINUX下默认搜索头文件及库文件的路径"><a href="#LINUX下默认搜索头文件及库文件的路径" class="headerlink" title="LINUX下默认搜索头文件及库文件的路径"></a>LINUX下默认搜索头文件及库文件的路径</h1><h1 id="编译连接"><a href="#编译连接" class="headerlink" title="编译连接"></a>编译连接</h1><p>多个文件编译在linux下编译，下面有三个文件，分别是1.cpp 和 2.cpp 和myhead.h 文件。</p><p>1.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myhead.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes !"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myhead.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">" print "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myhead.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __myhead_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __myhead_h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>假如他们都在一个目录下面，那么编译流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c 2.cpp             #将2.cpp 编译成2.o 文件</span><br><span class="line">g++ 1.cpp -o a.out 2.o   #多个文件一起链接</span><br></pre></td></tr></table></figure><p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -c 2.cpp</span><br><span class="line">g++ -c 1.cpp</span><br><span class="line">g++ 1.o 2.o -o test</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>声明模板类对象，报错“undefined reference to”</title>
      <link href="/z_post/Cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8A%A5%E9%94%99undefined_reference_to/"/>
      <url>/z_post/Cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8A%A5%E9%94%99undefined_reference_to/</url>
      
        <content type="html"><![CDATA[<h1 id="坑源"><a href="#坑源" class="headerlink" title="坑源"></a>坑源</h1><p>实现ZeroTensor项目中的<code>Shape3D</code>类时，为了可以处理多种类型的数据（int，double等），需要使用模板类</p><h1 id="出现问题和解决办法"><a href="#出现问题和解决办法" class="headerlink" title="出现问题和解决办法"></a>出现问题和解决办法</h1><p>在实现的时候将模板类的声明和定义写在的不同位置，编译时报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined reference to XXXX</span><br></pre></td></tr></table></figure></p><p>这是因为模板类并不是普通的类和成员函数！它们只是说明了如何生成类和成员函数定义。因此，不能将模板成员函数放在独立的实现文件中。</p><p>由于模板不是函数，因此它们不能单独编译。模板必须与特定的模板实例化请求一起使用。为此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件！</p><p>还有另一种解决办法就是在<code>stack.h</code>文件的末尾加上<code>#include stack.cpp</code>，并在<code>stack.cpp</code>文件中去掉对应的包含语句。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《CUDA By Example》</title>
      <link href="/z_post/CUDA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-CUDAByExample/"/>
      <url>/z_post/CUDA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-CUDAByExample/</url>
      
        <content type="html"><![CDATA[<h1 id="WHY-CUDA？-WHY-NOW？"><a href="#WHY-CUDA？-WHY-NOW？" class="headerlink" title="WHY CUDA？ WHY NOW？"></a>WHY CUDA？ WHY NOW？</h1>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>《C++ PrimerPlus》 第十五章</title>
      <link href="/z_post/Cpp-Book-CppPrimerPlusChapter15/"/>
      <url>/z_post/Cpp-Book-CppPrimerPlusChapter15/</url>
      
        <content type="html"><![CDATA[<h1 id="第十五章-友元、异常和其他"><a href="#第十五章-友元、异常和其他" class="headerlink" title="第十五章 友元、异常和其他"></a>第十五章 友元、异常和其他</h1><h2 id="15-1-友元"><a href="#15-1-友元" class="headerlink" title="15.1 友元"></a>15.1 友元</h2><p>类并非只能拥有友元函数，也可以将类作为友元。在这种情况下，友元类的所有方法都可以访问原始类的私有成员和保护成员。哪些函数、成员函数或类为友元是由类定义的，而不能从外部强加友情。因此 ，尽管友元被授予从外部访问类的私有部分的权限，但它们并不与面向对象的编程思想相悖。</p><h2 id="15-1-1-友元类"><a href="#15-1-1-友元类" class="headerlink" title="15.1.1 友元类"></a>15.1.1 友元类</h2><p>关于需要使用友元类的情况，可以想象电视机类和遥控器类之间的关系，首先，它们不是is-a，其次，也不是has-a，但是它们确实存在某个关系，这就是——友元。下面的语句使Remote成为友元类，友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。由于<code>Remote</code>类中访问了Tv类的成员，因此，编译器必须了解Tv类以后，才能处理Remote类，最简单的方法是首先定义Tv类，另一种方法是使用前向声明（forward delaration），这将稍后介绍。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tv</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Remote</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>以上代码，在电视机类里面声明遥控器类为友元类以后，遥控器类就可以访问电视机类的私有成员变量，而无需让电视机类修改自身的访问权限，就是说电视机对外界的访问权限是不变的，并没有破坏类的封装行。</p><h3 id="15-1-2-友元成员函数"><a href="#15-1-2-友元成员函数" class="headerlink" title="15.1.2 友元成员函数"></a>15.1.2 友元成员函数</h3><p>可以选择仅让特定的类成员变成另一个类的友元，而不必让整个类成员友元，但是这样做稍微有点麻烦，必须小心排列各种声明和定义的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">void</span> Remote::set_chanel(TV &amp;t, <span class="keyword">int</span> c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使编译器能够处理上面的代码，它必须知道Remote的定义，否则，它无法知道Remote是类还是别的什么，也无法确定<code>set_chanel</code>是这个类的方法。而前面又说了，Tv应定义在Remote定义之前，这就导致了循环依赖问题。避开这种问题的方法是使用前向声明（forward declaration）。为此，需要在Remote定义的前面插入下面的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Tv;</span><br></pre></td></tr></table></figure></p><p>这样，新的排列顺序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Tv;</span><br><span class="line">class Remote &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">class Tv&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意，Tv类与Remote类的定义不可以调换，因为编译器在Tv类的声明者是看到Remote的一个方法被声明为Tv类的友元之前，应该先看到Remote类的声明和<code>set_chanel()</code>方法的声明。</p><h3 id="15-1-3-其他友元关系"><a href="#15-1-3-其他友元关系" class="headerlink" title="15.1.3 其他友元关系"></a>15.1.3 其他友元关系</h3><p>可以通过让类彼此成为对方的友元来实现互相影响对象的功能。即除了Remote是Tv的友元外，Tv还是Remote的友元。需要注意一点的是，对于使用Remote对象的Tv方法，其原型可在Remote类声明之前声明，但必须在Remote类声明之后定义，以便编译器有足够的信息来编译该方法。</p><h3 id="15-1-4-共同的友元"><a href="#15-1-4-共同的友元" class="headerlink" title="15.1.4 共同的友元"></a>15.1.4 共同的友元</h3><p>需要使用友元的另一种情况是，函数需要访问两个类的私有数据。因此，可以将函数左右两个类的友元</p><h2 id="15-2-嵌套类（内部类）"><a href="#15-2-嵌套类（内部类）" class="headerlink" title="15.2 嵌套类（内部类）"></a>15.2 嵌套类（内部类）</h2><p>在C++中，可以将类声明放在另一个类中，在另一个类中声明的类被成为嵌套类（nested class），它通过提供新的类型类作用域来避免名称混乱。包含类的成员函数可以创建和使用被嵌套类的对象，而仅当声明位于公有部分，才能在包含类的外面使用嵌套类，而且必须使用作用域解析符。</p><p>对类进行嵌套与包含并不同。包含意味着将类对象作为另一个类的成员，而对类进行嵌套不会创建类成员，而是 <strong>定义了一种类型</strong> ，可以在包含类的其他方法内声明该类型的变量，该类型仅在包含嵌套类声明的类中有效。</p><h3 id="15-2-1-嵌套类和访问权限"><a href="#15-2-1-嵌套类和访问权限" class="headerlink" title="15.2.1 嵌套类和访问权限"></a>15.2.1 嵌套类和访问权限</h3><ol><li>作用域</li></ol><p>&emsp;&emsp;如果嵌套类是在另一个类的私有部分声明的，则只有这个类知道它。也就是说，只能通过这个类的成员来使用嵌套类，就像私有变量一样。而这个类的派生类，和外部的程序都无法访问到该嵌套类。</p><p>&emsp;&emsp;如果嵌套类是在另一个类的保护部分声明的，则它对于后者及其派生类都是可见的，但是对于外部师姐是不可见的。</p><p>&emsp;&emsp;如果嵌套类是在另一个类的公有部分声明的，则允许后者、后者的派生类以及外部世界访问它。并且，由于嵌套类的作用域为包含它的类，因此在外部世界使用它时，必须使用类限定符。</p><p>&emsp;&emsp;嵌套结构和枚举的作用域与嵌套类相同。下表总结了嵌套类、结构和枚举的作用域特征</p><div class="table-container"><table><thead><tr><th>声明位置</th><th>包含它的类是否可以使用它</th><th>从包含它的类派生的类是否可以使用它</th><th>在外部是否可以使用</th></tr></thead><tbody><tr><td>私有部分</td><td>是</td><td>否</td><td>否</td></tr><tr><td>保护部分</td><td>是</td><td>是</td><td>否</td></tr><tr><td>公有部分</td><td>是</td><td>是</td><td>是，通过类限定符使用</td></tr></tbody></table></div><ol><li>访问控制</li></ol><p>&emsp;&emsp; 类可见后，起决定作用的将是访问控制。对嵌套类访问权的控制规则与对常规类相同。例如，在Queue类声明中声明了Node嵌套类，这并没有赋予Queue类任何对Node类的访问特权，也没有赋予Node类任何对Queue类的访问特权。因此，Queue类对象只能显式的访问Node对象的公有成员。</p><h3 id="15-2-2-模板中的嵌套"><a href="#15-2-2-模板中的嵌套" class="headerlink" title="15.2.2 模板中的嵌套"></a>15.2.2 模板中的嵌套</h3><p>模板类可以正常使用嵌套类，不会带来额外的问题。</p><h2 id="15-3-异常"><a href="#15-3-异常" class="headerlink" title="15.3 异常"></a>15.3 异常</h2><p>程序有时会遇到运行阶段错误，导致程序无法正常的走下去。如，试图打开一个不可用的文件、请求过多的内存、遭遇不能接受的值等等。</p><p>C++的异常处理机制是一个相对较新的功能，有些老式编译器可能没有实现，有些编译器可能默认关闭这种特性，需要在选项中开启。比如“零除” 这种异常，很多新编译器通过生成一个表示无穷大的特殊浮点值来处理，cout将其显示为Inf、inf、INF等，有些编译器可能会直接崩溃。</p><h3 id="15-3-1-调用abort"><a href="#15-3-1-调用abort" class="headerlink" title="15.3.1 调用abort()"></a>15.3.1 调用abort()</h3><p><code>abort()</code>函数的原型位于头文件<code>cstdlib（stdlib.h）</code>中，其典型实现是向标准错误流发送消息abnormal program termination（程序异常终止），然后终止程序。它还返回一个随实现而异的值，告诉操作系统（或者父进程），处理失败。<code>abort()</code>是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。如果愿意，也可以使用<code>exit()</code>，该函数刷新文件缓冲区，但不显示消息。</p><h3 id="15-3-2-返回错误码"><a href="#15-3-2-返回错误码" class="headerlink" title="15.3.2 返回错误码"></a>15.3.2 返回错误码</h3><p>一种比异常终止更灵活的方法是，使用函数的返回值来指出问题。如果某些函数的任何数值返回都是有效的，那么可以增加一个指针参数或引用参数，来将返回值返回，同时将函数的返回值改成bool类型，来指出是否返回成功。</p><p>另一种方法使用一个全局变量。可能问题的函数可以在出现问题时将该全局变量设值为特定的值，而调用程序可以检查该变量。</p><h3 id="15-3-3-异常机制"><a href="#15-3-3-异常机制" class="headerlink" title="15.3.3 异常机制"></a>15.3.3 异常机制</h3><p>C++异常是对程序运行过程中发生的异常情况的一种响应。异常提供了将控制权从程序的一个部分传递到另一个部分的途径。对异常的处理有三个组成部分：</p><ul><li>引发异常</li><li>使用处理程序捕获异常</li><li>使用try块处理异常</li></ul><p><code>throw</code>语句实际上是跳转，即命令程序跳到另一条语句。<code>throw</code>关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征。</p><p>程序使用异常处理程序（exception handler）来捕获异常，异常处理程序位于要处理问题的程序中，<code>catch</code>关键字表示捕获异常。处理程序以关键字catch开头，随后是位于括号中的类型声明，他指出了异常处理程序要响应的异常类型。</p><p><code>catch</code>关键字和异常类型用作标签，指出当异常被引发时，程序应跳到这个为止执行。异常处理程序也被称为catch块。</p><p>try块标识可能引起特定异常的代码块，他后面跟一个或多个catch块。try块是由关键字try只是的，关键字try的后面是一个由花括号括起的代码块，表明需要注意这些代码引发的异常。</p><p>在默认情况下，如果函数引发了异常，而没有try块或没有匹配的处理程序时，程序将调用<code>abort()</code>函数。（默认行为可修改）。</p><h3 id="15-3-4-将对象用作异常类型"><a href="#15-3-4-将对象用作异常类型" class="headerlink" title="15.3.4 将对象用作异常类型"></a>15.3.4 将对象用作异常类型</h3><p>通常，引发异常的函数将传递一个对象。这样做的重要优点之一是，可以使用不同的异常类型来区分不同的函数在不同情况下引发的异常。另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。</p><p>根据不同的对象类型，可以跟不同的catch块进行匹配，类型不匹配的catch块将跳过不执行。</p><h3 id="15-3-5-异常规范和C-11"><a href="#15-3-5-异常规范和C-11" class="headerlink" title="15.3.5 异常规范和C++11"></a>15.3.5 异常规范和C++11</h3><p>C++98新增了异常规范（exception specification）的功能，但是在C++11中却被摒弃了。</p><p>新增关键字<code>noexcept</code>指出函数不会引发异。</p><h3 id="15-3-6-栈解退"><a href="#15-3-6-栈解退" class="headerlink" title="15.3.6 栈解退"></a>15.3.6 栈解退</h3><p>C++中处理函数的调用和返回时，会让程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将参数放到栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到栈中，以此类推。</p><p>现在假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。——这个过程被称为栈解退。</p><p><strong>栈解退的意义在于：对于普通的函数返回来说，仅仅会调用该函数放在栈中的对象的析构函数，而throw语句则处理try块和throw之间整个函数调用序列放在栈中的对象。所以，如果没有栈解退这种特性，则引发异常后，对于中间函数调用放在栈中的自动类对象，其析构函数将不会被调用。</strong></p><p><strong>也就是说：程序进行栈解退以回到能够捕获异常的地方时，将释放栈中的自动存储型变量。如果变量是类对象，将为该对象调用析构函数。</strong></p><h3 id="15-3-7-其他异常特性"><a href="#15-3-7-其他异常特性" class="headerlink" title="15.3.7 其他异常特性"></a>15.3.7 其他异常特性</h3><p>虽然throw-catch机制类似于函数返回机制，但还是有些不同之处：</p><ul><li>函数<code>fun()</code>中的返回语句将控制权返回到调用<code>fun()</code>的函数，但<code>throw</code>语句将控制权向上返回到第一个包含能够捕获相应异常的try-catch组合。</li><li>引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">problem</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">super</span><span class="params">()</span> <span class="title">throw</span><span class="params">(problem)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>( oh_no )&#123;</span><br><span class="line">    problem oops;</span><br><span class="line">    <span class="keyword">throw</span> oops;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  super();</span><br><span class="line">&#125;<span class="keyword">catch</span>(problem &amp;p)&#123; <span class="comment">//这里p虽然声明为引用，但是p指向的是oops的副本而不是oops本身，这是件好事，因为函数`super()`执行完毕后，oops将不复存在。</span></span><br><span class="line"><span class="comment">//既然如此，为何还要特意声明为引用？因为引用还有另一个重要特征：基类引用可以执行派生类对象。</span></span><br><span class="line"><span class="comment">//这有一个很大的用法在于，假设有一个异常类层次结构，并要分别处理不同的异常类型，则使用基类引用将能够捕获任何异常对象；</span></span><br><span class="line"><span class="comment">//而使用派生类对象只能捕获它所属类及从这个类派生而来的类的对象。引发的异常对象将被第一个与之匹配的catch块捕获。</span></span><br><span class="line"><span class="comment">//这意味着catch块的排列顺序应该与派生顺序相反。也就是要将捕获派生类的catch放前面，捕获基类的catch放后面</span></span><br><span class="line">  <span class="comment">//statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-8-exception类"><a href="#15-3-8-exception类" class="headerlink" title="15.3.8 exception类"></a>15.3.8 exception类</h3><p>较新的C++编译器将异常合并到语言中，并在<code>exception</code>头文件（以前为<code>exception.h</code>或<code>except.h</code>定义了<code>exception</code>类，C++可以把它用作其他异常类的基类。</p><p>C++库定义了很多基于exceptin的异常类型</p><ol><li>stdexcept异常类</li></ol><p>&emsp;&emsp;头文件<code>stdexcept</code>定义了其他几个异常类，首先，该文件定义了<code>logic_error</code>和<code>runtime_error</code>类，它们都是以公有方式从exception派生而来的。这两个新类被用作两个派生类系列的基类。</p><p>&emsp;&emsp;异常类系列<code>logic_error</code>描述了典型的逻辑错误：</p><ul><li>domain_error;</li><li>invalid_argument;</li><li>length_error;</li><li>out_of_bounds.</li></ul><p>&emsp;&emsp;<code>runtime_error</code>异常类系列描述了可能在运行期间发生但难以预计和防范的错误：</p><ul><li>range_error;</li><li>overflow_error;</li><li>underflow_error.</li></ul><p>&emsp;&emsp;一般，<code>logic_error</code>系列异常表明存在可以通过编程修复的问题，而<code>runtime_error</code>系列异常表明存在无法避免的问题。</p><p>&emsp;&emsp;如果上述库类不能满足需求，则应该从<code>logic</code>或<code>runtime</code>异常类中进行派生（而不是从<code>exception</code>），以确保派生出来的异常类可以归入同一个继承层次结构中。</p><ol><li>bad_alloc异常和new</li></ol><p>&emsp;&emsp;对于使用<code>new</code>导致的内存分配问题，C++的最新处理方式是让<code>new</code>引发<code>bad_alloc</code>异常。头文件<code>new</code>包含<code>bad_alloc</code>类的声明，他是从<code>exception</code>类公有派生出来的。但在以前，当无法分配请求的内存量时，<code>new</code>返回一个空指针。</p><ol><li>空指针和new</li></ol><p>&emsp;&emsp;老代码的逻辑是根据<code>new</code>返回的指针是否为空来判断是否失败的，为兼容这种情况，C++标准提供了一种在失败时返回空指针的<code>new</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Big* pb;</span><br><span class="line">pb = <span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) Big[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">if</span>(pb==<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>;</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-9-异常、类和继承"><a href="#15-3-9-异常、类和继承" class="headerlink" title="15.3.9 异常、类和继承"></a>15.3.9 异常、类和继承</h3><p>异常、类和继承以三种方式相互关联：</p><ul><li>像C++标准库一样，从一个异常类派生出另一个</li><li>在类定义中嵌套异常类声明，从而将异常类组合到类中去</li><li>上面的嵌套声明通过继承传给子类</li></ul><h3 id="15-3-10-异常何时会迷失方向"><a href="#15-3-10-异常何时会迷失方向" class="headerlink" title="15.3.10 异常何时会迷失方向"></a>15.3.10 异常何时会迷失方向</h3><p>异常被引发后，在两种情况下会导致问题：</p><ul><li>如果异常是在带异常规范的函数中引发的（C++11虽然摈弃了异常规范，但仍有人使用），则必须与规范列表中的某种异常匹配，否则称为意外异常（unexpected exception）。在默认情况下，程序会异常终止。</li><li>如果异常不是在函数中引发的（或者函数没有异常规范），则必须捕获该异常，如果没被捕获，则被称为未捕获异常（uncaught exception）。在默认情况下，程序会异常终止。</li></ul><p>可以对以上默认情况进行修改：</p><p>未捕获异常：未捕获异常不会导致程序理科异常终止。相反，程序将首先调用函数<code>terminate()</code>。在默认情况下，<code>terminate()</code>调用<code>abort()函数</code>。可以使用<code>set_terminate()</code>函数指定<code>terminate()</code>应调用的函数来修改其默认行为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"quit"</span>;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">5</span>); <span class="comment">// 退出状态值设为5</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">set_terminate(my_quit);</span><br></pre></td></tr></table></figure></p><p>意外异常：通过给函数指定异常规范，可以让函数的用户知道要捕获哪些异常，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double Argn(double , double ) throw (out_of_bounds);</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">  x = Argn(a,b);</span><br><span class="line">&#125;catch(out_of_bounds &amp; ex)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++11摒弃它的原因之一是：异常规范机制处理起来比较麻烦。p640</p><p>在意外异常发生时，将调用<code>unexpected()</code>函数，这个函数将调用<code>terminate()</code>，后者在默认情况下调用<code>abort()</code>。 C++提供了一个<code>set_unexpected ()</code>函数，但限制更严格。p640</p><h3 id="15-3-11-有关异常的注意事项"><a href="#15-3-11-有关异常的注意事项" class="headerlink" title="15.3.11 有关异常的注意事项"></a>15.3.11 有关异常的注意事项</h3><p>从前面关于如何使用异常的讨论可知，应在设计程序时就加入异常处理功能，而不是以后再添加。</p><p>但是这样做会增加代码量，同时异常和动态内存分配并非总能协同工作。</p><p>一句话：异常处理很复杂</p><h2 id="15-4-RTTI"><a href="#15-4-RTTI" class="headerlink" title="15.4 RTTI"></a>15.4 RTTI</h2><p>RTTI：运行阶段类型识别（RunTime Type Identification）</p><p>这是一项比较新的特性，一些旧的C++编译器不支持，还有一些编译器提供了开关RTTI的设值。</p><h3 id="15-4-1-RTTI的用途"><a href="#15-4-1-RTTI的用途" class="headerlink" title="15.4.1 RTTI的用途"></a>15.4.1 RTTI的用途</h3><p>RTTI旨在为程序在运行阶段确定对象的类型提供一种标准方式。</p><h3 id="15-4-2-RTTI的工作原理"><a href="#15-4-2-RTTI的工作原理" class="headerlink" title="15.4.2 RTTI的工作原理"></a>15.4.2 RTTI的工作原理</h3><p>C++有三个支持RTTI的元素：</p><ul><li>如果可能的话，<code>dynamic_cast</code>运算符将使用一个只想基类的指针来生成一个只想派生类的指针；否则，该运算符返回0——空指针</li><li><code>typeid</code>运算符返回一个指出对象的类型的值</li><li><code>type_info</code>结构存储了有关特定类型的信息</li></ul><p><strong>RTTI只适用于包含虚函数的类：</strong> 只能将RTTI用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生类对象的地址赋给基类指针。</p><ol><li>dynamic_cast运算符</li></ol><p>&emsp;&emsp; 该运算符是最常用的RTTI组件，</p><ul><li>它不能回答“指针指向的是哪类对象”这样的问题，</li><li>但能够回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题。</li></ul><p>&emsp;&emsp; 与知道“是哪类对象”相比，知道“类型转换是否安全”更通用，也更有用。主要是因为，通常项知道类型的原因在于：知道类型后，就可以知道调用特定的方法是否安全。 而要调用方法，类型并不一定要完全匹配，而可以是定义了方法的虚拟版本的基类类型。</p><p>&emsp;&emsp; 用法：<br><figure class="highlight cpp"><figcaption><span>ym</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Superb* pm = <span class="keyword">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; 通常，如果指向的对象<code>(*pt)</code>的类型为<code>Type</code>或从<code>Type</code>直接间接派生而来的类型，则下面的表达式将指针<code>pt</code>转换为<code>Type</code>类型的指针，并作为结果赋给<code>ps</code>，否则<code>ps</code>结果为0，即空指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps = <span class="keyword">dynamic_cast</span>&lt;Type *&gt;(pt)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; 也可以将<code>dynamic_cast</code>用于引用，其用法稍微有点不同：没有与空指针对应的引用值，因此无法使用特殊的引用值来指针失败。当请求不正确时，<code>dynamic_cast</code>将引发类型为<code>bad_cast</code>的异常，这种异常是从<code>exception</code>类派生而来的，在头文件<code>typeinfo</code>中定义，可以像下面这样使用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  Superb &amp; rs = <span class="keyword">dynamic_cast</span>&lt;Superb&amp;&gt;(rg);</span><br><span class="line">&#125;<span class="keyword">catch</span>(bad_cast&amp;)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>typeid运算符和type_info类</li></ol><p>&emsp;&emsp;<code>typeid</code>运算符使得能够确定两个对象是否为同种类型。它与<code>sizeof</code>有些相像，可以接受两种参数：</p><ul><li>类名</li><li>结果为对象的表达式</li></ul><p>&emsp;&emsp;<code>typeid</code>运算符返回一个对<code>type_info</code>对象的引用，其中，<code>type_info</code>是头文件<code>typeinfo</code>中定义的一个类。<code>type_info</code>类重载了<code>==</code>和<code>!=</code>运算符，可以进行类型间的比较。下面的代码判断<code>pg</code>指向的是否是一个<code>Magnificent</code>对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeid</span>(Magnificent) == <span class="keyword">typeid</span>(* pg); <span class="comment">//只会判断指针的类型，当基类指针指向子类时，得到的也是基类的类型</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果<code>pg</code>是一个空指针，程序将引发<code>bad_typeid</code>异常。该异常类型是从<code>exception</code>类派生而来的，是在头文件<code>typeinfo</code>中声明的。</p><ol><li>误用RTTI的例子</li></ol><p>如果在扩展的<code>if else</code>语句系列使用了<code>typeid</code>，则应高了是否应该是否虚函数和<code>dynamic_cast</code>。</p><h2 id="15-5-类型转换运算符"><a href="#15-5-类型转换运算符" class="headerlink" title="15.5 类型转换运算符"></a>15.5 类型转换运算符</h2><p>C语言中的类型转换运算符太过松散，因此，在C++中，提供了更严格的限制允许的类型转换，并添加4个类型转换运算符，使转换过程更规范：</p><ul><li>dynamic_cast</li><li>const_cast</li><li>static_cast</li><li>reinterpret_cast</li></ul><p><code>const_cast</code> 运算符用于执行只有一种用途的类型转换，即改变值为<code>const</code>或<code>volatile</code>，其语法与<code>dynamic_cast</code>运算符相同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span> &lt;type-name&gt; (expression)</span><br></pre></td></tr></table></figure></p><p>如果类型的其他方面也被修改，则上述类型转换将出错。也就是说，除了<code>const</code>或<code>volatile</code>特征可以不同外，<code>type-name</code>和<code>expression</code>的类型必须相同。</p><p>提供该运算符的原因是，有时候可能需要这样一个值，它在大多数时候是常量，而有时有事可以修改的。此时就可以声明为const，并在需要的时候使用<code>const_cast</code>。</p><p><code>static_cast</code>运算符的语法与其他类型转换运算符相同：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> &lt;type-name&gt; (expression)</span><br></pre></td></tr></table></figure></p><p>仅当<code>type-name</code>可被隐式转换成<code>expression</code>所属的类型或<code>expression</code>可被隐式转换为<code>type-name</code>所属的类型时，上述转换才是合法的，否则将出错。</p><p><code>reinterpret_cast</code>运算符用于天生危险的类型转换。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>轻量级深度学习框架ZeroTensor：（一）框架设计</title>
      <link href="/z_post/%E9%A1%B9%E7%9B%AE-ZeroTensor-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/z_post/%E9%A1%B9%E7%9B%AE-ZeroTensor-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>FocalLoss-ICCV2017</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-FocalLoss/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-FocalLoss/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> Focal Loss for Dense Object Detection<br><strong>作者:</strong> Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>(1) 分析并指出了One Stage方法精度不高的原因:</strong></p><ul><li><strong>极度不平衡的正负样本比例:</strong> anchor是一种类似sliding windows的选框方式, 这会使得正负样本的比例接近1000:1, 而且绝大部分负样本都是easy example.</li><li><strong>梯度优化过程被easy example过度影响:</strong> 这些easy example的loss虽然不高, 但由于数量众多, 最终合起来会对loss有很大的贡献, 从而导致优化的时候过度关注这些easy example, 这样会收敛到一个不够好的结果.</li></ul><p><strong>(2) 提出了解决正负样本比例和easy example 问题的Focal loss:</strong></p><script type="math/tex; mode=display">FL(p_t) = -(1-p_t)^{\gamma} log(p_t)</script><p>核心思想很简单, 就是在优化过程中逐渐减低那些easy example的权重, 这样会使得训练优化过程对更有意义的样本有更高的偏置.</p><p><strong>PS:</strong><br>注一: 为什么Focal Loss没有用在Two Stage方法上面? 这是因为以RCNN为代表的一系列Two Stage会在区域候选推荐阶段采用两个问题来降低正负样本比例和easy example问题带来的影响:</p><ul><li>采用NMS算法将物体位置候选框降低到一到两千个，更重要的是，这一到两千个可能位置并不是随机选取的，它们移除了大量的易分类负样本（背景框）</li><li>采用了biased-minibatch的采样策略, 比如，保证正样本和负样本的比例为1：3进行训练（这其实相当于起到了 $\alpha$ 因子的作用</li></ul><p><strong>Focal Loss 的两个重要性质:</strong></p><ol><li>当一个样本被分错的时候, $p_t$ 是很小的, 比如当 $y=1$ 时, $p_t$ 要小于0.5才算是错分类, 此时 $p_t$ 就比较小, 反之亦然, 因此调制系数就会趋近于1, 也就是说相比原来的loss没有太大的改变, 而当 $pt$ 趋近于1的时候, 说明此时分类正确而且是易分类样本, 调制系数就会趋近于0, 也就是该样本对总的loss的贡献度很小.</li><li>当 $gamma=0$ 的时候, focal loss就是传统的交叉熵损失, 随着 $gamma$ 的增加, 调制系数的影响力也会增加</li></ol><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>首先，Lin等人回顾了一下目前目标检测的发展概况，先进的目标检测算法目前大概分成两种，一种是one-stage的，一种是two-stage的。one-stage的代表作YOLO以一种简单统一的网络成功实现了实时检测的目的，但是它的准确率并不是best。相反的，two-stage的代表作RCNN系列则是在准确率方面完胜其他模型，但是它的检测速度真的是慢的有的可怜（相比于YOLO）。 于是，Lin他们就开始研究造成这种现象的原因，接着他们就发现原来是在训练的时候，后景数据相比于前景数据较少的缘故。为了解决这个问题，Lin等人对标准的交叉熵损失函数进行修改，降低那些已经分类很好的样例对loss的影响比重，称之为Focal Loss，也就是会特别关注某一些loss的意思。 最后，Lin等人实现了一个使用Focal Loss的简单的检测系统，最终在速度上几乎赶上了YOLO，并且在准确性了超过了现有的所有检测算法。源码可以在facebook的Detectron上取得：<br><a href="https://github.com/facebookresearch/Detectron" target="_blank" rel="noopener">https://github.com/facebookresearch/Detectron</a> .</p><p>作者介绍了一下two-stage方法的简单流程以及相关的论文，然后又介绍了以下YOLO和SSD等one-stage方法的概况，然后，<strong>作者指出这one-stage方法精确度低的主要原因是源于训练集数据分布的不平衡导致的。</strong> 由此，作者就引出了自己的Focal Loss损失函数，指出Focal Loss函数在面对具有较高confidence的样例时，其影响因子会接近于0,直观上来说，就说Focal Loss更关注那些hard examples。另外，作者还提出，Focal Loss的形式不是唯一的，很多其他的实现方法也能达到相似的结果。（其实我觉得这说明损失函数这一块还有很多工作可以往下研究）</p><p>为了证明Focal Loss的有效性，作者实现了一个one-stage检测模型，命名为RetinaNet（Retina是视网膜的意思），基于ResNet-101-FPN实现，还用到了feature pramid和anchor boxes等思想。</p><h2 id="传统检测系统"><a href="#传统检测系统" class="headerlink" title="传统检测系统"></a>传统检测系统</h2><p>主要是基于sliding-window paradigm的一类方法：HOG， DPMs等等。虽然滑动窗口类的方法在目标检测领域处于一线地位，但是随着deep learning的出现和研究，滑动窗口方法渐渐失去光芒。</p><h2 id="Two-stage-Detectors"><a href="#Two-stage-Detectors" class="headerlink" title="Two-stage Detectors"></a>Two-stage Detectors</h2><p>two-stage方法的先驱是Selective Search work，它会首先提取出一个稀疏的候选框集合（稀疏是指只有很少一部分包含物体），然后对这些候选框进行分类，看是否包含物体，或包含哪种物体。</p><p>之后，RCNN的诞生标志着深度学习技术成功引入目标检测领域，利用cnn网络对特征的高度抽象和提取，rcnn在物体检测的准确率上大幅度提高，后期的RCNN系列又不断的提出新的方法来提升准确率和速度，到Faster RCNN时，提出了RPN网络，将候选框选取阶段和分类阶段都放在了统一个网络，使之可以进行端到端训练。后续还有更多的关于这一系列的工作继续被人们研究着。</p><h2 id="One-stage-Detectors"><a href="#One-stage-Detectors" class="headerlink" title="One-stage Detectors"></a>One-stage Detectors</h2><p>OverFeat算是首个现代的基于深度学习的one-stage检测方法，而最近的SSD和YOLO更是激起了人名对one-stage方法的研究热情，但是one-stage方法最令人诟病的地方就在于它们较低的准确率。</p><p>为此，本文的工作就是想要知道是否one-stage检测算法可以在精确度上匹敌two-stage检测算法，同时还要保持一定的检测速度。</p><p>于是，作者提出了Focal Loss，一种新的损失函数，利用这个损失函数，可以在保持现在模型大框架不变的基础上，达到最好的检测水平！</p><h2 id="样本类别不均衡-Class-Imbalance"><a href="#样本类别不均衡-Class-Imbalance" class="headerlink" title="样本类别不均衡 Class Imbalance"></a>样本类别不均衡 Class Imbalance</h2><p>不管是传统的one-stage检测方法如boosted detectors， DMPs，还是最近的方法SSD，都会在训练阶段面临 $10^4\sim 10^5$ 个候选区域，这其中会包含大量的背景区域，也就是负样本，这种不平衡会造成两个问题：</p><ul><li>在训练时，在大多数位置都是负样本，这样只会贡献更多无用的信号</li><li>大量的负样本会导致模型在一定程度上的退化</li></ul><p>对于此问题，常用的解决方案是在训练阶段设计更复杂的样本抽取策略，但是这样速度就会受影响。而本文提出的Focal Loss，不仅解决了样本不均的问题，而且不需要增加额外的抽取策略，可以更快训练</p><h2 id="Robust-Estimation"><a href="#Robust-Estimation" class="headerlink" title="Robust Estimation"></a>Robust Estimation</h2><p>有很多工作乐于设计健壮的损失函数，具体可以看看原文的参考文献，这里就不说了（主要因为没有什么好讨论的地方，作者也只是提了一下）</p><h2 id="Focal-Loss"><a href="#Focal-Loss" class="headerlink" title="Focal Loss"></a>Focal Loss</h2><p>为了便于理解，从交叉熵（CE）的二分类问题出发：</p><script type="math/tex; mode=display">CE(p,y) = \begin{cases} -log(p)& \text {if y=1} \\ -log(1-p) & \text{otherwise}\end{cases}</script><p>当二分类问题中的样本分布不均时，数量多的样本的损失值对最终函数的影响会淹没数量少的样本产生的影响。多分类问题也是如此。</p><p>为了便于表示，对上面的公式进行改写： $CE(p,y) = CE(p_t) = -log(p_t)$，于是有：</p><script type="math/tex; mode=display">p_t = \begin{cases} p & \text{if y = 1} \\ 1-p & \text{otherwise} \end{cases}</script><h2 id="Balanced-Cross-Entropy"><a href="#Balanced-Cross-Entropy" class="headerlink" title="Balanced Cross Entropy"></a>Balanced Cross Entropy</h2><p>一个常用的解决办法就是引入一个权重因子 $\alpha \in [0,1]$，然后分别令 $\alpha$ 和 $1 - \alpha$作为两个类别的权重，$\alpha$ 的取值可以是根据类别出现的频率决定，也可以作为超参数，利用交叉验证来选取较好的值。我们使用这种方法作为baseline来与Focal loss进行比较：</p><script type="math/tex; mode=display">CE(p_t) = -\alpha log(p_t)</script><h2 id="Focal-Loss-Definition"><a href="#Focal-Loss-Definition" class="headerlink" title="Focal Loss Definition"></a>Focal Loss Definition</h2><p>本文的实验结果表明，类别分布不均会对交叉熵损失函数带来很大的影响。那些很容易被分类的负样本（背景等）贡献了损失函数及其梯度中的大部分影响力。尽管baseline方法的 $\alpha$ 因子可以平衡正负样本之间的比例，但它仍然不能把握好简单样本和困难样本的比例（应该困难样本多一些，简单样本少一些，这样有利于模型的健壮性）。于是，作者就提出了Focal Loss，主要引入了一个“调制因子” $(1-p_t)^\gamma$ ，其中 $\gamma \ge 0$ ，具体的形式化表示如下：</p><script type="math/tex; mode=display">FL(p_t) = -(1-p_t)^\gamma log(p_t)</script><p>直观上来讲，这个“调制因子”可以降低easy example对loss的contribution。同时，还应注意到，Focal Loss的形式不是唯一固定的，作者还在使用了其他不同形式的因子，比如结合了 $\alpha$ 因子：</p><script type="math/tex; mode=display">FL(p_t) = -\alpha_t(1-p_t)^\gamma log(p_t)</script><p>后文的大部分实验都使用的是上面这个形式的Focal Loss。</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fw1pzf56s3j20jf0i177e.jpg" alt=""></p><h2 id="Class-Imbalance-and-Model-Initialization"><a href="#Class-Imbalance-and-Model-Initialization" class="headerlink" title="Class Imbalance and Model Initialization"></a>Class Imbalance and Model Initialization</h2><p>二值分类模型在初始的时候，对两个类别的预测概率是均等的，在这种初始化条件下，如果某一个类别出现的次数过多，就会对损失函数产生较大的影响。为了解决这个问题，作者特意提出了“先入为主”的概念，也就是使得模型在开始的时候，对稀有类别（如前景类别）的预测概率的初始值设置的低一些，如0.01 。 经过实验表明，这样的方法可以提升模型训练的稳定性。</p><h2 id="Class-Imbalance-and-Two-stage-Detectors"><a href="#Class-Imbalance-and-Two-stage-Detectors" class="headerlink" title="Class Imbalance and Two-stage Detectors"></a>Class Imbalance and Two-stage Detectors</h2><p>Two-stage Detector 并没有使用类似 $\alpha$ 因此的方法来解决样本不均的问题。相反的，它们通过两个机制来降低这个问题带来的影响：（1）two-stage模式和（2）biased minibatch取样。首先，two-stage模式会在第一阶段就将近乎无限物体位置可能性降低到一到两千个，更重要的是，这一到两千个可能位置并不是随机选取的，它们移除了大量的易分类负样本（背景框）。第二，这些方法还设计了biased minibatch的取样策略，比如，保证正样本和负样本的比例为1：3进行训练（这其实相当于起到了 $\alpha$ 因子的作用。</p><h2 id="RetinaNet-Detector"><a href="#RetinaNet-Detector" class="headerlink" title="RetinaNet Detector"></a>RetinaNet Detector</h2><p>RetinaNet是一个单一的、统一的网络，它由一个backbone网络和两个task-specific子网络组成。backbone网络是现成的，主要负责计算卷积特征图谱。第一个子网络负责物体分类任务，第二个子网络负责bounding box回归任务，它们都是在backbone网络输出的卷积图谱上进行计算的。</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw1pzf7w44j213m0cr0wb.jpg" alt=""></p><p><strong>Feature Pyramid Network Backbone：</strong></p><p>采用了FPN作为backbone网络。</p><p><strong>Anchors:</strong></p><p>和FPN一样，对P3到P7使用了不同大小的anchors</p><p><strong>Classification Subnet：</strong></p><p>该子网络是一个较小的FCN，连接在FPN的每一层。</p><p>值得注意的一点是，该子网络并不与Box Regression Subnet共享参数，二者是互相独立的。</p><p><strong>Box Regresion Subnet：</strong></p><p>与分类子网络并行，该子网络也是一个FCN网络，连接在FPN的每一层上。目标是让anchor通过位移回归到gt box附近。</p><h2 id="Inference-and-Training"><a href="#Inference-and-Training" class="headerlink" title="Inference and Training"></a>Inference and Training</h2><p><strong>Inference：</strong> RetinaNet是有基于FPN和backbone和两个基于FCN的子网络组成的一个统一的单一网络，因此，在inference阶段，只需要简单的通过前向传播经过整个网络即可。为了提高速度，本文在每个FPN层级上，只会处理最多1000个box prediction。</p><p><strong>Focal Loss：</strong> 使用了上文提到的Focal Loss。取 $\gamma=2$ 。在训练阶段，本文强调将focal loss应用到所有100k个anchors上，主要目的是为了与RPN和SSD等模型作对比。</p><p>从实验结果上看，当 $\gamma$ 的值取得较大时，$\alpha$ 的值就应该取消一些（for$\gamma=2$ , $\alpha = 0.25$ works best)。</p><p><strong>Initialization：</strong> 本文分别实现了ResNet-50-FPN和ResNet-101-FPN。 对其中初始值可参见原文。</p><p><strong>Optimization：</strong></p><p>使用了SGD优化方法，在8个GPU上训练，每个minibatch有16张图片（一个GPU包含2张图片）。</p><p>损失函数为focal loss和标准smooth L1损失函数之和。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>YOLOv3</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-YOLOv3-Arxiv2018/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-YOLOv3-Arxiv2018/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>作者对YOLOv2进行了一些改进，使之在保持实时检测的同时，准确率又有所提升了。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>作者说他这一年（18年）基本没干啥，就是打打电话，玩玩推特，偶尔还帮别人干点活。。</p><p>然后因为只对YOLO做了一些改进，但是并没什么特别的地方，因此就写了这一篇技术报告,而没有选择发表成论文形式。</p><h1 id="The-Deal"><a href="#The-Deal" class="headerlink" title="The Deal"></a>The Deal</h1><p>作者说了，他们大部分的工作都是从别人那里吸取好的点子，同时训练了一个新的分类器网络（比别人的好，恩。。）</p><h2 id="Bounding-Box-Prediction"><a href="#Bounding-Box-Prediction" class="headerlink" title="Bounding Box Prediction"></a>Bounding Box Prediction</h2><p>和YOLO9000一样，在预测bounding box时使用了dimension clusters和anchor boxes。</p><p>YOLOv3在预测每个bouding box的objectness score时，使用的是logistic regression。</p><p>与faster rcnn不同的是，我们的系统只会给每个gt object指派一个bounding box。如果没有指派的话，就说明没有对象的box坐标，只有objectness。</p><h2 id="Class-Prediction"><a href="#Class-Prediction" class="headerlink" title="Class Prediction"></a>Class Prediction</h2><p>每个box使用了多标签分类，我们不选择softmax是因为发现它很难取得好的效果，因此，改用一个单独的logistic classifiers。在训练阶段，使用binary cross-entropy loss来进行类别预测。</p><h2 id="Predictions-Across-Scales"><a href="#Predictions-Across-Scales" class="headerlink" title="Predictions Across Scales"></a>Predictions Across Scales</h2><p>YOLOv3在三种不同的scales下进行预测。</p><h2 id="Feature-Extractor"><a href="#Feature-Extractor" class="headerlink" title="Feature Extractor"></a>Feature Extractor</h2><p>作者使用了一个新的网络模型来提取特征，主要是在Darknet-19中引入了residual network stuff，最终模型的卷积层数达到53层，也就是Darknet-53。</p><h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>仍然使用不带hard negative mining的图片训练。同时使用了multi-scale training，data augmentation，batch normalization，以及其他的一些标准程序。</p><h1 id="How-We-Do"><a href="#How-We-Do" class="headerlink" title="How We Do"></a>How We Do</h1><p>根据不同的评价标准，YOLO的性能差异较大，总的来说主要是因为YOLO虽然能标出物体的大致位置，但是画出的框并不是“完美”，使得在IOU要求高的评价标准上，YOLO的得分很低。</p><p>另外， 之前的YOLO在检测小物体上往往有很多瓶颈，而目前的YOLO已经在慢慢克服这方面的缺陷</p><h1 id="Things-We-Tried-That-Didn’t-Work"><a href="#Things-We-Tried-That-Didn’t-Work" class="headerlink" title="Things We Tried That Didn’t Work"></a>Things We Tried That Didn’t Work</h1><p><strong>Anchor box $x,y$ offset predictions</strong></p><p><strong>Linear $x,y$ predictions instread of logistic</strong></p><p><strong>Focal loss</strong></p><p><strong>Dual IOU thresholds and truth assignment</strong></p><h1 id="What-This-All-means"><a href="#What-This-All-means" class="headerlink" title="What This All means"></a>What This All means</h1><p>最后，作者说了为什么要选择其他的评价标准。</p><p>对于人类来说，很难直接区分出IOU0.3和IOU0.5之间的差别，那么我们要求计算机这样做是否合理呢（我认为是合理的。。。）</p><p>最后作者说出了对计算机视觉未来发展的一些“愿景”。（作者反对隐私泄漏和军事用途）</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>YOLO9000</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-YOLOv2-CVPR2017/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-YOLOv2-CVPR2017/</url>
      
        <content type="html"><![CDATA[<h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><a href="https://zhuanlan.zhihu.com/p/35325884" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35325884</a></p><h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p><a href="https://zhuanlan.zhihu.com/p/40659490" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40659490</a></p><p><img src="https://wx1.sinaimg.cn/mw1024/d7b90c85ly1fw97m47l6uj21e70hogsn.jpg" alt=""></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文提出了一个新的，实时目标检测模型，YOLO9000。首先，作者使用了不同的提升技巧来优化YOLO模型，同时，利用多尺度的训练方法，YOLO可以方便的在speed和accuracy之间进行tradeoff。在67FPS时，YOLOv2可以在VOC2007上活得76.8的mAP，在40FPS时，YOLOv2可以或者78.6mAP，超过了Faster RCNN和SSD的性能表现。尽管只有200个类里面的44个类的数据，YOLO9000仍然可以在ImageNet上获得19.7的mAP，对于不在COCO里面的156个类，YOLO可以获得16.0的mAP。9000的含义是说YOLO-v2可以运行在超过9000个不同的物体类别，同时保持实时检测。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>目前关于分类任务的数据集数量远远超过检测任务的数据集大小，而短期内，检测任务的数据集数量无法快速增长。对此，本文提出了一个新的方法来利用现有的分类任务的数据集，进而扩充当前目标检测系统的检测范围。</p><p>同时，本文还提出了一个联合训练方法，使得我们可以同时在检测数据集和分类数据集上训练检测器。（检测数据集提升定位能力，分类数据集提升类别容量和系统健壮性）</p><p>本文分两步：首先将YOLO升级到YOLOv2,然后利用本文提出的数据集联合方法来进行联合训练。</p><h1 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h1><p>YOLO的主要缺点在于定位错误和较低的召回率。 本文在优化这些缺点时，并不是选择扩大网络的规模，而是将整个网络简化，使表征信息更容易学习。根据之前的工作，我们采用了很多方法来提升YOLO的性能。</p><h2 id="Batch-Normalization："><a href="#Batch-Normalization：" class="headerlink" title="Batch Normalization："></a>Batch Normalization：</h2><p>在所有的卷积层之上加上BN，可以提升2%的mAP，并且可以去掉dropout层而不产生过拟合。</p><h2 id="高分辨率分类器-High-Resolution-Classifier："><a href="#高分辨率分类器-High-Resolution-Classifier：" class="headerlink" title="高分辨率分类器 High Resolution Classifier："></a>高分辨率分类器 High Resolution Classifier：</h2><p>之前的YOLO是利用ImageNet的224大小的图像预训练的，然后在检测时，会将224的图像放大到448尺寸。在YOLOv2,首先在448的ImageNet图像上进行finetune 10 epochs。这给了一定时间让网络适应更大的尺寸大小，然后再在该网络进行物体检测的finetune。 这可以提升4%mAP。</p><h2 id="Convolutional-With-Anchor-Boxes："><a href="#Convolutional-With-Anchor-Boxes：" class="headerlink" title="Convolutional With Anchor Boxes："></a>Convolutional With Anchor Boxes：</h2><p>YOLO使用叠在卷积层之上的全连接层的特征提取器来直接预测bounding box的坐标。 相比于YOLO，Faster RCNN使用了精心挑选的方式来获得预测的boundign box，它在anchor box的基础上进行预测，并且其预测层是卷积层。为此，本文移除了YOLO的全连接层，改用anchor box来预测bouding box。</p><p>首先，移除了一个pool层，从而使网络卷积层的输出有更高的分辨率。另外，还将网络的输入图像的分辨率降到416,这么做的原因是作者希望在特征图谱上得到奇数个locations，这样一来，就由一个center cell。YOLO的结构可以使416的图像降到13×13的大小。</p><p>在使用anchor box时，我们将类别预测问题从位置标定问题中分离出来，然后为每个anchor box预测类别和是否有物体。和YOLO一样，预测是否有物体时会预测gt和proposed box的IOU，类别预测时会计算给定有物体的条件下给出属于每个class的条件概率。</p><p>原来的YOLO会对每张图片产生98个box，而使用anchor box后，每张图片会产生上千个box。 不用anchor box时，本文的模型可以达到69.5的mAP和81%的recall。而是用了anchor box后，可以到大69.2的mAP和88%的recall。虽然mAP变低了，但是recall的提升说明本模型还有很大的提升空间。</p><h2 id="Dimension-Cluster："><a href="#Dimension-Cluster：" class="headerlink" title="Dimension Cluster："></a>Dimension Cluster：</h2><p>在使用anchor box时，主要遇到了两个问题。</p><p>第一：anchor box的维度是手动标定的。 anchor值的选择会对最终结果有一定影响。为了解决这个问题，我们不采用手动标定的方法，而是对训练集的boudning boxes用k-means clustering来自动找到较好的anchor值。如果使用基于欧式距离的标准k-means，那么更大的box就会产生更多的error。为了不让box的大小对最终的anchor值有影响，我们使用下面的式子作为距离度量：</p><script type="math/tex; mode=display">d(\text{box},\text{centroid}) = 1 - IOU(\text{box}, \text{centroid})</script><p>最终在模型复杂度和高召回率的权衡下，本文选择 $k=5$ 。</p><h2 id="直接位置预测-Direct-location-prediction"><a href="#直接位置预测-Direct-location-prediction" class="headerlink" title="直接位置预测 Direct location prediction"></a>直接位置预测 Direct location prediction</h2><p>使用anchor box的第二问题就是：模型不稳定，尤其是在早起迭代阶段。稳定性差的主要来源是box的坐标 $(x,y)$ ，在RPN网络中，网络会预测 $t_x$ 和 $t_y$ ，于是 $(x,y)$ 的值可以通过下面的公式计算得到：</p><script type="math/tex; mode=display">x = (t_x*w_a) - x_a</script><script type="math/tex; mode=display">y = (t_y*h_a) - y_a</script><p>本文不使用上面的方法，而是使用YOLO中的方法，预测相对于grid cell位置的相对坐标，这将gt限制在了0到1之间。这样的参数设置使得参数更容易学习，网络更加稳定。</p><h2 id="Fine-Grained-Features"><a href="#Fine-Grained-Features" class="headerlink" title="Fine-Grained Features"></a>Fine-Grained Features</h2><p>精细化的13×13的特征图谱对于标定大物体来说已经足够了，同时，由于特征更加细粒度，使得它在标定更小的物体时有一定提升。 Faster RCNN和SSD都在不同的特征图谱上执行，因此，它们得到的是一个区间的图像分辨率大小。  本文采用一个更简单的测率，直接添加一个passthrough层，使得从更早的26×26的层中得到特征。</p><p><strong>这个passthrough层将高分辨率的特征和低分辨率的特征连接起来，通过将相邻特征堆叠到不同的channes？</strong> 这将26×26×512的特征图谱变成了一个13×13×2048的特征图谱。</p><h2 id="Multi-Scale-Training"><a href="#Multi-Scale-Training" class="headerlink" title="Multi-Scale Training"></a>Multi-Scale Training</h2><p>为了使模型更加健壮，使用了不同尺度的图片来训练模型。在训练时，每经过一段迭代次数后，都会改变接受输入图片的size。由于本文的模型输出的尺寸会变成原来1/32,因此选择以下尺寸：{320,352,…,608}。</p><p>这样一来，一个网络可以在不同的分辨率下进行目标检测，可以取得更好的效果。</p><h1 id="Faster"><a href="#Faster" class="headerlink" title="Faster"></a>Faster</h1><p>大多数目标检测网络使用了VGG16作为基础网络，但是VGG16需要30.69billion浮点运算，十分复杂。</p><p>而本文使用基于GoogleNet的自定义网络，只需要8.52billion浮点运算。（但是精确性低于VGGnet）</p><h2 id="Darknet"><a href="#Darknet" class="headerlink" title="Darknet"></a>Darknet</h2><p>最终网络起名为Darknet-19。 具有19个卷积层和5个最大池化层。</p><h2 id="Training-for-classification"><a href="#Training-for-classification" class="headerlink" title="Training for classification"></a>Training for classification</h2><p>将网络在标准Imagenet 1000上进行训练。</p><p>SDG的初始学习率为0.1, 递减指数为0.4,权重递减为0.0005,momentum为0.9。</p><p>在训练时，使用了标准的数据增广方法：random crops，ratations，hue，saturation，exposure shifts等。</p><h2 id="Training-for-detection"><a href="#Training-for-detection" class="headerlink" title="Training for detection"></a>Training for detection</h2><p>将上面训练好的网络的最后一层卷积层移除，然后加上三个具有1024个filter的3×3卷积层，并在其中跟一个1×1的卷积层，使输出是我们需要的结果。 比如，对于VOC，需要有5个box，每个box有5个coordinates和20个class，所以需要125个filetes。 同时使用了passthrough层，以便模型可以使用fine grain features。</p><h1 id="Stronger"><a href="#Stronger" class="headerlink" title="Stronger"></a>Stronger</h1><p>本文提出了一种可以联合训练分类数据和检测数据的机制。本文的方法使用检测数据的图像标签来学习物体位置信息，使用分类数据的标签来扩充可以检测的物体的类别。</p><p>在训练阶段，我们了检测数据和分类数据混合。当网络模型看到一个带有检测标签的图片时，就会对YOLOv2的整个损失函数进行BP求导，当看到分类图片时，则只会对分类部分的损失函数进行BP求导。</p><p>上面的方法具有一些难点：</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>YOLO v1</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-YOLOv1-CVPR2016/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-YOLOv1-CVPR2016/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> You Only Look Once: Unified, Real-Time Object Detection</p><p><strong>作者:</strong> oseph Redmon, Santosh Divvala, Ross Girshick, Ali Farhadi</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><strong>(1) 将检测问题看做是回归问题</strong><br>对于给定的输入图像, YOLO会使用一个单一的网络 <strong>同时</strong> 给出bounding box的预测结果和对应的类别概率.</p><p><strong>(2) 没有Region Proposal的过程</strong><br>YOLO采用 $S\times S$ 的网格划分来确定候选框, 如果某个物体的中心落在了某个cell里, 那么这个cell就负责该物体的检测.</p><p><strong>PS:</strong><br>注一: YOLO中采用 $S\times S$ 的网格划分来确定候选框, 这实际上是一种很粗糙的选框方式, 同时也导致了YOLO在面对小目标物以及群落目标物时, 性能较差.(因为YOLOv1的同一个cell无法预测多个目标)</p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>YOLO将目标检测问题看作是一个回归问题，进而从整张图像中直接得到bounding boxes和对应的class probabilities。</p><p>之前的工作都是将检测任务看成是一个分类问题，如RCNN，通过区域提取，分类，区域修正，去重等等一系列工作得到检测结果，这样的模型十分复杂而且很难优化，因为区域提取和分类任务必须单独训练，麻烦且难以调试。</p><p>本文将目标检测问题看成是一个回归问题，直接从图片像素中得到bounding box坐标和class probabilities。</p><p>YOLO具有三大优点：</p><ol><li>Fast。 由于不用按照复杂的pipeline进行运作，YOLO只需要一个卷积网络就可以同时预测出多个物体，因此十分快</li><li>YOLO在进行推理时，可以看到整幅图片，因此，可以隐式地对物体的周围像素进行分析。这使得YOLO不容易在背景中错误识别。反观Fast RCNN，经常会将背景中的非物体检测出来。</li><li>YOLO的泛化性更好，可以学到更一般的特征。在自然图像上训练后，YOLO在艺术图像上可以取得相比于RCNN更好的检测效果。</li></ol><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p>YOLO没有提取候选区域的过程, 与之相对的, YOLO采用网格划分的方式来确定物体的候选区域框, 具体来说, YOLO会将图像按照 $S\times S$ 的大小划分成多个cell, 之后, 如果哪个物体的中心落在了某个cell里面, 那么这个cell就负责检测这个物体, 如下图中, 狗的中心落在了红色cell内, 则这个cell负责预测狗.</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fw93fvg9xdj20gp0etqe3.jpg" alt=""></p><p>“物体落在哪个cell, 哪个cell就负责预测这个物体” 分为训练和测试两个阶段:</p><ul><li>训练阶段. 在训练阶段, 如果物体中心落在这个cell, 那么就给这个cell打上这个物体的label, 让这个cell和该物体关联起来</li><li>测试阶段. cell会根据已经训练好的参数来决定自己负责预测哪个物体.</li></ul><p>网络的整体架构如下图所示:</p><p><img src="https://wx2.sinaimg.cn/mw1024/d7b90c85ly1fw93mm33q1j21kw0o80x2.jpg" alt=""></p><p>从图中可以看出, YOLO网络的输出网格是 7×7 大小的, 另外, 输出的channel数目30, 在每一个cell内, 前20个元素是每个类别的概率值, 然后2个元素对应2个边界框的置信度, 最后8个元素时2个边界框的 $(x,y,w,h)$.(每个cell会预测两个框, 最后选择IOU较大的来复杂物体的预测)</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw93lr5viuj20se0hunar.jpg" alt=""></p><p>根据网络的输出, 我们可以知道, YOLO的预测目标主要有三个: 类别预测, Confidence预测, Bounding box预测. 在训练阶段，该模型要优化下面的联合目标损失函数(第一行是bounding box预测, 接下来是confidence预测, 最后是类别预测)</p><script type="math/tex; mode=display">\lambda_{coord} \sum_{i=0}^{S^2} \sum_{j=0}^B I_{ij}^{obj}[(x_i-\hat x_x)^2 + (y_i - \hat y_i)^2] \+ \lambda_{coord}\sum_{i=0}^{S^2} \sum_{j=0}^B I_{ij}^{obj} [(\sqrt w_i - \sqrt{\hat w_i})^2 +(\sqrt h_i - \sqrt{\hat h_i})^2]</script><script type="math/tex; mode=display">+ \sum_{i=0}^{S^2}\sum_{j=0}^B I_{ij}^{obj} (C_i - \hat C_i)^2  + \lambda_{noobj}\sum_{i=0}^{S^2}\sum_{j=0}^{B} I_{ij}^{noobj}(C_i-\hat C_i)^2</script><script type="math/tex; mode=display">+ \sum_{i=0}^{S^2} I_i^{obj} \sum_{c\in \text{classes}} (p_i(c) - \hat p_i(c))^2</script><p>需要注意的是, 网络并不会总是计算所有的loss项, 具体地说:</p><ol><li>对于有物体中心落入的cell, 需要计算分类loss, 两个confidenceloss, 但只计算IOU较大的bounding box loss</li><li>对于没有物体中心落入的cell, 只需要计算confidence loss.</li></ol><p>另外, 我们发现每一项的计算(即使是分类)都是 L2 loss, 从另一角度体现出YOLO把分类问题转化为了回归问题.</p><h2 id="2-一体化检测"><a href="#2-一体化检测" class="headerlink" title="2. 一体化检测"></a>2. 一体化检测</h2><p>YOLO使用整幅图像的特征图谱进行预测，同时预测所有物体的所有bounding box。这样的设计思想，可以使得YOLO进行端到端的训练，并且能够进行实时检测。</p><p>系统将整张图片划分成 $S \times S$ 大小的网格。 如果某个物体落入了网格中的某一格，那么这个格子就负责检测该物体。</p><p>每个格子会预测B个bounding boxes和B个confidence scores。这些confidence scores反映了模型对这个box里面是否有物体，并且有多大的把握确定。 将confidence定义为 $Pr(Object)\times IOU_{pred}^{truth}$ 。 $IOU_{pred}^{truth}$ 代表真实框和预测框之间的IOU值。</p><p>每一个bounding box包含5个预测值：x，y，w，h，和confidence。</p><p>每一个grid cell预测C个conditional class probabilities，记为 $Pr(Class_i|Object)$ 。 C与B的个数之间没有直接关系。</p><p>在测试阶段，我们将conditional class probabilities和individual box confidence predictions相乘：</p><script type="math/tex; mode=display">Pr(Class_i|Object)\times Pr(Object)\times IOU_{pred}^{truth} = Pr(Class_i)\times IOU_{pred}^{truth}</script><p>由此可以得到针对每个box的特定class的confidence scores。这些scores代表着特定calss出现在box里面的概率，以及预测出来的box在多大程度上适应这个object。</p><p>最终预测的tensor维度： $S\times S\times (B\times 5+ C)$ 。</p><h2 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h2><p>YOLO：收到GoogleNet的启发，公有24层卷积层和2层全连接层</p><p>但是没有使用Inception模块，而是使用了 $3\times 3$ 的卷积层和一个 $1 \times 1$ 的reduction layers（减少depth）</p><p>fast YOLO：9个卷积层和2个全连接层。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>首先在ImageNet上进行了预训练。 预训练时，使用前20个卷积层，加上一个平均池化层，和一个全连接层。 使用了Darknet framework。</p><p> Ren et al证明在预训练的网络上添加卷积层和全连接层可以提升性能。因此，本文添加了4个卷积层和2个全连接层，都赋予随机初始值。 模型的输入图像像素为448 。</p><p> 最后一层同时预测class probabities和bounding box coordinates。 我们将box的宽和高都归一化到占图片宽高值的比例，因此coordinates的值在0到1之间。coordiantes的x和y归一化到对特定cell的相对位移，所以它们的值也在0到1之间。</p><p> 本文最后一层使用线性激活函数，其他层均使用leaky rectified linear 激活函数，如下所示：</p><script type="math/tex; mode=display">\phi(x) = \begin{cases} x & \text{if } x>0 \\ 0.1x& \text{otherwise} \end{cases}</script><p>本文的优化函数为平方和误差。 由于它对localization error的权重和对classification的权重是一样的，因此该函数并不能够很好的匹配我们的目标。为了解决问题，提升了bounding box coordinate predictions的loss，同时降低了confidence predictions的loss。 作者使用了 $\lambda_{coord} = 5$和 $\lambda_{noobj} =5$ 来实现这一目标。 同时为了更好的针对小目标，本文对bounding box的宽和高都使用了平方跟。</p><p>YOLO对每个grid cell都会预测出多个bounding boxes，而在训练阶段，我们只需要一个bouding box 来对每个物体负责。选取的原则是与GT有最高的IOU值。</p><p>在训练阶段，本文优化下面的联合目标损失函数：</p><script type="math/tex; mode=display">\lambda_{coord} \sum_{i=0}^{S^2} \sum_{j=0}^B I_{ij}^{obj}[(x_i-\hat x_x)^2 + (y_i - \hat y_i)^2] \+ \lambda_{coord}\sum_{i=0}^{S^2} \sum_{j=0}^B I_{ij}^{obj} [(\sqrt w_i - \sqrt{\hat w_i})^2 +(\sqrt h_i - \sqrt{\hat h_i})^2]</script><script type="math/tex; mode=display">+ \sum_{i=0}^{S^2}\sum_{j=0}^B I_{ij}^{obj} (C_i - \hat C_i)^2  + \lambda_{noobj}\sum_{i=0}^{S^2}\sum_{j=0}^{B} I_{ij}^{noobj}(C_i-\hat C_i)^2</script><script type="math/tex; mode=display">+ \sum_{i=0}^{S^2} I_i^{obj} \sum_{c\in \text{classes}} (p_i(c) - \hat p_i(c))^2</script><p>batch size为64，a momentum of 0.9 and a decay of 0.0005。</p><h2 id="推理阶段"><a href="#推理阶段" class="headerlink" title="推理阶段"></a>推理阶段</h2><p>平均每张图片会得到98个bounding boxes。</p><p>虽然采用了非极大值抑制，但是提升的效果并不高，不如RCNN和DPM那么明显。</p><h2 id="YOLO的局限性"><a href="#YOLO的局限性" class="headerlink" title="YOLO的局限性"></a>YOLO的局限性</h2><p>难以检测小物体和堆积在一起的物体，比如鸟群。</p><p>另外，YOLO对于不同大小的物体，其采取的损失函数是一样的，因此，在面对大物体时，细微的差别可能不会引起IOU的大幅变化，但是在面对小物体时，就会产生较大波动。YOLO的错误来源主要是由于定位错误。</p><h2 id="和其他检测系统的比较"><a href="#和其他检测系统的比较" class="headerlink" title="和其他检测系统的比较"></a>和其他检测系统的比较</h2><p><strong>Deformable parts models</strong>：</p><p>DPM使用了滑动窗口的方法来做目标检测。它的检测是由分离的好几段过程完成的。 相比来说，作者的模型统一了所有这些过程，并且取得了更快更好的效果（基本来说就是把DPM吊打了。。。，不过毕竟DPM是2010年的产品，不吊打说不过去了。。）</p><p><strong>RCNN</strong>：</p><p>RCNN没有使用滑动窗口的方法来获取bounding box，而是使用了Selective Search（之后也不用SS方法了，提出了RPN，继承到模型内部了）。同理，RCNN也是一种多阶段的方法，先画框，再检测，分两步走。YOLO在一定程度了也借鉴了RCNN及其变体的思想，但是YOLO是基于grid cell进行proposes bounding box的，所以最后只生成了98个框，而RCNN的框多大2000个，所以YOLO在速度上肯定是远超RCNN了，另外精度上也比RCNN高（不过RCNN只是region based检测方法的雏形，所以并不说明YOLO比RCNN整个系列都好）。</p><p><strong>Other Fast Detectors</strong>： RCNN其他系列来了，作为后出生的Fast RCNN和Faster RCNN，当然视为自家的兄弟出了口气，在精度上爆了YOLO，但是速度还是不及YOLO（YOLO是真的快，真正意义上的实时监测系统）</p><p><strong>Deep MultiBox</strong></p><p>14年出来的，SPPNet使用了它进行选框</p><p><strong>OverFeat</strong></p><p>13年的一篇文章</p><p><strong>MultiGrasp</strong></p><p>这是Joseph自己的工作，在YOLO之间发的，解决的任务是检测一张的图片中某个包含物体的区域，比YOLO要解决的任务简单的多，没什么好说的</p><h2 id="实验-Experiments"><a href="#实验-Experiments" class="headerlink" title="实验 Experiments"></a>实验 Experiments</h2><p>首先是在VOC2007上做了实验，然后专门针对YOLO和Fast RCNN进行比较，虽然整体mAP没有Fast高，但是在背景上的假正例比Fast少。接着，还给出2012VOC的实验结果。最后，还做了一个从自然图像训练，然后检测艺术作品的实验，提出YOLO可以学到更一般化的特征。</p><h2 id="4-1-Comparison-to-Other-Real-Time-Systems"><a href="#4-1-Comparison-to-Other-Real-Time-Systems" class="headerlink" title="4.1 Comparison to Other Real-Time Systems"></a>4.1 Comparison to Other Real-Time Systems</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法总结</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%8E%92%E5%BA%8F/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>最坏/好时间复杂度</th><th>空间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(n^2)$ / $O(n)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$ / $O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$O(n^2)$</td><td>$O(n^2)$ / $O(n)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(nlogn)$</td><td>$O(n^2)$ / $O(nlogn)$</td><td>$O(logn)$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$ / $O(nlogn)$</td><td>$O(n)$ 或 $O(1)$</td><td>稳定</td></tr><tr><td>堆排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$ / $O(nlogn)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>希尔排序</td><td>$O(nlogn)$</td><td>与步长 $d$ 有关 / $O(nlogn)$</td><td>$O(1)$</td><td></td></tr><tr><td>基数排序</td><td></td><td></td><td></td></tr></tbody></table></div><h1 id="1-冒泡"><a href="#1-冒泡" class="headerlink" title="1. 冒泡"></a>1. 冒泡</h1><p>从后往前, 相邻的数据两两比较, 一趟完成后, 第一个元素为最大/小值</p><p><strong>时间复杂度:</strong> $O(n^2)$</p><p><strong>空间复杂度:</strong> $O(1)$</p><p><strong>稳定性:</strong> 是稳定的, 主要就是遇到相等的元素时不要进行交换操作即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;input.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> bubble = input.size()<span class="number">-1</span>; bubble&gt;i; bubble--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[bubble<span class="number">-1</span>] &lt; input[bubble] )&#123; <span class="comment">//为了保证排序的稳定性, 这里不要用 &lt;=</span></span><br><span class="line">                <span class="keyword">int</span> temp = input[bubble];</span><br><span class="line">                input[bubble] = input[bubble<span class="number">-1</span>];</span><br><span class="line">                input[bubble<span class="number">-1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-选择-交换-排序"><a href="#2-选择-交换-排序" class="headerlink" title="2. 选择(交换)排序"></a>2. 选择(交换)排序</h1><p><strong>时间复杂度:</strong> $O(n^2)$</p><p><strong>空间复杂度:</strong> $O(1)$</p><p><strong>稳定性:</strong> 因为选择排序在交换两个元素时, 是不考虑其他元素的相对位置的, 所以, 不管怎么样, 只要发生交换, 就一定会造成不稳定. <strong>但是!!!</strong> 如果使用链表或者新开辟一个数组的话, 选择排序也是稳定的, 但实际上这种方法就没有交换的过程, 对于链表来说, 是把节点从链表中拿出来, 组成新的链表, 而不会对原来链表中的元素进行交换. 对于新开辟数组来说, 相当于是用空间换取稳定性, 同样也没有交换过程.</p><h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h1><p>将数据分为两个部分, 有序部分和无序部分, 一开始有序部分包含只包含第一个元素, 依次将无序部分的元素插入到有序部分 ( 插入的时间复杂度为 $O(n)$ ), 直到所有元素插入完毕.</p><p><strong>插入分为数组插入和链表插入(其实堆排序也算是一种插入排序)</strong></p><p>下面的时间和空间复杂度均指 <strong>数组直接插入</strong>, 对于链表, 时间和空间都是 $O(n)$</p><p><strong>时间复杂度:</strong> $O(n^2)$</p><p><strong>空间复杂度:</strong> $O(1)$</p><p><strong>稳定性:</strong> 只要在插入遇到相等元素时, 将新插入的放在最后, 那么就是稳定的.</p><h1 id="4-快排"><a href="#4-快排" class="headerlink" title="4. 快排"></a>4. 快排</h1><p><strong>时间复杂度:</strong> $nlogn$</p><p>快排的期望时间复杂度为 $O(nlogn)$ , 最坏时间复杂度为 $O(n^2)$, 为了避免出现最坏的情况, 可进行如下改进:</p><ol><li>哨兵元素的选择: 为了使每次划分的数不至于使两边相差过大, 我们可以选择三者取中法选择哨兵, 一般根据首尾元素和中间元素进行选择.</li><li>小数据量的改进: 递归的快排大概在n&lt;13的时候比插入要慢, 所以我们在n&lt;13的时候可以采用插入排序</li><li>相同数字的改进, 在存在大量相同数字的时候, 可以用两个指针保存相同数字的信息, 在划分时不用把它们算进去(这啥意思?//TODO)</li><li>递归的优化. 快排有两次递归调用, 我们可以用循环代替后面的一次递归.</li></ol><p><strong>空间复杂度:</strong> $logn$</p><p>对于就地快排来说, 它本身使用的空间是 $O(1)$ 的, 但是快排在 <strong>递归调用过程中, 就需要消耗一定的空间来保存哨兵及两端元素的下标</strong>, 而对于快排的非递归实现中, 需要借助两个栈来模拟系统对于数组<code>low</code>和<code>high</code>的存储情况(递归中的哨兵下标实际上会作为下一次递归的<code>low</code>或者<code>high</code>), :</p><ul><li>最优的情况下空间复杂度为: $O(logn)$, 每一次都平分数组</li><li>最差的情况下空间复杂度为: $O(n)$, 每一次两边都极度失衡 (主要与进行迭代的次数有关, 迭代次数多了, 占用的内存就多了)</li></ul><p><strong>稳定性:</strong></p><p>因为快排在划分两边的元素时, 会直接交换某两个元素的位置, 并且这种交换与其他元素的值没有关系, 因此, 如果刚好有相同元素, 很容易就会破坏稳定性.</p><p><strong>注意: 最好写出对输入的low和high进行越界检查的部分!! 这个有时候需要特别跟面试官提一声</strong></p><p><strong>递归实现:</strong><br>要知道Partition内部使用&lt;=的原因所在, 写成&lt;, 会造成死循环(当遇到相等元素时, 会无限交换)</p><p>另外, 如果令 <code>P=input[low]</code> , 那么一定要 <code>high--</code>在前, 否则会造成元素覆盖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void quickSort(vector&lt;int&gt;&amp; input, int low, int high)&#123;</span><br><span class="line">    if(input.size()==0 || low&lt;0 || low&gt;=input.size() || high&lt;0 || high&gt;=input.size())&#123;</span><br><span class="line">        cout&lt;&lt;&quot;error&quot;;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = Partition(input, low, high);</span><br><span class="line">    if(mid&lt;high)    quickSort(input, mid+1, high);</span><br><span class="line">    if(mid&gt;low)    quickSort(input, low, mid-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition(vector&lt;int&gt;&amp; input, int low, int high)&#123;</span><br><span class="line">    int p = input[low];</span><br><span class="line">    while(low&lt;high)&#123;</span><br><span class="line">      // 一定要high在前, 否则会造成数组元素覆盖, 回忆头条面试惨痛经历!</span><br><span class="line">        while(low&lt;high &amp;&amp; p&lt;=input[high]) high--; //这里注意, 如果忘了写=号, 就会陷入死循环</span><br><span class="line">        input[low] = input[high];</span><br><span class="line">        while(low&lt;high &amp;&amp; p&gt;=input[low]) low++;</span><br><span class="line">        input[high] = input[low];</span><br><span class="line">    &#125;</span><br><span class="line">    input[low] = p;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里Partition用的是&lt;=，那么在high位元素和p相等时，并不会执行交换，而是会high—, 如果忘了写等号, 就会陷入死循环。</p><p><strong>非递归实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> P = input[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; P &lt;= input[high]) high--;</span><br><span class="line">        input[low] = input[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; P &gt;= input[low]) low++;</span><br><span class="line">        input[high] = input[low];</span><br><span class="line">    &#125;</span><br><span class="line">    input[low] = P;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input.size()==<span class="number">0</span> || low&lt;<span class="number">0</span> || low&gt;=input.size() || high&lt;<span class="number">0</span> || high&gt;=input.size())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; qs_stack;</span><br><span class="line">    qs_stack.push(high); <span class="comment">//入栈顺序一定要注意, 要与后面的操作对应好</span></span><br><span class="line">    qs_stack.push(low);</span><br><span class="line">    <span class="keyword">while</span>(!qs_stack.empty())&#123;</span><br><span class="line">        low = qs_stack.top(); qs_stack.pop(); <span class="comment">// low后入栈, 所以就应该先出栈</span></span><br><span class="line">        high = qs_stack.top(); qs_stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(input, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low&lt;mid)&#123;</span><br><span class="line">            qs_stack.push(mid<span class="number">-1</span>);<span class="comment">//入栈顺序一定要注意,</span></span><br><span class="line">            qs_stack.push(low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high)&#123;</span><br><span class="line">            qs_stack.push(high);<span class="comment">//入栈顺序一定要注意,</span></span><br><span class="line">            qs_stack.push(mid+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p>核心思想是将两个有序数列进行合并，使其成为一个新的有序数列（时间复杂度为 $O(n)$ ）:</p><ul><li>将序列没相邻的两个数组进行归并(merge)操作, 形成<code>floor(n/2)</code>个序列, 排序后每个序列包含两个元素</li><li>将上述序列在此归并, 形成<code>floor(n/2)</code>个序列, 每个序列包含四个元素</li><li>重复上述归并操作, 直到所有元素归并完毕</li></ul><p><strong>时间复杂度: $O(nlogn)$</strong> 归并排序即使在最坏情况下, 时间复杂度也是 $O(nlogn)$, 这是它的一大优点.</p><p><strong>空间复杂度: $O(n)$ 或 $O(1)$</strong> 常见的归并排序实现算法都是 $O(n)$ 的空间复杂度, 因为它会额外申请一个与待排序数组相同大小的空间用来进行合并操作. 但是, 合并操作可以被优化成原地合并 (耗时会增加, 但是时间复杂度不变), 此时的空间复杂度就变成了 $O(1)$.</p><p><strong>稳定性:</strong> 在归并排序过程中, 相同元素有可能出现在同一组内或者不同组内, 如果在同一组内, 则默认就是稳定的, 如果在不同组内, 则根据组的前后位置来判断相同元素的顺序. 因此它是稳定的.</p><p><strong>关于归并排序的复杂度:</strong></p><ul><li>归并排序的时间复杂度不论是最优还是平均还是最差, 都是 $O(nlogn)$<br>在合并时，由两种选择，一种是不使用额外空间的插入合并，这样会增加时间开销。另一种是使用额外空间的合并，这样不增加时间开销，但是需要额外空间。（当然，如果使用的是链表，则没有这种情况，可以既不增加时间，也不增加空间开销）</li></ul><p><strong>常规归并排序:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(first&lt;last)&#123;</span><br><span class="line">    mid = (last+first)/<span class="number">2</span>;</span><br><span class="line">    mergesort(a, first, mid);</span><br><span class="line">    mergesort(a, mid+<span class="number">1</span>, last);</span><br><span class="line">    mergeArray(a, first,mid,mid+<span class="number">1</span>,last);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span></span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">  <span class="keyword">int</span> i = first1;</span><br><span class="line">  <span class="keyword">int</span> j = first2;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=last1 &amp;&amp; j&lt;=last2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.at(i) &lt; a.at(j))&#123;</span><br><span class="line">      temp.push_back(a.at(i));</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      temp.push_back(a.at(j));</span><br><span class="line">      j++;</span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=last1)&#123;</span><br><span class="line">    temp.push_back(a.at(i));</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=last2)&#123;</span><br><span class="line">    temp.push_back(a.at(j));</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;temp.size(); i++)</span><br><span class="line">    a.at(first1+i) = temp.at(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原地归并排序, 空间复杂度$O(1)$:</strong></p><p><img src="https://wx2.sinaimg.cn/mw1024/d7b90c85ly1fwgtrqaqkxj20gw0grq7t.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_memory</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::reverse(data.begin()+start1, data.begin()+end1);</span><br><span class="line">    <span class="built_in">std</span>::reverse(data.begin()+start2, data.begin()+end2);</span><br><span class="line">    <span class="built_in">std</span>::reverse(data.begin()+start1, data.begin()+end2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">        merge_sort(data, start, mid);</span><br><span class="line">        merge_sort(data, mid+<span class="number">1</span>, end);</span><br><span class="line">        merge_inplace(data, start, mid, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_inplace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start1;</span><br><span class="line">    <span class="keyword">int</span> j = start2;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j &amp;&amp; j&lt;=end2)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; data[i] &lt;= data[j]) i++;</span><br><span class="line">        <span class="keyword">int</span> index = j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; data[j] &lt;= data[i]) j++;</span><br><span class="line">        swap_memory(data, i, index<span class="number">-1</span>, index, j<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h1><h2 id="堆简介"><a href="#堆简介" class="headerlink" title="堆简介"></a>堆简介</h2><p>堆排序与快速排序，归并排序一样都是时间复杂度为 $O(NlogN)$ 的几种常见排序方法</p><p>堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p><p>如下图,是一个堆和数组的相互关系:</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvnw4zoqx8j20fm05ejrl.jpg" alt=""></p><p>因此,对于给定的某个节点的下标i, 可以很容易计算出这个节点的父节点, 子节点的下标</p><ul><li>Parent(i) = floor((i-1)/2)，i 的父节点下标</li><li>Left(i) = 2i + 1，i 的左子节点下标</li><li>Right(i) = 2(i + 1)，i 的右子节点下标</li></ul><p>堆一般分为两种,大顶堆和小顶堆, 前者每个节点的值都大于它的子节点,后者反之</p><p>大顶堆:</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvnw6humlgj20ad034aa5.jpg" alt=""></p><p>小顶堆:</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvnw6huqmhj20aa034t8s.jpg" alt=""></p><h2 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h2><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p><ul><li>最大堆调整（Max-Heapify）：将堆作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</li><li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>基于上面的三种操作,可以进行堆的插入和删除:</p><ul><li>插入: 将新元素放置在数组末尾,然后进行堆调整</li><li>删除: 移除堆顶,然后将数组末尾元素置于堆顶,然后进行堆调整(删除主要用于排序)</li></ul><p>最大堆调整（MAX‐HEAPIFY）的作用是保持最大堆的性质，是创建最大堆的核心子程序，作用过程如图所示：</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvnw58ecrjj20fo0bft95.jpg" alt=""></p><p>代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> index, <span class="keyword">int</span> heap_size)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> imax = index <span class="comment">//mark max index</span></span><br><span class="line">  <span class="keyword">int</span> ileft = index*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">// left child</span></span><br><span class="line">  <span class="keyword">int</span> iright = index*<span class="number">2</span>+<span class="number">2</span>; <span class="comment">// right child</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ileft &lt; heap_size &amp;&amp; vec[imax] &lt; vec[ileft])&#123;</span><br><span class="line">    imax = ileft;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(iright &lt; heap_size &amp;&amp; vec[imax] &lt; vec[iright])&#123;</span><br><span class="line">    imax = iright;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>( imax != index)&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(vec[imax], vec[index]);</span><br><span class="line">    max_heapify(vec, imax, heap_size); <span class="comment">//由于变换了当前节点,因此子树的堆结构可能被破坏,</span></span><br><span class="line">    <span class="comment">//递归调整, 这里imax的坐标是左右子节点的下标之一(因为进行了交换)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 堆是自下而上进行调整的,所以在调整当前节点符合堆要求之前,子树已经符合堆要求,</span></span><br><span class="line">  <span class="comment">//除非进行了节点交换,否则子树的堆结构不会被破坏, 无需进行额外处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> index, <span class="keyword">int</span> heap_size)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> imax = index;</span><br><span class="line">    <span class="keyword">int</span> ileft = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> iright = <span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ileft &lt; heap_size &amp;&amp; vec[imax] &lt; vec[ileft])&#123;</span><br><span class="line">      imax = ileft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iright &lt; heap_size &amp;&amp; vec[imax] &lt; vec[iright])&#123;</span><br><span class="line">      imax = iright;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( imax != index )&#123;</span><br><span class="line">      <span class="built_in">std</span>::(vec[imax], vec[index]);</span><br><span class="line">      index = imax; <span class="comment">//产生了交换, 可能破坏了左右子树的堆结构, 令index为左右子树之一的下标, 继续调整</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">//如果没有交换，说明当前结构的堆结构已经完成，直接跳出</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建最大堆（Build-Max-Heap）的作用是将一个数组改造成一个最大堆，接受数组和堆大小两个参数，Build-Max-Heap 将自下而上的调用 Max-Heapify 来改造数组，建立最大堆。因为 Max-Heapify 能够保证下标 i 的结点之后结点都满足最大堆的性质，所以自下而上的调用 Max-Heapify 能够在改造过程中保持这一性质。如果最大堆的数量元素是 n，那么 Build-Max-Heap 从 Parent(n) 开始，往上依次调用 Max-Heapify。</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvnw58irzvj20h20ipaf1.jpg" alt=""></p><p>代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_maxheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lasti_parent = <span class="built_in">std</span>::<span class="built_in">floor</span>((vec.size()<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = lasti_parent ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">    max_heapify(vec, i , vec.size()) <span class="comment">//从下到上对每个节点进行堆调整，无需从叶子节点开始</span></span><br><span class="line">    <span class="comment">//堆的size需要传整个size过去,因为下标从针对整个堆而言的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好堆以后,就可以通过移除堆顶来进行排序,每次将堆顶元素和数组末尾元素进行交换(这样可以不借助额外空间完成排序)，然后对数组的前n-1个元素重新进行堆调整构成新的大顶堆, 重复此过程知道堆中只剩下一个元素, 如下图所示:</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvnw6hzbkjj20gs0pq7cb.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">  build_maxheap(vec);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = vec.size()<span class="number">-1</span> ; i &gt; <span class="number">0</span>; i--)&#123; <span class="comment">//重复n-1次</span></span><br><span class="line">    <span class="built_in">std</span>::swap(vec[<span class="number">0</span>] , vec[i]) <span class="comment">//</span></span><br><span class="line">    Heapify(vec, <span class="number">0</span>, i); <span class="comment">//堆的大小变为i, 所以必须要设置一个变量来标识堆的size,而不是用vec.size()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Grasp_detection</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-Grasp_detection/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-Grasp_detection/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ 基础</title>
      <link href="/z_post/Cpp-%E5%9F%BA%E7%A1%80/"/>
      <url>/z_post/Cpp-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="闲杂"><a href="#闲杂" class="headerlink" title="闲杂"></a>闲杂</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Array &lt; Stack&lt;<span class="keyword">int</span>&gt; &gt; array_stack;</span><br><span class="line"><span class="comment">//在C++98中，要求至少用一个空白符将两个&gt;符号分开，以免与运算符&gt;&gt;混淆，C++11不要求这样做</span></span><br></pre></td></tr></table></figure><h1 id="花括号与分号"><a href="#花括号与分号" class="headerlink" title="花括号与分号"></a>花括号与分号</h1><p>在结构体与类定义大括号后面需要分号；<br>其余可要可不要<br>if else、try catch等组合语句如果在中间加了分号会将一个语句块分成两个</p><h1 id="cmath"><a href="#cmath" class="headerlink" title="cmath"></a>cmath</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br><span class="line">or</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">ceil(),floor() 向上、向下取整，不在命名std里面。</span><br><span class="line"></span><br><span class="line">ceil(5/2); // 2</span><br><span class="line">ceil(5.0/2); // 3</span><br><span class="line">floor(5.0/2); // 2:</span><br></pre></td></tr></table></figure><h1 id="std-find"><a href="#std-find" class="headerlink" title="std::find"></a>std::find</h1><p>返回范围 [first, last) 中满足特定判别标准的首个元素迭代器，查找失败则返回end迭代器</p><h1 id="std-sort"><a href="#std-sort" class="headerlink" title="std::sort"></a>std::sort</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数必须写在最外吗，否则无法通过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mysort</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&gt;b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">787</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::sort(v.begin(), v.end(), mysort);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = v.begin(); iter!= v.end(); iter++)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;* iter&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lamda 表达式</span></span><br><span class="line"><span class="built_in">std</span>::sort(s.begin(), s.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">       <span class="keyword">return</span> b &lt; a;   </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>截取vector中的一部分作为一个新的vector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>清空：clear()</p><p>在最后添加元素：push_back()</p><p>初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v3(<span class="number">5</span>, <span class="string">"hello"</span>); <span class="comment">// 创建有5个值为“hello”的string类对象的容器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>判断某元素是否存在<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vStr;</span><br><span class="line"><span class="keyword">int</span> nRet = <span class="built_in">std</span>::count(vStr.begin(), vStr.end(), <span class="string">"abc"</span>);<span class="comment">//返回向量中，“abc”元素的个数</span></span><br></pre></td></tr></table></figure></p><p>at：访问指定字符，有边界检查 <code>str.at(1)</code></p><p>front：访问首字符 (C++11) <code>str.front()</code></p><p>back：访问最后的字符（C++11）Cpp</p><h1 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h1><h2 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h2><h2 id="截取子串"><a href="#截取子串" class="headerlink" title="截取子串"></a>截取子串</h2><p>s.substr(pos, n)    截取s中从pos开始（包括0）的n个字符的子串，并返回</p><p>s.substr(pos)        截取s中从从pos开始（包括0）到末尾的所有字符的子串，并返回</p><h2 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h2><p>s.replace(pos, n, s1)    用s1替换s中从pos开始（包括0）的n个字符的子串</p><h2 id="查找子串"><a href="#查找子串" class="headerlink" title="查找子串"></a>查找子串</h2><p>s.find(s1)         查找s中第一次出现s1的位置，并返回（包括0）</p><p>s.rfind(s1)        查找s中最后次出现s1的位置，并返回（包括0）</p><p>s.find_first_of(s1)       查找在s1中任意一个字符在s中第一次出现的位置，并返回（包括0）</p><p>s.find_last_of(s1)       查找在s1中任意一个字符在s中最后一次出现的位置，并返回（包括0）</p><p>s.fin_first_not_of(s1)         查找s中第一个不属于s1中的字符的位置，并返回（包括0）</p><p>s.fin_last_not_of(s1)         查找s中最后一个不属于s1中的字符的位置，并返回（包括0）</p><h2 id="判断字符串string里面是否含有某个字符串"><a href="#判断字符串string里面是否含有某个字符串" class="headerlink" title="判断字符串string里面是否含有某个字符串"></a>判断字符串string里面是否含有某个字符串</h2><p>利用<code>string::size_type string::find(string &amp;);</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a=<span class="string">"abcdefghigklmn"</span>;</span><br><span class="line">    <span class="built_in">string</span> b=<span class="string">"def"</span>;</span><br><span class="line">    <span class="built_in">string</span> c=<span class="string">"123"</span>;</span><br><span class="line">    <span class="built_in">string</span>::size_type idx;</span><br><span class="line"></span><br><span class="line">    idx=a.find(b);<span class="comment">//在a中查找b.</span></span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="built_in">string</span>::npos )<span class="comment">//不存在。</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found\n"</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//存在。</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"found\n"</span>;</span><br><span class="line">    idx=a.find(c);<span class="comment">//在a中查找c。</span></span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="built_in">string</span>::npos )<span class="comment">//不存在。</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found\n"</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//存在。</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"found\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-字符串比较大小的两种方法"><a href="#c-字符串比较大小的两种方法" class="headerlink" title="c++字符串比较大小的两种方法"></a>c++字符串比较大小的两种方法</h2><ul><li>compare函数的使用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1=<span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.compare(<span class="string">"helloo"</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//返回-1；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.compare(<span class="string">"hello"</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//返回0 ；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.compare(<span class="string">"hell"</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//返回1；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用strcmp(aa1.c_str(),bb2.c_str())</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str1=<span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* str2=<span class="string">"hell"</span>;</span><br><span class="line">    <span class="keyword">char</span>* str3=<span class="string">"helloo"</span>;</span><br><span class="line">    <span class="keyword">char</span>* str4=<span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原型extern int strcmp(const char* s1,const char* s2);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str1,str2)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//返回1；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str1,str3)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//返回-1；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str1,str4)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//返回0.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统计字符串中某个字符出现了多少次"><a href="#统计字符串中某个字符出现了多少次" class="headerlink" title="统计字符串中某个字符出现了多少次"></a>统计字符串中某个字符出现了多少次</h2><p>使用算法库里面的count函数，使用方法是count（begin，end，‘a’），其中begin指的是起始地址，end指的是结束地址，第三个参数指的是需要查找的字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algotirhm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> temp = <span class="string">"aaabcdaaa!!!"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = count(temp.begin(),temp.end(),<span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"在字符串"</span> &lt;&lt; temp &lt;&lt; <span class="string">"中，"</span> &lt;&lt;<span class="string">"字母a出现的次数是"</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>at：访问指定字符，有边界检查 <code>str.at(1)</code></p><p>front：访问首字符 (C++11) <code>str.front()</code></p><p>back：访问最后的字符（C++11）Cpp</p><p>c_str：返回不可修改的C字符数组版本（带’\0’） <code>str.c_str()</code></p><h2 id="交换string的值"><a href="#交换string的值" class="headerlink" title="交换string的值"></a>交换string的值</h2><p>成员函数： <code>string::swap(string&amp; str)</code> 主要用于交换两个string的值，用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// swap strings</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">buyer</span> <span class="params">(<span class="string">"money"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">seller</span> <span class="params">(<span class="string">"goods"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Before the swap, buyer has "</span> &lt;&lt; buyer;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" and seller has "</span> &lt;&lt; seller &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  seller.swap (buyer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" After the swap, buyer has "</span> &lt;&lt; buyer;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" and seller has "</span> &lt;&lt; seller &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Before the swap, buyer has money and seller has goods</span></span><br><span class="line"><span class="comment"> After the swap, buyer has goods and seller has money</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>非成员函数<code>std::swap()</code>可以将string内部的两个元素进行交互。同时，也可以对两个string进行交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">std</span>::swap(str1.at(<span class="number">0</span>), str1.at(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str2 = <span class="string">"def"</span>;</span><br><span class="line">    <span class="built_in">std</span>::swap(str1, str2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">bac</span></span><br><span class="line"><span class="comment">def</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><p>在STL中</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《CUDA C Programming Guide》</title>
      <link href="/z_post/CUDA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-CUDACProgrammingGuide-md/"/>
      <url>/z_post/CUDA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-CUDACProgrammingGuide-md/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-介绍"><a href="#第一章-介绍" class="headerlink" title="第一章 介绍"></a>第一章 介绍</h1><p>GPU在进行浮点数运算时超高的精确度和速度，其原因在于GPU很擅长解决计算密集型和高并行计算。</p><p>多核CPU和GPU的一个挑战在于怎么编写并行的程序来利用这些多核。</p><p>CUDA并行变成模式就是希望用一个较低的学习曲线来解决这个问题。</p><p>三个关键的抽象：线程组等级、共享内存、障碍同步</p><h1 id="第二章-编程模型"><a href="#第二章-编程模型" class="headerlink" title="第二章  编程模型"></a>第二章  编程模型</h1><h2 id="2-1-Kernels"><a href="#2-1-Kernels" class="headerlink" title="2.1 Kernels"></a>2.1 Kernels</h2><p>kernel程序用<code>__global__</code>定义。并且用一种新的执行配置语法<code>&lt;&lt;&lt;...&gt;&gt;&gt;</code>来决定CUDA的线程数量。每一个线程都会在给定的“线程ID”下执行kernel，线程ID可以通过kernel内部的<code>threadIdx</code>变量来获取。</p><p>下面的代码显示了向量加法。 总共启动了N个线程，每个都执行一个对应位相加运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Kernel definition</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">VecAdd</span><span class="params">(<span class="keyword">float</span>* A, <span class="keyword">float</span>* B, <span class="keyword">float</span>* C)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = threadIdx.x;</span><br><span class="line">  C[i] = A[i] + B[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Kernel invocation with N threads</span></span><br><span class="line">  VecAdd&lt;&lt;&lt;<span class="number">1</span>,N&gt;&gt;&gt;(A,B,C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-线程结构（Thread-Hierarchy）"><a href="#2-2-线程结构（Thread-Hierarchy）" class="headerlink" title="2.2 线程结构（Thread Hierarchy）"></a>2.2 线程结构（Thread Hierarchy）</h2><p>为了方便，<code>threadIdx</code>包含三个组成向量，因此，线程可以使用一维，二维或者三维的<code>thread index</code>，由此，可以表示一维，二维或者三维的线程块（“thread block”）。</p><p>线程的索引和它的线程ID是直接关联的。对于一维线程块来说，它们是一样的。对于二维线程块来说，索引为 $(x，y)$ 的线程，其线程ID为：$(x+yD_x)$ 。对于三维线程块来说，索引为 $(x,y,z)$ 的线程，其线程ID为： $(x+ yD_x +zD_xD_y)$ 。</p><p>下面的代码显示了矩阵加法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Kernel definition</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">MatAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[C][C])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = threadIdx.x;</span><br><span class="line">  <span class="keyword">int</span> j =threadIndx.y;</span><br><span class="line">  C[i][j] = A[i][j] + B[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//Kernel invocation with one block of N*N*1 threads</span></span><br><span class="line">  <span class="keyword">int</span> numBlocks = <span class="number">1</span>;</span><br><span class="line">  <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(N,N)</span></span>;  <span class="comment">//&lt;&lt;&lt;&gt;&gt;&gt;语法可以接受int类型或者dim3类型的数据</span></span><br><span class="line">  MatAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A,B,C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread block的索引可以通过<code>blockIdx</code>变量获得，thread block的维度的size可以通过<code>blockDim</code>变量获得。</p><p>扩展上面的<code>MatAdd()</code>代码，使其可以处理多blocks，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Kernel definition</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">MatAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[N][N])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">  <span class="keyword">int</span> j = blockIdx.y * blockDim.y + threadInx.y;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;N &amp;&amp; j&lt;N)&#123;</span><br><span class="line">    C[i][j] = A[i][j] + B[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//Kernel invocation</span></span><br><span class="line">  <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">  <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(N / threadsPerBlock.x, N / threadsPerBlock.y)</span></span>;</span><br><span class="line">  MatAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程块必须独立执行，因此它们必须能够在任意的顺序下并行执行。</p><p>CUDA使用<code>__syncthreads()</code>来协调共享内存和各个线程之间的执行。</p><h2 id="2-3-内存结构（Memory-Hierarchy）"><a href="#2-3-内存结构（Memory-Hierarchy）" class="headerlink" title="2.3 内存结构（Memory Hierarchy）"></a>2.3 内存结构（Memory Hierarchy）</h2><p>由两种额外的只读内存空间可以被所有线程访问到：常量内存空间（constant memory spaces）和纹理内存空间（texture memory spaces）。</p><h2 id="2-4-异构编程"><a href="#2-4-异构编程" class="headerlink" title="2.4 异构编程"></a>2.4 异构编程</h2><p>CUDA编程模型假设所有线程都是在物理上单个的设备上运行的，每个设备都当做是主机的从处理程序。比如，kernel在GPU上执行，而剩下的C程序在CPU上执行。</p><p>CUDA编程模型还假设主机和设备都DRAM中各自维护自己的内存，对应这“主机内存（host memory）”和“设备内存（divice memory）”。因此，程序通过调用CUDA运行时来管理主机和设备的内存。</p><h2 id="2-5-计算能力（Compute-Capability）"><a href="#2-5-计算能力（Compute-Capability）" class="headerlink" title="2.5 计算能力（Compute Capability）"></a>2.5 计算能力（Compute Capability）</h2><p>计算能力用设备的版本号标识，有时也称为“SM version”。有major revision number“X”和minor revision number“Y”组成，记为X.Y。</p><h1 id="第三章-编程接口（Programming-Interface）"><a href="#第三章-编程接口（Programming-Interface）" class="headerlink" title="第三章 编程接口（Programming Interface）"></a>第三章 编程接口（Programming Interface）</h1><p>CUDA提供了诸多扩展语法来并行变成（如kernel），任何包含这些扩展语法的源文件都需要需要nvcc编译器来编译。</p><h2 id="3-1-Compilation-with-NVCC"><a href="#3-1-Compilation-with-NVCC" class="headerlink" title="3.1 Compilation with NVCC"></a>3.1 Compilation with NVCC</h2><p>Kernels can be written using the CUDA instruction set architecture, called PTX, which<br>is described in the PTX reference manual.</p><h3 id="3-1-1-编译工作流"><a href="#3-1-1-编译工作流" class="headerlink" title="3.1.1 编译工作流"></a>3.1.1 编译工作流</h3><h4 id="3-1-1-1-离线编译-Offline-Compilation"><a href="#3-1-1-1-离线编译-Offline-Compilation" class="headerlink" title="3.1.1.1 离线编译 Offline Compilation"></a>3.1.1.1 离线编译 Offline Compilation</h4><p>nvcc编译器可以编译包含host code和device code的混合代码。nvcc首先会将device code从host code中分离出来，然后，会进行以下两步：</p><ul><li>编译device code到assembly form（PTX code）或者binary form（cubin objec）</li><li>修改host code，将<code>&lt;&lt;&lt;...&gt;&gt;&gt;</code>语法替换成必要的CUDA C运行时函数。</li></ul><p>被修改的host code要么输出成C code，要么把直接输出成object code。</p><h4 id="3-1-1-2-即时编译-Just-in-Time-Compilation"><a href="#3-1-1-2-即时编译-Just-in-Time-Compilation" class="headerlink" title="3.1.1.2 即时编译 Just-in-Time Compilation"></a>3.1.1.2 即时编译 Just-in-Time Compilation</h4><h3 id="二进制兼容性-Binary-Compatibility"><a href="#二进制兼容性-Binary-Compatibility" class="headerlink" title="二进制兼容性 Binary Compatibility"></a>二进制兼容性 Binary Compatibility</h3><p>Binary code is architecture-specific。通过<code>-code=sm_35</code>的形式来指定特定的architecture。注意，编译好的二进制代码是向上兼容的，也就是如果二进制代码设定的计算能力版本号为 $X.y$ ，那么该代码就只能运行在 $X.z$上，其中 $z\ge y$ 。</p><h3 id="3-1-3-PTX-兼容性"><a href="#3-1-3-PTX-兼容性" class="headerlink" title="3.1.3 PTX 兼容性"></a>3.1.3 PTX 兼容性</h3><p>一些PTX指令仅仅支持在高计算机能力版本的GPU中使用。</p><p>指针某些计算能力版本的PTX code总是可以转换成binary code，进而都更高计算能力的版本中使用。</p><p>其他有些版本，则不能直接使用。</p><h3 id="3-1-4-应用兼容性"><a href="#3-1-4-应用兼容性" class="headerlink" title="3.1.4 应用兼容性"></a>3.1.4 应用兼容性</h3><p>为了满足bianry兼容性和PTX兼容性，推荐使用即时编译。</p><p>通过<code>-gencode</code>、<code>-arch</code>和<code>-code</code>编译选项来指定计算能力版本号及其兼容性。</p><h3 id="3-1-5-C-C-兼容性"><a href="#3-1-5-C-C-兼容性" class="headerlink" title="3.1.5 C/C++ 兼容性"></a>3.1.5 C/C++ 兼容性</h3><p>CUDA源文件的前端遵循C++语法规则。host code可以完美支持C++语言发。但是，device code支持C++语法中的一个子集，详细可以参见C/C++ Language Support。</p><h3 id="3-1-6-64-Bit-Compatibility"><a href="#3-1-6-64-Bit-Compatibility" class="headerlink" title="3.1.6 64-Bit Compatibility"></a>3.1.6 64-Bit Compatibility</h3><p>64位的nvcc会将device code编译成64位模式（即，指针占64位）。此时host code必须在32位模式下执行。</p><p>32位device、host同理</p><p><code>-m64</code> 选项可以切换nvcc的位数。</p><h2 id="3-2-CUDA-C-Runtime"><a href="#3-2-CUDA-C-Runtime" class="headerlink" title="3.2 CUDA C Runtime"></a>3.2 CUDA C Runtime</h2><p>运行时使用<code>cudart</code>库实现。 或者使用<code>cudart.lib</code>、<code>libcudart.a</code>进行静态链接，或者使用<code>cudart.dll</code>、<code>cudart.so</code>进行动态链接。</p><p>正如前面异构编程提到的。CUDA编程模型将系统看走是由device和host组成的一个整体，二者管理各自的内存。</p><h3 id="3-2-1-初始化"><a href="#3-2-1-初始化" class="headerlink" title="3.2.1 初始化"></a>3.2.1 初始化</h3><p>没有专门的初始化函数<br>在初始化阶段，runtime为系统中的每一个device创建上下文。</p><h3 id="3-2-2-设备内存-Device-Memory"><a href="#3-2-2-设备内存-Device-Memory" class="headerlink" title="3.2.2 设备内存 Device Memory"></a>3.2.2 设备内存 Device Memory</h3><p>Kernels操控device memory之外的代码。所以runtime会提供allocate，deallocate和copy等函数来复制device memory，同时在host和device内存之间传输数据。</p><p>Divice memory可以申请linear memory或者CUDA arrays。</p><p>CUDA arrays是不透明的内存形式，专门用于优化texture fetching。</p><p>Linear memory存在于40位的地址空间中，可以使用<code>cudaMalloc()</code>函数申请，用<code>cudaFree()</code>函数释放，同时，可以用<code>cudaMemcpy()</code>函数来将数据在host和device之间交换。</p><p><code>cudaMallocPitch()</code>和<code>cudaMalloc3D()</code>推荐用来申请2D和3D数组。<code>cudaMemcpy2D</code>。</p><p><code>cudaGetSymbolAddress()</code>用来检索指向内存的地址。</p><p><code>cudaGetSymbolSize()</code>可以得到申请内存的大小。</p><h3 id="3-2-3-共享内存-Shared-Memory"><a href="#3-2-3-共享内存-Shared-Memory" class="headerlink" title="3.2.3 共享内存 Shared Memory"></a>3.2.3 共享内存 Shared Memory</h3><p>Shared Memory在Thread Hierarchy上要比global memory更快。</p><p><strong>矩阵乘法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrices are stored in row-major order:</span></span><br><span class="line"><span class="comment">// M(row, col) = *(M.elements + row * M.width + col)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">float</span>* elements;</span><br><span class="line">&#125; Matrix;</span><br><span class="line"><span class="comment">// Thread block size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 16</span></span><br><span class="line"><span class="comment">// Forward declaration of the matrix multiplication kernel</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">MatMulKernel</span><span class="params">(<span class="keyword">const</span> Matrix, <span class="keyword">const</span> Matrix, Matrix)</span></span>;</span><br><span class="line"><span class="comment">// Matrix multiplication - Host code</span></span><br><span class="line"><span class="comment">// Matrix dimensions are assumed to be multiples of BLOCK_SIZE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatMul</span><span class="params">(<span class="keyword">const</span> Matrix A, <span class="keyword">const</span> Matrix B, Matrix C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Load A and B to device memory</span></span><br><span class="line">Matrix d_A;</span><br><span class="line">d_A.width = A.width; d_A.height = A.height;</span><br><span class="line"><span class="keyword">size_t</span> size = A.width * A.height * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">cudaMalloc(&amp;d_A.elements, size);</span><br><span class="line">cudaMemcpy(d_A.elements, A.elements, size,</span><br><span class="line">cudaMemcpyHostToDevice);</span><br><span class="line">Matrix d_B;</span><br><span class="line">d_B.width = B.width; d_B.height = B.height;</span><br><span class="line">size = B.width * B.height * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">cudaMalloc(&amp;d_B.elements, size);</span><br><span class="line">cudaMemcpy(d_B.elements, B.elements, size,</span><br><span class="line">cudaMemcpyHostToDevice);</span><br><span class="line"><span class="comment">// Allocate C in device memory</span></span><br><span class="line">Matrix d_C;</span><br><span class="line">d_C.width = C.width; d_C.height = C.height;</span><br><span class="line">size = C.width * C.height * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">cudaMalloc(&amp;d_C.elements, size);</span><br><span class="line"><span class="comment">// Invoke kernel</span></span><br><span class="line"><span class="function">dim3 <span class="title">dimBlock</span><span class="params">(BLOCK_SIZE, BLOCK_SIZE)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">dimGrid</span><span class="params">(B.width / dimBlock.x, A.height / dimBlock.y)</span></span>;</span><br><span class="line">MatMulKernel&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(d_A, d_B, d_C);</span><br><span class="line"><span class="comment">// Read C from device memory</span></span><br><span class="line">cudaMemcpy(C.elements, Cd.elements, size,</span><br><span class="line">cudaMemcpyDeviceToHost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Free device memory</span></span><br><span class="line">cudaFree(d_A.elements);</span><br><span class="line">cudaFree(d_B.elements);</span><br><span class="line">cudaFree(d_C.elements);</span><br><span class="line"><span class="comment">// Matrix multiplication kernel called by MatMul()</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">MatMulKernel</span><span class="params">(Matrix A, Matrix B, Matrix C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Each thread computes one element of C</span></span><br><span class="line"><span class="comment">// by accumulating results into Cvalue</span></span><br><span class="line"><span class="keyword">float</span> Cvalue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> row = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"><span class="keyword">int</span> col = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; A.width; ++e)</span><br><span class="line">Cvalue += A.elements[row * A.width + e]</span><br><span class="line">* B.elements[e * B.width + col];</span><br><span class="line">C.elements[row * C.width + col] = Cvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-4-Page-Locked-Host-Memory"><a href="#3-2-4-Page-Locked-Host-Memory" class="headerlink" title="3.2.4 Page-Locked Host Memory"></a>3.2.4 Page-Locked Host Memory</h3><p>plhm有诸多好处，如：</p><ul><li>可以使copy更快</li><li>可以直接映射到地址空间，消除copy到device memory的需求</li><li>在fron-side bus上， plhm的bandwidth更高。</li></ul><p>但是，plhm是稀缺资源，因此，在申请时一定要注意不能过度使用。</p><h4 id="3-2-4-1-移动内存-Portable-Memory"><a href="#3-2-4-1-移动内存-Portable-Memory" class="headerlink" title="3.2.4.1 移动内存 Portable Memory"></a>3.2.4.1 移动内存 Portable Memory</h4><p>一块page-locked内存可以备用在与任意一个设备的连接上。但是默认情况下，使用page-locked内存的好处仅仅会在当前block所申请的设备（或者那些共享了内存的设备）上显现。</p><p>为了使这些好处对于所有设备来说都是可行的，block需要将flag cudaHostAllocPortable传递到cudaHostAlloc中去，或者将flag cudaHostRegisterPortable传递到cudaHostRegister中去。</p><h4 id="3-2-4-2-Write-Combining-Memory"><a href="#3-2-4-2-Write-Combining-Memory" class="headerlink" title="3.2.4.2 Write-Combining Memory"></a>3.2.4.2 Write-Combining Memory</h4><p>该内存通过释放L1和L2的缓存资源，使得更多缓存资源可以给后面的应用使用。</p><p>从host中读取write-combining 内存比较慢，所以常常只用于写。</p><h4 id="3-2-4-3-Mapped-Memory"><a href="#3-2-4-3-Mapped-Memory" class="headerlink" title="3.2.4.3 Mapped Memory"></a>3.2.4.3 Mapped Memory</h4><p>使用cduaHostAllocMapped或者cudaHostRegisterMapped可以使一块page-locked host内存映射到设备的地址空间中。</p><p>因此，这样的内存块往往有两个地址，分别是host地址和device地址。</p><p>直接kernel中访问host内存有以下几点优势：</p><ul><li>无需在device中申请内存块，也无需在device和host中来还传输数据</li><li>在执行kernel时，无需使用“流”来overlap数据的传输</li></ul><h4 id="3-2-5-异步并发执行-Asynchronous-Concurrent-Execution"><a href="#3-2-5-异步并发执行-Asynchronous-Concurrent-Execution" class="headerlink" title="3.2.5 异步并发执行 Asynchronous Concurrent Execution"></a>3.2.5 异步并发执行 Asynchronous Concurrent Execution</h4><p>CUDA将下列操作当作一个独立的任务，它们可以互相并发执行：</p><ul><li>在host上计算</li><li>在device上计算</li><li>将host上的内存传输到device上</li><li>将device上的内存传输到host上</li></ul><h4 id="3-2-5-1-在Host和Device之间并发执行"><a href="#3-2-5-1-在Host和Device之间并发执行" class="headerlink" title="3.2.5.1 在Host和Device之间并发执行"></a>3.2.5.1 在Host和Device之间并发执行</h4><p>通过异步调用，许多device操作都可以排成队列，进而利用CUDA driver来执行。这减轻了host线程管理device的负担，使得它可以执行其他任务。下列device操作相对于host来说是异步的。</p><ul><li>启动Kernel</li><li>将内存拷贝到一个单一的deivce内存中</li><li>将内存从host拷贝到device中小于64将内存从host拷贝到device中小于64KB的内存块中</li><li>用带有Async后缀的函数来进行内存拷贝</li><li>内存设定函数的调用（Memory set function calls）</li></ul><h4 id="3-2-5-2-Concurrent-Kernel-Execution"><a href="#3-2-5-2-Concurrent-Kernel-Execution" class="headerlink" title="3.2.5.2 Concurrent Kernel Execution"></a>3.2.5.2 Concurrent Kernel Execution</h4><p>计算能力告诉2.x的版本可以并发启动多个kernels。</p><p>可以通过concurrentKernel设备属性来查看是否支持并发启动。</p><h4 id="3-2-5-3-Overlap-of-Data-Tranfer-and-Kernel-Execution"><a href="#3-2-5-3-Overlap-of-Data-Tranfer-and-Kernel-Execution" class="headerlink" title="3.2.5.3 Overlap of Data Tranfer and Kernel Execution"></a>3.2.5.3 Overlap of Data Tranfer and Kernel Execution</h4><p>有一些设备可以从GPU利用kernel执行来进行异步的内存拷贝，应用需要想设备询问是否具有这种功能，可以通过检查asyncEngineCoune设备属性来查看，如果大于0就是支持的。</p><h4 id="3-2-5-4-并发数据传输-Concurrent-Data-Transfers"><a href="#3-2-5-4-并发数据传输-Concurrent-Data-Transfers" class="headerlink" title="3.2.5.4 并发数据传输 Concurrent Data Transfers"></a>3.2.5.4 并发数据传输 Concurrent Data Transfers</h4><p>一些计算能力在2.x以上的设备可以在进行数据传输是进行overlap，应用可以通过asyncEngineCount来检查设备是否支持该功能</p><h4 id="3-2-5-5-流-Streams"><a href="#3-2-5-5-流-Streams" class="headerlink" title="3.2.5.5 流 Streams"></a>3.2.5.5 流 Streams</h4><p>应用通过“流”来管理并发的操作。一个“流”代表这一串由“命令”组成的序列</p><h4 id="3-2-5-5-1-创建和销毁：Creation-and-Destruction"><a href="#3-2-5-5-1-创建和销毁：Creation-and-Destruction" class="headerlink" title="3.2.5.5.1 创建和销毁：Creation and Destruction"></a>3.2.5.5.1 创建和销毁：Creation and Destruction</h4><p>下面的代码创建了两个流，同时在page-locked内存中申请了flaot类型的hosrtPtr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cudaStream_t stream[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">cudaStreamCreate(&amp;stream[i]);</span><br><span class="line"><span class="keyword">float</span>* hostPtr;</span><br><span class="line">cudaMallocHost(&amp;hostPtr, <span class="number">2</span> * size);</span><br></pre></td></tr></table></figure><p>这两条流都经过下面的代码定义，执行一个从host到device的内存拷贝操作，一个kernel启动操作，以及一个从device到host的的内存拷贝操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">cudaMemcpyAsync(inputDevPtr + i * size, hostPtr + i * size,</span><br><span class="line">size, cudaMemcpyHostToDevice, stream[i]);</span><br><span class="line">MyKernel &lt;&lt;&lt;<span class="number">100</span>, <span class="number">512</span>, <span class="number">0</span>, stream[i]&gt;&gt;&gt;</span><br><span class="line">(outputDevPtr + i * size, inputDevPtr + i * size, size);</span><br><span class="line">cudaMemcpyAsync(hostPtr + i * size, outputDevPtr + i * size,</span><br><span class="line">size, cudaMemcpyDeviceToHost, stream[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过cudaStreamDestroy()可以释放流：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">  cudaStreamDestroy(stream[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-5-5-2-默认流-Default-Stream"><a href="#3-2-5-5-2-默认流-Default-Stream" class="headerlink" title="3.2.5.5.2 默认流 Default Stream"></a>3.2.5.5.2 默认流 Default Stream</h5><p>对于使用<code>--default-stream per-thread</code>编译选项的代码来说，默认流是一条常规的流，并且每个主线程都有它自己的默认流</p><p>对于使用<code>--default-stream legacy</code>编译选项的代码来说，默认流是一条特殊的流，被称为<code>NULL stream</code> ，并且每一个设备都具有一条单一的NULL stream供所有的host线程使用。它的特殊性源自于它会隐式的进行同步操作。</p><h5 id="3-2-5-5-3-显式同步"><a href="#3-2-5-5-3-显式同步" class="headerlink" title="3.2.5.5.3 显式同步"></a>3.2.5.5.3 显式同步</h5><p>以下几种方式可以对流进行显式同步操作：</p><ul><li>cudaDeviceSynchronize()</li><li>cudaStreamSynchronize()</li><li>cudaStreamWaitEvent()</li><li>cudaStreamQuery()</li></ul><p>为了避免不必要的速率降低，以上所有的同步函数通常用于timing purpoese或者用于孤立一个拷贝或启动的失败。</p><h5 id="3-2-5-5-4-隐式同步"><a href="#3-2-5-5-4-隐式同步" class="headerlink" title="3.2.5.5.4 隐式同步"></a>3.2.5.5.4 隐式同步</h5><p>从两个不同流传过来的指令中的其中一条出现了问题，那么就无法并发运行。</p><p>同步操作越晚执行越好。</p><h5 id="3-2-5-5-5-Overlapping-行为"><a href="#3-2-5-5-5-Overlapping-行为" class="headerlink" title="3.2.5.5.5 Overlapping 行为"></a>3.2.5.5.5 Overlapping 行为</h5><p>对于两个流里面的操作，如一个是从host拷贝内存到device，另一个是从device拷贝内存到host，则这两条指令直接存在Overlap。</p><h5 id="3-2-5-5-6-回调函数Callbacks"><a href="#3-2-5-5-6-回调函数Callbacks" class="headerlink" title="3.2.5.5.6 回调函数Callbacks"></a>3.2.5.5.6 回调函数Callbacks</h5><p>运行时提供了可以在流中的任何位置插入回调函数的指令：<code>cudaStreamAddCallback()</code>。</p><h5 id="3-2-5-5-7-流优先级-Stream-Priorities"><a href="#3-2-5-5-7-流优先级-Stream-Priorities" class="headerlink" title="3.2.5.5.7 流优先级 Stream Priorities"></a>3.2.5.5.7 流优先级 Stream Priorities</h5><p>相对优先级使用<code>cudaStreamCreateWithPriority()</code></p><p>获取优先级范围[highest priority,lowest priority]使用<code>cudaDeviceGetStramPriorityRange</code>。</p><p>下面的代码包含了获取当前设备的优先级范围：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the range of stream priorities for this device</span></span><br><span class="line"><span class="keyword">int</span> priority_high, priority_low;</span><br><span class="line">cudaDeviceGetStreamPriorityRange(&amp;priority_low, &amp;priority_high);</span><br><span class="line"><span class="comment">// create streams with highest and lowest available priorities</span></span><br><span class="line">cudaStream_t st_high, st_low;</span><br><span class="line">cudaStreamCreateWithPriority(&amp;st_high, cudaStreamNonBlocking, priority_high);</span><br><span class="line">cudaStreamCreateWithPriority(&amp;st_low, cudaStreamNonBlocking, priority_low);</span><br></pre></td></tr></table></figure><h4 id="3-2-5-6-事件-Events"><a href="#3-2-5-6-事件-Events" class="headerlink" title="3.2.5.6 事件  Events"></a>3.2.5.6 事件  Events</h4><p>runtime 同时还提供了密切监视device进程的方法，主要是通过appliocation来异步记录事件完成时的事件点。</p><h5 id="3-2-5-6-1-创建和销毁"><a href="#3-2-5-6-1-创建和销毁" class="headerlink" title="3.2.5.6.1 创建和销毁"></a>3.2.5.6.1 创建和销毁</h5><p>下面的代码创建了2个事件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaEvent_t event1, event2;</span><br><span class="line">cudaEventCreate(&amp;event1);</span><br><span class="line">cudaEventCreate(&amp;event2);</span><br></pre></td></tr></table></figure></p><p>下面的代码销毁了2个事件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaEventDestroy(event1);</span><br><span class="line">cudaEventDestroy(event2);</span><br></pre></td></tr></table></figure></p><h5 id="3-2-5-6-2-运行时间"><a href="#3-2-5-6-2-运行时间" class="headerlink" title="3.2.5.6.2 运行时间"></a>3.2.5.6.2 运行时间</h5><p>下面的代码可以用来监视事件的运行时间（从start到end）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cudaEventRecord(start, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">cudaMemcpyAsync(inputDev + i * size, inputHost + i * size,</span><br><span class="line">size, cudaMemcpyHostToDevice, stream[i]);</span><br><span class="line">MyKernel&lt;&lt;&lt;<span class="number">100</span>, <span class="number">512</span>, <span class="number">0</span>, stream[i]&gt;&gt;&gt;</span><br><span class="line">(outputDev + i * size, inputDev + i * size, size);</span><br><span class="line">cudaMemcpyAsync(outputHost + i * size, outputDev + i * size,</span><br><span class="line">size, cudaMemcpyDeviceToHost, stream[i]);</span><br><span class="line">&#125;</span><br><span class="line">cudaEventRecord(stop, <span class="number">0</span>);</span><br><span class="line">cudaEventSynchronize(stop);</span><br><span class="line"><span class="keyword">float</span> elapsedTime;</span><br><span class="line">cudaEventElapsedTime(&amp;elapsedTime, start, stop);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-5-7-同步调用"><a href="#3-2-5-7-同步调用" class="headerlink" title="3.2.5.7 同步调用"></a>3.2.5.7 同步调用</h4><p>可以使用<code>cudaSetDeviceFlags()</code>配合一些特定的flags？？</p><h3 id="3-2-6-Multi-Device-System"><a href="#3-2-6-Multi-Device-System" class="headerlink" title="3.2.6 Multi-Device System"></a>3.2.6 Multi-Device System</h3><h4 id="3-2-6-1-Device-Enumeration"><a href="#3-2-6-1-Device-Enumeration" class="headerlink" title="3.2.6.1 Device Enumeration"></a>3.2.6.1 Device Enumeration</h4><p>一个host系统可以有多个devices，下面的代码展示了如何枚举这些设备，并查询它们的属性，决定可启用CUDA的设备数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceCount;</span><br><span class="line">cudaGetDeviceCount(&amp; deviceCount);</span><br><span class="line"><span class="keyword">int</span> device;</span><br><span class="line"><span class="keyword">for</span>( device = <span class="number">0</span>; device&lt;deviceCount; device++)&#123;</span><br><span class="line">  cudaDeviceProp deviceProp;</span><br><span class="line">  cudaGetDeviceProperties(&amp;deviceProp, device);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Device %d has compute capability %d.%d. \n"</span>),</span><br><span class="line">  device, deviceProp.major, deviceProp.minor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-6-2-Device-Selection"><a href="#3-2-6-2-Device-Selection" class="headerlink" title="3.2.6.2 Device Selection"></a>3.2.6.2 Device Selection</h4><p>host线程可以在任何时候使用<code>cudaSetDevice()</code>来设置device。device的内存申请和kernel启动都会在当前设置的device上进行，如果没有调用该函数，则当前的设备默认为0.</p><p>下面的代码展示了如何设置当前的device，以及申请内存和执行kernel</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size = <span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">cudaSetDevice(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">float</span>* p0;</span><br><span class="line">cudaMalloc(&amp;p0, size);<span class="comment">// Allocate memory on device 0</span></span><br><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p0);<span class="comment">// Launch kernel on device 0</span></span><br><span class="line">cudaSetDevice(<span class="number">1</span>);<span class="comment">// Set device 1 as current</span></span><br><span class="line"><span class="keyword">float</span>* p1;</span><br><span class="line">cudaMalloc(&amp;p1,size);<span class="comment">// Allocate memory on device 1</span></span><br><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>,<span class="number">128</span>&gt;&gt;&gt;(p1);<span class="comment">// Launch kernel on device 1</span></span><br></pre></td></tr></table></figure><h4 id="3-2-6-3-Stream-and-Event-Behavior"><a href="#3-2-6-3-Stream-and-Event-Behavior" class="headerlink" title="3.2.6.3 Stream and Event Behavior"></a>3.2.6.3 Stream and Event Behavior</h4><p>如果stream没有绑定到当前的device，那么kernel launch就会失败</p><p>即使stream没有绑定到当前的device，memory copy也会成功</p><p>如果input event和input stream 绑定到了不同的diveces上面，那么<code>cudaEventRecord()</code> will fail</p><p>如果两个input events绑定到了不同的devices上面，那么<code>cudaEventElapsedTime()</code> will fail</p><p>即使input event绑定到了不同于当前device的device上面，<code>cudaEventSynchronize()</code>和<code>cudaEventQuery()</code>仍然will succeed</p>]]></content>
      
      
      <categories>
          
          <category> CUDA </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++中关于*、&amp;、*&amp;以及&amp;*的解析.md</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%EF%BC%8C%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%A3%E6%9E%90-md/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%EF%BC%8C%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%A3%E6%9E%90-md/</url>
      
        <content type="html"><![CDATA[<p>由一道牛客网《剑指offer》的编程题引发的思考，题目如下：</p><p>二叉搜索树与双向链表：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中结点指针的指向。</p><p>按照递归的解题思路，有如下解答：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* prenode = <span class="literal">nullptr</span>;</span><br><span class="line">        recurve(pRootOfTree,prenode);</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurve</span><span class="params">(TreeNode* root, TreeNode*&amp; prenode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurve(root-&gt;left,prenode);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = prenode;</span><br><span class="line">        <span class="keyword">if</span>(prenode!=<span class="literal">nullptr</span>) prenode-&gt;right = root;</span><br><span class="line">        prenode = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurve(root-&gt;right,prenode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码中23行使用了<code>TreeNode*&amp; prenode</code>，这里，如果缺少了<code>&amp;</code>，则结果会出错！</p><p>以下，对C++中*、&amp;、*&amp;以及&amp;* 四种形式展开讨论。</p><h1 id="代表指针"><a href="#代表指针" class="headerlink" title="* 代表指针"></a>* 代表指针</h1><h1 id="amp-代表引用、别名"><a href="#amp-代表引用、别名" class="headerlink" title="&amp; 代表引用、别名"></a>&amp; 代表引用、别名</h1><p>指针和引用的区别之一：</p><p>参数传递时，不管是传值还是传指针，函数都会产生一个临时副本变量，但在传引用时，不会生成临时变量。</p><h1 id="amp-首先是一个指针，然后前面的-amp-代表是这个指针的引用。-指针的引用其实就是指针的一个别名，和指针具有相同的地址。"><a href="#amp-首先是一个指针，然后前面的-amp-代表是这个指针的引用。-指针的引用其实就是指针的一个别名，和指针具有相同的地址。" class="headerlink" title="*&amp; 首先是一个指针，然后前面的&amp;代表是这个指针的引用。 指针的引用其实就是指针的一个别名，和指针具有相同的地址。"></a>*&amp; 首先是一个指针，然后前面的&amp;代表是这个指针的引用。 指针的引用其实就是指针的一个别名，和指针具有相同的地址。</h1><h1 id="amp-首先是一个变量的引用，然后是指向这个引用的指针，但是，因为引用不是对象，没有实际的地址，因此-不能定义指向引用的指针-。"><a href="#amp-首先是一个变量的引用，然后是指向这个引用的指针，但是，因为引用不是对象，没有实际的地址，因此-不能定义指向引用的指针-。" class="headerlink" title="&amp;* 首先是一个变量的引用，然后是指向这个引用的指针，但是，因为引用不是对象，没有实际的地址，因此 不能定义指向引用的指针 。"></a>&amp;* 首先是一个变量的引用，然后是指向这个引用的指针，但是，因为引用不是对象，没有实际的地址，因此 <strong>不能定义指向引用的指针</strong> 。</h1><p><strong>问题：向函数中传递指针和传递指针的引用的区别</strong></p><p>如果传递的是指针，那么会先复制该指针，在函数内部使用的是复制后的指针，这个指针与原来的指针虽然指向相同的地址，但是如果在函数内部将复制后的指针指向了另外的地址，那么不会影响原来的指针。</p><p>但是对于传递指针的引用，如果将传递进来的指针指向了新的地址，那么原始的指针也会指向新的地址，这也是为什么在该题中，必须使用指针的引用，而不能使用指针的原因。就是因为在这段代码中，要对指针指向的值进行更改，而在递归的函数中，又需要保证prenode指向的值保持统一，因此，必须使用指针的引用来使在不同层的递归函数中，prenode指向的值都是一样的。</p><p>在传递指针的引用时，还有另外一个问题，那就是如果由于原始的指针不再指向原始对象了，所以如果没有其他指针指向该原始对象的话，就会造成内存泄漏。同理，如果在函数内释放了指针的引用，那么在函数外部就不能在使用原来的指针了，因为原来的内存已经被释放了。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中NULL和nullptr之间的区别.md</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%ADNULL%E3%80%81null%E5%92%8Cnullptr%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-md/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%ADNULL%E3%80%81null%E5%92%8Cnullptr%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-md/</url>
      
        <content type="html"><![CDATA[<p><strong>首先，C++中没有null，只有NULL和nullptr。</strong></p><p>NULL引渡自C语言，一般由宏定义实现，而nullptr则是C++11的新增关键字。在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0，编译器一般对其实际定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">#define NULL 0</span><br><span class="line">#else</span><br><span class="line">#define NULL ((void *)0)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>出现C++和C定义不一致的原因是，在C++中不允许(void*)类型进行隐式转换，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char* a =&quot; Hello&quot;;</span><br><span class="line"></span><br><span class="line">void foo(void* p)&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo(a);</span><br></pre></td></tr></table></figure></p><p>以上这种调用方式在C++中是不允许的，在C++中指针必须有明确的类型定义。如上需使用foo((char*)a)才可以;但是将NULL定义为0带来的另一个问题是无法与整数的零区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func(int data);</span><br><span class="line"></span><br><span class="line">void func(char* data);</span><br></pre></td></tr></table></figure><p>那么在传入NULL参数时，编译器将无法确定到底使用哪个函数定义，造成编译时错误。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。nullptr的一种实现方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const class nullptr_t&#123;</span><br><span class="line">public:</span><br><span class="line">    template&lt;class T&gt;  inline operator T*() const&#123; return 0; &#125;</span><br><span class="line">    template&lt;class C, class T&gt; inline operator T C::*() const &#123; return 0; &#125;</span><br><span class="line">private:</span><br><span class="line">    void operator&amp;() const;</span><br><span class="line">&#125; nullptr = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。但nullptr仍然存在一定问题，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun(char* p);</span><br><span class="line"></span><br><span class="line">void fun(int* p);</span><br></pre></td></tr></table></figure><p>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Video-based Sign Language Recognition without Temporal Segmentation</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-Video_based_Sign_Language_Recognition/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-Video_based_Sign_Language_Recognition/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>世界上具有上百万的聋哑患者使用手语进行交流，因此，实现从手语到自然语言的翻译是一件非常有意义的事情。目前，手语识别（SLR）问题主要由两量子问题组成：逐个单词进行识别的独立SLR、对整个句子进行翻译的连续SLR。 目前现有的连续SLR方法基本上都是用独立SLR作为基本模块, 同时结合额外的预处理和后处理操作来实现, 这里的预处理一般是指时域分割,后处理指句子合成. 但是, 时域分割问题本身的误差不可避免就会不断的传递给后续的步骤, 更糟糕的是, 这种独立SLR模块需要经过十分费劲的标注过程来使得一段视频中每一个动作都有与之对应的单词标签. 光这一点就对数据集的获取造成了不小的阻碍.</p><p>为了解决这些困难和挑战, 作者就提出了一种新的连续手语识别模型框架, 将其命名为Hierarchical Attention Network with Latent Space(LS-HAN)(基于隐式空间的多级注意力网络), 这个网络框架可以免去时域分割的预处理过程.</p><p>LS-HAN有三部分组成:</p><ul><li>一个双流卷积神经网络: 用于生成视频的特征表示.</li><li>隐式空间: 用于建立视频与自然语言之间的语义联系(semantic gap)</li><li>多级的注意力网络: 基于隐式空间的识别网络</li></ul><h1 id="介绍——Introduction"><a href="#介绍——Introduction" class="headerlink" title="介绍——Introduction"></a>介绍——Introduction</h1><p>在SLR问题中的一个关键挑战在于表示肢体运动、手势和面部表情的关系描述器的设计。目前主要有两类：手工设计特征 和 基于CNN和特征提取方法。 本文欲计划设计一个双流的3D-CNN模型，用于对视频特征进行提取。</p><p>时域分割问题在连续SLR中是一个十分困难的问题。 普遍的解决思路是将连续的SLR解析成独立的单词进行识别，这样就需要解决时域分割问题。 由于需要翻译的动作十分多样，因此很难进行检测，同时，时域分割作为一个预处理步骤，会将分割误差传递给后续步骤。并且，对每个动作打标签也是一项很耗时的任务。</p><p>受到基于LSTM的视频描述工作的启发，我们利用一个等级式的注意力网络（Hierarchical Attention Network HAN）规避了时域分割问题。HAN是在考虑结构信息和注意力机制之后，对LSTM的一个扩展。大体思路是将整个视频流送入的HAN中，然后一个单词一个单词的将句子输出。 但是，HAN仅仅是通过前一个单词，来预测后一个单词的最大可能性，忽略了video和句子之间的关系。最终结果是，它可能会出现鲁棒性问题。<br>为了改善这个问题，本文引入隐式共建模型来挖掘视频和句子之间的关系。</p><p>一句话总结，本文主要的贡献点有以下三个：</p><ul><li>一个新的双流3D CNN，用于生成全局和局部的视频特征表征</li><li>一个新的LS-HAN框架，可以规避连续SLR中的时域分割问题</li><li>对提出的LS-HAN框架中的相关性损失函数和分辨损失函数进行联合优化</li><li>编辑了目前最大的针对连续SLR问题的现代汉语手语识别数据集</li></ul><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><h2 id="连续SLR"><a href="#连续SLR" class="headerlink" title="连续SLR"></a>连续SLR</h2><p>大多数现有的SLR研究都是针对独立SLR来做, 有点类似于动作识别。更具挑战性的问题是连续SLR的研究。大多数现有的连续SLR方法都将句子级别的识别分为以下三个阶段：视频时域分割，独立单词识别，基于语言模型的句子融合。例如，DTW-HMM提出了一个基于粗粒度时域分割的阈值矩阵。2017年提出了一个新的基于HMM的语言模型。最近，transitional movements吸引了很多的关注，因为它们可以当作时域分割的基础。</p><p>尽管采用时域分割很普遍，但是时域分割问题本质上是很难解决的：因为手语之间的过度动作transitional movements在识别时，依然显得很脆弱和混乱。更糟糕的是, 将连续的SLR任务转化为独立的SLR任务, 需要对大量的数据进行标注, 这是很耗时耗力的.</p><h2 id="视频描述生成"><a href="#视频描述生成" class="headerlink" title="视频描述生成"></a>视频描述生成</h2><p>图像描述生成是一个相关的研究领域，它通过描述视频序列中的场景/物体/动作来生成一段简单的话。一个流行的方法是序列到序列，视频到文本的方法，它将两个LSTM置于CNN之上。 还有的文章使用注意力机制来自动选择可能性最大的帧. 还有其他更多关于LSTM的扩展。</p><p>抛开视频描述生成和手语翻译在目标和技术手段上的一些相似之处，二者依然是两个完全不同的任务。前者仅仅是对输入视频的一个简单的总结, 但是后者必须要在语义层面上建立视频与自然语言之间的联系. ( 如对于同一段视频, 前者输出一个人在比划手势是正确的输出, 而后者必须输出这个人比划的收拾的具体含义)</p><h2 id="基于潜在空间的学习"><a href="#基于潜在空间的学习" class="headerlink" title="基于潜在空间的学习"></a>基于潜在空间的学习</h2><p>潜在空间模型是一个用来在不同模态的语义鸿沟之间建立联系的流行的工具。 例如, 有文章使用隐式空间和LSTM结合进行联合学习, 将其用于生成视频描述.</p><h1 id="手语视频特征表示"><a href="#手语视频特征表示" class="headerlink" title="手语视频特征表示"></a>手语视频特征表示</h1><p>手语视频主要由身体的上半部分决定，尤其是手势动作。识别手势动作的主要挑战是手的形态和方向具有很强的不确定性, 由此会组合出大量不同的手势动作。</p><p>受到最近深度学习技术在目标检测任务上的进展，我们提出了一个双流的3D CNN模型，用于生成视频特征的表征。这个3DCNN模型会同时接受整个视频帧和剪裁后的手势图像，并且独立的送到两个流中去，最终会通过一个融合机制，将它们融合在一起。因此，这个模型可以提取出整体信息和局部信息的特征编码。</p><h2 id="手势检测和跟踪"><a href="#手势检测和跟踪" class="headerlink" title="手势检测和跟踪"></a>手势检测和跟踪</h2><p>我们首先用fasterrcnn预训练了VOC2007数据，然后，从CSL中选取了400帧进行finetune。之后，所有的视频都逐帧处理。</p><p>当手的性状变化很大, 或者被衣服遮挡时, faster rcnn的检测可能会失败, 因此,使用了compressive tracking</p><h2 id="双流3D-CNN"><a href="#双流3D-CNN" class="headerlink" title="双流3D CNN"></a>双流3D CNN</h2><p>本文基于 C3D（Tran et al 2015） 设计了一个3D CNN双流模型, 该模型将一段手语动作等分成16帧, 并从中提取相应的时序特征. 模型的输入是一串视频截图（16帧）。模型中的上行流被设计用来提取全局手部位置和移动(global hand locations/motions), 缩放到227×227.  下行流关注局部手势信息, 输入是剪裁后的图片(227×227). 这里的这个局部信息就是跟踪两只手, 然后在两只手上画bounding box, 最后将两只手的特征信息按照多通道的方式添加在一起, 送入网络当中. 不管是上行流还是下行流, 他们的网络结构都是一样的, 包含8个卷积层和5个池化层. 最后是两个全连接层, 上行流和下行流的特征图谱会在这里结合.</p><p>双流CNN模型首先会对独立的SLR数据集进行预训练。训练完以后会把网络的softmax和最后一层fully connected layer都拿掉. (也就是说我们要的只是前面的卷积网络特征提取器, 深度学习, 说白了, 就是特征学习, 留下最后一层全连接层, 主要是为了将多维度的卷积特征图谱转换成一个一维向量, 方便后面的流程). 这个全连接层上面有4096个神经元, 因此, 最后输出的就是一个4096长度的一维向量.</p><p>上面的整个过程就可以看做是用一个滑动窗口在时间维度上对视频流不断的截图, 然后将截图源源不断的送入到神经网络当中, 目的是为了获取每一种视频截图的特征表征, 由于采用了这种双流结构, 因此这种特征表征结合了全局和局部信息(全局就是手移动的轨迹和位置, 局部就是手具体做了什么动作), 某种程度上可以认为是将当前的视频截图编码成了一个4096维的特征向量, 这个特征向量可以高度概括这一帧当中的信息, 最终, 一整段视频就会被编码一连串的4096为的向量, 最终就成了一个n×4096为的特征矩阵, n就是总共截取的帧数.</p><h2 id="LS-HAN-Model"><a href="#LS-HAN-Model" class="headerlink" title="LS-HAN Model"></a>LS-HAN Model</h2><p>HAN(Hierarchical Attention Network) 是LSTM的一种扩展, 主要针对输入数据使用了注意力机制. 模型的损失函数同时考虑了视频与句子之间的相关性误差 $E_r$, 以及HAN的识别误差 $E_c$.</p><script type="math/tex; mode=display">\min_{\theta_r, \theta_c} \frac{1}{N}</script><p>上式中, N 代表了训练集中的实例数量, $V^{(i)},S^{(i)}$ 代表第 $i$ 个视频实例(注意这里不是截图)和句子, $\theta_r, \theta_c$ 分别代表隐式空间和HAN的参数. R是正则项. $\lambda_1, \lambda_2$ 用于调节这三项的权重占比. 下面对这个损失函数的每一项具体介绍</p><h2 id="视频和句子之间的隐式空间"><a href="#视频和句子之间的隐式空间" class="headerlink" title="视频和句子之间的隐式空间"></a>视频和句子之间的隐式空间</h2><p>如图2所示，我们模型框架的输入是视频和对应标注好的句子。视频用提取到的global-local特征表示，句子中的每一个单词都用one hot向量表示。我们令视频为 $V=(v_1,v_2,…,v_n)$, 令句子为 $S=(s_1,s_2,…,s_m)$, 这里每一个 $v_i$ 都代表的是视频中的一个截图的特征向量, n表示总共的截图数量, $s_i$ 表示句子中的每一个单词的one-hot向量,m为单词数目.</p><p>隐式空间的目标就是构建一个”空间”, 在这个空间里面, 可以建立起视频截图特征向量和句子单词onehot向量之间的联系, 也就是说, 我们要将 $V$ 和 $S$ 映射到同一个隐式空间中去, 于是, 映射后的视频截图和句子可以表示成: $f_v(V) = (v_1’, v_2’, …,v_n’)$ 和  $f_s(S) = (s_1’, s_2’,…,s_m’)$ 这里, $f_v$ 和 $f_s$ 分别对应这一个映射函数, 可以用矩阵表示:</p><script type="math/tex; mode=display">f_v(x) = T_vx, f_s(x) = T_s x</script><p>其中, 权重矩阵 $T_v \in R^{D_s\times D_c}$, $T_s \in R^{D_s\times D_w}$, $D_s$ 就是隐式空间的维度.</p><p>接下来, 我们就需要衡量 $f_v(V)$ 和 $f_s(S)$ 之间的相关程度. 用DTW(Dynamic Time Warping)算法来找到最小的累加和距离,同时还会考虑时域的路径. (因为视频片段和word基本是一一对应的)</p><script type="math/tex; mode=display">D[i,j] = min(D[i-1, j], D[i-1, j-1]) + d(i,j)</script><script type="math/tex; mode=display">d(i,j) = \|T_vv_i - T_s s_j\|_ 2</script><p>上式中, $D[i,j]$ 代表了 $(v_1’,…v_i’)$ 和 $(s_1’,…s_j’)$ 的距离, 而$d(i,j)$ 则代表了 $v_i’$ 和 $s_j’$ 之间的距离(二范式).</p><p>于是, 我们将视频实例和一个句子之间的损失定义为:</p><script type="math/tex; mode=display">E_r(V,S;\theta_r) = D(n,m)</script><p>上面的DTW算法有一个假设前提, 那就是如果句子中的单词出现在前面, 那么与这个单词对应的视频片段也应该出现在前面. 正常来说这样的假设不是特别合理, 比如说对于视频描述这个任务来说, 这个假设就很不合适, 但是手语识别他有自身的特殊性, 在进行短句子的手语动作时, 这种假设是可行的, 而这篇文章使用的数据集中的句子都不超过10个词, 所以这里我们就暂时认为这个假设是对的吧.</p><p>上面还有个warping path的概念, 实际上就调整视频和句子之间的对齐程度.</p><p>上面公式的具体实现不是贪心, 而是基于回溯的, 所以最后找到的就是最小的.</p><p>隐式空间的目标是建立连接语义鸿沟的空间。 将视频截图和句子映射到同一个隐式空间中。</p><p>Dynamic Time Warping（DTW）算法：衡量 $f_v 和 f_s$之间的相关性。</p><h2 id="Recognition-with-HAN"><a href="#Recognition-with-HAN" class="headerlink" title="Recognition with HAN"></a>Recognition with HAN</h2><p>受到最近sequence to sequence模型的启发，识别问题可以看作是在给定video的情况下，求句子的log条件分布率的估计。（LSTM）。</p><p>首先，输入帧序列通过隐式空间进行编码，然后，根据每一个帧序列的特征向量来预测对应的单词。 扩展HAN中的编码器使其能够反应多级结构(从clips到word, 或者从word到clips)，同时引入注意力机制。</p><p>如图4所示, 蓝色的输入分别代表隐式空间中的clips序列特征和words序列特征. 可以看出, 该模型包含两个编码器和一个解码器。每一个编码器都是一个带有注意力机制的 bidirectional LSTM，而解码器一个单独的LSTM。 clip编码器将视频截图编码，使其对齐到单词向量上。如图5所示, 本文在经验上选取了3种对齐机制：（实验证明3比较好，因为本文选择3）</p><ol><li>将clips分成两个子序列 (总共就两个word)</li><li>每两个clips分出一个子序列 (总共有L/2个word)</li><li>均分出7个子序列（因为在训练集中的句子平均含有7个单词）。</li></ol><p>经过编码以后, 会生成对应的特征表示向量, 然后就需要进行解码, 在解码的时候我们是知道标注的真实句子信息的, 首先 #START 表示开始符号, 根据隐式向量的特征表示, LSTM会先预测第一个单词 $y_1$, 然后, 继续用LSTM在当前处的输出 $h_t$ 和第一个真实单词’the’的onehot向量来预测第二个单词, 就是这样一直下去, 直到遇到#END为止. 用Softmax函数在输入为 $h_t$ 下条件下输出 $y_t$ 的概率 (概率最大的那个就是当前cell的输出):</p><script type="math/tex; mode=display">p(y_t | h_t)</script><p>这一部分的损失函数为(这里这个是log损失函数, 如果预测结果是正确项的条件概率越接近于1, 则log对应项就越小):</p><script type="math/tex; mode=display">E_c(V,S;\theta_r, \theta_c)</script><h2 id="Learning-and-Recognition-of-LS-HAN-Model"><a href="#Learning-and-Recognition-of-LS-HAN-Model" class="headerlink" title="Learning and Recognition of LS-HAN Model"></a>Learning and Recognition of LS-HAN Model</h2><p>最终, 我们的损失函数可以写成下面这样:</p><script type="math/tex; mode=display">\min_{T_v,T_s,\theta}</script><p>在进行训练优化时, 分别对隐式空间的参数 $T_v, T_s$ 和HAN的参数 $\theta$ 求偏导</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>总共有两个开源数据，一个是CSL，另一个是德国手语数据集RWTH-PHONEIX-Weather。</p><p>CSL包含25k个标注的视频实例，总共超过100小时，共50位手语者。17K用于训练，2K用于验证，6K用于测试。每一个视频实例都会与一个完整的句子相关联.</p><p>RWTH-PHONEIX-Weather包含7K天气预测的句子，共9位手语者。</p><p>所有的视频均为25帧每秒，分辨率为210×260 。 5672用于训练, 540用于验证, 629用于测试.</p><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><p>每一段视频都会被分成16帧, 要么缩放, 要么裁剪, 输入大小为 227×227. 输出是4096长度的一维向量, 正如前面介绍的那样.</p><h2 id="Evaluation-Metircs-评价标准"><a href="#Evaluation-Metircs-评价标准" class="headerlink" title="Evaluation Metircs 评价标准"></a>Evaluation Metircs 评价标准</h2><script type="math/tex; mode=display">Accuracy = 1 - \frac{S + I + D}{N} \times 100%</script><p>上式中, SID分别代表将预测句子转换成真实句子所需要的最少的替换(substitution), 插入(insertion)和删除(deletion)操作, N代表句子的真实长度. 注意, 由于这三种操作都会降低准确率, 因此准确率是有可能为负值的</p><p>(顺便我还感觉这个评价标准也太粗糙了, 感觉不是精心设计过的标准, 但是貌似还有人用, 而且一般好的实验都是会用很多不同标准横向纵向去比较的, 所以我感觉作者只用这一个评价标准, 要么就是手语识别没有特别好, 特征规范的通用标准, 要么就是作者在别的标准上表现不好, 这个表现我也没太查到, 所以也只是猜测.).</p><h2 id="实验结果和分析"><a href="#实验结果和分析" class="headerlink" title="实验结果和分析"></a>实验结果和分析</h2><p>先来看表2, 因为本文的方法主要是基于LSTM来做的, 因此, 第一部分是各种LSTM的变种方法, 这些变种方法基本都不是用来解决手语识别问题的, 所以精度差是自然的(我也不知道作者为啥要这么比, 感觉有点不公平).</p><p>再看第二部分, 第二部分确确实实都是针对手语识别问题, 而且都是针对连续手语识别问题, 但是这些方法居然比第一部分的还低, 这我就有点搞不懂了, 然后我看到这个年份, 我就感觉这个数据怎么这么奇怪啊, 07年到14年这都7年的时间就提升了0.01,  我就感觉匪夷所思. 我感觉这篇文章整个的模型结构和设计思路还是挺不错的, 但是这个实验部分就真的支撑数据让人有点不信服.</p><p>表3: 这个表3看起来勉强还行, 是和最近发表的paper方法比较的, 这个精度提升确实不高.</p><h2 id="HAN和LS的关系"><a href="#HAN和LS的关系" class="headerlink" title="HAN和LS的关系"></a>HAN和LS的关系</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《C++ PrimerPlus》 第十四章</title>
      <link href="/z_post/Cpp-Book-CppPrimerPlusChapter14/"/>
      <url>/z_post/Cpp-Book-CppPrimerPlusChapter14/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四章-C-中的代码重用"><a href="#第十四章-C-中的代码重用" class="headerlink" title="第十四章 C++中的代码重用"></a>第十四章 C++中的代码重用</h1><p>除了公有继承之外，还有其他促进代码重用的方法：</p><ul><li>包含/组合/层次话：在类中使用另一个类的对象做成员</li><li>私有或保护继承：用于实现has-a关系，即新的类将包含另一个类的对象</li></ul><h2 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h2><p>string类</p><p>valarray类：这是一个模板类</p><h2 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h2><p>另一种实现has-a关系的途径——私有继承。</p><p>使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。</p><p>“包含”是将对象作为一个命名的成员添加到类中，而“私有继承”将对象作为一个未被命名的继承对象添加到类中。</p><ol><li>初始化基类组件，对于继承类，需要使用成员初始化列表语法，使用类名而不是成员名称来标识构造函数。</li><li>访问基类的方法：可以通过将私有的成员函数包含在一个公有函数中来访问该私有方法。</li><li>访问基类对象：通过this指针和强制类型转换来创建对应的对象或引用</li><li>访问基类的友元函数：用类名显式的限定函数名不适合友元函数，这是因为友元不属于类。然而，可以通过显式的转换为基类来调用正确的函数。</li></ol><h3 id="14-2-2-使用包含还是私有继承。"><a href="#14-2-2-使用包含还是私有继承。" class="headerlink" title="14.2.2 使用包含还是私有继承。"></a>14.2.2 使用包含还是私有继承。</h3><p>通常，应使用包含来建立has-a关系。如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。</p><h3 id="14-2-3-保护继承"><a href="#14-2-3-保护继承" class="headerlink" title="14.2.3 保护继承"></a>14.2.3 保护继承</h3><p>保护继承是私有继承的变体。使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。</p><p>当从派生类派生出另一个类时，私有继承和保护继承之间的区别在于：</p><p>使用私有继承时，第三代类将不能使用基类的接口，这是因为继承的公有方法在派生类中将变成私有方法。使用保护继承时，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。</p><p><strong>各种继承方式</strong>:</p><div class="table-container"><table><thead><tr><th>特征</th><th>公有继承</th><th>保护继承</th><th>私有继承</th></tr></thead><tbody><tr><td>公有成员变成</td><td>派生类的公有成员</td><td>派生类的保护成员</td><td>派生类的私有成员</td></tr><tr><td>保护成员变成</td><td>派生类的保护成员</td><td>派生类的保护成员</td><td>派生类的私有成员</td></tr><tr><td>私有成员变成</td><td>只能通过基类接口访问</td><td>只能通过基类接口访问</td><td>只能通过基类接口访问</td></tr><tr><td>能否隐式向上转换</td><td>能</td><td>能（但只能在派生类中）</td><td>否</td></tr></tbody></table></div><p>隐式向上转换（implicit upcasting）：意味着无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。</p><h3 id="14-2-4-使用using重新定义访问权限"><a href="#14-2-4-使用using重新定义访问权限" class="headerlink" title="14.2.4 使用using重新定义访问权限"></a>14.2.4 使用using重新定义访问权限</h3><p>使用保护派生或私有派生时，基类的公有成员将成为保护成员或私有成员。假设要设即为的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法。</p><p>另一种方法是，将函数调用包装在另一个函数调用中，即使用一个using声明来指出派生类可以使用特定的基类成员，即使采用的是私有派生。例如，假设希望通过Student类能够使用valarray的方法min()和max()，可以如下书写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student: private std::string, private std::valarray&lt;double&gt;&#123;</span><br><span class="line">  public:</span><br><span class="line">  using std::valarray&lt;double&gt;::min;</span><br><span class="line">  using std::valarray&lt;double&gt;::max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：using声明只使用成员名——没有圆括号、函数特征表和返回类型。</p><p>有一种老式的不带using声明的方法，它看起来就像是不包含关键字using的using声明，但是这种方法已被摒弃，即将体制使用。</p><h2 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h2><p>MI描述的是有多个直接基类的类，与单继承一样，公有MI表示的也是is-a关系。例如，可以从Waiter类和Singer类派生出SingingWaiter类。</p><p>私有MI和保护MI可以表示has-a关系。</p><p>MI可能会带来很多新问题，其中最重要的问题是：</p><ul><li>从两个不同的基类继承同名方法;</li><li>从两个或更多相关基类那里继承同一个类的多个实例。</li></ul><h3 id="14-3-1-有多少个Work"><a href="#14-3-1-有多少个Work" class="headerlink" title="14.3.1 有多少个Work"></a>14.3.1 有多少个Work</h3><p>如果多个类来自于同一个基类，而当前类又继承这多个类，那么，就会有多个最原始的基类副本，者造成了二义性。</p><p>为了解决以上问题，C++引入了一种新技术——虚基类（virtual base calss），使MI成为可能。</p><ol><li>虚基类：虚基类使得从多个类（它们的基类相同）派生出的对象之只继承一个基类对象。</li><li>新的构造函数规则：使用虚基类时，需要对类构造函数采用一种新的方法。对于非虚基类，唯一可以出现在初始化列表中的构造函数是即时基类构造函数。但这些构造函数可能需要将信息传递给其基类。（详细请看p558）</li></ol><h3 id="14-3-2-哪个方法"><a href="#14-3-2-哪个方法" class="headerlink" title="14.3.2 哪个方法"></a>14.3.2 哪个方法</h3><p>因为多重继承，有时会继承多个同名方法，因此，需要指出使用哪一个方法。</p><p>可以使用作用域解析运算符来指定使用的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SingingWaiter <span class="title">newhire</span><span class="params">(<span class="string">"Elise"</span>, <span class="number">2005</span>, <span class="number">6</span>, soprano)</span></span>;</span><br><span class="line">newhire.Singer::Show();</span><br></pre></td></tr></table></figure></p><p>然而，更好的方法是在SingingWaiter中重新定义<code>Show()</code>，并指出要使用哪个<code>Show()</code>。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SingingWaiter::Show()&#123;</span><br><span class="line">  Singer::Show;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于多继承，使用模块化的方式而不是递增方式来在派生类的同名函数中使用基类函数，即提供一个只显示Work组件的方法和一个只显示Waiter组件 <strong>或</strong> Singer组件的方法。然后，在<code>SingingWaiter::Show()</code>方法中将组件组合起来。详细见p559。</p><p><strong>总结：</strong> 在祖先相同时，使用MI必须引入虚基类，并修改构造函数初始化列表的规则。</p><p>下面介绍一些有关MI的问题。</p><ol><li>混合使用虚基类和非虚基类</li></ol><p>当类通过多条虚途径和非虚途径继承某个特定的基类时，该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。</p><ol><li>虚基类和支配</li></ol><p>派生类中的名称优先于直接或间接祖先类中的相同名称。</p><p>如果无法用优先规则判断出使用哪个名称，则会导致二义性。</p><h2 id="14-4-类模板"><a href="#14-4-类模板" class="headerlink" title="14.4 类模板"></a>14.4 类模板</h2><p>C++的类模板为生成通用的类声明提供了一种更好的方法（C++最初不支持模板，单模板被引入后，就一直在演化，因此有的编译器可能不支持这里的所有特性）。模板提供参数化（parameterized）类型，即能够将类型名作为参数传递给接收方来建立类或函数。</p><p>C++库提供了多个模板类，如vector、array、valarray等等。</p><h3 id="14-4-1-定义类模板"><a href="#14-4-1-定义类模板" class="headerlink" title="14.4.1 定义类模板"></a>14.4.1 定义类模板</h3><p>模板类以下面这样的代码开头：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里使用<code>class</code>并不意味着Type必须是一个类，而只是表明Type是一个通用的类型说明符，在使用模板时，将使用时间的类型替换它。较新的C++实现推荐使用关键字<code>typename</code>来代替<code>class</code>。</p><p>当模板被调用时，<code>Type</code>将被具体的类型值（如<code>int</code>或<code>string</code>）取代。</p><p>同样，可以使用模板成员函数替换原有类的类方法，每个函数头都将以相同的模板声明打头（如果在类声明中定义了方法，即内联定义，则可以省略模板前缀和类限定符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool Stack&lt;T&gt;::push(const T&amp; item)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong> 模板声明本身并不是类和成员函数，它们属于C++编译器指令，说明了如何生成对应的类和成员函数定义。而模板的具体实现则被称为实例化（instantiation）或具体化（specialization）。</p><p>不能将模板成员函数放在独立的实现文件中（以前，C++标准确实提供了关键字export，让您能够将模板成员函数放在独立的实现文件中，但支持该关键字的编译器不多，C++11不再这样使用export，而是将其保留用于其他用途）。 由于模板不是函数，它们不能单独编译，模板必须与特定的模板实例化请求一起使用。为此，最简单的方法是就所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。</p><h3 id="14-4-2-使用模板类"><a href="#14-4-2-使用模板类" class="headerlink" title="14.4.2 使用模板类"></a>14.4.2 使用模板类</h3><p>可以用所需的具体类型替换泛型名，就可以声明一个类型为模板类的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">int</span>&gt; kernels;</span><br><span class="line">Stack&lt;<span class="built_in">string</span>&gt; colonels;</span><br></pre></td></tr></table></figure><p>注意，必须显式的提供所需的类型，这与常规的函数模板是不同的，因为编译器可以根据函数的参数类型来确定要生成哪种函数。</p><h3 id="14-4-3-深入探讨模板类"><a href="#14-4-3-深入探讨模板类" class="headerlink" title="14.4.3 深入探讨模板类"></a>14.4.3 深入探讨模板类</h3><p>关于使用指针在作为Stack<t>的类型，比如用字符指针替换string来作为T类型。这样会带来一些问题。</t></p><ul><li><code>char* s</code>：单纯的<code>char* s</code>并没有给<code>s</code>分配合适的空间，这会使<code>s</code>的值存在某些不合适的内存单元中</li><li><code>char s[40]</code>：这虽然分配了空间，但是s的大小固定，且s本身是数组名，虽然代表地址，但是无法进行运算，有些操作会引起冲突。</li><li><code>char* po = new char[40]</code>：这次分配了空间，<code>po</code>也成为了变量，但仍有问题，具体看p573。</li></ul><p>但是并不是说不能使用指针作为T，只是在使用时，需要多家注意，考虑谨慎。</p><h3 id="14-4-4-数组模板示例和非类型参数"><a href="#14-4-4-数组模板示例和非类型参数" class="headerlink" title="14.4.4 数组模板示例和非类型参数"></a>14.4.4 数组模板示例和非类型参数</h3><p>使用非类型参数来说模板达到某些目的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ArrayTP&lt;<span class="keyword">double</span>,<span class="number">12</span>&gt; one;</span><br><span class="line">ArrayTP&lt;<span class="keyword">double</span>,<span class="number">13</span>&gt; two;</span><br></pre></td></tr></table></figure><p>表达式参数方法的主要缺点是，每组数组的大小都将生成自己的模板，而利用构造函数的方法只会生成一个类声明，并将数组大小信息传递给类的构造函数，详细见p578。</p><h3 id="14-4-5-模板多功能性"><a href="#14-4-5-模板多功能性" class="headerlink" title="14.4.5 模板多功能性"></a>14.4.5 模板多功能性</h3><p>可以将常规类的技术用于模板类，模板类可以用作基类，也可用作组件类，还可用作其他模板的类型参数。</p><ol><li>递归使用模板</li></ol><ol><li>使用多个类型参数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T1 a;</span><br><span class="line">  T2 b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">T1&amp; <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T2&amp; <span class="title">second</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>默认模板参数</li></ol><p>可以为类型参数提供默认值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span> = <span class="title">int</span>&gt; <span class="title">class</span> <span class="title">Topo</span>&#123;</span>...&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="14-4-6-模板的具体化"><a href="#14-4-6-模板的具体化" class="headerlink" title="14.4.6 模板的具体化"></a>14.4.6 模板的具体化</h3><p>模板以泛型的方式描述类，而具体化是使用具体的类型生成类声明。</p><ol><li>隐式实例化（implicit instantiation）</li></ol><p>&emsp;&emsp;声明一个或多个对象，指出所需的类型，编译器使用通用模板提供的处方生成具体的类定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt; stuff;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译器在需要对象之前，不会生成类的隐式实例化，如下面的代码，第二条语句才会使编译器生成类定义，并根据定义创建一个对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="keyword">double</span>, <span class="number">30</span>&gt; *pt;</span><br><span class="line">pt = <span class="keyword">new</span> ArrayTP&lt;<span class="keyword">double</span>, <span class="number">30</span>&gt;;</span><br></pre></td></tr></table></figure></p><ol><li>显式实例化（explicit instantiation）</li></ol><p>&emsp;&emsp;当使用关键字<code>template</code>并指出所需类型来声明类时，编译器将生成类声明的显式实例化。在这种情况下，孙然没有创建或提及类对象，编译器也将生成类声明（包括方法定义）。和隐式实例化一样，也将根据通用模板来生成具体化。（<strong>这里没搞懂</strong>）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span>&lt;string, 100&gt;;</span></span><br></pre></td></tr></table></figure></p><ol><li>显式具体化（explicit specialization）</li></ol><p>&emsp;&emsp;显式具体化是特定类型（用于替换模板中的泛型）的定义。有时候，可能需要在为特殊类型实例化时，对模板进行修改，使其行为不同。在这种情况下，可以创建显式具体化。（<strong>这块也没看懂</strong>）</p><p>&emsp;&emsp;另外，假设模板是用<code>&gt;</code>运算符来对值进行比较，对于数字，管用。如果T表示一个type，则只要定义了<code>T::operator&gt;()</code>方法，这也管用。但如果T是由<code>const char*</code>表示的字符串，这将不管用。实际上，模板倒是可以正常工作，但字符串将按地址（按照字母顺序）排序。这要求类定义使用<code>strcmp()</code>，而不是<code>&gt;</code>来对值进行比较。</p><ol><li>部分具体化（partial specialization）</li></ol><p>&emsp;&emsp;C++允许部分具体化，即部分限制模板的通用性。例如，可以给类型参数之一指定具体类型，下面的代码将T2具体化为int，但T1保持不变：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//general template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">class</span> <span class="title">Pair</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="comment">//specialization with T2 set to int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt; <span class="title">class</span> <span class="title">Pair</span>&lt;T1, int&gt; &#123;</span>...&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="14-4-7-成员模板"><a href="#14-4-7-成员模板" class="headerlink" title="14.4.7 成员模板"></a>14.4.7 成员模板</h3><p>模板可用作结构、类或模板类的成员。要完全实现STL的设计，必须使用这项特性。</p><h3 id="14-4-8-将模板作为参数"><a href="#14-4-8-将模板作为参数" class="headerlink" title="14.4.8 将模板作为参数"></a>14.4.8 将模板作为参数</h3><p>模板除了可以包含类型参数（<code>typename T</code>）和非类型参数（<code>int n</code>）之外，还可以包含本身就是模板的参数，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Thing</span>&gt; <span class="title">class</span> <span class="title">Crab</span></span></span><br><span class="line"><span class="class">//其中，<span class="title">template</span>&lt;typename T&gt;<span class="title">class</span>是类型，<span class="title">Thin</span>是参数</span></span><br></pre></td></tr></table></figure></p><h3 id="14-4-9-模板类和友元"><a href="#14-4-9-模板类和友元" class="headerlink" title="14.4.9 模板类和友元"></a>14.4.9 模板类和友元</h3><p>模板类声明也可以有友元。模板的友元分三类：</p><ol><li>非模板友元</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HasFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>; <span class="comment">//(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(HasFriend &amp;)</span></span>; <span class="comment">//(2) 错误</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;T&gt; &amp;)</span></span>; <span class="comment">//(3) 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中的（1）式在模板中将一个常规函数声明为友元，该声明使<code>counts()</code>函数成为模板所有实例化的友元，<code>counts()</code>函数不是通过对象调用的（它是友元，不是成员函数），也没有对象参数。它通过以下几种方式访问<code>HasFriend</code>对象：访问全局对象;使用全局指针访问非全局对象;创建自己的对象;访问独立于对象的模板类的静态数据成员。如果要为友元函数提供模板类参数，则不能通过（2）式来达到目的，原因是不存在<code>HasFriend</code>这样的对象，而只有特定的具体化，如<code>HasFriend&lt;short&gt;</code>，这里<code>short</code>可以用<code>T</code>表示，因为参数传递时就会指明<code>T</code>的类型，因此，要提供模板类参数，必须指明具体化。</p><ol><li>约束（bound）模板友元，即友元的类型取决于类被实例化时的类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">reprot</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//（2）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriendT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">void</span> counts&lt;TT&gt;();</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;使友元本身成为模板，使累得每一个具体化都获得与友元匹配的具体化，包含三步：首先，在类定义之前声明每个模板函数，如（1）所示，然后，在函数中再次将模板声明为友元，声明中的<code>&lt;&gt;</code>指出这是模板具体化，对于<code>report()</code>，<code>&lt;&gt;</code>可以为空，因为可以从函数参数推断出如下模板类型参数：<code>HasFriendT&lt;TT&gt;</code>，也可以写完整：<code>report&lt;HasFriendT&lt;TT&gt; &gt; (HasFriendT&lt;TT&gt; &amp;)</code>。但<code>counts</code>函数没有参数，因此必须使用模板参数语法<code>&lt;TT&gt;</code>来指明具体化。最后一步是友元提供模板定义。</p><ol><li>非约束（unbound）模板友元，即友元的所有具体化都是类的每一个具体化的方式</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManyFriend</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(C&amp;, D&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于非约束友元，友元模板类型参数与模板类类型参数是不同的，如上代码所示。</p><h3 id="14-4-10-模板别名（C-11）"><a href="#14-4-10-模板别名（C-11）" class="headerlink" title="14.4.10 模板别名（C++11）"></a>14.4.10 模板别名（C++11）</h3><p>可以使用<code>typedef</code>为模板具体化指定别名：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define three typedef aliases</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>,12&gt; arrd;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 12&gt; arri;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>:<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,12&gt; arrst;</span><br><span class="line">arrd gollons;</span><br><span class="line">arri days;</span><br><span class="line">arrst months;</span><br></pre></td></tr></table></figure></p><p>C++11提供了一种新的可以简化上述任务的方法——使用模板提供一系列别名，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> arrtype = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T,<span class="number">12</span>&gt;;</span><br><span class="line"><span class="comment">//这将arrtype定义为一个模板别名，可以使用它来指定类型，如下所示</span></span><br><span class="line">arrtype&lt;<span class="keyword">double</span>&gt; gallons;</span><br><span class="line">arrtype&lt;<span class="keyword">int</span>&gt; days;</span><br><span class="line">arrtype&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; months;</span><br><span class="line"><span class="comment">//总之， arrtype&lt;T&gt; 就表示类型 std::array&lt;T,12&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《深入应用C++11——代码优化与工程级应用》</title>
      <link href="/z_post/Cpp-Book-%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8Cpp11/"/>
      <url>/z_post/Cpp-Book-%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8Cpp11/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-使用C-11让程序更简洁、更现代"><a href="#第一章-使用C-11让程序更简洁、更现代" class="headerlink" title="第一章 使用C++11让程序更简洁、更现代"></a>第一章 使用C++11让程序更简洁、更现代</h1><h2 id="1-1-类型推导"><a href="#1-1-类型推导" class="headerlink" title="1.1 类型推导"></a>1.1 类型推导</h2><p>C++11引入了<code>auto</code>和<code>decltype</code>关键字实现类型推导。</p><h3 id="1-1-1-auto类型推导"><a href="#1-1-1-auto类型推导" class="headerlink" title="1.1.1 auto类型推导"></a>1.1.1 auto类型推导</h3><p><strong>1、auto关键词的新意义</strong><br><code>auto</code> 可用于隐式类型定义。</p><p>不同于Python等动态类型语言（运行时才确定数据类型），隐式类型定义的类型推导发生在编译器。（C++是静态类型语言）</p><p>使用auto声明的变量必须立刻初始化，以让编译器推断出它的实际类型，并在 <strong>编译</strong> 时将auto占位符替换为真正的类型。</p><p><strong>2、auto的推导规则</strong></p><ul><li>当不声明为指针或引用时，auto的推导结果会将初始化表达式的引用和cv限定符抛弃</li><li>当声明为指针或引用时，auto的推导结果将保持初始化表达式的cv属性。</li></ul><p><strong>3、auto的限制</strong></p><ul><li>auto不能用于函数参数</li><li>auto不能用于非静态成员变量</li><li>auto无法定义数组</li><li>auto无法推导出模板参数</li></ul><p><strong>4、什么时候用auto</strong></p><ul><li>当类型的名称很长时，可以用auto简化代码</li><li>当不确定变量应用被定义成什么类型时，如泛型函数的参数类型。</li></ul><p><strong>注意：</strong> auto虽然好用，但是不应该过度使用，否则，会严重降低代码的可读性和可维护性。</p><h3 id="1-1-2-decltype"><a href="#1-1-2-decltype" class="headerlink" title="1.1.2 decltype"></a>1.1.2 decltype</h3><p><strong>1、获知表达式的类型</strong></p><p><code>decltype</code>关键字用于在编译时推导出一个表达式的类型，其语法格式为<code>decltype(exp)</code>，该关键字并不会真正计算表达式的值。</p><p><strong>2、decltype的推导规则</strong></p><ul><li>当exp是标识符、类访问表达式时，decltype(exp)和exp的类型一致</li><li>当exp是函数调用时，decltype(exp)和返回值的类型一致</li><li>其他情况，若exp是一个左值，则decltype(exp)是exp类型的左值 <strong>引用</strong> ，否则和exp类型一致。</li></ul><p><strong>3、decltype的实际应用</strong></p><p>decltype的应用多出现在泛型编程中。</p><p>decltype也经常用在通过变量表达式抽取变量类型上。</p><h3 id="1-1-3-返回类型后置语法——auto和decltype的结合使用"><a href="#1-1-3-返回类型后置语法——auto和decltype的结合使用" class="headerlink" title="1.1.3 返回类型后置语法——auto和decltype的结合使用"></a>1.1.3 返回类型后置语法——auto和decltype的结合使用</h3>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的左值、右值、右值引用解析</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC_%E5%8F%B3%E5%80%BC_%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC_%E5%8F%B3%E5%80%BC_%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h1><p>C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。</p><p>在C++11中可以取地址的的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，<code>int a = b+c</code>, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式<code>b+c</code>、函数<code>int func()</code>的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，<code>＆(b+c)</code>这样的操作则不会通过编译。</p><p>纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；</p><p><strong>左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址</strong></p><p>将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。右值引用本身就是一个xvalue。</p><h2 id="不能根据在等号左边还是右边来判断左值和右值"><a href="#不能根据在等号左边还是右边来判断左值和右值" class="headerlink" title="不能根据在等号左边还是右边来判断左值和右值"></a>不能根据在等号左边还是右边来判断左值和右值</h2><p>左值出现在等号右边的情况：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br></pre></td></tr></table></figure></p><p>右值出现在等号左边的情况（不能作为赋值的对象，赋值没有意义）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((i&gt;0) ? i : j) = 1;</span><br></pre></td></tr></table></figure></p><h1 id="右值、将亡值"><a href="#右值、将亡值" class="headerlink" title="右值、将亡值"></a>右值、将亡值</h1><p>在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。</p><p>将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p><h1 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h1><p>左值引用就是对一个左值进行引用的类型。右值引用（C++11新特性）就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p><p>右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</p><p>左值引用通常也不能绑定到右值，但 <strong>常量左值引用</strong> 是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int &amp;a = 2;       # 左值引用绑定到右值，编译失败</span><br><span class="line"></span><br><span class="line">int b = 2;        # 非常量左值</span><br><span class="line">const int &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line">const int d = 2;  # 常量左值</span><br><span class="line">const int &amp;e = d; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line">const int &amp;&amp;b =2;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure><p>右值引用本质上也是一种引用，只是它必须且只能绑定在右值上。由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：</p><ul><li>右值引用的对象，是临时的，即将被销毁</li><li>右值引用的对象，不会在其他地方使用</li></ul><p>这两个特性意味着：接受和使用右值引用的代码，可以自由的接管所引用对象的资源，而无需担心对其他代码逻辑造成数据破坏</p><p>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要<code>std::move()</code>将左值强制转换为右值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a=2;</span><br><span class="line">int b=1;</span><br><span class="line">int &amp;&amp;r1 = 3; //编译通过，右值引用可以绑定到字面常量上</span><br><span class="line">int &amp;&amp;r2 = a+b; //编译通过，右值引用可以绑定到临时变量上</span><br><span class="line">int &amp;&amp;r3 = a;             # 编译失败</span><br><span class="line">int &amp;&amp;r4 = std::move(a);  # 编译通过</span><br></pre></td></tr></table></figure><h2 id="右值引用本身是左值"><a href="#右值引用本身是左值" class="headerlink" title="右值引用本身是左值"></a>右值引用本身是左值</h2><p>右值引用本身是左值，通过下面的代码，我们发现，可以通过右值引用的名字得到他的地址，因此，右值引用本身就是左值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; r1 = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;r1;  <span class="comment">//编译通过，输出r1的地址</span></span><br></pre></td></tr></table></figure></p><p>下表列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。</p><p><img src="https://s1.ax1x.com/2018/09/02/Pxz8uF.png" alt="Pxz8uF.png"></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编译型语言、解释型语言、静态类型语言、动态类型语言的概念与区别</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h1><h2 id="1、编译型语言"><a href="#1、编译型语言" class="headerlink" title="1、编译型语言"></a>1、编译型语言</h2><p>需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。</p><p>优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。</p><p>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p><p>代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift</p><h2 id="2、解释型语言"><a href="#2、解释型语言" class="headerlink" title="2、解释型语言"></a>2、解释型语言</h2><p>解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。</p><p>优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</p><p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p><p>代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby</p><h2 id="3、混合型语言"><a href="#3、混合型语言" class="headerlink" title="3、混合型语言"></a>3、混合型语言</h2><p>既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行（博友回复指出）。</p><p>Java先生成字节码再在Java虚拟机中解释执行。</p><p>严格来说混合型语言属于解释型语言。C#更接近编译型语言。</p><h1 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h1><h2 id="1、动态语言"><a href="#1、动态语言" class="headerlink" title="1、动态语言"></a>1、动态语言</h2><p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p><p>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p><h2 id="2、静态语言"><a href="#2、静态语言" class="headerlink" title="2、静态语言"></a>2、静态语言</h2><p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p><h2 id="3、注意："><a href="#3、注意：" class="headerlink" title="3、注意："></a>3、注意：</h2><p>很多人认为解释型语言都是动态语言，这个观点是错的！Java是解释型语言但是不是动态语言，Java不能在运行的时候改变自己结构。反之成立吗？动态语言都是解释型语言。也是错的！Object-C是编译型语言，但是他是动态语言。得益于特有的run time机制（准确说run time不是语法特性是运行时环境，这里不展开）OC代码是可以在运行的时候插入、替换方法的。</p><p>C#也是动态语言，通过C#的反射机制可以动态的插入一段代码执行。</p><h1 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h1><h2 id="1、动态类型语言"><a href="#1、动态类型语言" class="headerlink" title="1、动态类型语言"></a>1、动态类型语言</h2><p>很多网上资料把动态类型语言和动态语言混为一谈，简直是误人子弟。动态类型语言和动态语言是完全不同的两个概念。动态类型语言是指在运行期间才去做数据类型检查的语言，说的是数据类型，动态语言说的是运行时改变结构，说的是代码结构。</p><p>动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。（Python只有到了运行时才能确定某一个变量的具体类型）</p><p>主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、Perl。</p><p>2、静态类型语言</p><p>静态语言的数据类型是在编译其间确定的或者说运行之前确定的，是在编译阶段就完成的，编写代码的时候要明确确定变量的数据类型。</p><p>主要语言：C、C++、C#、Java、Object-C。</p><h2 id="3、注意：-1"><a href="#3、注意：-1" class="headerlink" title="3、注意："></a>3、注意：</h2><p>相当一部分程序员，认为解释型语言都是动态类型语言，编译型语言都是静态类型语言。这个也是错的。swift是编译型语言但是它也是动态类型语言。C#和Java是解释型语言也是静态类型语言。</p><h1 id="强类型语言和弱类型语言"><a href="#强类型语言和弱类型语言" class="headerlink" title="强类型语言和弱类型语言"></a>强类型语言和弱类型语言</h1><h2 id="1、强类型语言："><a href="#1、强类型语言：" class="headerlink" title="1、强类型语言："></a>1、强类型语言：</h2><p>强类型语言，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型。你不能把一个整形变量当成一个字符串来处理。</p><p>主要语言：Java、C#、Python、Object-C、Ruby</p><h2 id="2、弱类型语言："><a href="#2、弱类型语言：" class="headerlink" title="2、弱类型语言："></a>2、弱类型语言：</h2><p>数据类型可以被忽略，一个变量可以赋不同数据类型的值。一旦给一个整型变量a赋一个字符串值，那么a就变成字符类型。</p><p>主要语言：JavaScript、PHP、C、C++（C和C++有争议，但是确实可以给一个字符变量赋整形值，可能初衷是强类型，形态上接近弱类型）</p><h2 id="3、注意：-2"><a href="#3、注意：-2" class="headerlink" title="3、注意："></a>3、注意：</h2><p>一个语言是不是强类型语言和是不是动态类型语言也没有必然联系。Python是动态类型语言，是强类型语言。JavaScript是动态类型语言，是弱类型语言。Java是静态类型语言，是强类型语言。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《剑指offer》</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-%E5%89%91%E6%8C%87offer/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p><h2 id="解法一-每一行用一次二分"><a href="#解法一-每一行用一次二分" class="headerlink" title="解法一: 每一行用一次二分"></a>解法一: 每一行用一次二分</h2><p><strong>时间复杂度:</strong> $O(nlogn)$ (该复杂度无法通过牛客OJ)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="built_in">array</span>[i].size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][mid]) low = mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][mid]) high = mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一行二分需要 logn 的时间, 总共有n行.</p><h2 id="解法二-从左下角开始"><a href="#解法二-从左下角开始" class="headerlink" title="解法二: 从左下角开始"></a>解法二: 从左下角开始</h2><p><strong>时间复杂度:</strong> $O(n)$</p><p>从左下角开始, 向右为大数方向, 向上为小数方向, 每次至少移动一位, 总共需要移动n次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, len = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][j]) j++;  <span class="comment">// target在大数方向</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][j]) i--;  <span class="comment">// target在小数方向</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="解法-从前向后记录空格，从后向前替换空格"><a href="#解法-从前向后记录空格，从后向前替换空格" class="headerlink" title="解法: 从前向后记录空格，从后向前替换空格"></a>解法: 从前向后记录空格，从后向前替换空格</h2><p><strong>时间复杂度:</strong>  $O(n)$</p><p>需要注意, 如果替换的空间超过了length的申请空间, 则需要重新申请空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> white_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> char_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> *s = str;</span><br><span class="line">        <span class="keyword">while</span>(*s!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*s == <span class="string">' '</span>) white_count++;</span><br><span class="line">            <span class="keyword">else</span> char_count++;</span><br><span class="line">            s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>* res_str = str;</span><br><span class="line">        <span class="keyword">if</span>(char_count + white_count*<span class="number">3</span> &gt;length)</span><br><span class="line">            res_str = <span class="keyword">new</span> <span class="keyword">char</span>[char_count+white_count*<span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> old_length = char_count+white_count+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> new_length = char_count+white_count*<span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(old_length &gt;=<span class="number">0</span> &amp;&amp; new_length &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[old_length] != <span class="string">' '</span>)&#123;</span><br><span class="line">                res_str[new_length--]=str[old_length--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                old_length--;</span><br><span class="line">                res_str[new_length--]=<span class="string">'0'</span>;</span><br><span class="line">                res_str[new_length--]=<span class="string">'2'</span>;</span><br><span class="line">                res_str[new_length--]=<span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str = res_str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h2 id="解法一-reverse"><a href="#解法一-reverse" class="headerlink" title="解法一: reverse"></a>解法一: reverse</h2><p><strong>时间复杂度:</strong>  $O(n)$<br><strong>空间复杂度:</strong>  $O(n)$</p><p>顺序访问, 然后将vector里面的元素逆置.  这两部操作时间复杂度皆为 $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-swap-实际上依然是reverse"><a href="#解法二-swap-实际上依然是reverse" class="headerlink" title="解法二: swap (实际上依然是reverse)"></a>解法二: swap (实际上依然是reverse)</h2><p><strong>时间复杂度:</strong>  $O(n)$<br><strong>空间复杂度:</strong>  $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (res.size()<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len = res.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;=mid;i++)</span><br><span class="line">            <span class="built_in">std</span>::swap(res[i], res[len-i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-栈"><a href="#解法三-栈" class="headerlink" title="解法三: 栈"></a>解法三: 栈</h2><p><strong>时间复杂度:</strong>  $O(n)$<br><strong>空间复杂度:</strong>  $O(2n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            res.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a>4.重建二叉树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p> <strong>首先需要注意一点的是: 这里前序和中序不能包含重复的元素, 否则无法确定前序和中序中节点的对应关系</strong></p><h2 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(<br><strong>空间复杂度:</strong></p><p>根据前序和中序的对应关系, 利用递归完成构建, 构建时, 先构建当前节点, 然后是左右子树.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(pre, <span class="number">0</span>, pre.size()<span class="number">-1</span>, vin, <span class="number">0</span>, vin.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre, <span class="keyword">int</span> pre_i, <span class="keyword">int</span> pre_j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vin, <span class="keyword">int</span> vin_i, <span class="keyword">int</span> vin_j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_i &gt; pre_j || vin_i &gt; vin_j) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode( pre[pre_i] ); <span class="comment">// 当前节点</span></span><br><span class="line">        <span class="keyword">int</span> v = vin_i;</span><br><span class="line">        <span class="keyword">while</span>(pre[pre_i] != vin[v]) v++; <span class="comment">//找到前序在中序中的对应节点, 这里可以用哈希表来改进查找的复杂度</span></span><br><span class="line">        node-&gt;left = helper(pre, pre_i+<span class="number">1</span>, pre_i+v-vin_i, vin, vin_i, v<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = helper(pre, pre_i+v-vin_i+<span class="number">1</span>, pre_j, vin, v+<span class="number">1</span>, vin_j);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; tree_stack;</span><br><span class="line">        <span class="keyword">if</span>(pre.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        tree_stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;pre.size() ; i++)&#123;</span><br><span class="line">            TreeNode * cur_node = tree_stack.top();</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;val != vin[index])&#123;</span><br><span class="line">                cur_node-&gt;left = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                tree_stack.push(cur_node-&gt;left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>( !tree_stack.empty() &amp;&amp; tree_stack.top()-&gt;val == vin[index])&#123; <span class="comment">// 注意, 这里不能用cur_node, 而必须用tree_stack.top()</span></span><br><span class="line">                    cur_node = tree_stack.top(); tree_stack.pop(); index++;</span><br><span class="line">                &#125;</span><br><span class="line">                cur_node-&gt;right = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                tree_stack.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h1><h1 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h1><h1 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.斐波那契数列</h1><script type="math/tex; mode=display">f(n) = \begin{cases} 0, & n=0 \\ 1, & n=1(或2) \\ f(n-1)+f(n-2), & n>2 \end{cases}</script><h2 id="解法一-递归-超时-超内存"><a href="#解法一-递归-超时-超内存" class="headerlink" title="解法一: 递归(超时,超内存)"></a>解法一: 递归(超时,超内存)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span> || number==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(number<span class="number">-1</span>)+jumpFloor(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-迭代-1"><a href="#解法二-迭代-1" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="number">1</span>, n2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n2;</span><br><span class="line">            n2 = n2+n1;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-迭代-2"><a href="#解法二-迭代-2" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><h1 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2 id="解法一-递归-超时-超内存-1"><a href="#解法一-递归-超时-超内存-1" class="headerlink" title="解法一: 递归(超时, 超内存)"></a>解法一: 递归(超时, 超内存)</h2><p>设n个台阶的跳法有 $f(n)$ 种, 当青蛙跳上一个台阶后, 剩下的走法就是只有n-1个台阶的走法, 因此就是 $f(n-1)$ , 同理, 如果当前跳了2个台阶, 那么剩下的就是f(n-2), 因此有以下公式:</p><script type="math/tex; mode=display">f(n) = \begin{cases} 1, & n=1 \\ 2, & n=2 \\ f(n-1) + f(n-2) & n>1 \end{cases}</script><p>从上可以看出, 这道题就是斐波那契数列的变种, 不同之处在于初始值不同(因为台阶为2时, 有两种跳法), 因此解法同上.</p><h2 id="解法二-迭代-3"><a href="#解法二-迭代-3" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=number; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=n2;</span><br><span class="line">            n2 = n2 + n1;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="解法一-递归-1"><a href="#解法一-递归-1" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>对于n个台阶, 可以跳1次, 2次, …., n次, 那么对应的剩下的台阶的跳法就有 $f(n-1), f(n-2), …, f(n-n)$ 种, 所以有下式:</p><script type="math/tex; mode=display">f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)</script><script type="math/tex; mode=display">f(n) = \begin{cases} 1, & n=0 \\ 1, & n=1 \\ 2*f(n-1), & n>=2 \end{cases}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jumpFloorII(number<span class="number">-1</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h1><p>对于 $n \times 2$ 大小的矩形, 可以竖着排列一个 $2\times 1$ 矩形, 或者横着排列上下两个 $2\times 1$ 的矩形, 那么对应的剩下的矩形面积就分别为 $(n-1) \times 2$ 和 $(n-2) \times 2$, 所以有下式:</p><script type="math/tex; mode=display">f(n) = \begin{cases} 1, & n=1 \\ 2, & n=2 \\ f(n-1) + f(n-2) & n>1 \end{cases}</script><h2 id="解法一-递归-超时"><a href="#解法一-递归-超时" class="headerlink" title="解法一: 递归(超时)"></a>解法一: 递归(超时)</h2><h2 id="解法二-迭代-4"><a href="#解法二-迭代-4" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="number">1</span>, n2=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=number; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n2;</span><br><span class="line">            n2 = n2+n1;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2 id="解法一-按位与-amp"><a href="#解法一-按位与-amp" class="headerlink" title="解法一: 按位与&amp;"></a>解法一: 按位与<code>&amp;</code></h2><p><strong>时间复杂度:</strong> $O(1)$, 因为最多比较32次(long为64次)<br><strong>空间复杂度:</strong> $O(1)$</p><p><strong>注意:</strong> <code>(n&amp;i)</code> 一定要带括号, 因为它的优先级比<code>==, !=</code> 等符号低.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>( i!=<span class="number">0</span> )&#123;</span><br><span class="line">             <span class="keyword">if</span>( (n&amp;i) != <span class="number">0</span>) count++; <span class="comment">// 注意, 这里的判断条件是 !=0, 并且 n&amp;i 一定要带括号</span></span><br><span class="line">             i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法二-n-amp-n-1"><a href="#解法二-n-amp-n-1" class="headerlink" title="解法二: n&amp;(n-1)"></a>解法二: <code>n&amp;(n-1)</code></h2><p>一个整数 $n$, 将其与 $n-1$ 按位逻辑与, 得到的数刚好是将 $n$ 最右边的1置为0(其他位不变), 那么一个数有多少个1, 就可以进行多少次这样的操作.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">             n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">             count++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2 id="解法一-递归-2"><a href="#解法一-递归-2" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>当n为偶数时: $x^n = x^{n/2} \times x^{n/2}$<br>当n为奇数时: $x^n = x\times x^{n/2} \times x^{n/2}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">return</span> (un%<span class="number">2</span>==<span class="number">0</span>) ? myPow(x*x, un/<span class="number">2</span>) : x*myPow(x*x, un/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-非递归"><a href="#解法二-非递归" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>n要么为偶数, 要么为奇数, 就算为奇数, 也可以拆分成 $x\times x^{n-1}$ 的形式, 对于偶数n, 可以写成 $x^{n/2} \times x{n/2}$ 的形式, 对于 $x^{n/2}$, 可以继续按奇数偶数进行拆分. 举例来说, 对于x=2, n=10 , 可以写成 $2^{10} = 2^{5} \times 2^{5}$ 对于 $2^5$ , 可以写成, $2 \times 2^2 \times 2^2$, 可以看出, x每次与自身相乘后, n的次数就会变成原来二分之一, 这样, 可以用循环实现幂乘的操作, 如下所示.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">double</span> res =<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(un&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(un%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                res * = x;</span><br><span class="line">            &#125;</span><br><span class="line">            x * =x;</span><br><span class="line">            un /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h1><h1 id="14-链表中倒数第k个节点"><a href="#14-链表中倒数第k个节点" class="headerlink" title="14.链表中倒数第k个节点"></a>14.链表中倒数第k个节点</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="解法一-两个指针"><a href="#解法一-两个指针" class="headerlink" title="解法一: 两个指针"></a>解法一: 两个指针</h2><p><strong>时间复杂度:</strong> $O(n)$  遍历一次<br><strong>空间复杂度:</strong> $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = pListHead, * p2 = pListHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p1 = p1-&gt;next; p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="解法一-两个指针pre和cur"><a href="#解法一-两个指针pre和cur" class="headerlink" title="解法一: 两个指针pre和cur"></a>解法一: 两个指针pre和cur</h2><p><strong>时间复杂度:</strong> $O(n)$ 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p><p>利用两个指针<code>pre</code>和<code>cur</code>维持当前节点和前一个节点, 然后执行反转操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = pHead;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="解法一-原地合并"><a href="#解法一-原地合并" class="headerlink" title="解法一: 原地合并"></a>解法一: 原地合并</h2><p>用辅助指针head申请一个指向头结点的指针, 并用cur维护当前节点, 通过比较大小进行插入合并<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode * head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="literal">nullptr</span> &amp;&amp; pHead2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = pHead1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = pHead2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead1!=<span class="literal">nullptr</span>) cur-&gt;next = pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead2!=<span class="literal">nullptr</span>) cur-&gt;next = pHead2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">nullptr</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">nullptr</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">            pHead1-&gt;next = Merge(pHead1-&gt;next, pHead2);</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pHead2-&gt;next = Merge(pHead1, pHead2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2 id="解法一-非递归"><a href="#解法一-非递归" class="headerlink" title="解法一: 非递归"></a>解法一: 非递归</h2><p>每找到一个相等的节点, 就判断就是为子树</p><p>采用的是先根遍历的非递归写法, 在入栈之前就进行判断.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode * &gt; pre_root;</span><br><span class="line">        <span class="keyword">while</span>(!pre_root.empty() || pRoot1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pRoot1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; is_subtree(pRoot1, pRoot2))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                pre_root.push(pRoot1);</span><br><span class="line">                pRoot1 = pRoot1-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pre_root.empty())&#123;</span><br><span class="line">                pRoot1 = pre_root.top(); pre_root.pop();</span><br><span class="line">                pRoot1 = pRoot1-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_subtree</span><span class="params">(TreeNode * pRoot1, TreeNode * pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode * &gt; pre_root;</span><br><span class="line">        <span class="keyword">while</span>(!pre_root.empty() || pRoot2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pRoot2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span> || pRoot2-&gt;val != pRoot1-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                pre_root.push(pRoot1);</span><br><span class="line">                pre_root.push(pRoot2);</span><br><span class="line">                pRoot1 = pRoot1-&gt;left;</span><br><span class="line">                pRoot2 = pRoot2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pre_root.empty())&#123;</span><br><span class="line">                pRoot2 = pre_root.top(); pre_root.pop(); <span class="comment">// 注意入栈与出栈的顺序要刚好相反</span></span><br><span class="line">                pRoot1 = pre_root.top(); pre_root.pop();</span><br><span class="line">                pRoot1 = pRoot1-&gt;right;</span><br><span class="line">                pRoot2 = pRoot2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-递归-1"><a href="#解法二-递归-1" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>; <span class="comment">//用result变量来记录是否已经是子树, 如果result一旦为true, 就直接返回, 不用再继续递归</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="literal">nullptr</span> &amp;&amp; pRoot2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            result = is_subtree(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result) result = HasSubtree(pRoot1-&gt;left, pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result) result = HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_subtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span> || pRoot2-&gt;val != pRoot1-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> is_subtree(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; is_subtree(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树<br>            8<br>           /  \<br>          6   10<br>         / \  / \<br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           /  \<br>          10   6<br>         / \  / \<br>        11 9 7  5</p><h2 id="解法一-递归-3"><a href="#解法一-递归-3" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>先根遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode * pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode * temp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = temp;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-非递归-1"><a href="#解法二-非递归-1" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>先根遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode * pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode * &gt; pre_root;</span><br><span class="line">        TreeNode * cur = pRoot;</span><br><span class="line">        <span class="keyword">while</span>(!pre_root.empty() || cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                TreeNode * temp = cur-&gt;left;</span><br><span class="line">                cur-&gt;left = cur-&gt;right;</span><br><span class="line">                cur-&gt;right = temp;</span><br><span class="line">                pre_root.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pre_root.empty())&#123;</span><br><span class="line">                cur = pre_root.top(); pre_root.pop();</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h2 id="解法一-按层打印"><a href="#解法一-按层打印" class="headerlink" title="解法一: 按层打印"></a>解法一: 按层打印</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p><p>按照层从外而内进行打印, 需要注意层的边界条件, 以及上下层和左右层之间不能重复.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> ||matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size(), col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> layers = (<span class="built_in">std</span>::min(row,col) + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> layer=<span class="number">0</span>; layer&lt;layers; layer++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=layer, j=layer; j&lt; col-layer; j++ )</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=layer+<span class="number">1</span>, j=col-layer<span class="number">-1</span>; i&lt;row-layer<span class="number">-1</span>; i++)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            <span class="comment">// 这里的 i &gt; (row-1)/2 也可以写作 layer != row-1-layer, 避免上下重复</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=row-layer<span class="number">-1</span>, j=col-layer<span class="number">-1</span>; i &gt; (row<span class="number">-1</span>)/<span class="number">2</span> &amp;&amp; j &gt;=layer; j--)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            <span class="comment">// 这里的 j &lt; col/2 也可以写作 layer != col-1-layer, 避免左右重复</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=row-layer<span class="number">-2</span>, j=layer; j &lt; col/<span class="number">2</span> &amp;&amp;  i&gt;layer; i--)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h2 id="解法-利用辅助栈实现"><a href="#解法-利用辅助栈实现" class="headerlink" title="解法: 利用辅助栈实现"></a>解法: 利用辅助栈实现</h2><p>应用一个辅助栈，压的时候，如果A栈的压入比B栈压入大，B栈不压，，，，小于等于，AB栈同时压入，出栈，如果，AB栈顶元素不等，A出，B不出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1,s2;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty()) s2.push(value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s1.top() &lt;= s2.top()) s2.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top()==s2.top()) s2.pop();</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2 id="解法-模拟栈的压入-弹出"><a href="#解法-模拟栈的压入-弹出" class="headerlink" title="解法: 模拟栈的压入, 弹出"></a>解法: 模拟栈的压入, 弹出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.push(pushV[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.top() != popV[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;pushV.size())</span><br><span class="line">                    s.push(pushV[j++]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>更简洁的写法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;pushV.size() ;)&#123;</span><br><span class="line">            s.push(pushV[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j&lt;popV.size() &amp;&amp; s.top() == popV[j])&#123;s.pop(); j++;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h2 id="解法-层次遍历"><a href="#解法-层次遍历" class="headerlink" title="解法: 层次遍历"></a>解法: 层次遍历</h2><p>用一个变量<code>cur_len</code>来维护当前层的节点数, 这样就无序额外存储层深等其他信息.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q_tree;</span><br><span class="line">        q_tree.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q_tree.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_len = q_tree.size(); <span class="comment">// 获取当前层节点数目</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cur_len; i++)&#123; <span class="comment">//直到遍历完当前层节点</span></span><br><span class="line">                TreeNode* cur_node = q_tree.front(); q_tree.pop();</span><br><span class="line">                res.push_back(cur_node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) q_tree.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) q_tree.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h2 id="解法-根据后序序列的特性设计递归判断规则"><a href="#解法-根据后序序列的特性设计递归判断规则" class="headerlink" title="解法: 根据后序序列的特性设计递归判断规则"></a>解法: 根据后序序列的特性设计递归判断规则</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(sequence, <span class="number">0</span>, sequence.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_i = start;</span><br><span class="line">        <span class="keyword">while</span>(cur_i &lt; end &amp;&amp; sequence[cur_i] &lt; sequence[end]) cur_i++;</span><br><span class="line">        <span class="keyword">int</span> mid = cur_i;</span><br><span class="line">        <span class="keyword">while</span>(cur_i &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[cur_i] &lt;sequence[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cur_i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> b1 = helper(sequence, start, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">bool</span> b2 = helper(sequence, mid, end<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> b1&amp;&amp;b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h2 id="解法一-递归解法"><a href="#解法一-递归解法" class="headerlink" title="解法一: 递归解法"></a>解法一: 递归解法</h2><p>先根遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_list;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">int</span> cur_number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        cur_number += root-&gt;val;</span><br><span class="line">        v_list.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur_number == expectNumber &amp;&amp; root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">            res.push_back(v_list);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span> ) FindPath(root-&gt;left, expectNumber);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>) FindPath(root-&gt;right, expectNumber);</span><br><span class="line">        cur_number -= root-&gt;val;</span><br><span class="line">        v_list.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>另一种写法:</strong> 通过减法控制当前的和<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_list;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="comment">//int cur_number = 0;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        expectNumber -= root-&gt;val; <span class="comment">// 注意这里是减法</span></span><br><span class="line">        v_list.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == expectNumber &amp;&amp; root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>) <span class="comment">//条件语句变为 0 == expectNumber</span></span><br><span class="line">            res.push_back(v_list);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span> ) FindPath(root-&gt;left, expectNumber);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>) FindPath(root-&gt;right, expectNumber);</span><br><span class="line">        <span class="comment">//cur_number -= root-&gt;val; //注意, 可以不加这条语句</span></span><br><span class="line">        v_list.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法二-非递归-2"><a href="#解法二-非递归-2" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">非递归法：后序遍历</span></span><br><span class="line"><span class="comment">1.进栈时候，把值同时压入路径的向量数组，修正路径的和</span></span><br><span class="line"><span class="comment">2.出栈时候，先判断和是否相等，且该节点是否是叶节点，</span></span><br><span class="line"><span class="comment">判断完成后保持和栈一致，抛出路径，修改路径的和</span></span><br><span class="line"><span class="comment">3.向量数组和栈的操作要保持一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root, <span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">while</span> (root || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (root)&#123;</span><br><span class="line">                s.push(root); v.push_back(root-&gt;val); expectNumber -= root-&gt;val;</span><br><span class="line">                <span class="comment">//能左就左，否则向右</span></span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            root = s.top();</span><br><span class="line">            <span class="keyword">if</span> (expectNumber == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                res.push_back(v);</span><br><span class="line">            s.pop(); v.pop_back(); expectNumber += root-&gt;val;</span><br><span class="line">            <span class="comment">//右子数没遍历就遍历，如果遍历就强迫出栈</span></span><br><span class="line">            <span class="keyword">if</span> (!s.empty() &amp;&amp; s.top()-&gt;left == root)</span><br><span class="line">                root = s.top()-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = <span class="literal">NULL</span>;<span class="comment">//强迫出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>链表的复制不同于其他复制，在进行链表复制时，必须创建新的节点，同时，不能通过<code>newnode-&gt;next = oldnode-next</code>对新节点进行赋值，这是因为这样赋值会使新链表指向旧链表的节点，造成混乱。</p><h2 id="正确解题思路："><a href="#正确解题思路：" class="headerlink" title="正确解题思路："></a>正确解题思路：</h2><ul><li>先对原链表中的每一个节点进行复制，将复制的节点插入到原节点之后，比如原链表是<code>A-&gt;B-&gt;C</code>，则复制后应该变成<code>A-&gt;A1-&gt;B-&gt;B1-&gt;C-&gt;C1</code>。</li><li>再按照原始链表中随机指针的指向，对新节点的随机指针进行赋值。</li><li>将链表拆分</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//少考虑这种情况会发生段错误</span></span><br><span class="line">        RandomListNode* curnode = pHead;</span><br><span class="line">        <span class="comment">//C++允许在声明结构变量时省略关键字struct，但是C不允许</span></span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* clonenode = <span class="keyword">new</span> RandomListNode(curnode-&gt;label);</span><br><span class="line">            clonenode-&gt;next = curnode-&gt;next;</span><br><span class="line">            curnode-&gt;next = clonenode;</span><br><span class="line">            curnode = clonenode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curnode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123; <span class="comment">// 因为random有可能指向前面的节点, 所以必须在拆分链表之前进行random指针的赋值, 而不能在拆分链表的同时进行赋值</span></span><br><span class="line">            <span class="keyword">if</span>(curnode-&gt;random!=<span class="literal">NULL</span>)&#123;  <span class="comment">//少考虑这种情况会不满足个别用例</span></span><br><span class="line">                curnode-&gt;next-&gt;random = curnode-&gt;random-&gt;next;</span><br><span class="line">                curnode = curnode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curnode-&gt;next-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">                curnode = curnode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curnode = pHead;</span><br><span class="line">        RandomListNode* newhead = pHead-&gt;next;</span><br><span class="line">        RandomListNode* newcur = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newcur-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                curnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curnode-&gt;next = newcur-&gt;next;</span><br><span class="line">            newcur-&gt;next = newcur-&gt;next-&gt;next;</span><br><span class="line">            curnode = curnode-&gt;next;</span><br><span class="line">            newcur = newcur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中结点指针的指向。</p><h2 id="解法一：自己的思路"><a href="#解法一：自己的思路" class="headerlink" title="解法一：自己的思路"></a>解法一：自己的思路</h2><p>后序遍历，递归实现，首先将左子树全部变成有序的，然后将右子树全部变成有序的。由于在返回时，返回的是左右子树的根节点，因此，在将当前根节点与左右子树拼接时，需要移动到左子树的最后一个元素上（最大），与当前根节点的left拼接。对于右子树，要移动到右子树的第一个元素上（最小），与当前根节点的right拼接。</p><p>这里有一个需要注意的地方，以下两种声明方式，指针一定要初始化之后才能使用，会使代码结果表现不同，前者超时，后者通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* pre=<span class="literal">nullptr</span>,* next=<span class="literal">nullptr</span>;</span><br><span class="line">TreeNode* pre,* next;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = recurve(pRootOfTree);</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recurve</span><span class="params">(TreeNode* pRootOfTree)</span></span>&#123;</span><br><span class="line">        TreeNode* pre=<span class="literal">nullptr</span>,* next=<span class="literal">nullptr</span>; <span class="comment">// 这里，如果没有指定nullptr，则程序会超时！！！</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>!=pRootOfTree-&gt;left)</span><br><span class="line">            pre = recurve(pRootOfTree-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>!=pRootOfTree-&gt;right)</span><br><span class="line">            next = recurve(pRootOfTree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                pre=pre-&gt;right;</span><br><span class="line">            pRootOfTree-&gt;left = pre;</span><br><span class="line">            pre-&gt;right = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(next-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                next = next-&gt;left;</span><br><span class="line">            pRootOfTree-&gt;right = next;</span><br><span class="line">            next-&gt;left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：中序遍历，递归实现"><a href="#解法二：中序遍历，递归实现" class="headerlink" title="解法二：中序遍历，递归实现"></a>解法二：中序遍历，递归实现</h2><p>由于对搜索二叉树来说，中序遍历的结果就是有序的，因此，只需要通过维护一个prenode指针来标记当前节点的上一个节点即可完成双向有序链表。</p><p>注意，这里有一个非常关键的点，那就是<code>TreeNode*&amp; prenode</code>，如果少了<code>&amp;</code>引用标识，则结果错误！具体原因看文章关于<code>*&amp;</code>和<code>*</code>的联系和区别。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* prenode = <span class="literal">nullptr</span>;</span><br><span class="line">        recurve(pRootOfTree,prenode);</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurve</span><span class="params">(TreeNode* root, TreeNode*&amp; prenode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurve(root-&gt;left,prenode);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = prenode;</span><br><span class="line">        <span class="keyword">if</span>(prenode!=<span class="literal">nullptr</span>) prenode-&gt;right = root;</span><br><span class="line">        prenode = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurve(root-&gt;right,prenode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法三：中序遍历，非递归实现"><a href="#解法三：中序遍历，非递归实现" class="headerlink" title="解法三：中序遍历，非递归实现"></a>解法三：中序遍历，非递归实现</h2><p>基于中序遍历的非递归方法，思路与解法二一致。</p><p><del><strong>但是这里有个疑问，为什么使用下面的代码会发生段错误。</strong></del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(pRootOfTree-&gt;left!=nullptr)</span><br><span class="line">    pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">return pRootOfTree;</span><br><span class="line"></span><br><span class="line">发生段错误的原因主要是因为没有对pRootOfTree进行空指针检查,</span><br><span class="line">就直接使用了该指针的成员变量, 访问了本不存在的内存, 从而造成</span><br><span class="line">了段错误, 修改方法是在程序前加上空指针检查</span><br></pre></td></tr></table></figure></p><p>以下代码额外设置了一个指针指向第一个节点，以避免使用上面代码带来的段错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S_node;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        TreeNode* P = pRootOfTree;</span><br><span class="line">        <span class="comment">// TreeNode* node = pRootOfTree; 进行了空指针检查, 所以不用再使用这个指针了, 下面也是同理</span></span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>||!S_node.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                S_node.push(P);</span><br><span class="line">                P = P-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!S_node.empty())&#123;</span><br><span class="line">                P = S_node.top();</span><br><span class="line">                P-&gt;left = pre;</span><br><span class="line">                <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pre-&gt;right = P;</span><br><span class="line">                &#125;<span class="comment">//else</span></span><br><span class="line">                    <span class="comment">//node = P;</span></span><br><span class="line">                pre = P;</span><br><span class="line">                S_node.pop();</span><br><span class="line">                P = P-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">        <span class="comment">//return node;</span></span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27.字符串的排列"></a>27.字符串的排列</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a，b，c所能排列出来的所有字符串abc，acb，bac，cab和cab。</p><h2 id="思路（没想到）："><a href="#思路（没想到）：" class="headerlink" title="思路（没想到）："></a>思路（没想到）：</h2><p>将一个字符串看成两个部分，前一部分为首位字母，剩下的是后一部分。通过将首位字母与后一部分的所有字符交换（包括跟自己交换），可以得到第一个位置的所有可能情况。然后，再将剩下的部分看作是一个新的字符串，同样将剩余部分分成两部分，其中，第一部分是剩余部分的首位。如此，可以按照递归进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bool my_sort(string s1, string s2)&#123; return s1&lt;s2;&#125;;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v_string;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>) <span class="keyword">return</span> v_string;</span><br><span class="line">        PermutationHelp(v_string, <span class="number">0</span>, str);</span><br><span class="line">        <span class="built_in">std</span>::sort(v_string.begin(), v_string.end());</span><br><span class="line">        <span class="keyword">return</span> v_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PermutationHelp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v_string, <span class="keyword">int</span> pos, <span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="comment">/* if(pos == 0 )&#123;</span></span><br><span class="line"><span class="comment">            v_string.push_back(str);</span></span><br><span class="line"><span class="comment">            PermutationHelp(v_string, pos+1, str);</span></span><br><span class="line"><span class="comment">        &#125; * /</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //这里i=pos而不是pos+1的原因是：如果用pos+1,会导致丟解，即自己与自己交换的那种情况没有继续向下递归</span></span><br><span class="line"><span class="comment">        for(int i=pos; i&lt;str.length(); i++)&#123;</span></span><br><span class="line"><span class="comment">            std::swap(str.at(pos), str.at(i));</span></span><br><span class="line"><span class="comment">            if(std::count(v_string.begin(), v_string.end(), str) == 0)</span></span><br><span class="line"><span class="comment">                v_string.push_back(str);</span></span><br><span class="line"><span class="comment">            PermutationHelp(v_string, pos+1, str);</span></span><br><span class="line"><span class="comment">            //std::swap(str.at(pos), str.at(i));</span></span><br><span class="line"><span class="comment">            //注释本行的原因是因为，这里，由于，我们只需要将后面的n-1中字符依次置换到首位，因此，无须在置换后进行还原再置换，直接进行置换即可</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="更简洁的写法"><a href="#更简洁的写法" class="headerlink" title="更简洁的写法"></a>更简洁的写法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">""</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute_helper(res, <span class="number">0</span>, str);</span><br><span class="line">        <span class="built_in">std</span>::sort(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="keyword">int</span> pos , <span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == str.size())</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt;str.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[pos] == str[i] &amp;&amp; pos!=i) <span class="keyword">continue</span>; <span class="comment">//防止重复出现, 如"aa", 则只输出一个 [a,a]</span></span><br><span class="line">                <span class="built_in">std</span>::swap(str[pos], str[i]);</span><br><span class="line">                permute_helper(res, pos+<span class="number">1</span>, str);</span><br><span class="line">                <span class="built_in">std</span>::swap(str[pos], str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28.数组中出现次数超过一半的数字"></a>28.数组中出现次数超过一半的数字</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h2 id="思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为-nlog-n-。"><a href="#思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为-nlog-n-。" class="headerlink" title="思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为 $nlog(n)$ 。"></a>思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为 $nlog(n)$ 。</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bool mysort(int a, int b) &#123;return a&lt;b;&#125;</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counts;</span><br><span class="line">            <span class="built_in">std</span>::sort(numbers.begin(), numbers.end());</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">std</span>::count(numbers.begin(), numbers.end(), numbers.at((<span class="keyword">int</span>)numbers.size()/<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (n &gt; numbers.size()/<span class="number">2</span>) <span class="keyword">return</span> numbers.at((<span class="keyword">int</span>)numbers.size()/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>根据快排的思想，由于该数字一定在数组的中间位置，那么可以借助Partition来实现，随机选一个数字进行Partition，如果返回的mid索引最终停在N/2处，那么该索引对应的数字就有可能是答案，此时，只需统计该数字的出现次数即可。</p><p>该方法的时间复杂度是 $O(n)$ ，因为只会执行一边的Partition，并不会执行另一边。</p><p>需要注意，具体在代码中看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mysort</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a&lt;b;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = Partition(numbers, low, high);</span><br><span class="line">        <span class="keyword">while</span>(mid != numbers.size()/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; numbers.size()/<span class="number">2</span>)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                mid = Partition(numbers, low, high);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                mid = Partition(numbers,low, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">std</span>::count(numbers.begin(), numbers.end(), numbers.at(mid)) &gt; numbers.size()/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> numbers.at(mid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = numbers.at(low);</span><br><span class="line">        <span class="keyword">int</span> mid = low;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; p &lt; numbers.at(high)) high--;</span><br><span class="line"><span class="comment">//这里如果p用的是&lt;,则需要下面的low++逻辑，否则，会陷入死循环，如果用的是&lt;=，则在返回时，会返回首个元素的坐标</span></span><br><span class="line">            numbers.at(low) = numbers.at(high);</span><br><span class="line">            <span class="keyword">if</span>(low!=high) low++;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; p &gt; numbers.at(low)) low++;</span><br><span class="line">            numbers.at(high) = numbers.at(low);</span><br><span class="line">            <span class="keyword">if</span>(low!=high) high--;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.at(low) = p;</span><br><span class="line">        <span class="keyword">if</span>(low == high) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路三："><a href="#思路三：" class="headerlink" title="思路三："></a>思路三：</h2><p> 如果数组中存在这样一个数，那么这个数的出现次数一定大于其他所有数的出现次数总和，因此，设置两个变量，一个number用来存储数组中的第一个数，另一个num置为1,如果下一个数与number数相同，则num加一，否则减1,如果num被减为0,那么number转而存储下一个数，同时将num置为1。</p><p>这样，如果存在这个数，最终这个数一定为number，且num大于1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        int number = numbers.at(0);</span><br><span class="line">        int num = 1;</span><br><span class="line">        for(vector&lt;int&gt;::iterator iter = numbers.begin()+1; iter != numbers.end(); iter++)&#123;</span><br><span class="line">            if(num == 0)&#123; //这里与下面的区别之一是，一定要放在for训练内部的前面</span><br><span class="line">                number = *(iter-1); //区别之二这里如果使用iter-1,则无须在最后做count检查</span><br><span class="line">                num = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(number == *iter) num++;</span><br><span class="line">            else num--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(num &gt;= 1) return number; //这里，num只需要&gt;=1 即可，仔细想一想这是为什么，为啥用了iter-1,就不用检查count。</span><br><span class="line">        else return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        int number = numbers.at(0);</span><br><span class="line">        int num = 1;</span><br><span class="line">        for(vector&lt;int&gt;::iterator iter = numbers.begin(); iter != numbers.end(); iter++)&#123;</span><br><span class="line">            if(number == *iter) num++;</span><br><span class="line">            else num--;</span><br><span class="line">            if(num == 0)&#123;</span><br><span class="line">                number = *iter;</span><br><span class="line">                num = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count(numbers.begin(), numbers.end(), number) &gt; numbers.size()/2) return number;</span><br><span class="line">        //由于上面用的是iter，所以最终的num为1的数，只是有可能是我们要得数字，因此，需要进行检查。</span><br><span class="line">        else return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入n个整数，找出最小的K个数，例如输入4,5,1,6,2,7,3,8，则输出1,2,3,4。</p><p>一定要考虑边界情况：</p><ul><li>数组为空</li><li>k大于数组size</li><li>k小于0</li></ul><h2 id="思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为-nlog-n-n-。-快排"><a href="#思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为-nlog-n-n-。-快排" class="headerlink" title="思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为 $nlog(n) + n$ 。 快排"></a>思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为 $nlog(n) + n$ 。 快排</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; k_input;</span><br><span class="line">        if(k &gt; input.size() || input.size()&lt;=0) return k_input;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = input.size()-1;</span><br><span class="line">        quickSort(input, low, high);</span><br><span class="line">        //vector&lt;int&gt; k_input(&amp;input.at(0), &amp;input.at(k-1));</span><br><span class="line">        for(int i=0; i&lt;k; i++) k_input.push_back(input.at(i));</span><br><span class="line">        return k_input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void quickSort(vector&lt;int&gt;&amp; input, int low, int high)&#123;</span><br><span class="line">        int mid = Partition(input, low, high);</span><br><span class="line"></span><br><span class="line">        if(mid&lt;high)    quickSort(input, mid+1, high);</span><br><span class="line">        if(mid&gt;low)    quickSort(input, low, mid-1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Partition(vector&lt;int&gt;&amp; input, int low, int high)&#123;</span><br><span class="line">        int p = input[low];</span><br><span class="line">        while(low&lt;high)&#123;</span><br><span class="line">            while(low&lt;high &amp;&amp; p&lt;=input[high]) high--;</span><br><span class="line">            input[low] = input[high];</span><br><span class="line">            while(low&lt;high &amp;&amp; p&gt;=input[low]) low++;</span><br><span class="line">            input[high] = input[low];</span><br><span class="line">        &#125;</span><br><span class="line">        input[low] = p;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路二：遍历整个数组，将当前元素与k-input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k-input。时间复杂度-O-nk-。（该思想与冒泡排序思想类似）。"><a href="#思路二：遍历整个数组，将当前元素与k-input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k-input。时间复杂度-O-nk-。（该思想与冒泡排序思想类似）。" class="headerlink" title="思路二：遍历整个数组，将当前元素与k_input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k_input。时间复杂度 $O(nk)$ 。（该思想与冒泡排序思想类似）。"></a>思路二：遍历整个数组，将当前元素与k_input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k_input。时间复杂度 $O(nk)$ 。（该思想与冒泡排序思想类似）。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; k_input;</span><br><span class="line">        if(k&gt;input.size() || input.size()&lt;=0) return k_input;</span><br><span class="line">        k_input.push_back(input.at(0));</span><br><span class="line">        for(auto iter = input.begin()+1; iter!=input.end(); iter++)&#123;</span><br><span class="line">            for(int i =0 ;i&lt;k; i++)&#123;</span><br><span class="line">                if(i == k_input.size())&#123;</span><br><span class="line">                    k_input.push_back(*iter);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if(*iter &lt; k_input.at(i))&#123;</span><br><span class="line">                    k_input.insert(k_input.begin()+i, *iter);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(k_input.size() &gt; k) k_input.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return k_input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-大顶堆"><a href="#解法三-大顶堆" class="headerlink" title="解法三: 大顶堆"></a>解法三: 大顶堆</h2><p>遍历数组, 维护一个大顶堆, 每遇到一个比堆顶小的数, 就将其插入大顶堆 (如果是找最大的k个数, 就用小顶堆)</p><p>时间复杂度: $nlogk$</p><p>借助<code>priority_queue</code>数据结构<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k&gt;input.size()) <span class="keyword">return</span> res;  <span class="comment">//边界条件</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">int</span> count_k =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count_k &lt; k)&#123;</span><br><span class="line">                q.push(input[i]);</span><br><span class="line">                count_k++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count_k&gt;<span class="number">0</span> &amp;&amp; input[i] &lt; q.top())&#123; <span class="comment">//一定要带上count_k判断, 否则当q为空时, 使用top()会造成段错误</span></span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            res.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>利用数组实现堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec_heap, <span class="keyword">int</span> index, <span class="keyword">int</span> heap_size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=index;</span><br><span class="line">        <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;heap_size &amp;&amp; vec_heap[max] &lt; vec_heap[left])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = max;</span><br><span class="line">            max = left;</span><br><span class="line">            left = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;heap_size &amp;&amp; vec_heap[max] &lt; vec_heap[right])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = max;</span><br><span class="line">            max = right;</span><br><span class="line">            right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != max)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(vec_heap[index], vec_heap[max]);</span><br><span class="line">            heapify(vec_heap, max, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k &gt; input.size()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k;i++)&#123;</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//初始化堆</span></span><br><span class="line">            heapify(res, i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; input.size(); i++)&#123; <span class="comment">//i要从k开始, 因为k之前的已经是堆了</span></span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; res[<span class="number">0</span>])&#123;</span><br><span class="line">                res[<span class="number">0</span>] = input[i];</span><br><span class="line">                heapify(res, <span class="number">0</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = res.size()<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(res[<span class="number">0</span>], res[i]);</span><br><span class="line">            heapify(res, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法四-快速选择算法"><a href="#解法四-快速选择算法" class="headerlink" title="解法四: 快速选择算法"></a>解法四: 快速选择算法</h2><p><strong>时间复杂度:</strong> 平均为 $O(n)$</p><p>复杂度分析: 每次都会扔掉一半, 所以每次进行检查的元素个数为之前的一半, 所有时间复杂度大致为:</p><script type="math/tex; mode=display">T(n) = n + n/2 + n/8 + ... + (n/2)^k = n*(1-2^{-k})/(1-2^{-1}) = 2n</script><p>也就是说, 只要枢纽元素的选择使得两边的元素数量尽可能均衡, 就可以得到 $O(n)$ 的时间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k&gt;input.size()) <span class="keyword">return</span> res;</span><br><span class="line">        quick_select(input, <span class="number">0</span>, input.size()<span class="number">-1</span>, k);</span><br><span class="line">        <span class="comment">//运行完 quick_select 以后, k之前的元素都比k位置上的元素小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_select</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = <span class="built_in">std</span>::min(vec[low], <span class="built_in">std</span>::min( (vec[low]+vec[high])/<span class="number">2</span>, vec[high])); <span class="comment">//三元取中间作为枢纽元, 避免最坏情况</span></span><br><span class="line">        <span class="keyword">int</span> low_bak = low, high_bak = high;</span><br><span class="line">        <span class="built_in">std</span>::swap(P, vec[low]);</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&lt;=vec[high]) high--;</span><br><span class="line">            vec[low] = vec[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&gt;=vec[low]) low++;</span><br><span class="line">            vec[high] = vec[low];</span><br><span class="line">        &#125;</span><br><span class="line">        vec[low] = P; <span class="comment">//此时, low所处位置为枢纽元P, low之前的都小于P, low之后的都大于P</span></span><br><span class="line">        <span class="keyword">if</span>(low == k<span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">//如果low所处位刚好为k-1, 则从这之前的k个元素一定是最小的(包括vec[low]自身)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( k &lt; low) quick_select(vec, <span class="number">0</span>, low, k);</span><br><span class="line">        <span class="keyword">else</span> quick_select(vec, low+<span class="number">1</span>, high, k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="问题扩展-1"><a href="#问题扩展-1" class="headerlink" title="问题扩展 1"></a>问题扩展 1</h2><p>输入是两个整数数组, 他们任意两个数的和有可以组成一个数组, 求这个和中的前k个数</p><p><strong>分析:</strong></p><ol><li>假设两个整数数组为A和B, 各有N个元素, 任意两个数的和组成的数组C就有 $N^2$ 个, 那么可以把这些和看成N个有序数列, 由此, 问题就转变成了在这 $N^2$ 个有序数列里, 找到前k个最小的元素.<ul><li>A[1]+B[1] &lt;= A[1]+B[2] &lt;= A[1]+B[3] &lt;= …</li><li>A[2]+B[1] &lt;= A[2]+B[2] &lt;= A[2]+B[3] &lt;= …</li><li>…</li><li>A[N]+B[1] &lt;= A[N]+B[2] &lt;= A[N]+B[3] &lt;= …</li></ul></li></ol><h2 id="问题扩展-2"><a href="#问题扩展-2" class="headerlink" title="问题扩展 2"></a>问题扩展 2</h2><p>有两个序列A和B都按照升序排列, 对于 1&lt;=i,j&lt;=k, 求k个最小的(ai+bj), 要求算法尽量高效.</p><h1 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><h2 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h2><p>穷举遍历，时间复杂度 $O(n^2)$ 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int max=array.at(0);</span><br><span class="line">        for(auto iter=array.begin(); iter!=array.end(); iter++)&#123;</span><br><span class="line">            //if(*iter &gt; 0)&#123;</span><br><span class="line">                int temp = 0;</span><br><span class="line">                for(auto it = iter; it!=array.end(); it++)&#123;</span><br><span class="line">                    temp += *it;</span><br><span class="line">                    if(temp &gt; max)</span><br><span class="line">                        max = temp;</span><br><span class="line">                //&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种写法(感觉更好理解些)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> max_sum = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : <span class="built_in">array</span>)&#123;</span><br><span class="line">            cur_sum += x;</span><br><span class="line">            <span class="keyword">if</span>(cur_sum &gt; max_sum) <span class="comment">// 更新max_sum</span></span><br><span class="line">                max_sum = cur_sum;</span><br><span class="line">            <span class="keyword">if</span>(cur_sum &lt; <span class="number">0</span>) <span class="comment">// 如果当前和为负, 则重置cur_sum</span></span><br><span class="line">                cur_sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>$O(n)$ 的方法，根据数组性质，设置两个变量，一个记录当前的最大值，一个记录当前的子序列之和。首先，如果当前子序列之和为负，那么就是说，从当前位置开始的子序列，比从之前位置开始的子序列大，那么就可以不考虑从之前位置开始的子序列，之前累计的和也被抛弃。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="built_in">array</span>.at(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> s = <span class="built_in">array</span>.at(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">array</span>.begin()+<span class="number">1</span>; iter!=<span class="built_in">array</span>.end(); iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                s = * iter;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s += * iter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( max &lt; s)&#123;</span><br><span class="line">                max = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h2><p>动态规划。与解法二的思路异曲同工，核心思想可有下述公式表示。 $f(i)代表以第i个数字结尾的子数组的连续最大和$</p><script type="math/tex; mode=display">f(x)=\begin{cases}pData[i]& {i=0 或者f(i-1)\le 0} \\f(i-1)+pData[i]& {i\ne 0 并且 f(i-1) > 0}\end{cases}</script><p>上面的形式是递归的，通常情况下都用递归的方式来分析动态规划问题，但最终都会基于循环去编码。  上述公式对应的非递归形式就是思路二的代码。</p><p>递归写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int max = array.at(0);</span><br><span class="line">        f(array, array.size()-1, max);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int f(vector&lt;int&gt;&amp; array, int i, int&amp; max)&#123;</span><br><span class="line">        if(i==0) return array.at(0);</span><br><span class="line">        int f1  = f(array, i-1, max);</span><br><span class="line">        if(f1&lt;0)</span><br><span class="line">            f1 = array.at(i);</span><br><span class="line">        else&#123;</span><br><span class="line">            f1 = f1+ array.at(i);</span><br><span class="line">        &#125;</span><br><span class="line">        if(f1&gt; max) max =f1;</span><br><span class="line">        return f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="31-整数中1出现的次数（从1到整数n中1出现的次数）"><a href="#31-整数中1出现的次数（从1到整数n中1出现的次数）" class="headerlink" title="31.整数中1出现的次数（从1到整数n中1出现的次数）"></a>31.整数中1出现的次数（从1到整数n中1出现的次数）</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><h2 id="解法一：-1"><a href="#解法一：-1" class="headerlink" title="解法一："></a>解法一：</h2><p>直接借助C++函数，先将int转换成string，然后count计算string里面‘1’的个数。（这种方法可能面试不会满意，可以提一下，不过肯定有其他方法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count_1 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="built_in">std</span>::to_string(i);</span><br><span class="line">            count_1 += <span class="built_in">std</span>::count(str.begin(), str.end(), <span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count_1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：-1"><a href="#解法二：-1" class="headerlink" title="解法二："></a>解法二：</h2><p>对每个数字进行除和求余的运算，得到每个数字中1的个数，然后将个数相加。 该方法的复杂度为 $O(nlogn)$ ，该种思想过于直接，时间复杂度较高，属于次等方案。（注意：这里的log底数按理说是10 ，但说大O记法是不考虑常数的，所以直接表示成log就可以）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i1 = has1(i);</span><br><span class="line">            <span class="keyword">if</span>(i1)</span><br><span class="line">                count+=i1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">has1</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三：-1"><a href="#解法三：-1" class="headerlink" title="解法三："></a>解法三：</h2><p><strong>时间复杂度:</strong>  $O(logn)$</p><p>设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上为1的情况有多少种进行分析</p><p>根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</p><p>当i表示百位，且百位对应的数&gt;=2时,如n=31456,i=100，则a=314,b=56，此时百位为1的情况有a/10+1=32（最高两位0~31，百位为1,共32种），每一种都包含100个连续的点，即共有(a%10+1) * 100种情况百位为1</p><p>当i表示百位，且百位对应的数为1时，如n=31156， i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)种情况是包含100个连续点，当最高两位为31（即a=311），本次只对应部分情况00~56，共b+1种，所有点加起来共有（a%10*100）+(b+1)种情况可以是百位为1</p><p>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的情况有a/10=31种（最高两位0~30）</p><p>综合以上三种情况，当百位对应0或2时，有(a+8)/10次包含所有100个点，当百位为1时，即(a%10==1)为真时，另外需要增加部分情况b+1种</p><p>之所以补8，是因为当百位为0 或者 1 时，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;=n; i*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = n/i;</span><br><span class="line">            <span class="keyword">int</span> b = n%i;</span><br><span class="line">            count+=(a+<span class="number">8</span>)/<span class="number">10</span>*i+(<span class="keyword">int</span>)(a%<span class="number">10</span>==<span class="number">1</span>)*(b+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h2><p>剑指offer的递归方法，没看懂，感觉好像有错误？</p><h1 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h2 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h2><ol><li>找出一个新的排序规则，同时要证明这个排序规则是有效的</li><li>看到将两个int整数拼接在一起，就应该想到大数问题</li></ol><h2 id="解法一：-2"><a href="#解法一：-2" class="headerlink" title="解法一："></a>解法一：</h2><p>主要考虑如何制定一个合理的判断规则：</p><p><strong>比较两个字符串s1, s2大小的时候，先将它们拼接起来，比较s1+s2,和s2+s1那个大，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面。</strong></p><p>基于上面的规则，首先将<code>vector&lt;int&gt;</code>转换成对应的<code>vector&lt;string&gt;</code>，然后直接利用快排进行排序，最后将排好序的字符串向量拼接输出。</p><p>时间复杂度为主要在排序，因此为 $O(nlogn)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=numbers.begin(); it!=numbers.end(); it++)&#123;</span><br><span class="line">            str_numbers.push_back(<span class="built_in">std</span>::to_string(*it));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        quickSort(str_numbers, low, high);</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = str_numbers.begin(); it != str_numbers.end(); it++)&#123;</span><br><span class="line">            s+=*it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; str_numbers, <span class="keyword">int</span> low , <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = Partition(str_numbers, low, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) quickSort(str_numbers,mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;low) quickSort(str_numbers, low, mid<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; str_numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> p = str_numbers.at(low);</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="built_in">string</span> s1= p + str_numbers.at(high);</span><br><span class="line">            <span class="built_in">string</span> s2= str_numbers.at(high) + p;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; s1.compare(s2) &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                high--;</span><br><span class="line">                s1 = p + str_numbers.at(high);</span><br><span class="line">                s2 = str_numbers.at(high) + p;</span><br><span class="line">            &#125;</span><br><span class="line">            str_numbers.at(low) = str_numbers.at(high);</span><br><span class="line">            <span class="comment">//if(high&gt;low) low++; //冗余语句 可有可无</span></span><br><span class="line"></span><br><span class="line">            s1 = p + str_numbers.at(low);</span><br><span class="line">            s2 = str_numbers.at(low) + p;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; s1.compare(s2) &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                s1 = p + str_numbers.at(low);</span><br><span class="line">                s2 = str_numbers.at(low) + p;</span><br><span class="line">            &#125;</span><br><span class="line">            str_numbers.at(high) = str_numbers.at(low);</span><br><span class="line">            <span class="comment">//if(high&gt;low) high--;  //可有可无</span></span><br><span class="line">        &#125;</span><br><span class="line">        str_numbers.at(low) = p;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h1><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数</p><h2 id="解法一：-3"><a href="#解法一：-3" class="headerlink" title="解法一："></a>解法一：</h2><p>最简单的方法，就是对所有整数进行判断，该方法很容易超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ugly=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">            <span class="keyword">if</span>(IsUgly(num))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                ugly = num;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsUgly</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            num /=<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：-2"><a href="#解法二：-2" class="headerlink" title="解法二："></a>解法二：</h2><p>用空间换时间，用一个数组将之前的丑数都存起来，然后，在判断下一个丑数时，不用对逐个整数判断，而只是与丑数和2,3,5的乘积进行判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用指针时，一定要千万注意，指针会改变指向地址的值，使得其他指向该地址的指针，其指向的值也跟着变！</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>* UglyArray = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        UglyArray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt; index; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> *Ugly2 = UglyArray;</span><br><span class="line">            <span class="keyword">int</span> *Ugly3 = UglyArray;</span><br><span class="line">            <span class="keyword">int</span> *Ugly5 = UglyArray;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly2 * <span class="number">2</span> &lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly2++;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly3 * <span class="number">3</span> &lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly3++;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly5 * <span class="number">5</span>&lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly5++;</span><br><span class="line">            UglyArray[i] = Min(*Ugly2 *<span class="number">2</span>, *Ugly3 *<span class="number">3</span>, *Ugly5 *<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = UglyArray[index<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">delete</span>[] UglyArray;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b,<span class="keyword">const</span> <span class="keyword">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a&lt;b? a:b;</span><br><span class="line">        <span class="keyword">return</span> x&lt;c? x:c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="34-第一次只出现一次的字符"><a href="#34-第一次只出现一次的字符" class="headerlink" title="34.第一次只出现一次的字符"></a>34.第一次只出现一次的字符</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）</p><h2 id="解法一（自想）"><a href="#解法一（自想）" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>每遇到一个字符，判断其是否是第一次出现，则将它存在一个vector once里面，如果不是，则判断该字符是否在另一个vector more里面，如果没在，则该once中的该字符转移到mul里面，接着判断下一个字符。最终，输出once里面的首个元素。</p><p>该方法时间复杂度为 $O(n^2)$，并不令人满意。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; once_char;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; mul_char;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isfirst = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = once_char.begin(); it!=once_char.end(); it++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[*it] == str[i])&#123;</span><br><span class="line">                    isfirst = <span class="literal">false</span>;</span><br><span class="line">                    once_char.erase(it);</span><br><span class="line">                    mul_char.push_back(str[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isfirst)&#123;</span><br><span class="line">                <span class="keyword">auto</span> mul_it = find(mul_char.begin(), mul_char.end(), str[i]);</span><br><span class="line">                <span class="keyword">if</span>(mul_it != mul_char.end())</span><br><span class="line">                    isfirst = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isfirst)&#123;</span><br><span class="line">                once_char.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(once_char.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> once_char.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：牛客"><a href="#解法二：牛客" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>借助哈希表，时间复杂度为 $O(n)$。哈希表的构造可以用256大小的数组实现，字符对应的int值可作为哈希表的索引，表内的内容存储了该字符出现的次数。总共需要遍历两次字符串，第一次更新数组内字符出现的次数，第二次找到首个出现次数为1的字符。空间复杂度为 $O(1)$ （256是常数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash_map[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">            hash_map[i] = <span class="number">0</span>; <span class="comment">//若少了初始化数组，则通不过，经过验证，数组默认内部不是0,而是随机数？</span></span><br><span class="line">       <span class="comment">//有一种更标准初始化为0的方法，无需显式while循环：int hash_map[256]= &#123;0&#125;;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            hash_map[<span class="keyword">int</span>(str[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash_map[<span class="keyword">int</span>(str[i])] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>输入描述:</p><p>题目保证输入的数组中没有的相同的数字</p><p>数据范围：</p><pre><code>对于%50的数据,size&lt;=10^4对于%75的数据,size&lt;=10^5对于%100的数据,size&lt;=2*10^5</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>仔细思考，这道题的P的数量会非常大，对于长度为n的数组，其P值最大可为 $\frac{n(n-1)}{2}$ 个。根据体重给出的数据，n最大可为 $2\times 10^5$ ，因此，P最大为 $\frac{2\times 10^5\times(2\times10^5 -1)}{2} \approx 2\times 10^{10}$,因此，使用int类型的数据时，有可能超过限制。所以，要使用long！</p><h2 id="解法一（自）"><a href="#解法一（自）" class="headerlink" title="解法一（自）"></a>解法一（自）</h2><p>  暴力求解，时间复杂度 $O(n^2)$ ，这样做肯定不行</p><h2 id="解法二（剑指）-归并排序思想"><a href="#解法二（剑指）-归并排序思想" class="headerlink" title="解法二（剑指）: 归并排序思想"></a>解法二（剑指）: 归并排序思想</h2><p>将数组中的元素进行归并排序, 排序的时候, 如果前面子数组的元素大于后面的元素, 那么可以组成的逆序对的数量就是后面元素剩余的元素数量(两个子数组各自都已经排好序).</p><h3 id="这里需要注意的几点："><a href="#这里需要注意的几点：" class="headerlink" title="这里需要注意的几点："></a>这里需要注意的几点：</h3><ol><li>初始化是，将data数据复制到temp中，然后在递归时，将data和temp数组交换传递，可以不用在数组融合时，将temp中的数据复制到data中， 减少计算次数</li><li>数组融合时使用的while循环，条件均为 $&lt;=$ 或  $&gt;=$。</li><li>每次得到P的一部分时，都进行取余数，可保证P的值不会过大。（但还是要用long型整数）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp= data;</span><br><span class="line">      <span class="comment">//int P=0;</span></span><br><span class="line">      <span class="keyword">long</span> P = mergeSort(data,temp, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> P%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (last - first)/<span class="number">2</span>;</span><br><span class="line">      mid += first;</span><br><span class="line">      <span class="keyword">long</span> inv1=<span class="number">0</span>,inv2=<span class="number">0</span>,inv=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(first&lt; last)&#123;</span><br><span class="line">        <span class="comment">//这里，首先temp和data相同，因此对于mergeSort来说，可以顺序颠倒</span></span><br><span class="line">        <span class="comment">//此时相当于把temp当前真实数组，而data当作了缓存空间</span></span><br><span class="line">        <span class="comment">//经过mergeSort后，data里面数据就是分别排好序的</span></span><br><span class="line">        <span class="comment">//所以传向mergeArray时，要把data放前面，把temp放后面</span></span><br><span class="line">          inv1 = mergeSort(temp, data, first, mid);  <span class="comment">//必须temp在前, 因为temp是已经将子数组排序过的</span></span><br><span class="line">          inv2 = mergeSort(temp, data, mid+<span class="number">1</span>, last);</span><br><span class="line">          inv = mergeArray(data, temp, first, mid, mid+<span class="number">1</span>, last); <span class="comment">//此处data在前的原因是经过mergeSort以后, data变成了排序号的.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//上面这种写法的可读性不好, 如果在mergArray函数里面, 使data = temp , 就能写出下面这种可读性较好的形式(但是由于多了赋值操作, 在牛客上会超时)</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          inv1 = mergeSort(data, temp, first, mid);</span></span><br><span class="line"><span class="comment">          inv2 = mergeSort(data, temp, mid+1, last);</span></span><br><span class="line"><span class="comment">          inv = mergeArray(data, temp, first, mid, mid+1, last);</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (inv1+inv2+inv)%<span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">mergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">int</span> inv = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> t = last2;</span><br><span class="line">      <span class="keyword">int</span> i = last1;</span><br><span class="line">      <span class="keyword">int</span> j = last2;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=first1 &amp;&amp; j&gt;=first2)&#123;</span><br><span class="line">          <span class="keyword">if</span>(data.at(i) &gt; data.at(j))&#123;</span><br><span class="line">              temp.at(t) = data.at(i);</span><br><span class="line">              inv += j-first2+<span class="number">1</span>;;</span><br><span class="line">              i--;</span><br><span class="line">              t--;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              temp.at(t) = data.at(j);</span><br><span class="line">              j--;</span><br><span class="line">              t--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=first1)&#123;</span><br><span class="line">          temp.at(t) = data.at(i);</span><br><span class="line">          t--;</span><br><span class="line">          i--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;=first2)&#123;</span><br><span class="line">          temp.at(t) = data.at(j);</span><br><span class="line">          j--;</span><br><span class="line">          t--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// data=temp  //这个赋值操作会使得代码整体的可读性较好, 但是可能会超时</span></span><br><span class="line">      <span class="keyword">return</span> inv%<span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="36-两个链表的第一个公共节点"><a href="#36-两个链表的第一个公共节点" class="headerlink" title="36.两个链表的第一个公共节点"></a>36.两个链表的第一个公共节点</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p><h2 id="解法一：-4"><a href="#解法一：-4" class="headerlink" title="解法一："></a>解法一：</h2><p>分析公共子节点的特点，首先，是单向链表，因此，从第一个公共子节点开始，后面的都是一样的，所以最好是能从链表的最后一项还是比较。但由于是单向链表，因此只能从头访问，从能访问最后的节点。 <strong>就像是先进先出一样</strong>  因此，考虑用两个辅助栈来帮助实现～</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s2;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead1; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s1.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead2; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s2.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* firstCN = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.top() == s2.top())&#123;</span><br><span class="line">                firstCN = s1.top();</span><br><span class="line">                s1.pop();</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p><h2 id="解法一（自想）-1"><a href="#解法一（自想）-1" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>先利用二分查找找到该数字的下标，然后统计该数字左右两边的相等数的个数，虽然二分查找的时间复杂度为$O(logn)$，但是在对该数左右两边查看相等数个数时，时间复杂度为 $O(n)$，因此，最终的时间复杂度应为 $O(n)$ 。 （这样的复杂度不会让面试官满意）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = index<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;data.size() &amp;&amp; data.at(index) == k)&#123;</span><br><span class="line">                index++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; data.at(i) == k)&#123;</span><br><span class="line">                i--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.at(first) == num) <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearch(data, num ,first, mid);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearch(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：牛客-1"><a href="#解法二：牛客-1" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>分析上面的方法，时间复杂度高的主要原因来自于最后的顺序检索。设想一下，如果知道目标数字出现的第一个位置和最后一个位置，是否就不用再进行顺序检索了？  于是，可以将二分查找算法改成分别查找目标数字的首次出现位置和末次出现位置。也就是说，如果mid上的数字等于num，同时mid-1（mid&gt;0）上的数字不等于num，则mid为首次出现位置，否则，首次出现位置就应该还在前半段，同理，末次出现位置也是相似的道理。</p><p>结合以上讨论，将二分查找分成两个函数，分别找首次和末次位置，这样时间复杂度就是 $O(logn)$，无需进行顺序查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> index1 = binarySearchFirst(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> index2 = binarySearchLast(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(index1 == <span class="number">-1</span> || index2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> index2-index1+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first &gt; last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> || data.at(mid<span class="number">-1</span>) != num)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> binarySearchFirst(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearchFirst(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearchFirst(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first &gt; last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==last || data.at(mid+<span class="number">1</span>)!=num)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> binarySearchLast(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearchLast(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearchLast(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三-解法二的非递归实现-更简洁易懂"><a href="#解法三-解法二的非递归实现-更简洁易懂" class="headerlink" title="解法三: 解法二的非递归实现(更简洁易懂)"></a>解法三: 解法二的非递归实现(更简洁易懂)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> first_k = <span class="number">-1</span>, last_k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &lt; k) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[low] != k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> first_k = low;</span><br><span class="line">        high = data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; data[mid]) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        last_k = low;</span><br><span class="line">        <span class="keyword">return</span> last_k - first_k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h2 id="解法一-非递归-1"><a href="#解法一-非递归-1" class="headerlink" title="解法一: 非递归"></a>解法一: 非递归</h2><p>利用<del>BFS广度优先遍历</del>（错了，树没有广度遍历，这个应该叫层次遍历），<del>结合一个专门存储当前节点所处深度的队列实现</del> 利用一个<code>layer_count</code>变量来记录当前层总共的节点数, 每次当<code>pop</code>了当前节点数个节点后, <code>depth</code>都会增1，最终的树深度，就应该等于<del>广度优先遍</del>层次遍历历最后一个访问节点所处的深度。（因为这肯定是最后一层，也就是最深的一层）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; tree_q;</span><br><span class="line">        tree_q.push(pRoot);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!tree_q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_count = tree_q.size(); <span class="comment">//记录当前层共有多少节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;layer_count; i++)&#123; <span class="comment">// 根据当前层节点进行pop</span></span><br><span class="line">                TreeNode* cur_node = tree_q.front(); tree_q.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) tree_q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) tree_q.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：牛客-2"><a href="#解法二：牛客-2" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>二叉树中的某个节点的深度，就是其左子树深度和右子树深度较大者+1 ， 二叉树的深度就是根节点的深度，所以，利用递归的思想实现。（代码简洁，但是复杂复杂度好像和广度优先一样，都是n？ 是这样吗？）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> depth1 = <span class="number">1</span>, depth2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left!=<span class="literal">nullptr</span>) depth1 = TreeDepth(pRoot-&gt;left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;right!=<span class="literal">nullptr</span>) depth2 = TreeDepth(pRoot-&gt;right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> depth1&gt;depth2 ? depth1 : depth2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更简洁的写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max( TreeDepth(pRoot-&gt;left)+<span class="number">1</span>, TreeDepth(pRoot-&gt;right)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39.平衡二叉树"></a>39.平衡二叉树</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><h2 id="解法一（自想）-2"><a href="#解法一（自想）-2" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>将题目看作是求左右子树的深度，如果深度差超过1,那么就不是二叉树，返回一个特殊的标识（-1），这种方法属于一边遍历，一边判断，只需要遍历每个节点一次，通过递归实现。时间复杂度为 $O(logn)$</p><p><strong>有一种“不太好”的方法是每遇到一个节点，就单独求一次这个节点对应的树的深度，这种做法要遍历一个节点很多次，是一种典型的不令人满意的做法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tdepth = treeDepth(pRoot);</span><br><span class="line">        <span class="keyword">if</span>(tdepth!=<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftdepth = treeDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(leftdepth == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightdepth = treeDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(rightdepth == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(leftdepth-rightdepth) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(leftdepth,rightdepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更凝练的写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree_depth(pRoot)==<span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tree_depth</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_depth = tree_depth(pRoot-&gt;left); <span class="comment">//注意, 这里没有 +1,</span></span><br><span class="line">        <span class="keyword">if</span>(left_depth==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 在这里直接断left_depth判断, 如果发现=-1,就一路返回, 无需再求右子树深度</span></span><br><span class="line">        <span class="keyword">int</span> right_depth = tree_depth(pRoot-&gt;right); <span class="comment">//注意, 这里没有 +1</span></span><br><span class="line">        <span class="keyword">if</span>(right_depth==<span class="number">-1</span> || <span class="built_in">abs</span>(left_depth-right_depth) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>; <span class="comment">// 注意, 这有一定要有+1, 因为树深度就等于左右子树最大深度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><p>（暴力解法就不提了，肯定不是最优。）</p><h2 id="解法一：异或"><a href="#解法一：异或" class="headerlink" title="解法一：异或"></a>解法一：异或</h2><p>注：异或运算符还可以实现无中间变量的两个数字互换：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">4</span>;</span><br><span class="line">a = a^b; <span class="comment">// a = 2^4 = 6</span></span><br><span class="line">b = a^b; <span class="comment">// b = 6^4 = 2</span></span><br><span class="line">a = a^b; <span class="comment">// a = 6^2 = 4</span></span><br><span class="line"><span class="comment">//同理有</span></span><br><span class="line">a = a + b; <span class="comment">// a = 2+4 = 6</span></span><br><span class="line">a = a - b; <span class="comment">// b = 6-4 = 2</span></span><br><span class="line">a = a - b; <span class="comment">// a = 6-2 = 4</span></span><br></pre></td></tr></table></figure></p><p>异或运算的性质：任何一个数字异或它自己都等于0 。与0异或则保留原值<br>也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。</p><p>（这里不限定是一次，只要是奇数次都可以）</p><p>本题数列中，有两个出现一次的数字，第一次先全部异或，得到的结果是两个一次数字的异或值，该异或值至少有一位的值为1 (即在这一位上, 两个数字一个为0, 一个为1), 因此，找到这一位，然后根据这一位这数组分成两拨，如此一来，每一拨都变成了上面的简单情况。</p><p>（同理，如果有N个一次数字，可以通过不断分拨的方法解决, 例如, 如果有3个一次数字, 则找了为1的那一位, 可以将其分成具有2个一次数字和具有一个一次数字的两拨数组）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span> * num1,<span class="keyword">int</span> * num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size() &lt; <span class="number">2</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> xor_res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : data)</span><br><span class="line">            xor_res ^= x;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( (xor_res &amp; i) == <span class="number">0</span>) <span class="comment">// 按位异或的优先级小于 '==' 的优先级, 因此一定要用括号括起来</span></span><br><span class="line">            i = i&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        *num1=<span class="number">0</span>, *num2=<span class="number">0</span>; <span class="comment">//return;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : data)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (x &amp; i) != <span class="number">0</span>)  <span class="comment">// 按位与的优先级小于 '!=' , 所以必须用括号</span></span><br><span class="line">                *num1 = *num1 ^ x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2 = *num2 ^ x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扩展-数组中只有一个数出现一次，其他数都出现了2次，找出这个数字"><a href="#扩展-数组中只有一个数出现一次，其他数都出现了2次，找出这个数字" class="headerlink" title="扩展: 数组中只有一个数出现一次，其他数都出现了2次，找出这个数字"></a>扩展: 数组中只有一个数出现一次，其他数都出现了2次，找出这个数字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find1From2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> len = a.size(), res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">         res = res ^ a[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="扩展-数组中只有一个数出现一次，其他数字都出现了3次，找出这个数字"><a href="#扩展-数组中只有一个数出现一次，其他数字都出现了3次，找出这个数字" class="headerlink" title="扩展: 数组中只有一个数出现一次，其他数字都出现了3次，找出这个数字"></a>扩展: 数组中只有一个数出现一次，其他数字都出现了3次，找出这个数字</h2><p>例如数组a[]={2,4,4,4,6,6,6};结果则返回2；思路则是利用位运算，因为其他数字都出现了三次，那么他们的二进制相同位上1的个数则是3的倍数，这样的话，最后统计完3的倍数的位清0，剩下的1则都是那个只出现一次的数的位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find1From3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *bits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>]; <span class="comment">//因为整数一般为4字节, 32位</span></span><br><span class="line">    <span class="keyword">int</span> len = a.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)&#123;</span><br><span class="line">            bits[j] = bits[j] + ( (a[i]&gt;&gt;j) &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bits[i] % <span class="number">3</span> !=<span class="number">0</span>)&#123;</span><br><span class="line">            res = res | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] bits;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="41-和为S的连续正数序列"><a href="#41-和为S的连续正数序列" class="headerlink" title="41.和为S的连续正数序列"></a>41.和为S的连续正数序列</h1><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<br>输出描述:<br>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p><h2 id="解法一（自想）-3"><a href="#解法一（自想）-3" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>设置两个变量记录当前序列的start位置和end位置，判断当前序列的和:</p><ul><li>如果=sum，则存储当前序列，并将start+1,序列前进;</li><li>如果&gt;sum,将应减去序列中的最小值，也就是start指向位置的值，然后start+1;</li><li>如果&lt;sum，则应该再加上下一个值，也就是end指向的值。</li></ul><p>然后再进行上面的循环，直到start指向的位置值为sum/2,此时就已经不可能出现和为sum的连续序列了。该方法时间复杂度为$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end =start; start &lt;= sum/<span class="number">2</span> ;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp == sum)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numseq;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i&lt;end; i++)&#123;</span><br><span class="line">                    numseq.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                results.push_back(numseq);</span><br><span class="line">                tmp -=start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( tmp &gt; sum)&#123;</span><br><span class="line">                tmp -= start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                tmp += end;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-等差序列求和公式"><a href="#解法二-等差序列求和公式" class="headerlink" title="解法二: 等差序列求和公式"></a>解法二: 等差序列求和公式</h2><h1 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42.和为S的两个数字"></a>42.和为S的两个数字</h1><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</p><h2 id="解法一（自想）-4"><a href="#解法一（自想）-4" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>设置两个变量，分别指向数组的第一个位置和最后一个位置，然后将这两个变量所指位置的值相加，分以下三种情况：</p><ul><li><code>=sum;</code> <del>判断二者乘积是否比当前最小值小，如果是，则改变最小值的持有值。 不管是否小，都将num1++</del> 实际上, 根本无需判断是否比当前最小值小, 因为对于和相同的两组数, 数字差值较大的那一组的成绩一定小于数字差值较小的, 因此, 只要找到符合和为sum条件的两个数字, 即可直接返回, 无需进行任何额外判断.</li><li><code>&gt;sum; num2--;</code></li><li><code>&lt;sum; num1++;</code><br>循环以上三步直到 <code>num1&gt;=num2</code>。最后判断minnum1和minnum2的值，如果二者相等，说明数组里面不存在这样的数对儿，返回空vector，若不相等，则输出这两个值。</li></ul><p>结论证明：<br>假设：找到两组满足条件的数组对 $（x，y）$、$（x+a,y-a）$，其中（ $x+y=S, 0&lt;a&lt;y-x$ ）</p><script type="math/tex; mode=display">x*y-[(x+a)(y-a)]=x*y-x*y-(y-x)a+a2=a[a-(y-x)]</script><p>因为 $0&lt;a&lt;y-x$ ,所以 $a-(y-x)&lt;0$ ,所以 $a[a-(y-x)]&lt;0$<br>因此 $(x,y)$ 乘积一定比 $(x+a,y-a)$ 小</p><p>当第一次找到符合条件的两个数字时, 它们的乘积就一定是最小的, 所以可以直接退出.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//在使用容器的back()方法访问时，必须要确保容器不是空的，否则会出现段错误（访问越界）</span></span><br><span class="line">        <span class="keyword">int</span> maxnum1 = <span class="built_in">array</span>.back(), maxnum2 = <span class="built_in">array</span>.back();</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[low] + <span class="built_in">array</span>[high] == sum)&#123; <span class="comment">//首次找到就可返回</span></span><br><span class="line">                res.push_back(<span class="built_in">array</span>[low]);</span><br><span class="line">                res.push_back(<span class="built_in">array</span>[high]);</span><br><span class="line">                <span class="keyword">return</span> res; <span class="comment">//首次找到就可返回</span></span><br><span class="line">                low++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[low] + <span class="built_in">array</span>[high] &lt; sum)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h1><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h2 id="解法一（自想）：利用str-substr-pos-n"><a href="#解法一（自想）：利用str-substr-pos-n" class="headerlink" title="解法一（自想）：利用str.substr(pos,n)"></a>解法一（自想）：利用str.substr(pos,n)</h2><p><strong>注意：</strong></p><p>这道题看似简单，实则很容易考虑不全，主要需注意以下几点：</p><ul><li>n大于str.length()的情况</li><li>str.length()=0的情况</li><li>n为负数的情况（虽然这里牛客没考虑，我觉得题里没说正数，所以是有负数的可能的）</li></ul><p><strong>越是简单的题，越要注意各种情况的考虑，因为这种题的考察点就是考虑是否全面，而不是题怎么解</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=str.length())  n = n % str.length();</span><br><span class="line">        res=str.substr(n);</span><br><span class="line">        res += str.substr(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二（牛客）：反转"><a href="#解法二（牛客）：反转" class="headerlink" title="解法二（牛客）：反转"></a>解法二（牛客）：反转</h2><p>利用多次反转的方法，首先将字符串按照n的位置分成两部分，然后进行以下三步（abcdefg，2）：</p><ul><li>反转前一部分：ba</li><li>反转后一部分：gfed</li><li>反转整个字符串：bagfed -&gt; defgab</li></ul><p>时间复杂度也为$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">my_inverse</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> start, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i&lt;=mid; i++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(str[i], str[high-i+start]); <span class="comment">// 这里注意交换时的下标, 因为i是从start开始的, 所以高位的下标应该为high-(i-start)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) n = str.size() + n; <span class="comment">//左移-1位, 等于右移1位, 等于左移size-1位</span></span><br><span class="line">        my_inverse(str, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        my_inverse(str, n, str.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//return str;</span></span><br><span class="line">        my_inverse(str, <span class="number">0</span>, str.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44.翻转单词顺序列"></a>44.翻转单词顺序列</h1><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h2 id="解法一：-5"><a href="#解法一：-5" class="headerlink" title="解法一："></a>解法一：</h2><p>设值两个标记i，j，都从字符串的最后一位开始，如果当前字符不是空格，那么i指向下一个，直到遇到空格为止，此时，将i到j范围内字符提取出来，然后把令j=i。重复以上过程，直到i=0为止。 该解法时间复杂度为 $O(n)$ 而且只需遍历一边字符串。</p><p>但是空间复杂度也为 $O(n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = str.length()<span class="number">-1</span>, j=str.length()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;<span class="comment">//这里注意不能用双引号,双引号代表字符串,在C++内部,""与''表示的是不同的东西</span></span><br><span class="line">                res += str.substr(i+<span class="number">1</span>,j-i);</span><br><span class="line">                res += <span class="string">" "</span>;</span><br><span class="line">                i--;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                res += str.substr(i,j-i+<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法二（牛客）：两次反转"><a href="#解法二（牛客）：两次反转" class="headerlink" title="解法二（牛客）：两次反转"></a>解法二（牛客）：两次反转</h2><p>首先反转整个字符串，然后以空格为间隔，反转每个单词。时间复杂度也是$O(n)$ 。<br>空间复杂度为 $O(1)$</p><h1 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h1><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张)他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h2><p>该题目需要注意：1123 这样的顺序返回的是false</p><h2 id="解法一-自想"><a href="#解法一-自想" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>分析能组成顺子的数字的特征，首先，最大的数字和最小的数字他们的差一定要比numbers的size小，否则，肯定连不了顺子。比如12345和2300等。其次，如果数组中出现非0的重复数字，那么也一定不是顺子。因此，代码可以这样写：</p><ul><li>找出非0的最大值和最小值</li><li>在找最值的时候顺便利用最简单的hash表来存储每个数字出现的次数，hash表长度为14，key值为数字，value值为key值出现的次数，如果value出现&gt;1的情况，则直接返回false</li><li>做判断，如果max-min&lt; numbers.size()，则返回true，否则返回false。</li></ul><p>以上程序时间复杂度为$O(n)$ ，并且只需要遍历一次numbers。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] == <span class="number">0</span>) i++;</span><br><span class="line">        <span class="keyword">int</span> min=numbers.at(i);</span><br><span class="line">        <span class="keyword">int</span> max = numbers.at(i);</span><br><span class="line">        <span class="keyword">int</span> zeronum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">14</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.begin(); it!=numbers.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it &lt; min &amp;&amp; *it!=<span class="number">0</span>) min = *it;</span><br><span class="line">            <span class="keyword">if</span>(*it &gt; max) max = *it;</span><br><span class="line">            <span class="keyword">if</span>(*it == <span class="number">0</span>) zeronum++;</span><br><span class="line">            count[*it]++;</span><br><span class="line">            <span class="keyword">if</span>(*it != <span class="number">0</span> &amp;&amp; count[*it] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max-min &lt;= numbers.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面对max和min赋值的时候, 有可能会出现需要遍历n次的情况, 用下面的方法稍微改进一下(复杂度不变), 要注意不论是max还是min, 都不能为0.(全0的情况时, 会返回true)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> poke_hash[<span class="number">14</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max_poke = INT_MIN, min_poke = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item : numbers)&#123;</span><br><span class="line">            poke_hash[item]++;</span><br><span class="line">            <span class="keyword">if</span>(item!=<span class="number">0</span> &amp;&amp; poke_hash[item]&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(item!=<span class="number">0</span> &amp;&amp; item &lt; min_poke) min_poke = item;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(item!=<span class="number">0</span> &amp;&amp; item &gt; max_poke) max_poke = item;</span><br><span class="line">            <span class="keyword">if</span>(max_poke!=INT_MIN &amp;&amp; min_poke!=INT_MAX &amp;&amp; max_poke - min_poke &gt;= numbers.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="解法二（牛客）："><a href="#解法二（牛客）：" class="headerlink" title="解法二（牛客）："></a>解法二（牛客）：</h2><p>先排序，在统计0的个数，再用0填补空缺，时间复杂度为 $O(nlogn)$ 不如上面的方法好。</p><h1 id="46-圆圈中最后剩下的数：约瑟夫（Josephuse）环问题"><a href="#46-圆圈中最后剩下的数：约瑟夫（Josephuse）环问题" class="headerlink" title="46.圆圈中最后剩下的数：约瑟夫（Josephuse）环问题"></a>46.圆圈中最后剩下的数：约瑟夫（Josephuse）环问题</h1><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>0,1,…,n-1这n个数字排成一个圆圈，从数字0开始每次删除m-1处的数字，然后从这个数字的下一位继续从0开始，删除m-1处的数字，求出圆圈里剩下的最后一个数字</p><h2 id="解法一（自想）：利用vector维护动态数组模拟约瑟夫环"><a href="#解法一（自想）：利用vector维护动态数组模拟约瑟夫环" class="headerlink" title="解法一（自想）：利用vector维护动态数组模拟约瑟夫环"></a>解法一（自想）：利用vector维护动态数组模拟约瑟夫环</h2><p>利用一个vector维护一个动态数组，数组内的内容是每个孩子的编号，每次要删除的节点位置，都在index+m-1处，如果index+m-1超过了数组的大小，则对数组的size求余即可。该算法是最简单的一种思路，<del>时间复杂度为：$O(n)$</del> ，vector或list在删除时，由于要将后面的元素向前挪，所以erase的时间<br>复杂度为 $O(n)$ ，因此，总的时间复杂度为$O(n^2)$。</p><p>空间复杂度为 $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; joseph_ring;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            joseph_ring.push_back(i);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(joseph_ring.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            index = (index+m<span class="number">-1</span>) % joseph_ring.size();</span><br><span class="line">            joseph_ring.erase(joseph_ring.begin() + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joseph_ring[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二（牛客）：经典解法，用环形链表模拟圆圈"><a href="#解法二（牛客）：经典解法，用环形链表模拟圆圈" class="headerlink" title="解法二（牛客）：经典解法，用环形链表模拟圆圈"></a>解法二（牛客）：经典解法，用环形链表模拟圆圈</h2><p>可以用<code>std::list</code>或者<code>std::vector</code>来模拟一个环形链表，由于它们本身不是循环的，因此需要记得手动实现循环逻辑（其实就是解法一）</p><p>如果要求不可以使用标准模板库里面的数据容器来模拟环形链表，那么可以自己设计结构体类型，实现一个循环链表。</p><p>这里由于链表随机在删除节点时的时间复杂度为 $O(1)$ , 但是无法进行随机访问，只能顺序访问，因此删除时需要先顺序移动到该节点上才行, 所以要时间复杂度仍然为$O(n^2)$</p><p>空间复杂度为$O(n)$。</p><h2 id="解法三（牛客）："><a href="#解法三（牛客）：" class="headerlink" title="解法三（牛客）："></a>解法三（牛客）：</h2><p>分析每次删除时的数字规律，总结出以下公式，按照公式编写递归或非递归程序，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$ 。</p><script type="math/tex; mode=display">f(n) = \begin{cases} 0 & n=1 \\  [f(n-1,m)+m]\%n & n>1 \end{cases}</script><p>思考过程：当把第m个数(下标为m-1)去掉以后, 就只剩下了n-1个数, 此时, 再从下标m开始, 继续进行大小为n-1的约瑟夫环问题. 这里假设我们已经知道了大小为n-1的约瑟夫环问题的解为下标 $x’$, 则 $x’$ 在大小为n的约瑟夫环问题里面的下标应该为: $x = (x’ + m) % n$ . 由此式即可得到上面的递归公式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;= <span class="number">0</span> || m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n)&#123; <span class="comment">// 注意是&lt;=, 因为此处的i代表的是size, 必须要一直计算到i==n为止</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 这里的else就算没有, 结果也是对的</span></span><br><span class="line">                res = (res+m)%i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">递归写法</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="47-非常规法求前n项和"><a href="#47-非常规法求前n项和" class="headerlink" title="47.非常规法求前n项和"></a>47.非常规法求前n项和</h1><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>这道题本身没有实际意义，侧重考察发散性思维和对C++相关机制的理解程度。</p><h2 id="解法一：构造函数"><a href="#解法一：构造函数" class="headerlink" title="解法一：构造函数"></a>解法一：构造函数</h2><p>每声明一个对象，则构造函数都被调用一次，因此，可以借助静态变量来在构造函数内部实现累加操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sum</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">        sum()&#123;i++; s+=i;&#125;;</span><br><span class="line">        ~sum()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            s = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">int</span> sum::i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum::s = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sum::<span class="built_in">set</span>();</span><br><span class="line">        sum a[n];</span><br><span class="line">        <span class="keyword">return</span> sum::s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：虚函数"><a href="#解法二：虚函数" class="headerlink" title="解法二：虚函数"></a>解法二：虚函数</h2><p>利用虚函数来模拟递归函数，可以在两个类中分别定义函数，其中一个函数充当递归函数的角色，另一个函数处理终止递归的情况，然后在两个函数里二选一。</p><p>这里用到了一个小trick，那就是对于整型变量n，执行<code>!!n</code>以后，可以将其转换成布尔值（0和1）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual int sum(int n)&#123;return 0;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">A* Array[2];  //这里必须为指针，否则不会进入B的sum 函数</span><br><span class="line">class B : public A&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual int sum(int n)&#123;return Array[!!n]-&gt;sum(n-1) + n;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        class A a;</span><br><span class="line">        class B b;</span><br><span class="line">        Array[0] = &amp;a;</span><br><span class="line">        Array[1] = &amp;b;</span><br><span class="line">        return Array[1]-&gt;sum(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面用了虚函数，那么使用普通的函数可以吗？答案是否定的，因为使用普通函数时，无法同时调用两个类的函数，最终只会调用A类的sum函数。</p><h2 id="解法三：函数指针"><a href="#解法三：函数指针" class="headerlink" title="解法三：函数指针"></a>解法三：函数指针</h2><p>同样是上面的思想，不过改为使用函数指针来实现两个函数模拟递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*fun[<span class="number">2</span>])</span><span class="params">(<span class="keyword">int</span> n)</span> </span>= &#123;A,B&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun[!!n](n<span class="number">-1</span>) + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法四：模板类"><a href="#解法四：模板类" class="headerlink" title="解法四：模板类"></a>解法四：模板类</h2><p>使用模板类完成递归，这种方法有一个很大的缺点就是整个过程是在编译阶段完成的，因此无法使用动态的n，而必须是在编译期间就能确定的常量，另外，编译器对递归编译代码的递归深度也是有限制的，所以n不能太大。</p><h1 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h1><h1 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h1><h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br>输入描述:</p><p>输入一个字符串,包括数字字母符号,可以为空</p><p>输出描述:</p><p>如果是合法的数值表达则返回该数字，否则返回0</p><h2 id="解法一（自想）："><a href="#解法一（自想）：" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>从头开始逐个字符遍历，每次遇到一个“数字”，就将之间的res×10，然后再加上这个数字。需要特别注意“-123”，“+123”等情况。 时间复杂度为 $O(n)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            negative=<span class="literal">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'+'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; str.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                res = res*<span class="number">10</span> + (<span class="keyword">int</span>)(str[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(negative) res = <span class="number">0</span> - res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><p>上面的代码虽然已经解决了牛客的题，但是有几点是需要特别注意的！</p><p>首先，题目很简单，所以这道题的考察点只在于是否将所有情况都考虑到了，以下是一些可能的情况，日后再遇到一定要想起来：</p><ul><li>首先考虑如何返回错误，首先不能使用可以转换成数值类型（int，bool，char）的数据直接指明错误（比如返回0，无法得知到底是错误当时真的是0），由此，可以创建一个全局的错误变量，如果要返回错误，则返回0并且将该变量状态改变。</li><li>非数字类符号不全是错误输出，如：<code>+123</code>、<code>-123</code></li><li>只输入<code>+</code>和<code>-</code>时，要返回错误</li><li><code>string str==&quot;&quot;</code>时，也要返回错误</li><li>如果为<code>char str*</code>，则要判断指针是否为空</li><li>一定要考虑数值溢出情况（当转换的数字大于最大正数，小于最小负数时，会溢出）</li></ul><h1 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h1><h2 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h2><p>对于每个数组中的数字，都到前面的数字中去寻找是否有重复的。</p><p>时间复杂度： $O(n^2)$  空间复杂度： $O(1)$</p><h2 id="解法二：哈希"><a href="#解法二：哈希" class="headerlink" title="解法二：哈希"></a>解法二：哈希</h2><p>建立长度为n的哈希表，每次遇到一个数字x，就在hash[x]增1，如果此时hash[x]变为2，那么就说明有重复。</p><p>时间复杂度： $O(n)$  空间复杂度： $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hash(length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; length; i++)&#123;</span><br><span class="line">            hash[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(hash[numbers[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><h1 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h1><h2 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><h2 id="解法一（自想）：-1"><a href="#解法一（自想）：-1" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>将乘积看成两段，前i-1项的乘积，和后n-i项的乘积，分开计算，最终合并。<br>时间复杂度： $O(n)$   空间复杂度： $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = A.begin(); it!=A.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it!=A.begin()) tmp *= *(it<span class="number">-1</span>);</span><br><span class="line">            B.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=A.size()<span class="number">-1</span>) tmp *= A.at(i+<span class="number">1</span>);</span><br><span class="line">            B.at(i) *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h1><h2 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括<code>.</code>和<code>*</code>的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>aaa</code>与模式<code>a.a</code>和<code>ab*ac*a</code>匹配，但是与<code>aa.a</code>和<code>ab*a</code>均不匹配</p><h2 id="解法一：（牛客）"><a href="#解法一：（牛客）" class="headerlink" title="解法一：（牛客）"></a>解法一：（牛客）</h2><p>主要分两种情况：</p><ul><li>当前字符的下一个字符不是<code>*</code></li><li>当前字符的字一个字符是<code>*</code></li></ul><p>对于第一种情况：直接判断是否相等（包含‘.’的情况）</p><p>对于第二种情况，需要分情况讨论：</p><ul><li>当前字符与pattern当前字符不相等，则patter当前只能出现零次，调用<code>match(str, pattern+2)</code></li><li>当前字符与pattern字符相等（包含‘.’的情况），则pattern的选择有两种，出现零次，或者出现一次以上，这两种情况都必须考虑，否则会丢解，如（aab和a.*ab），因此，需要调用<code>match(str, pattern+2) || match(str+1, pattern)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( *str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( *str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( *(pattern+<span class="number">1</span>) != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*str!=<span class="string">'\0'</span> &amp;&amp; (*str == *pattern || *pattern==<span class="string">'.'</span>))  <span class="comment">//  *str的条件不能丢</span></span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(*str!=<span class="string">'\0'</span> &amp;&amp; (*str == *pattern || *pattern==<span class="string">'.'</span>))  <span class="comment">//这里的if else组合语句是必须的，否则会在不能出现多次时，函数仍然考虑出现多次的情况，造成误解</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>) || match(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h1><h2 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h2 id="解法一（自想）：-2"><a href="#解法一（自想）：-2" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>没有难点，考察点主要在于各种情况的考虑（以下均为false）：</p><ul><li>+</li><li>-</li><li>+12.2.2</li><li>12e</li><li>12e-</li><li>12E+4.3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*string == &apos;\0&apos;) return false;</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        int point_count = 0;</span><br><span class="line">        while( (*string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos;)</span><br><span class="line">             || *string == &apos;.&apos;)&#123;</span><br><span class="line">            if (*string == &apos;.&apos;) point_count++;</span><br><span class="line">            if (point_count &gt; 1) return false;</span><br><span class="line">            string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        if(*string == &apos;e&apos; || *string == &apos;E&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        while( *string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos; )</span><br><span class="line">            string++;</span><br><span class="line">        if(*string != &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h1><h2 id="解法一（牛客）：哈希表"><a href="#解法一（牛客）：哈希表" class="headerlink" title="解法一（牛客）：哈希表"></a>解法一（牛客）：哈希表</h2><p>建立一个哈希表和一个char数组（均为256大小），哈希表存储每个字符出现的次数，key为char，value为次数，数组存储所有 <strong>曾经</strong> 出现过一次的字符。</p><p>时间复杂度 $O(n)$  空间复杂度 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="keyword">char</span> hash_c[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> first_c[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hash_c[ch]++;</span><br><span class="line">        <span class="keyword">if</span>(hash_c[ch] == <span class="number">1</span>)&#123;</span><br><span class="line">            *(first_c+index) = ch;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;index; i++)</span><br><span class="line">            <span class="keyword">if</span> (hash_c[*(first_c+i)] == <span class="number">1</span>) <span class="keyword">return</span> *(first_c+i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="55-链表中环的入口节点"><a href="#55-链表中环的入口节点" class="headerlink" title="55.链表中环的入口节点"></a>55.链表中环的入口节点</h1><h2 id="解法一（牛客）"><a href="#解法一（牛客）" class="headerlink" title="解法一（牛客）"></a>解法一（牛客）</h2><p>假设有环，并且环中的节点数为n，那么只要设值两个指针，一个slow指针指向头结点，另一个fast指针指向第n+1个节点，然后每次slow指针和fast指针都增1，那么肯定会在环的头部相遇（因为fast刚好比slow领先了一个环的长度）</p><p>因此，首先需要判断是否有环，思路是：从头结点开始，slow每次走一步，fast每次走两步，那么只要有环，slow和fast就一定会在环中的某个节点处相遇，如果无环，则fast一定先到达空指针</p><p>判断有环后，令fast从当前节点开始，继续往下走（每次走一步），并记录步数，最终遇到slow时的步数就是环的长度。</p><p>该方法时间复杂度为 $O(n)$  空间复杂度为  $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(step&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            step--;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二（牛客）：-断链法"><a href="#解法二（牛客）：-断链法" class="headerlink" title="解法二（牛客）： 断链法"></a>解法二（牛客）： 断链法</h2><p>同理，先判断有环无环</p><p>然后记录两个指针，一个当前节点指针cur，一个相邻祖先指针pre，每经过一个节点时，都将pre指针的next置为nullptr，则当cur的next为空时，既为环的首个节点。</p><p>该方法的时间复杂度为O(n)，且只需遍历两次，且第二次遍历的时候正好遍历n个节点，但是缺点是会破坏链结构，补救办法是使用额外的标记来替代断链，但是这样会增加额外空间开销</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;next == pHead) <span class="keyword">return</span> pHead;  <span class="comment">//需要特别考虑只有一个节点并且自己组成环的情况</span></span><br><span class="line">        slow = pHead;</span><br><span class="line">        fast = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            slow = fast;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三：没太看懂"><a href="#解法三：没太看懂" class="headerlink" title="解法三：没太看懂"></a>解法三：没太看懂</h2><p><a href="https://blog.csdn.net/dawn_after_dark/article/details/82564271" target="_blank" rel="noopener">https://blog.csdn.net/dawn_after_dark/article/details/82564271</a><br>对应文中解法一</p><h1 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56.删除链表中重复的结点"></a>56.删除链表中重复的结点</h1><h2 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2 id="解法一（自想）：-3"><a href="#解法一（自想）：-3" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>这道题本身比较简单，只需要维护一个pre指针和cur指针，分别指向前一个结点和当前结点，如果当前结点和下一个结点的值相等，那么就删除当前结点，最后我pre指针的next值设置为指向未重复的结点</p><p>但是！本题恶心了我很久，一直报段错误，主要原因是有的结点没有做空判断，就访问了结点的val或者next成员，此时如果结点是空的，那么就会报段错误，主要有以下这么几个情况：</p><ul><li>头结点本身就是重复的，这个需要删除头结点，另外判断是否重复时，还要检查头结点的下一个结点是否为空，如果为空，则不能访问其val值，否则，报段错误</li><li>在进行重复判断时，访问<code>cur-&gt;next-&gt;val</code>时，需要先判断<code>cur-&gt;next</code>是否为空，如果为空，则不能访问其val值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead == nullptr || pHead-&gt;next == nullptr) return pHead;</span><br><span class="line">        ListNode* newHead = new ListNode(0); //  建立一个新的结点，其next用于标识头结点，以便在头结点重复时，指向新的头结点</span><br><span class="line">        newHead-&gt;next = pHead;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        ListNode* pre = newHead;</span><br><span class="line"></span><br><span class="line">        while(cur != nullptr &amp;&amp; cur-&gt;next !=nullptr)&#123;   // 注意   这里一定必须是 &amp;&amp; ，如果是|| ，则下面有可能会访问到空结点的val，造成段错误</span><br><span class="line"></span><br><span class="line">            if(cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class="line">                ListNode* dup = cur-&gt;next;</span><br><span class="line">                while(cur-&gt;val == dup-&gt;val &amp;&amp; dup!=nullptr)&#123;  // 同理，让验证所有欲访问的结点不为空</span><br><span class="line">                    dup = dup-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = dup;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return newHead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="57-二叉树的下一个节点"><a href="#57-二叉树的下一个节点" class="headerlink" title="57.二叉树的下一个节点"></a>57.二叉树的下一个节点</h1><h1 id="58-对称的二叉树"><a href="#58-对称的二叉树" class="headerlink" title="58.对称的二叉树"></a>58.对称的二叉树</h1><h2 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="　题目描述"></a>　题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解法一（牛客）：递归"><a href="#解法一（牛客）：递归" class="headerlink" title="解法一（牛客）：递归"></a>解法一（牛客）：递归</h2><p>要判断一个树是否对称，需要判断其树的左右子节点是否相等，同时还要判断左子树的右子树和右子树的左子树是否相等，以及左子树的左子树和右子树的右子树是否相等，然后如此递归解之：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymHelper(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymHelper</span><span class="params">(TreeNode* subRoot1, TreeNode* subRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> subRoot2==<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1-&gt;val != subRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> b1 = isSymHelper(subRoot1-&gt;right, subRoot2-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> b2 = isSymHelper(subRoot1-&gt;left, subRoot2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> b1&amp;&amp;b2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二（牛客）：非递归"><a href="#解法二（牛客）：非递归" class="headerlink" title="解法二（牛客）：非递归"></a>解法二（牛客）：非递归</h2><p>关键还是知道怎么样才能判断一个<br>二叉树是否对称，只要采用前序、中序、后序、层次遍历等任何一种遍历方法，分为先左后右和先<br>右后左两种方法，只要两次结果相等就说明这棵树是一颗对称二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//以下为层次遍历</span><br><span class="line">//与普通遍历不同的是，对于这道题，必须要把左右子树都存入到queue中，不论是否为空，因为只有这样才能将整个二叉树的结构存储起来，以便判断</span><br><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        if( nullptr==pRoot) return true;</span><br><span class="line">        q1.push(pRoot);</span><br><span class="line">        q2.push(pRoot);</span><br><span class="line">        TreeNode* cur1;</span><br><span class="line">        TreeNode* cur2;</span><br><span class="line">        while(!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">            cur1 = q1.front(); q1.pop();</span><br><span class="line">            cur2 = q2.front(); q2.pop();</span><br><span class="line">            if(cur1 == cur2 &amp;&amp; nullptr == cur1)</span><br><span class="line">                continue;</span><br><span class="line">            if(nullptr == cur1 || nullptr == cur2)</span><br><span class="line">                return false;</span><br><span class="line">            if(cur1-&gt;val != cur2-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            q1.push(cur1-&gt;left); q1.push(cur1-&gt;right);</span><br><span class="line">            q2.push(cur2-&gt;right); q2.push(cur2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三（牛客）：非递归"><a href="#解法三（牛客）：非递归" class="headerlink" title="解法三（牛客）：非递归"></a>解法三（牛客）：非递归</h2><p>=非递归算法，利用DFS和BFS===========================</p><p> BFS使用Queue来保存成对的节点</p><ol><li>出队的时候也是成对成对的<pre><code>       1.若都为空，继续；        2.一个为空，返回false;        3.不为空，比较当前值，值不等，返回false；</code></pre><ol><li>确定入队顺序，每次入队都是成对成对的，如left.left， right.right ;left.rigth,right.left</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(pRoot-&gt;left); q.push(pRoot-&gt;right);</span><br><span class="line">        TreeNode* lnode; TreeNode* rnode;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            lnode = q.front(); q.pop();</span><br><span class="line">            rnode = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == lnode &amp;&amp; <span class="literal">nullptr</span> == rnode) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == lnode || <span class="literal">nullptr</span> == rnode) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(lnode-&gt;val != rnode-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            q.push(lnode-&gt;left); q.push(rnode-&gt;right);</span><br><span class="line">            q.push(lnode-&gt;right); q.push(rnode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>DFS使用stack来保存成对的节点</p><ol><li>出栈的时候也是成对成对的 ，<pre><code>         1.若都为空，继续；         2.一个为空，返回false;         3.不为空，比较当前值，值不等，返回false；</code></pre></li><li>确定入栈顺序，每次入栈都是成对成对的，如left.left， right.right ;left.rigth,right.left</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        s.push(pRoot-&gt;left);</span><br><span class="line">        s.push(pRoot-&gt;right);</span><br><span class="line">        TreeNode* lnode; TreeNode* rnode;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            rnode = s.top(); s.pop();</span><br><span class="line">            lnode = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span>( <span class="literal">nullptr</span>==lnode &amp;&amp; <span class="literal">nullptr</span> == rnode)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>( <span class="literal">nullptr</span> == lnode || <span class="literal">nullptr</span> == rnode)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(lnode-&gt;val != rnode-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(lnode-&gt;left); s.push(rnode-&gt;right);</span><br><span class="line">            s.push(lnode-&gt;right); s.push(rnode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h1><h2 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解法一（自想）：-4"><a href="#解法一（自想）：-4" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>利用两个queue，一个用于层次遍历树节点，另一个用于存储对应节点的depth，然后每次访问节点时，都判断当前节点的层数，如果为奇数层，则将该层直接push back到结果向量中，如果为偶数，则将该层数据进行reverse后再push back到结果向量中。</p><p>时间复杂度为 $O(n^2)$  空间复杂度为 $O(n)$</p><p>需要注意的是最后一层的边界条件与其它层不同一样，需要专门判断以下，具体可以看下面的点注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q_node;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q_depth;</span><br><span class="line">        q_node.push(pRoot);</span><br><span class="line">        q_depth.push(<span class="number">1</span>);</span><br><span class="line">        TreeNode* cur; <span class="keyword">int</span> depth;</span><br><span class="line">        <span class="keyword">int</span> global_depth = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer;</span><br><span class="line">        <span class="keyword">while</span>(!q_node.empty())&#123;</span><br><span class="line">            cur = q_node.front(); q_node.pop();</span><br><span class="line">            depth = q_depth.front(); q_depth.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q_node.push(cur-&gt;left);</span><br><span class="line">                q_depth.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q_node.push(cur-&gt;right);</span><br><span class="line">                q_depth.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(depth == global_depth)&#123;</span><br><span class="line">                cur_layer.push_back(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q_node.empty())&#123;</span><br><span class="line">                  <span class="comment">// 对应最后一层的情况，当到了最后一层时，depth不会再继续增1了，</span></span><br><span class="line">                  <span class="comment">//所以不能通过global depth或depth的大小来判断是否进行pushback，</span></span><br><span class="line">                  <span class="comment">//需要通过看是否达到了最后一个节点来判断</span></span><br><span class="line">                    <span class="keyword">if</span>(global_depth % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        res.push_back(cur_layer);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        reverse(cur_layer.begin(), cur_layer.end());</span><br><span class="line">                        res.push_back(cur_layer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(global_depth % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res.push_back(cur_layer);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reverse(cur_layer.begin(), cur_layer.end());</span><br><span class="line">                    res.push_back(cur_layer);</span><br><span class="line">                &#125;</span><br><span class="line">                cur_layer.clear();</span><br><span class="line">                cur_layer.push_back(cur-&gt;val);</span><br><span class="line">                global_depth=depth;</span><br><span class="line">                <span class="keyword">if</span>(q_node.empty()) res.push_back(cur_layer);</span><br><span class="line">                <span class="comment">//这句话用于处理最后一层只有一个节点的情况，如果只有一个节点的话，</span></span><br><span class="line">                <span class="comment">//那么当前queue就为空，不会进入下一次循环，从而导致最后一层没有pushback进去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：牛客-3"><a href="#解法二：牛客-3" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>同样的思路，另一种写法，更加简洁，通过while里面内置for循环，来保证每次for循环都会将一整层的节点放进队列中，无需额外的数组来存储depth信息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/91b69814117f4e8097390d107d2efbe0</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        <span class="keyword">bool</span> even = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//将vec声明在内部，省去每次的clear操作，clear操作需要对vector进行遍历，并将每个元素置为null？</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> size = que.size(); <span class="comment">//当前存的节点数目就是这一层所有的节点，之前层的到已经被取出, 并且这一层的子节点还没有开始入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123; <span class="comment">//将该层所有节点的子节点入队列，同时当到达该层最后一个节点时终止</span></span><br><span class="line">                TreeNode* tmp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(even) <span class="comment">//根据奇偶标识判断是否需要reverse</span></span><br><span class="line">                <span class="built_in">std</span>::reverse(vec.begin(), vec.end());</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            even = !even;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h1><h2 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解法一（半自想）："><a href="#解法一（半自想）：" class="headerlink" title="解法一（半自想）："></a>解法一（半自想）：</h2><p>while循环加for循环，无需额外记录层数，具体看59题解法二分析</p><p>时间和空间复杂度为 $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">            <span class="keyword">if</span>(pRoot== <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; q_node;</span><br><span class="line">            q_node.push(pRoot);</span><br><span class="line">            <span class="keyword">while</span>(!q_node.empty())&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> cur_size = q_node.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cur_size; i++)&#123;</span><br><span class="line">                    TreeNode* cur_node = q_node.front(); q_node.pop();</span><br><span class="line">                    cur_layer.push_back(cur_node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) q_node.push(cur_node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) q_node.push(cur_node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(cur_layer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h1><h1 id="62-二叉搜索树的第k个节点"><a href="#62-二叉搜索树的第k个节点" class="headerlink" title="62.二叉搜索树的第k个节点"></a>62.二叉搜索树的第k个节点</h1><h2 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h2 id="解法一（自想）：-5"><a href="#解法一（自想）：-5" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>中根遍历，遍历到第k个节点时将其输出，如果k大于节点数量，输出nullptr, 时间复杂度 $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s_node;</span><br><span class="line">        TreeNode* P =  pRoot;</span><br><span class="line">        <span class="comment">//ctor&lt;TreeNode*&gt; vec_node;</span></span><br><span class="line">        <span class="keyword">int</span> cur_k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(P!=<span class="literal">nullptr</span> || !s_node.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s_node.push(P);</span><br><span class="line">                P = P-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!s_node.empty())&#123;</span><br><span class="line">                P = s_node.top(); s_node.pop();</span><br><span class="line">                cur_k++;</span><br><span class="line">                <span class="keyword">if</span>(cur_k == k) <span class="keyword">break</span>;</span><br><span class="line">                P = P-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_k == k) <span class="keyword">return</span> P;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h1><h2 id="解法一-自想-1"><a href="#解法一-自想-1" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>插入时用vector的insert方法,按顺序插入,空间为 $O(n)$ ,时间复杂度为$O(n)$ 返回中位数时直接利用下标,时间复杂度和空间复杂度都为 $O(1)$.</p><p>这里关于vector的insert方法,有两个需要注意的点:</p><ul><li>it = vec.insert(it,num);  如果后序还要继续插入的话, 就必须将insert的结果重新赋值给it, 否则如果没有重新赋值而直接继续使用it的话,会导致段错误,  这里因为已经不需要继续插入了,所以可以用break直接跳出,无需赋值</li><li>插入时,如果num比vec里面所有的数都大, 那么会导致插入失败, 此时 ,应使用push_back将num插入到最后</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            vec.insert(vec.begin(), num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> is_insert=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=vec.begin(); it!=vec.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it &gt; num)&#123;</span><br><span class="line">                vec.insert(it,num);</span><br><span class="line">                is_insert=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!is_insert) vec.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x1 = vec.size()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> x2 = (vec.size()<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (vec[x1]+vec[x2])/<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h2><p>插入的时候不考虑排序,在查找中位数时可以使用基于Partition的方法,时间复杂度为 $O(n)$.</p><h2 id="解法三-AVL树"><a href="#解法三-AVL树" class="headerlink" title="解法三:AVL树"></a>解法三:AVL树</h2><p>插入时间复杂度为 $O(logn)$  找中位数时间复杂度为 $O(1)$</p><h2 id="解法四-牛客-用大顶堆和小顶堆"><a href="#解法四-牛客-用大顶堆和小顶堆" class="headerlink" title="解法四(牛客):用大顶堆和小顶堆"></a>解法四(牛客):用大顶堆和小顶堆</h2><p>思路:</p><p>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。　　因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是 O(logn)。由于只需 O(1)时间就可以得到位于堆顶的数据，因此得到中位数的时间效率是 O(1)。</p><p>首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过 1</p><p>还要保证最大堆中里的所有数据都要小于最小堆中的数据</p><p>当数据的总数目是偶数时，按照前面分配的规则会把新的数据插入到最小堆中。如果此时新的数据比最大堆中的一些数据要小，怎么办呢？</p><p>可以先把新的数据插入到最大堆中，接着把最大堆中的最大的数字拿出来插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中的所有数字都大于最大堆中的数字。 当需要把一个数据插入到最大堆中，但这个数据小于最小堆里的一些数据时，这个情形和前面类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt; &gt; q_max;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; q_min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( q_max.size()&gt; q_min.size() )&#123;</span><br><span class="line">            q_max.push(num);</span><br><span class="line">            <span class="keyword">int</span> tmp = q_max.top(); q_max.pop();</span><br><span class="line">            q_min.push(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q_min.push(num);</span><br><span class="line">            <span class="keyword">int</span> tmp = q_min.top(); q_min.pop();</span><br><span class="line">            q_max.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res;</span><br><span class="line">        <span class="keyword">if</span>(q_max.size() == q_min.size())&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = q_max.top();</span><br><span class="line">            <span class="keyword">int</span> x2 = q_min.top();</span><br><span class="line">            res = (x1+x2)/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = q_max.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入时间复杂度为 $O(logn)$  找中位数时间复杂度为 $O(1)$</p><h1 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h1><h2 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2 id="解法一-自想-2"><a href="#解法一-自想-2" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>用最直接的办法, 每次求出滑动窗口内的最大值, 然后存到max_res向量里面, 该方法时间复杂度为 $O(nm)$ . 空间为 $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max_res;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> max_res; <span class="comment">//无符号整数, 要首先考虑size为0的情况, 否则会导致下面的程序数组越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; num.size()-size+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_max;</span><br><span class="line">            <span class="comment">//if(i&lt;num.size())  tmp_max = num[i]; //这里的if语句看起来是多余的, 实际上可以帮助进行数组越界检查, 有助于快速确定bug位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt; i+size ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] &gt; tmp_max) tmp_max = num[j]; <span class="comment">// 这里同样可以进行越界检查, 有助于bug定位, bug修复后可去掉</span></span><br><span class="line">            &#125;</span><br><span class="line">            max_res.push_back(tmp_max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二-讨论区"><a href="#解法二-讨论区" class="headerlink" title="解法二(讨论区):"></a>解法二(讨论区):</h2><p>使用双端队列deque, 从下标0开始, 一直到n-1, 每次进行如下步骤:</p><ul><li>当前元素是否比队列中最后一个元素大, 如果大, 说明队列元素以后也不可能再成为较大值, 直接pop, 如此循环, 直到队列为空或者遇到比当前值大的元素</li><li>判断队列中队首的元素是否过期(若队空则直接下一步, 无需判断), 若过期, 则pop, 否则, 不管( 只看队首, 队内的元素是否过期不影响算法, 因为就算过期后面也会将其淘汰)</li><li>将当前元素的下标存到队尾</li><li>将新的队首元素存到结果向量max_res中</li></ul><p>注意: 队列里面存的是下标,  而不是元素本身的值,  后面在提到队列的元素值时,  均是指队列中存储的下标对应的元素值.</p><p>时间复杂度分析: 不是 $O(n*szie)$  而是 $O(n)$ ?</p><p>原因:  假设队列里面的正好包含size个元素(最多就为size个), 那么这三个元素对应的值一定是递减的,  因为如果不是递减中, 在进行第一个判断时, 就会将其移除,  此时, 如果新来了一个元素, 如果该元素值小于队列中所有的值, 那么就只可能进行一次判断, 而不是循环size次, 而如果均大于队列中的值, 那么队列中的元素个数就会变成1个,  这样, 在下次进行判断时, 只会与一个元素做判断,  如果是元素值位于中间, 那么下一次做判断的元素个数也会减少一部分, 综上, 内部while循环时, 相对于普通的循环嵌套,  该种循环可以认为是常数级(虽然还是与size的大小有关, 但是总体来说,  要做的判断次数比通常的循环小).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; max_res;</span><br><span class="line">        deque&lt;int&gt; dq_index;</span><br><span class="line">        for(int i =0; i&lt; num.size(); i++)&#123;</span><br><span class="line">            while(!dq_index.empty() &amp;&amp; num[i] &gt; num[dq_index.back()] )&#123;</span><br><span class="line">                dq_index.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            if(!dq_index.empty() &amp;&amp; i-dq_index.front()&gt;= size)</span><br><span class="line">                    dq_index.pop_front();</span><br><span class="line">            dq_index.push_back(i);</span><br><span class="line">            if(i&gt;=size-1)</span><br><span class="line">                max_res.push_back(num[dq_index.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h1><h2 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>这是一个可以用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。<br>重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。<br>　　由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个<br>字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。<br>　　由于路径不能重复进入矩阵的格子，还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的<br>格子和路径字符串中相应的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下一个字符<br>如果4个相邻的格子都没有匹配字符串中下一个的字符，表明当前路径字符串中字符在矩阵中的定位不正确，我们需要回到前一个，然后重新定位。<br>　　一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置</p><p><strong>本题一定要注意边界条件即特殊情况的判断:</strong></p><ul><li>当矩阵所有元素一样时(这种情况一定要注意先)</li><li>当矩阵只有一个元素时(这两种情况要注意, 先进入递归程序, 然后再对flag矩阵进行判断, 否则, 当子串和矩阵大小一样时, 就无法判断到下一个字符是否==’\0’了)<br>-</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str[0] == &apos;\0&apos;) return true;</span><br><span class="line"></span><br><span class="line">        int* flag_matrix = new int[rows*cols];</span><br><span class="line">        for(int i = 0; i&lt;rows; i++)&#123;</span><br><span class="line">            for(int j =0 ;j&lt;cols; j++)&#123;</span><br><span class="line">                flag_matrix[i*cols+j] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt; rows; i++)&#123;</span><br><span class="line">            for(int j = 0;j&lt; cols; j++)&#123;</span><br><span class="line">                if(matrix[i*cols+j] == str[0])&#123;</span><br><span class="line">                    bool is_path = hasPath_helper(matrix,flag_matrix,i,j, rows, cols, str, 0);</span><br><span class="line">                    if(is_path)</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delete []flag_matrix;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasPath_helper(char* matrix,int* flag_matrix, int i, int j, int rows, int cols, char* str,int x)&#123;</span><br><span class="line">        if(str[x] == &apos;\0&apos;) return true;</span><br><span class="line"></span><br><span class="line">        if(i&lt;0 || i&gt;=rows || j&lt;0 || j&gt;=cols) return false;</span><br><span class="line">        if(flag_matrix[i*cols+j] == 0 || matrix[i*cols+j] != str[x]) return false;</span><br><span class="line"></span><br><span class="line">        flag_matrix[i*cols+j] = 0;</span><br><span class="line">        bool is_path = hasPath_helper(matrix, flag_matrix, i, j-1, rows, cols, str, x+1) ||</span><br><span class="line">                       hasPath_helper(matrix, flag_matrix, i-1 , j, rows, cols, str, x+1) ||</span><br><span class="line">                       hasPath_helper(matrix, flag_matrix, i, j+1, rows, cols, str, x+1) ||</span><br><span class="line">                        hasPath_helper(matrix, flag_matrix, i+1, j, rows, cols, str, x+1);</span><br><span class="line">        flag_matrix[i*cols+j] = 1;</span><br><span class="line">        return is_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h1><h2 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>回溯法, 如果当前节点的位数值满足要求, 那么从当前节点开始, 满足要求的格子数字应该等于” 1+左+右+上+下”, 其中方向代表这个方向上的满足要求的格子数.</p><p>注意每走过一次格子, 需要将flag矩阵中当前格子的标识设为”已走过(1)”,  并且, 由于此任务是统计符合条件的格子总数, 所以和一般的回溯法不同, 不能在递归结束后将该格子的标识重新复位(否则不同路径上回到同一个格子重复计数).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mc_helper(int threshold,int cur_i, int cur_j, vector&lt; vector&lt;int&gt; &gt;&amp; flag_matrix)&#123;</span><br><span class="line">        int rows = flag_matrix.size();</span><br><span class="line">        int cols = flag_matrix[0].size();</span><br><span class="line">        int cur_val = cur_i/10 + cur_i%10 + cur_j/10 + cur_j%10;</span><br><span class="line"></span><br><span class="line">        if(cur_val &gt; threshold</span><br><span class="line">           || cur_i&lt;0 || cur_i &gt;=rows || cur_j&lt;0 || cur_j&gt;=cols</span><br><span class="line">           || flag_matrix[cur_i][cur_j]) return 0;</span><br><span class="line"></span><br><span class="line">        flag_matrix[cur_i][cur_j] = 1;</span><br><span class="line">        return 1 + mc_helper(threshold, cur_i, cur_j-1, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i, cur_j+1, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i-1, cur_j, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i+1, cur_j, flag_matrix);</span><br><span class="line">        //flag_matrix[cur_i][cur_j] = 0;</span><br><span class="line">        //return cur_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int movingCount(int threshold, int rows, int cols)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(rows&lt;=0 || cols&lt;=0) return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; flag_matrix(rows, vector&lt;int&gt;(cols));</span><br><span class="line">        int count = mc_helper(threshold,0, 0, flag_matrix);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FCN-CVPR2015</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2015-FCN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2015-FCN/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong> Fully Convolutional Networks for Semantic Segmentation<br><strong>作者:</strong> Jonathan Long, Evan Shelhamer, Trevor Darrell</p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><p><del>全卷积网络: 只有最后一层是全连接层, 并且在针对 object detection 任务进行 fine-tuning 时, 会将该全连接层移除. (但是分类任务仍然需要这一层来输出最后的分类结果)</del></p><p><strong>(1) 利用FCN网络进行语义级别的图像分割</strong><br>与经典的CNN在卷积层之后使用全连接层得到固定长度的特征向量进行分类的方法不同, FCN将全连接层转化为卷积层, 使其可以接受任意尺寸的图像输入, 然后采用反卷积层对卷积层的 feature map 进行上采样, 使它恢复到输入图像相同的尺寸,, 从而可以对每个图像像素都产生一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素的分类.</p><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文的主要是建立一个全卷积网络，该网络可以接受任意尺寸的图片（因为没有全连接层，所以无需限定图片尺寸）,同时可以十分高效的输出相应尺寸的结果。本文定义和详细描述了全卷积网络的空间信息，解释了它们可以应用与空间密集型预测任务，并且画出了与之前模型的联系。本文将当前流行的AlexNet、VGGNet和GoogLeNet应用到全卷积网络中去，并对其进行迁移学习。然后，本文定义了一个新的网络，它将一个深层的粗糙layer的语义信息和一个浅层的精化layer的语义信息结合起来，最终生成了一个精确的详细的分割结果。本文的模型在众多数据集上都取得了sota表现（2015）</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>简要介绍了一下从图像分类到语义分割任务中，卷积网络起到的推进作用。并且指出本文的模型是目前（2015）为止第一个可以训练FANs end to end预测像素，并且支持supervised pre-training的网络模型。</p><p>本文模型无需任何前处理或后处理操作，也将不会产生随之而来的负面影响。本文还定义了一种新式的“skip”结构来结合深层粗糙的语义信息和浅层，精化的语义信息。后面会详细介绍</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>简单提了一下从分类到实例分割的相关论文。然后从以下几个方面进行了介绍。</p><p><strong>Fully convolutional networks：</strong> 介绍了全卷积网络的发展的现状，从90年代开始，就已经有人开始使用全卷积网络了，但是全卷积网络相对研究成果还是较少。</p><p><strong>Dense prediction with convnets：</strong> 目前已经有一些工作将convnets应用到了密集型预测任务。这些方法都包含有以下几点共有特征：</p><ul><li>模型较小：模型和容量和感受野都有一定限制。</li><li>patchwise training：在预测指定像素时，只将此像素和其周围像素作为输入送入模型里训练，即每一个像素都会作为中心像素被训练来预测这个像素所属的分类。patch-wise的问题无疑非常明显，第一：训练中用的patch会大量重叠，非常低效。第二：由于patch-wise大量的计算量，预测的时候很慢。</li><li>后处理：超像素映射，随机field正则化，局部分类</li><li>input shifting and output interlacing for dense output as introduced by OverFeat</li><li>多尺寸金字塔处理</li><li>tanh非线性包含</li><li>融合（ensembles）</li></ul><p>FCN则没有以上机制。 与现有模型不同，本文使用image classification作为有监督的预训练，同时fine-tune全卷积，以期望从整张输入图片中快速且高效的学到相应的特征。目前大多数的模型和方法都不是端到端的。</p><h2 id="Fully-convolutional-networks"><a href="#Fully-convolutional-networks" class="headerlink" title="Fully convolutional networks"></a>Fully convolutional networks</h2><p>开始的时候介绍了一下卷积网络是怎么回事，在此不坐赘述。</p><p>全卷积网络由于没有了全连接层的限制, 因此可以接受任意尺寸的输入, 并且生成相应的维度形状.<br>dFCN的一个real-valued损失函数定义了一个任务：如果损失函数是最后一层中spatial dimensions的总和 $\ell(x;\theta) = \sum_{ij}\ell’(x_{ij};\theta)$ ，那么它的梯度就会是它所有spatial components的梯度的总和。因此对于在整张图片上 $\ell$ 的sgd就是等于将最后一层所有感受野作为一个minibatch的$\ell’$的sgd。</p><p>当这些感受野重合度非常大时，layer-by-layer方式的前向计算和反向计算相比于path-by-patch的方式，就变得十分高效。</p><h3 id="Adapting-classifiers-for-dense-prediction"><a href="#Adapting-classifiers-for-dense-prediction" class="headerlink" title="Adapting classifiers for dense prediction"></a>Adapting classifiers for dense prediction</h3><p>大多数经典网络结构中都具有全连接层, 该层接受固定尺寸的输入, 同时会输出nonspatial outputs. 这使得全连接层的维度固定, 同时放弃了空间坐标(因为全连接都是一维的). 但是, 这些全连接层同样可以被看做是通过卷积核在整个输入区域上进行卷积操作的网络层. 可以将它们全部强制转换成全连接网络, 以便可以接受任意尺寸的输入, 同时输出对应的分类图谱(classifization maps). 该转换过程如图2所示</p><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwjeuyyn17j20s20kgn41.jpg" alt=""></p><p>最主要的是, 尽管最终生成的图谱和原始网络中的差不多, 但是由于大量的重叠区域, 会使得计算成本分摊, 降低计算量. 比如,</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文解读 </tag>
            
            <tag> 网络模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《GPU高性能编程CUDA实战 CUDA By Example》</title>
      <link href="/z_post/CUDA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-GPU%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8BCUDA%E5%AE%9E%E6%88%98CUDAByExample/"/>
      <url>/z_post/CUDA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-GPU%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8BCUDA%E5%AE%9E%E6%88%98CUDAByExample/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-为什么需要CUDA"><a href="#第一章-为什么需要CUDA" class="headerlink" title="第一章 为什么需要CUDA"></a>第一章 为什么需要CUDA</h1><h2 id="1-1-本章目标"><a href="#1-1-本章目标" class="headerlink" title="1.1 本章目标"></a>1.1 本章目标</h2><p>了解历史和发展历程</p><h2 id="1-2-并行处理的历史"><a href="#1-2-并行处理的历史" class="headerlink" title="1.2 并行处理的历史"></a>1.2 并行处理的历史</h2><p>中央处理器性能的提升逐渐变得困难</p><h2 id="1-3-GPU计算的崛起"><a href="#1-3-GPU计算的崛起" class="headerlink" title="1.3 GPU计算的崛起"></a>1.3 GPU计算的崛起</h2><h2 id="1-4-CUDA"><a href="#1-4-CUDA" class="headerlink" title="1.4 CUDA"></a>1.4 CUDA</h2><h3 id="1-4-1-CUDA架构是什么"><a href="#1-4-1-CUDA架构是什么" class="headerlink" title="1.4.1 CUDA架构是什么"></a>1.4.1 CUDA架构是什么</h3><p>cuda架构包含了一个统一的着色器流水线，使得执行通用计算的程序能够对芯片上的每个数学逻辑单元（Arithmetic Logic Unit，ALU）进行排列。另外，NVIDIA在实现ALU时都确保它们满足IEEE单精度浮点数学运算的需求，并且可以使用一个裁剪后的指令集来执行通用计算，而不是仅限于执行图形计算。此外，GPU上的执行单元不仅能任意地读写内存，同时还能访问由软件管理的缓存，也称为共享内存。</p><p>CUDA架构的所有这些功能都是为了使GPU不仅能执行传统的图形计算，还能高效的执行通用计算。</p><h3 id="1-4-2-CUDA架构的使用"><a href="#1-4-2-CUDA架构的使用" class="headerlink" title="1.4.2 CUDA架构的使用"></a>1.4.2 CUDA架构的使用</h3><p>NVIDIA专门开发了一款编译器来编译CUDA C语言。现在，用户不再需要了解OpenGL或者DirectX图形编程结构，也不需要将通用计算问题伪装为图形计算问题。</p><h2 id="1-5-CUDA的应用"><a href="#1-5-CUDA的应用" class="headerlink" title="1.5 CUDA的应用"></a>1.5 CUDA的应用</h2><p>医学影像、流体力学等等</p><h1 id="第二张-入门"><a href="#第二张-入门" class="headerlink" title="第二张 入门"></a>第二张 入门</h1><h2 id="2-1-本章目标"><a href="#2-1-本章目标" class="headerlink" title="2.1 本章目标"></a>2.1 本章目标</h2><p>配置环境</p><h2 id="2-2-开发环境"><a href="#2-2-开发环境" class="headerlink" title="2.2 开发环境"></a>2.2 开发环境</h2><ul><li>支持CUDA的图形处理器</li><li>NVIDIA设备驱动程序</li><li>CUDA开发工具箱</li><li>标准C编译器</li></ul><p>由于CUDA C应用程序将在两个不同的处理器上执行计算，因此需要两个编译器。其中一个编译器为GPU编译代码，另一个为CPU编译代码。</p><h1 id="第三章-CUDA简介"><a href="#第三章-CUDA简介" class="headerlink" title="第三章 CUDA简介"></a>第三章 CUDA简介</h1><h2 id="3-1-本章目标"><a href="#3-1-本章目标" class="headerlink" title="3.1 本章目标"></a>3.1 本章目标</h2><p>第一段cuda c代码、了解host和device之间的区别、了解其他信息</p><h2 id="3-2-第一个程序"><a href="#3-2-第一个程序" class="headerlink" title="3.2 第一个程序"></a>3.2 第一个程序</h2><h3 id="3-2-1-Hello，World！"><a href="#3-2-1-Hello，World！" class="headerlink" title="3.2.1 Hello，World！"></a>3.2.1 Hello，World！</h3><p>将CPU以及系统的内存成为主机（host）。而将GPU及其内存成为设备（device）。</p><p>在GPU设备上执行的函数通常称为核函数（kernel）。</p><p>没有核函数，只考虑在主机运行的CUDA代码和标准的C在很大程度上是没有区别的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-核函数调用"><a href="#3-2-2-核函数调用" class="headerlink" title="3.2.2 核函数调用"></a>3.2.2 核函数调用</h3><p>在上面的示例中添加核函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">kernel</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  kernel&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello,World!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码有两处新增：</p><ul><li>一个空的核函数<code>kernel()</code>，并且带有修饰符<code>__global__</code></li><li>对这个空的核函数的调用语句，并且带有修饰字符&lt;&lt;<1,1>&gt;&gt;</1,1></li></ul><p>cuda的host代码默认是由系统的标准C编译器来编译的（如Linux的GNU gcc和Windodws的VS），NVIDIA工具只是将代码交给host编译器，它表现出的行为就好像CUDA不存在一样。</p><p>而当遇到具有<code>__global__</code>修饰符的函数时，编译器就会将该函数编译为在device上运行。在此例子中，函数<code>kernel()</code>将被交给编译device代码的编译器，而<code>main()</code>函数将被交给host编译器。</p><p>而对<code>kernel()</code>函数的调用语句则使用了一种尖括号和两个数值的方式。这将在后面相似介绍。</p><h3 id="3-2-3-传递参数"><a href="#3-2-3-传递参数" class="headerlink" title="3.2.3 传递参数"></a>3.2.3 传递参数</h3><p>以下代码展示了如何像核函数传递参数并取得返回结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">  *c = a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="keyword">int</span> *dev_c;</span><br><span class="line">  HANDLE_ERROR(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_c, size(<span class="keyword">int</span>)));</span><br><span class="line"></span><br><span class="line">  add&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;(<span class="number">2</span>,<span class="number">7</span>,dev_c);</span><br><span class="line"></span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(&amp;c,</span><br><span class="line">    dev_c,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">    cudaMemcpyDeviceToHost));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"2+7 = %d\n"</span>,c);</span><br><span class="line">   cudaFree(dev_c);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上多行代码包含两个概念：</p><ul><li>可以像调用C函数那样将参数传递给核函数</li><li>当设备执行任何有用的操作时，都需要分配内存，例如将计算值返回给主机</li></ul><p><strong>cudaMalloc()函数：</strong>（注意，分配内存的指针不是该函数的返回值，这点与<code>malloc()</code>不同）</p><ul><li>参数一： 一个指针，指向用于保存新分配内存地址的变量。注意，由于C语言中，指针传递是本身也是值传递的，所以为了使指针本身的值（不是指针地址指向的值）可以改变，因此在传递时要使用双重指针void**，这样做的主要原因还是因为分配内存的指针最终不是通过函数返回，而是直接改变参数值导致的（如果传的是一重指针，则改变的是pd指向的内存空间的数据，而不是pd本身，所以pd也就不能指向GPU的内存了）。</li><li>参数二：分配内存的大小</li></ul><p>CUDA C的简单行及其强大功能在很大成都上都是来源于它淡化了主机代码和设备代码之间的差异。然而，程序员一定不能在主机代码中对<code>cudaMalloc()</code>返回的指针进行解引用（Dereference）。主机代码可以将这个指针作为参数传递，对其执行算术运算，甚至可以将其转换为另一种不同的类型。但是，绝对不饿昆虫使用这个指针来读取或写入内存。</p><p>CUDA中对设备指针的使用限制总结如下：</p><ul><li>可以将<code>cudaMalloc()</code>分配的指针传递给在设备上执行的函数</li><li>可以在设备代码中使用<code>cudaMalloc()</code>分配的指针进行内存读写操作</li><li>可以将<code>cudaMalloc()</code>分配的指针传递给在主机上执行的函数</li><li>不能在主机代码中使用<code>cudaMalloc()</code>分配的指针进行内存读写操作</li></ul><p>在主机代码中，可以通过调用<code>cudaMemcpy()</code>来访问设备上的内存。这个函数调用的行为类型与标准C中的<code>memcpy()</code>，只不过多了一个参数来指定设备内存指针究竟是源指针还是目标指针。如，当最后一个参数为<code>cudaMemcpyDeviceToHost</code>时，代表运行时源指针是一个设备指针，而目标指针是以个主机指针。此外还有参数<code>cudaMemcpyHostToDevice</code>和<code>cudaMemcpyDeviceToDevice</code>等，如果源指针和目标指针都是位于主机上，那么可以直接调用标准C的<code>memcpy()</code>函数。</p><h2 id="3-3查询设备"><a href="#3-3查询设备" class="headerlink" title="3.3查询设备"></a>3.3查询设备</h2><p>对于拥有多个支持CUDA的设备，需要通过某种方式来确定使用的是哪一个设备。</p><p>首先，我们希望知道在系统中有多少个设备是支持CUDA架构的，并且这些设备能够运行基于CUDA C编写的核函数。要获得CUDA设备的数量，可以调用<code>cudaGetDeviceCount()</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">HANDLE_ERROR(cudaGetDeviceCount(&amp;count));</span><br></pre></td></tr></table></figure></p><p>在调用<code>cudaGetDeviceCount()</code>后，可以对每个设备进行迭代，并查询各个设备的相关信息。CUDA runtime将返回一个<code>cudaDeviceProp</code>类型的结构，其中包含了设备的相关属性。相关属性的含义可见书p20。可以利用<code>cudaGetDeviceProperties()</code>来获得i号设备的属性:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cudaDeviceProp prop;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    cudaGetDeviceCount(&amp;count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt; count; i++)&#123;</span><br><span class="line">cudaGetDeviceProperties(&amp;prop, i);</span><br><span class="line">  <span class="comment">//对设备的属性执行某些操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在知道了每个可用的属性以后，接下来就可以进行一些具体的操作，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;prop.major&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><h2 id="3-4-设备属性的使用"><a href="#3-4-设备属性的使用" class="headerlink" title="3.4 设备属性的使用"></a>3.4 设备属性的使用</h2><p>根据在<code>cudaGetDeviceCount()</code>和<code>cudaGetDeviceProperties()</code>中返回的结果，我们可以对每个设备进行迭代，来找到我们期望的某些达到要求的设备。但是这种迭代操作执行起来有些繁琐，因此CUDA runtime提供了一种自动方式来执行这个迭代操作。首先，找出希望设备拥有的属性并将这些属性填充到一个<code>cudaDeviceProp</code>结构。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cudaDeviceProp prop;</span><br><span class="line"><span class="built_in">memset</span>(&amp;prop, <span class="number">0</span> , <span class="keyword">sizeof</span>(cudaDeviceProp));</span><br><span class="line">prop.major = <span class="number">1</span>;</span><br><span class="line">prop.minor = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>之后，将该结构传递给<code>cudaChooseDevice()</code>，这样CUDA runtime运行时将查找是否存在某个设备满足这些条件，并返回一个设备ID，我们可以将这个设备ID传递给<code>cudaSetDevice()</code>。随后，所有的设备操作都将在这个设备上执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cudaDeviceProp prop;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;prop, <span class="number">0</span> , <span class="keyword">sizeof</span>(cudaDeviceProp));</span><br><span class="line">  prop.major = <span class="number">1</span>;</span><br><span class="line">  prop.minor = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dev;</span><br><span class="line">  cudaGetDevice(&amp;dev);</span><br><span class="line"></span><br><span class="line">  cudaChooseDevice(&amp;dev, &amp;prop);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"ID:"</span>&lt;&lt;dev&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-CUDA-C并行编程"><a href="#第四章-CUDA-C并行编程" class="headerlink" title="第四章 CUDA C并行编程"></a>第四章 CUDA C并行编程</h1><h2 id="4-1-本章目标"><a href="#4-1-本章目标" class="headerlink" title="4.1 本章目标"></a>4.1 本章目标</h2><ul><li>了解CUDA在实现并行性时采用的一种重要方式。</li><li>用CUDAC编写第一段并行代码</li></ul><h2 id="4-2-CUDA并行编程"><a href="#4-2-CUDA并行编程" class="headerlink" title="4.2 CUDA并行编程"></a>4.2 CUDA并行编程</h2><h3 id="4-2-1-矢量求和运算"><a href="#4-2-1-矢量求和运算" class="headerlink" title="4.2.1 矢量求和运算"></a>4.2.1 矢量求和运算</h3><p>假设有两组数据，将这两组数据中对应的元素两两想加，并将结果保存在第三个数组中。</p><ol><li>基于CPU的矢量求和</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tid = <span class="number">0</span>; <span class="comment">//这是第0个CPU，因此索引从0开始</span></span><br><span class="line">  <span class="keyword">while</span>(tid&lt;N)&#123;</span><br><span class="line">    c[tid] = a[tid] + b[tid];</span><br><span class="line">    tid += <span class="number">1</span>; <span class="comment">// 由于只有一个CPU，因此每次递增1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面将代码特意写成方便修改为并行代码的形式，如，在双核处理器上，<code>tid</code>的设置可以分别为0和1，tid递增的大小可以改为2等。这就相当于在两个CPU上，一个执行奇数位想加，一个执行偶数位想加。</p><ol><li>基于GPU的矢量求和</li></ol><p>首先给出<code>mian()</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line">  <span class="keyword">int</span> *dev_a, *dev_b, *dev_c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在GPU上分配内存，注意这里要知道为什么使用void**</span></span><br><span class="line">  cudaMalloc( (<span class="keyword">void</span>**)&amp;dev_a, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  cudaMalloc( (<span class="keyword">void</span>**)&amp;dev_a, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  cudaMalloc( (<span class="keyword">void</span>**)&amp;dev_a, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">  ...<span class="comment">//创建a，b数组并赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将数组a，b复制到GPU</span></span><br><span class="line">  cudaMemcpy(dev_a, a, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyHostToDevice);</span><br><span class="line">  cudaMemcpy(dev_b, b, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  add&lt;&lt;&lt;N,<span class="number">1</span>&gt;&gt;&gt;(dev_a, dev_b, dev_c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将数组c从GPU复制到CPU</span></span><br><span class="line">  cudaMemcpy(c, dev_c, N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">  ...<span class="comment">//显式结果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放GPU上分配的内存</span></span><br><span class="line">  cudaFree(dev_a);</span><br><span class="line">  cudaFree(dev_b);</span><br><span class="line">  cudaFree(dev_c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下核函数的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add&lt;&lt;&lt;N,1&gt;&gt;&gt;(dev_a, dev_b, dev_c);</span><br></pre></td></tr></table></figure></p><p>尖括号中的两个数值将传递给runtime，作用是告诉runtime如何启动核函数：</p><ul><li>第一个参数：表示设备在执行款核函数时使用的并行线程块的数量。</li><li>参数二：需要多少个线程格（Grid）（一格表示N个线程块的集合）</li></ul><p>我们将每个并行执行环境都称为一个线程块（Block），对于此例，将有N个线程块在GPU上运行（N个运行核函数的副本）。</p><p>问题：如何在代码中知道当前正在运行的是哪一个线程块？</p><p>回答：利用变量<code>blockIdx.x</code> 。 这是一个内置变量，在CUDA runtime中已经预先定义了这个变量，无需在代码中声明，该变量中包含的值就是当前执行设备代码的线程块的索引。</p><p>接下来是GPU版本的<code>add()</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tid = blockIdx.x;  <span class="comment">//计算机该索引处的数据</span></span><br><span class="line">  <span class="keyword">if</span>(tid &lt; N)</span><br><span class="line">  c[tid] = a[tid] + b[tid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当启动核函数时，我们将并行线程块的数量指定为N。这个并行线程块集合就称为一个“线程格（Grid）”。因此，此例表示我们想要一个一维的线程格，其中每个线程格包含N个线程块，每个线程块的<code>blockInx.x</code>的值都是不同的，cuda会为每个设备代码副本提供不同的<code>blockInx.x</code>。</p><p>需要注意的一点是：在启动线程块数组时，数组每一维（N）的最大数量不能超过65535。这是一种硬件限制，如过启动的线程块数量超过了这个限制，那么程序将运行失败。</p><h3 id="4-2-2-一个有趣的示例"><a href="#4-2-2-一个有趣的示例" class="headerlink" title="4.2.2 一个有趣的示例"></a>4.2.2 一个有趣的示例</h3><p>绘制Julia集的曲线</p><p>Julia集算法：通过下面的迭代等式对复平面中的点求值。如果在计算某个点时，迭代等式的计算结果是发散的，那么这个点就不属于Julia集合。</p><script type="math/tex; mode=display">Z_{n+1} = Z_n^2 + C</script><ol><li>基于CPU的Julia集</li></ol><p>先看main函数，它通过工具库创建了一个大小合适的位图图像，接着，将一个指向位图数据的指针传递给了核函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//julia.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel</span><span class="params">(Mat&amp; M)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">julia</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="comment">//定义一个通用结构来保存复数值,r为实部，i为虚部</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cuComplex</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> r;</span><br><span class="line">    <span class="keyword">float</span> i;</span><br><span class="line">    cuComplex(<span class="keyword">float</span> a , <span class="keyword">float</span> b ):r(a),i(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">magnitude2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> r*r+i*i;&#125;</span><br><span class="line"></span><br><span class="line">    cuComplex <span class="keyword">operator</span>*(<span class="keyword">const</span> cuComplex&amp; a)&#123;</span><br><span class="line"><span class="keyword">return</span> cuComplex(r*a.r-i*a.i, i*a.r + r*a.i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cuComplex <span class="keyword">operator</span>+(<span class="keyword">const</span> cuComplex&amp; a)&#123;</span><br><span class="line"><span class="keyword">return</span> cuComplex(a.r+r, a.i+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DIM = <span class="number">800</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cv::<span class="function">Mat <span class="title">M</span><span class="params">(DIM,DIM,CV_8UC1)</span></span>;</span><br><span class="line">  kernel(M);</span><br><span class="line">imshow(<span class="string">"Test"</span>,M);   <span class="comment">//窗口中显示图像</span></span><br><span class="line">imwrite(<span class="string">"E:/灰度图.jpg"</span>,M);    <span class="comment">//保存生成的图片</span></span><br><span class="line">waitKey(<span class="number">0</span>); <span class="comment">//等待按任意键后窗口自动关闭</span></span><br><span class="line">getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel</span><span class="params">(Mat&amp; M)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;M.rows;y++)<span class="comment">//遍历每一行每一列并设置其像素值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;M.cols;x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> juliaValue = julia(x,y);</span><br><span class="line">    M.at&lt;uchar&gt;(x,y)=<span class="number">155</span>*juliaValue+<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断函数，如果该点属于集合返回1，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">julia</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> scale = <span class="number">1.5</span>;</span><br><span class="line">    <span class="keyword">float</span> jx = scale*(<span class="keyword">float</span>)(DIM/<span class="number">2</span> - x)/(DIM / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">float</span> jy = scale*(<span class="keyword">float</span>)(DIM/<span class="number">2</span> - y)/(DIM / <span class="number">2</span>);</span><br><span class="line">    <span class="function">cuComplex <span class="title">c</span><span class="params">(<span class="number">-0.8</span>, <span class="number">0.154</span>)</span></span>;</span><br><span class="line">    <span class="function">cuComplex <span class="title">a</span><span class="params">(jx,jy)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">200</span>; i++)&#123;</span><br><span class="line">      a = a*a+c;</span><br><span class="line">      <span class="keyword">if</span>(a.magnitude2() &gt; <span class="number">1000</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>kernel</code>核函数对将要绘制的所有点进行迭代，并在每次迭代时调用<code>julia</code>来判断该点是否属于Julia集（“是”则涂红色，“否”则涂黑色）。</p><p><code>该</code>函数首先将像素坐标转换为复数空间的坐标，为了将复平面的原点定位到图像中心，代码将像素位置移动了<code>MID/2</code>，然后，为了确保图像的范围为-1.0到1.0，我们将图像的坐标缩放了<code>DIM/2</code>倍。在计算处复空间中的点之后，需要判断这个点是否属于Julia集。通过迭代判断（本示例迭代200次，在每次迭代完成后，都会判断结果是否超过某个阈值），如果属于集合，就返回1，否则，返回0。最后运行指令<code>g++ julia.cpp</code>pkg-config —cflags —libs opencv<code>-o julia</code>生成的效果图如下：</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvjoriuw74j20lw0lxdia.jpg" alt=""></p><ol><li>基于GPU的Julia集</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &quot;opencv2/core/core.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">__global__ void  kernel(unsigned char* ptr);</span><br><span class="line">__device__ int julia(int x, int y);</span><br><span class="line">const int DIM = 800;</span><br><span class="line">struct cuComplex&#123;</span><br><span class="line">    float r;</span><br><span class="line">    float i;</span><br><span class="line">    __device__ cuComplex(float a , float b ):r(a),i(b)&#123;&#125;</span><br><span class="line">    __device__ float magnitude2()&#123;return r*r+i*i;&#125;</span><br><span class="line"></span><br><span class="line">    __device__ cuComplex operator*(const cuComplex&amp; a)&#123;</span><br><span class="line">return cuComplex(r*a.r-i*a.i, i*a.r + r*a.i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __device__ cuComplex operator+(const cuComplex&amp; a)&#123;</span><br><span class="line">return cuComplex(a.r+r, a.i+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    cv::Mat M(DIM,DIM,CV_8UC1);</span><br><span class="line"></span><br><span class="line">    unsigned char bitmap[DIM][DIM];    </span><br><span class="line">    unsigned char *dev_bitmap; //定义一定char二维数组，用来存储GPU传过来的结果</span><br><span class="line">    cudaMalloc(&amp;dev_bitmap, DIM*DIM);</span><br><span class="line"></span><br><span class="line">    dim3 grid(DIM,DIM);</span><br><span class="line">    kernel&lt;&lt;&lt;grid,1&gt;&gt;&gt;(dev_bitmap);</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(bitmap,dev_bitmap, DIM*DIM , cudaMemcpyDeviceToHost);</span><br><span class="line">   for (int y=0;y&lt;M.rows;y++)        //遍历每一行每一列并设置其像素值</span><br><span class="line">&#123;</span><br><span class="line">for (int x=0;x&lt;M.cols;x++)</span><br><span class="line">&#123;</span><br><span class="line">    M.at&lt;uchar&gt;(x,y)=bitmap[y][x];</span><br><span class="line">    //M.at&lt;uchar&gt;(x,y)=juliaValue+100;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    imshow(&quot;Test&quot;,M);   //窗口中显示图像</span><br><span class="line">    waitKey(0);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">__global__ void  kernel(unsigned char* ptr)&#123;</span><br><span class="line">    int x = blockIdx.x;</span><br><span class="line">    int y = blockIdx.y;</span><br><span class="line">    int offset = x+ y*gridDim.x;</span><br><span class="line">    int juliaValue = julia(x,y);</span><br><span class="line">    ptr[offset] = 255*juliaValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">__device__ int julia(int x, int y)&#123;</span><br><span class="line">    const float scale = 1.5;</span><br><span class="line">    float jx = scale*(float)(DIM/2 - x)/(DIM/2);</span><br><span class="line">    float jy = scale*(float)(DIM/2 - y)/(DIM/2);</span><br><span class="line">    cuComplex c(-0.8, 0.156);</span><br><span class="line">    cuComplex a(jx,jy);</span><br><span class="line">    int i = 0 ;</span><br><span class="line">    for(i = 0; i&lt;200; i++)&#123;</span><br><span class="line">a = a*a +c;</span><br><span class="line">if(a.magnitude2() &gt; 1000)</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，在程序中指定了多个并行线程块来执行函数kernel。并且，使用了一种新的类型来声明了一个二维的线程格：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(DIM, DIM)</span></span>;</span><br></pre></td></tr></table></figure></p><p>类型dim3并不是标准C定义的类型，它可以表是一个三维数组，至于为什么不直接用二维数组，CUDA开发人员主要是为了日后的扩展，所以用三维数组来表示二维数组，数组的第三维默认为1。下面的代码将线程块grid传递给CUDA运行时：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel&lt;&lt;&lt;grid,<span class="number">1</span>&gt;&gt;&gt;(dev_bitmap);</span><br></pre></td></tr></table></figure></p><p>代码中还使用了修饰符<code>__device__</code>，这代表代码将在GPU而不是主机上运行，由于这些函数已声明为<code>__device__</code>，因此只能从其他<code>__device__</code>函数或者<code>__global__</code>函数中调用它们。</p><p>通常，我们将在GPU上启动的线程块集合称为一个线程格。从名字的含义可以看出，线程格既可以是一维的线程块集合，也可以是二维的线程块集合。核函数的每个副本都可以通过内置变量<code>blockIdx</code>来判断哪个线程块正在执行它。塌秧，还可以通过内置变量<code>gridDim</code>来获得线程格的大小。</p><h1 id="第五章-线程协作"><a href="#第五章-线程协作" class="headerlink" title="第五章 线程协作"></a>第五章 线程协作</h1><h2 id="5-1-本章目标"><a href="#5-1-本章目标" class="headerlink" title="5.1 本章目标"></a>5.1 本章目标</h2><ul><li>了解CUDA C中的线程</li><li>了解不同线程之间的通信机制</li><li>了解并行执行线程的同步机制</li></ul><h2 id="5-2-并行线程块的分解"><a href="#5-2-并行线程块的分解" class="headerlink" title="5.2 并行线程块的分解"></a>5.2 并行线程块的分解</h2><p>当启动核函数时，我们会指定第一个参数的值，也就是指定多个并行副本，我们将这些兵行副本称为线程块（Block）。尖括号中的第二个参数表示CUDA运行时在每个线程块中创建的线程数量，因此，总共启动的线程数量可按下面的公式计算：</p><script type="math/tex; mode=display">N个线程块 \times M个线程每线程块 = N个并行线程</script><h3 id="5-2-1-矢量求和：重新回顾"><a href="#5-2-1-矢量求和：重新回顾" class="headerlink" title="5.2.1 矢量求和：重新回顾"></a>5.2.1 矢量求和：重新回顾</h3><p>使用线程块中的并行线程，能够完成一些并行线程块无法完成的工作。</p><h4 id="1-使用线程实现GPU上的矢量求和（即在一个线程块内设置多条线程）"><a href="#1-使用线程实现GPU上的矢量求和（即在一个线程块内设置多条线程）" class="headerlink" title="1.使用线程实现GPU上的矢量求和（即在一个线程块内设置多条线程）"></a>1.使用线程实现GPU上的矢量求和（即在一个线程块内设置多条线程）</h4><p>相较于之前的矢量求和，需要修改两个地方，第一是将下面的代码#1式改成代码#2式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add&lt;&lt;&lt;N,<span class="number">1</span>&gt;&gt;&gt;(dev_a, dev_b, dev_C);</span><br><span class="line"></span><br><span class="line">add&lt;&lt;&lt;<span class="number">1</span>,N&gt;&gt;&gt;(dev_a, dev_b, dev_c);</span><br></pre></td></tr></table></figure></p><p>第二是修改索引方式，有限现在只有一个线程块，所以不能再用<code>blockIdx</code>来获取索引了，而应使用线程索引，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tid = threadIdx.x;</span><br></pre></td></tr></table></figure></p><p>完整的代码如下所是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/*#define N 20*/</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> * dev_a, <span class="keyword">int</span>* dev_b, <span class="keyword">int</span>* dev_c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = threadIdx.x; <span class="comment">//注意此处使用的是线程索引</span></span><br><span class="line">    <span class="keyword">if</span>(tid&lt;N)</span><br><span class="line">    dev_c[tid] = dev_a[tid] + dev_b[tid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> b[N];</span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">a[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">b[i]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* dev_a;</span><br><span class="line">    <span class="keyword">int</span>* dev_b;</span><br><span class="line">    <span class="keyword">int</span>* dev_c;</span><br><span class="line"></span><br><span class="line">    cudaMalloc(&amp;dev_a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line">    cudaMalloc(&amp;dev_b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line">    cudaMalloc(&amp;dev_c, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(dev_a,a,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N, cudaMemcpyHostToDevice); <span class="comment">//第一个参数为目的地址，第二个为原地址，第三个为空间大小</span></span><br><span class="line">    cudaMemcpy(dev_b,b,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    add&lt;&lt;&lt;<span class="number">1</span>,N&gt;&gt;&gt;(dev_a,dev_b,dev_c); <span class="comment">//线程块数为1，每块内的线程数为N</span></span><br><span class="line"></span><br><span class="line">    cudaMemcpy(c, dev_c, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:c) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-在GPU上对更长的矢量求和"><a href="#2-在GPU上对更长的矢量求和" class="headerlink" title="2.在GPU上对更长的矢量求和"></a>2.在GPU上对更长的矢量求和</h4><p>之前在第四章我们提到，由于硬件原因，线程块的数量不能超过65535。 同样，对于启动核函数时每个线程块中的线程数量，也有一定的限制。具体来说，最大的线程数量不能超过设备属性结构中maxThreadsPerBlock域的值。对于很多图形处理器而言，这个限制值是每个线程块512个线程（目前GTX 980Ti为1024个）。通过下面的代码可以获得当前机器上的最大线程数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cudaDeviceProp prop;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    cudaGetDeviceCount(&amp;count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt; count; i++)&#123;</span><br><span class="line">cudaGetDeviceProperties(&amp;prop, i);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;prop.maxThreadsPerBlock&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output：1024</span></span><br></pre></td></tr></table></figure></p><p>为了通过并行对长度大于1024的矢量进行相加，必须将线程和线程块结合起来才能实现，因此仍然需要改动两个地方：核函数中的索引计算方法和核函数的调用方式：（使用多个线程块，并且每个线程块包含多个线程）</p><p>首先是修改索引计算方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;</span><br></pre></td></tr></table></figure></p><p>在上面的赋值语句中使用了一个新的内置变量，<code>blockDim</code>。对于所有线程块来说，这个变量是一个常数，保存的是线程块中每一维的线程数量。（回顾第四章，在gridDim中保存了一个类似的值，即在线程格中每一维的线程块数量。但要知道，gridDim是二维的，blockDim是三维的，只是很少用的高维索引值）</p><p>另一处修改是核函数调用本身，为了保证最终启动的线程数量不少于预期量，可以通过一种常见的技术来对需要启动的线程块数量进行向上取整，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add&lt;&lt;&lt; (N+<span class="number">127</span>)/<span class="number">128</span>, <span class="number">128</span> &gt;&gt;&gt; (dev_a, dev_b, dev_c);</span><br></pre></td></tr></table></figure></p><p>上面的代码当N不是128的整数倍时，会启动过多的线程，这时候，判断语句<code>if (tid&lt;N)</code>就表现处作用了，它可以确保进行计算的线程的不会对越过数组边界的内存进行读取或写入：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tid &lt; N)</span><br><span class="line">  c[tid] = a[tid] + b[tid];</span><br></pre></td></tr></table></figure></p><h4 id="3-在GPU上对任意长度的矢量求和"><a href="#3-在GPU上对任意长度的矢量求和" class="headerlink" title="3.在GPU上对任意长度的矢量求和"></a>3.在GPU上对任意长度的矢量求和</h4>]]></content>
      
      
      <categories>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DenseNet-xxx</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-DenseNet/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-DenseNet/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文解读 </tag>
            
            <tag> 网络模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【置顶】基于深度学习的目标检测</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%A7%88/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>下面对每篇文章及模型的亮点和优势进行了简单总结, 点击模型标题可以跳转至相关论文解读 (都是按照自己的理解记录的, 难免存在纰漏或者词不达意的地方, 如果你发现了错误, 诚恳的希望你能帮我指出来, 万谢!)</p><h1 id="基于深度学习的目标检测发展轨迹"><a href="#基于深度学习的目标检测发展轨迹" class="headerlink" title="基于深度学习的目标检测发展轨迹"></a>基于深度学习的目标检测发展轨迹</h1><p>下图为自RCNN以来，提出的有关目标检测的文章，其中，标红的部分为具有标志性意义的检测模型。</p><p><strong><a href="#RCNN">RCNN (CVPR, 2013, 必读)</a></strong> $\longrightarrow$ <strong><a href="#OverFeat">OverFeat (ICLR, 2014, 必读)</a></strong> $\longrightarrow$ <a href="#MultiBox">MultiBox (CVPR, 2014)</a></p><p><a href="#CoupleNet">Couple Net (ICCV, 2017)</a></p><p><a href="#OHEM">OHEM (CVPR, 2016)</a><br><a href="#Focal Loss">Focal Loss (ICCV, 2017)</a></p><p><img src="https://github.com/hoya012/deep_learning_object_detection/blob/master/assets/deep_learning_object_detection_history.PNG?raw=true" alt=""></p><h1 id="经典模型结构"><a href="#经典模型结构" class="headerlink" title="经典模型结构"></a>经典模型结构</h1><ul><li><a href="../计算机视觉-ResNet-CVPR2016">ResNet (CVPR, 2016)</a></li><li><a href="../计算机视觉-Inception系列V1-V4">Inception系列V1-V4</a></li><li><a href="../计算机视觉-FCN-CVPR2015">FCN (CVPR, 2015)</a></li></ul><h1 id="其他论文"><a href="#其他论文" class="headerlink" title="其他论文"></a>其他论文</h1><ul><li><a href="#Group Normalization">Group Normalization (ECCV, 2018)</a></li><li><a href="../计算机视觉-CVPR2018-NonLocal">Non-local NN (CVPR, 2018)</a></li></ul><h1 id="Trick"><a href="#Trick" class="headerlink" title="Trick"></a>Trick</h1><ul><li><a href="../计算机视觉-NMS">NMS</a></li><li><a href="#SoftNMS">Soft NMS (ICCV, 2017)</a></li><li>[Learning NMS(CVPR, 2018)]</li><li><a href="#SofterNMS">Softer NMS (Arxiv, 2018)</a></li></ul><p><span id="RCNN"></span></p><h1 id="RCNN-CVPR2014"><a href="#RCNN-CVPR2014" class="headerlink" title="RCNN-CVPR2014"></a><a href="../计算机视觉-RCNN-CVPR2014">RCNN-CVPR2014</a></h1><p>本文是一种工程上的艺术成就, 成功的将CNN运用到了目标检测任务当中, 开启了CNN统治目标检测领域的时代.<br><strong>(1) 利用SS (Selective Search)提取候选区域框:</strong><br>本篇文章利用SS(Selective Search) 算法首先生成大约2000个候选区域框</p><p><strong>(2) 将CNN用于目标检测任务:</strong><br>CNN拥有十分强大的特征提取能力, 并且无需人为设计特征算子, 对提取出来的每个候选区域框进行CNN计算, 获取到固定长度的特征向量</p><p><strong>(3) 利用SVM分类器对候选框分类:</strong><br>训练SVM分类器, 对候选区域框的特征向量进行分类.</p><p><strong>(4) 使用回归其精细修正候选框位置</strong></p><p>注: 以上几个步骤是独立训练的, 这也是RCNN后续改进的空间</p><p><span id="OverFeat"></span></p><h1 id="OverFeat-ICLR2014"><a href="#OverFeat-ICLR2014" class="headerlink" title="OverFeat-ICLR2014"></a><a href="../计算机视觉-OverFeat-ICLR2014">OverFeat-ICLR2014</a></h1><p><strong>(1) Multi-Scale Classification:</strong><br>在分类任务上, 虽然训练时采用和AlexNet相同的multi crop方法, 但是在预测阶段没有使用AlexNet的crop投票策略, 而是提出了Multi-Scale Classification方法, 一句话概括就是 <strong>对整个图片以不同的尺寸, 并且对每一个location进行模型预测</strong></p><p><strong>(2) 利用了全卷积的思想代替全连接</strong><br>降低了滑动窗口的计算代价, 同时支持任意尺寸的图片输入</p><p><strong>(3) 可以用同一个模型完成分类, 定位, 检测任务:</strong><br>同一个模型, 只需要用回归层替换分类层, 即可完成目标定位任务, 同时利用了贪心策略来融合最终的定位结果</p><h1 id="MultiBox-CVPR2014"><a href="#MultiBox-CVPR2014" class="headerlink" title="MultiBox-CVPR2014"></a><a href="../计算机视觉-MultiBox-CVPR2014">MultiBox-CVPR2014</a></h1><p><strong>(1) 将目标边框检测转化为回归问题:</strong><br>将物体检测问题定义为输出多个bounding box的回归问题. 同时每个bounding box会输出关于是否包含目标物体的置信度, 使得模型更加紧凑和高效</p><p><strong>(2) 通过损失函数将检测器训练过程整合到神经网络内部:</strong><br>将训练bounding box检测器作为整个网络训练过程的一部分, 也就是说在损失函数中包含了关于bounding box的损失项. 通过联合训练, 不仅利用了神经网络强大的特征表示能力, 而且将检测器的训练集成到了网络中</p><p><strong>(3) 无类别监督训练, 使得边框推荐复杂度与类别无关, 易于扩展</strong><br>作者将本文的目标边框检测器在无监督的样本下训练, 由于本方法主要完成的功能就是画框, 并不会输出框中包含的物体类别, 因此训练的时候无需知道样本的类别信息. 这也使得该方法的计算复杂度与类别信息几乎无关, 可以轻易的推广到未知的类别当中. (当然也可以进行相关类别的训练, 对每个类别都训练一个检测器, 模型的总参数会随着类别数线性增加)</p><h1 id="SPPNet-ECCV2014"><a href="#SPPNet-ECCV2014" class="headerlink" title="SPPNet-ECCV2014"></a><a href="../计算机视觉-SPPNet-ECCV2014">SPPNet-ECCV2014</a></h1><p><strong>(1) 提出了一种新的池化方法—-空间金字塔池化SPP</strong>:</p><ul><li>可以接受任意尺寸的输入图片,并生成固定长度的表征向量</li><li>可以进行多尺度的联合训练, 提升模型精度</li><li>这种池化方法是比较general的, 可以提升不同模型架构的性能(分类任务)</li></ul><p><strong>(2) 将SPP用于目标检测, 并且使用了先求卷积特征图谱, 后取区域的的策略(并不是首次提出):</strong><br>大大提升了模型训练和预测的速度(在预测阶段, 比RCNN快24~102倍, 同时取得了更好的精度).</p><p>PS:<br><strong>注1: 在特征图谱上使用检测方法不是该文首次提出</strong>, 而SPP的贡献在于结合了deep CNN结构强大的特征提取能力和SPP的灵活性, 使得精度和速度同时提高<br>注2: 相比于RCNN, SPPNet使用了EdgeBoxes( $0.2s/img$ )的方法来进行候选区域推荐, 而不是Selective Search( $1\sim 2s/img$ )<br>注3: SPPNet在ILSVRC2014的目标检测任务上取得第二名, 在图片分类任务上取得第三名</p><h1 id="MR-CNN"><a href="#MR-CNN" class="headerlink" title="MR-CNN"></a>MR-CNN</h1><p>5</p><h1 id="DeepBox"><a href="#DeepBox" class="headerlink" title="DeepBox"></a>DeepBox</h1><p>6</p><h1 id="AttentionNet"><a href="#AttentionNet" class="headerlink" title="AttentionNet"></a>AttentionNet</h1><p>7</p><h1 id="FastRCNN"><a href="#FastRCNN" class="headerlink" title="FastRCNN"></a><a href="../计算机视觉-FastRCNN-ICCV2015">FastRCNN</a></h1><p>大幅提升了RCNN的训练时间和预测时间, <del>并且在PASCAL VOC 2007 上测试的准确率相差无几.</del></p><p><strong>(1) 直接在特征图谱上获取候选框:</strong><br>在用SS算法得到候选框的坐标以后, 将整张图片直接送入卷积网络, 然后, 将所有候选框的坐标映射到特征图谱上, 直接从特征图谱上获取到候选框的特征子图.</p><p><strong>(2) 提出RoI Pooling层:</strong><br>受到SPPNet的启发, FastRCNN 提出了一种RoI Pooling层, 它可以看作是SPP层在单一pyramid level上的一种特殊情况. RoI Pooling会将不同size的候选区域特征图片转化成固定尺寸的特征向量, 突破了全连接层对输入尺寸的限制.</p><p><strong>(3) 其他变动:</strong></p><ul><li>用softmax分类器替换了svm分类器</li><li>用Smooth L1损失替换了L2损失</li><li>在全连接层用SVD奇异值矩阵分解来降低计算成本</li><li>在训练SVM的时候不需要额外的硬盘存储特征</li></ul><h1 id="DeepProposal"><a href="#DeepProposal" class="headerlink" title="DeepProposal"></a>DeepProposal</h1><p>9<br>#<br>10</p><h1 id="FasterRCNN-RPN"><a href="#FasterRCNN-RPN" class="headerlink" title="FasterRCNN(RPN)"></a><a href="../计算机视觉-FasterRCNN-NIPS2015">FasterRCNN(RPN)</a></h1><p><strong>(1) Region Proposals Network:</strong><br>抛弃了外部的候选区域推荐算法, 提出RPN网络结构, 将候选区域推荐过程整合到神经网络里面, 至此, 目标检测中的所有过程都被统一到了一个网络中, 可以进行完全的端到端训练. RPN最终推荐的候选区域个数为 $W\times H \times k$ , $W\times H$ 为卷积特征图谱size, $k$ 为anchor boxes的数量.</p><p><strong>(2) 共享计算:</strong><br>RPN网络与前面的卷积层共享同样的卷积计算结果, 加快了模型速度. 提高了模型的精度.</p><p><strong>(3) 其他要点:</strong></p><ul><li>在预测物体位置时, 不直接在图片的坐标系中预测, 而是专为基于anchor box的位移预测, 这使得问题简化, 同时使得网络更容易学习</li></ul><p>12</p><h1 id="YOLO-v1"><a href="#YOLO-v1" class="headerlink" title="YOLO v1"></a><a href="../计算机视觉-YOLOv1-CVPR2016">YOLO v1</a></h1><p><strong>(1) 将检测问题看做是回归问题</strong><br>对于给定的输入图像, YOLO会使用一个单一的网络 <strong>同时</strong> 给出bounding box的预测结果和对应的类别概率.</p><p><strong>(2) 没有Region Proposal的过程</strong><br>YOLO将输入图片划分成 $S\times S$ 的网格, 如果某个物体的中心落在了某个cell里, 那么这个cell就负责该物体的检测.</p><p><strong>PS:</strong><br>注一: YOLO中采用 $S\times S$ 的网格划分来确定候选框, 这实际上是一种很粗糙的选框方式, 同时也导致了YOLO在面对小目标物以及群落目标物时, 性能较差.(因为YOLOv1的同一个cell无法预测多个目标, 也就是说YOLOv1理论上最多检测出49个物体).</p><h1 id="G-CNN"><a href="#G-CNN" class="headerlink" title="G-CNN"></a>G-CNN</h1><p>13</p><h1 id="AZNet"><a href="#AZNet" class="headerlink" title="AZNet"></a>AZNet</h1><p>14</p><h1 id="Inside-OutsideNet-ION"><a href="#Inside-OutsideNet-ION" class="headerlink" title="Inside-OutsideNet(ION)"></a>Inside-OutsideNet(ION)</h1><p>15</p><h1 id="HyperNet-CVPR-16"><a href="#HyperNet-CVPR-16" class="headerlink" title="HyperNet CVPR 16"></a><a href="./的">HyperNet CVPR 16</a></h1><p>16<br><span id="OHEM"></span></p><h1 id="OHEM-CVPR2016"><a href="#OHEM-CVPR2016" class="headerlink" title="OHEM-CVPR2016"></a><a href="../计算机视觉-OHEM-CVPR2016">OHEM-CVPR2016</a></h1><p><strong>提出了一种在线的难样例挖掘算法:</strong><br>作者根据每个RoIs的loss的大小来决定哪些是难样例, 哪些试试简单样例, 通过这种方法, 可以更高效的训练网络, 并且可以使得网络获得更小的训练loss. 同时, OHEM还具有以下两个优点:</p><ul><li><strong>消除FastRCNN系列模型中的一些不必要这参数</strong> , 这些参数大多都是为了解决难样例问题服务的, 在使用OHEM以后, 不仅无需在对这些超参数进行调优, 同时还能获得更好的性能表现.</li><li><strong>OHEM算法可以与其他多种提升模型精度的trick相结合</strong>, 对于大多数模型(RCNN系列), 在使用了OHEM以后, 都能够获得精度上的提高, 可以看做是一种普适性的提升精度的方法.</li></ul><p>注: 在实现OHEM上, 作者为了提升速度和效率, 特意设计了两个RoI网络, 以减少无用的计算.</p><h1 id="CRAFT"><a href="#CRAFT" class="headerlink" title="CRAFT"></a>CRAFT</h1><p>18</p><h1 id="MultiPatNet-MPN"><a href="#MultiPatNet-MPN" class="headerlink" title="MultiPatNet(MPN)"></a>MultiPatNet(MPN)</h1><p>19</p><h1 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h1><p><img src="https://wx2.sinaimg.cn/large/d7b90c85ly1fwbhhr03m4j216z0rtdmo.jpg" alt=""></p><p><strong>(1) 在不同尺度的feature map上进行预测:</strong></p><p>YOLO的网格划分法精度较低, 但是速度很快, 而Faster的anchor box法, 精度很高, 但是速度很慢, SSD同时考虑了这两种方法的优劣, 提出了在不同层的feature map上面进行anchor box选取的方法, 并在这些不同尺度的feature map上面进行物体类别检测和box检测. (这一点不同于OverFeat和YOLO, 它们只会在同一个feature map上面进行分类预测和box回归).</p><p><strong>(2) 添加了一些额外的卷积层来进行预测任务:</strong><br>在对不同尺度的feature map进行预测时, SSD使用了额外的层进行预测. 在这些层上的每一个location, 都会产生响应的box (对于特征图谱的每一个像素点, 都会产生一定数量的anchor box), 并对box进行预测和回归</p><p><strong>(3) 默认box和宽高比:</strong><br>在每一个feature map的cell里面, 预测默认框相对于cell的偏移量, 同时预测该box属于每个类别的score. 具体来说, 对于每一个cell(location), 都会有 $k$ 个默认box, 对于这 $k$ 个默认box中的每一个box, 都会计算 $c$ 个类别score和4个相对偏移量. 因此, 对于每一个location, 需要有 $(c+4)k$ 个输出, 也就是需要<br>$(c+4)k$ 个卷积核. 又因为特征图谱的大小为 $mn$, 所以最终的输出为 $(c+4)kmn$, 其中 $kmn$ 为box的数量, $(c+4)$ 为每个box带有的值.</p><p><strong>(4) 使用了数据增广, 难样例挖掘, atrous算法等trick大幅度提升精度和速度</strong><br>这个其实算不上亮点, 只不过作者确实使用这些技术提升性能不少</p><h1 id="GBDNet"><a href="#GBDNet" class="headerlink" title="GBDNet"></a>GBDNet</h1><p>21</p><h1 id="CPF"><a href="#CPF" class="headerlink" title="CPF"></a>CPF</h1><p>22</p><h1 id="MS-CNN"><a href="#MS-CNN" class="headerlink" title="MS-CNN"></a>MS-CNN</h1><p>23</p><h1 id="R-FCN-NIPS2016"><a href="#R-FCN-NIPS2016" class="headerlink" title="R-FCN-NIPS2016"></a><a href="../计算机视觉-R-FCN-NIPS2016">R-FCN-NIPS2016</a></h1><p><strong>(1) 利用position sensitive score map将目标位置信息融合进RoI</strong><br>在一般情况下, <strong>分类任务具有平移不变性, 而检测任务却要求对目标的平移做出正确响应.</strong> 在Faster RCNN类的方法中RoI pooling之前都是卷积, 具有平移不变性, 但是一旦经过RoI pooling 之后, 后面的网络结果就不再具备平移不变性了. 因此, <strong>本文提出了position sensitive score map来将目标位置的信息融合进RoI.</strong></p><p><strong>(2) 让更多的层共享计算</strong><br>对于Faster RCNN等基于感兴趣区域的检测方法来说, 实际上是 <strong>分成了几个subnetwork</strong>, 第一个用来在整张图上做比较耗时的conv, 这些操作与region无关, 是计算共享的. 第二个subnetwork是用来产生候选区域(如RPN), 第三个subnetwork是用来分类或者进一步对box进行回归的, 这个subnetwork和region是有关系的, 衔接在这个subnetwork和前两个subnework中间的就是RoI pooling. 本文希望将耗时的卷积都尽量移到前面共享的subnetwork上面去, 因此与FasterRCNN相比(前91层共享, RoI pooling之后, 后10层不共享)不同, 将ResNet所有的101层都放在的前面共享的subnetwork中, 最后用来进行prediction的卷积只有1层, 大大减少了计算量.</p><h1 id="PVANET"><a href="#PVANET" class="headerlink" title="PVANET"></a>PVANET</h1><p>25</p><h1 id="DeepID-Net"><a href="#DeepID-Net" class="headerlink" title="DeepID-Net"></a>DeepID-Net</h1><p>26</p><h1 id="NoC"><a href="#NoC" class="headerlink" title="NoC"></a>NoC</h1><p>27</p><h1 id="DSSD"><a href="#DSSD" class="headerlink" title="DSSD"></a><a href="../计算机视觉-DSSD-Arxiv2017">DSSD</a></h1><p><strong>(1) 利用反卷积模块向特征图谱中添加更多的上下文信息</strong><br>主要是对SSD的一点改进, SSD使用了不同阶段的卷积特征图谱进行目标检测, 而DSSD受到人体姿态识别任务的启发, 将这些不同阶段的卷积特征图谱通过反卷积模块连接起来, 然后再进行目标检测的预测任务.</p><p><strong>(2), 预测模块采用Residual模块</strong><br>这个不算是亮点, 不过也是改动之一, 基本来说就说原始的SSD是直接在特征图谱预测结果并计算损失的, 而DSSD在预测之前会先经过一个Residual模块做进一步的特征提取, 然后在进行预测.</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwtpkdiie6j21480trdn7.jpg" alt=""></p><h1 id="TDM"><a href="#TDM" class="headerlink" title="TDM"></a>TDM</h1><p>29</p><h1 id="Feature-Pyramid-Net-FPN"><a href="#Feature-Pyramid-Net-FPN" class="headerlink" title="Feature Pyramid Net(FPN)"></a><a href="../计算机视觉-FPN-CVPR2017">Feature Pyramid Net(FPN)</a></h1><p><strong>提出了多尺度的特征金字塔结构:</strong><br>将最后一层特征图谱进行不断尽快上采样, 并与每一个金字塔阶级的特征图谱进行加法合并操作, 得到新的表征能力更强的不同金字塔层次的特征图谱, 然后将RoI按照尺寸分别映射到这些特征图谱上, 再在每个特征图谱上进行类别和位置预测. 可以直观感受到, 这种多尺度的特征图谱在面对不同尺寸的物体时, 具有更好的鲁棒性, 尤其是在面对小型物体时. 同时, 这种特征金字塔结构是一种通用的特征提取结构, 可以应用到不同的网络框架中, 显著提高(5~8%)模型的召回率(因为提出了更多不同尺度, 不同特征信息的anchor box), 并且可以广泛提高(2~3%)模型的mAP.</p><h1 id="YOLO-v2"><a href="#YOLO-v2" class="headerlink" title="YOLO v2"></a><a href="../计算机视觉-YOLOv2-CVPR2017">YOLO v2</a></h1><p>YOLO v2 实际上没有提出任何新的想法或者点子, 它的主要贡献在于尝试了当时几乎所有的可以提升模型性能的方法, 并且通过大量实验找出了一个相对比较好的参数组合.(作者在使用这些方法时有一个基本原则—-保持检测速度, 所以YOLOv2最终不仅精度提升, 其检测速度依然很快)</p><p><strong>(1) 使用了anchor box思想:</strong><br>YOLO v1是基于每个cell的 $B$ 个bounding box来预测物体的, 因此同一个cell只能预测出一种物体, 如果有两个物体的中心都落在了同一个cell里面, 则不能全都检测出来. 而 YOLOv2 结合了anchor box的思想 (不同尺寸和大小的anchor box, 可以检测到不同的物体) , 同时将网络的输入调整到416×416, 经过多个卷积层和池化层以后, 得到了13×13 (5个池化层,缩小32倍)的feature map, 然后在这个feature map上面使用anchor box(作者选了k=5种), 最终会生成 $13\times 13\times 5 = 845$ 个候选区域框(相比于YOLO v1的98个, 多多了).</p><ul><li>未使用anchor box: 69.6mAP, 81% recall</li><li>使用anchor box: 69.2mAP, 88% recall</li></ul><p>下降的原因, 个人觉得是YOLO在采用anchor box获取候选框的同时, 依然采用YOLOv1的训练方法, YOLOv2的损失函数是一个非常复杂的形式, 导致其在更新参数时很容易顾不过来, 因此其出错的概率也相应提升.</p><p><strong>(2) 在每个卷积层之后都是用了BN</strong></p><p><strong>(3) 网络舍弃了全连接层, 采用全卷积FCN:</strong></p><p><strong>(4) 使用了跨层连接</strong><br>借鉴了ResNet恒等映射的思想. 其中一个好处就是使得梯度更容易传播.</p><h1 id="RON"><a href="#RON" class="headerlink" title="RON"></a>RON</h1><p>32</p><h1 id="DCN"><a href="#DCN" class="headerlink" title="DCN"></a>DCN</h1><p>33</p><h1 id="DeNet"><a href="#DeNet" class="headerlink" title="DeNet"></a>DeNet</h1><p><span id="CounpleNet"></span></p><h1 id="CoupleNet"><a href="#CoupleNet" class="headerlink" title="CoupleNet"></a><a href="../计算机视觉-ICCV2017-CoupleNet">CoupleNet</a></h1><p><strong>在进行区域分类时, 同时使用了全局信息,上下文信息和局部信息综合判断</strong><br>提出了一个新颖的全卷积网络, 并称之为CoupleNet, 它可以在目标检测中结合使用全局和局部信息. 具体来说, CoupleNet会将由RPN网络产生的候选区域送入到coupling module中, 该模块包含两个分支. 第一条分支利用position-sensitive RoI pooling来捕获物体的局部信息, 另一条分支利用RoI pooling对全局上下文信息进行编码. 接着, 我们设计了不同的coupling策略和归一化方法来使用这些不同分支格子的优势.</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwuvmld7psj21kw0t4agk.jpg" alt=""></p><p><span id="Focal Loss"></span></p><h1 id="Focal-Loss-ICCV2017"><a href="#Focal-Loss-ICCV2017" class="headerlink" title="Focal Loss-ICCV2017"></a><a href="../计算机视觉-FocalLoss-ICCV2017">Focal Loss-ICCV2017</a></h1><p><strong>(1) 分析并指出了One Stage方法精度不高的原因:</strong></p><ul><li><strong>极度不平衡的正负样本比例:</strong> anchor是一种类似sliding windows的选框方式, 这会使得正负样本的比例接近1000:1, 而且绝大部分负样本都是easy example.</li><li><strong>梯度优化过程被easy example过度影响:</strong> 这些easy example的loss虽然不高, 但由于数量众多, 最终合起来会对loss有很大的贡献, 从而导致优化的时候过度关注这些easy example, 这样会收敛到一个不够好的结果.</li></ul><p><strong>(2) 提出了解决正负样本比例和easy example 问题的Focal loss:</strong></p><script type="math/tex; mode=display">FL(p_t) = \begin{cases} -(1-p_t)^{\gamma}log(p_t) & 当y=1 \\ -p_t^{\gamma}log(1-p_t) & 当y=0 \end{cases}</script><p>核心思想很简单, 就是在优化过程中逐渐减低那些easy example的权重, 这样会使得训练优化过程对更有意义的样本有更高的偏置. 所谓easy example指的就是那些预测概率与真实概率十分相近的样本, 这些样本已经被网络很容易切正确的分类了, 所以应该适当减少他们的loss以降低他们对参数更新的影响程度.  以上面的公式为例, 当真实标签为1时, 如果预测概率(假设二分类) $p_t$ 接近于1, 则此样本是easy样本, 因此, 前面的 $(1-p_t)^{\gamma}$ , 就会非常小, 起到了抑制简单样本的作用.</p><p><strong>注1:</strong> $\gamma$ 的值越大, 则简单样本对于loss的贡献程度越小, 当 $\gamma = 0$ 时, 会退化到普通的交叉熵函数.</p><p><strong>注2:</strong> 文中在使用 $\gamma$ 参数的情况下, 还是用了另一个参数 $\alpha$ ,如下所示:</p><script type="math/tex; mode=display">FL(p_t) = \begin{cases} -\alpha (1-p_t)^{\gamma}log(p_t) & 当y=1 \\ -(1-\alpha) p_t^{\gamma}log(1-p_t) & 当y=0 \end{cases}</script><p>在经过一系列调参之后, 得到 $\alpha=0.25, \gamma = 2$ 为最优组合. 可以看到, 加在正样本前面的 $\alpha$ 要更小, 个人猜测这是因为使用了Focal Loss之后, 原本在数量上不在优势的前景区域或许在对loss的贡献度上反超了后景区域, 因此, 需要对前景区域赋予更低的权重.</p><p><strong>(3) 基于Focal Loss设计并实现了RetinaNet</strong></p><p><strong>PS:</strong><br>注一: 为什么Focal Loss没有用在Two Stage方法上面? 这是因为以RCNN为代表的一系列Two Stage会在区域候选推荐阶段采用两个问题来降低正负样本比例和easy example问题带来的影响:</p><ul><li>采用NMS算法将物体位置候选框降低到一到两千个，更重要的是，这一到两千个可能位置并不是随机选取的，它们移除了大量的易分类负样本（背景框）</li><li>采用了biased-minibatch的采样策略, 比如，保证正样本和负样本的比例为1：3进行训练（这其实相当于起到了 $\alpha$ 因子的作用</li></ul><p>36</p><h1 id="Mask-RCNN"><a href="#Mask-RCNN" class="headerlink" title="Mask RCNN"></a>Mask RCNN</h1><p><a href="https://www.zhihu.com/people/big-big-stone/posts" target="_blank" rel="noopener">https://www.zhihu.com/people/big-big-stone/posts</a></p><h1 id="DSOD"><a href="#DSOD" class="headerlink" title="DSOD"></a>DSOD</h1><p>38</p><h1 id="SMN"><a href="#SMN" class="headerlink" title="SMN"></a>SMN</h1><p>39</p><h1 id="YOLO-v3"><a href="#YOLO-v3" class="headerlink" title="YOLO v3"></a><a href="../计算机视觉-YOLOv3-Arxiv2018">YOLO v3</a></h1><p>40</p><h1 id="SIN"><a href="#SIN" class="headerlink" title="SIN"></a>SIN</h1><p>41</p><h1 id="STDN"><a href="#STDN" class="headerlink" title="STDN"></a>STDN</h1><p>42</p><h1 id="RefineDet"><a href="#RefineDet" class="headerlink" title="RefineDet"></a>RefineDet</h1><p><strong>结合了one-stage方法和two-stage方法各自的优势, 提出了一个基于single-shot的检测模型:</strong><br>模型主要包含两大模块, 分别是anchor精化模块和物体检测模块. 网络采用了类似FPN的思想, 通过 Transfer Connection Block 将特征图谱在两个模块之间传送, 不仅提升了的精度, 同时还在速度方面取得了与one-stage方案相媲美的表现</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwp44jaiyij213h0o2n1j.jpg" alt=""></p><h1 id="RFBNet"><a href="#RFBNet" class="headerlink" title="RFBNet"></a>RFBNet</h1><p>44</p><p><span id="Group Normalization"></span></p><h1 id="Group-Normalization-ECCV2018"><a href="#Group-Normalization-ECCV2018" class="headerlink" title="Group Normalization-ECCV2018"></a><a href="../计算机视觉-ECCV2018-GroupNormalization">Group Normalization-ECCV2018</a></h1><p><strong>针对BN对batch size的依赖问题, 提出了一种新的通用型归一化方法</strong><br>提出了一个用于替代BN的简单算法, 称之为GN(Group Normalization). GN将输入图谱的通道分成不同的组, 并且计算每一组的mean和variance, 然后将其进行归一化. GN的计算复杂度与batch size 的大小是相互独立的, 并且它的准确度在不同范围内的batch size下仍然是稳定的. 并且在整体表现和不同任务上的效果均强于其他类型的归一化方法(LN,IN等)</p><p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fww0h6ugadj20s80kjacr.jpg" alt=""></p><p><span id="SoftNMS"></span></p><h1 id="SoftNMS-ICCV2017"><a href="#SoftNMS-ICCV2017" class="headerlink" title="SoftNMS-ICCV2017"></a><a href="../计算机视觉-ICCV2017-SoftNMS">SoftNMS-ICCV2017</a></h1><p><strong>提出了一种NMS的变体, 通过利用该变体, 基本上可以提升任何模型的检测准确率</strong><br>作者们提出了一种新式的NMS算法, 并且利用该算法, 可以普遍提高当前现有模型的召回率(尤其是面对重叠程度大的物体), 同时, 由于可以不增加复杂度的情况下直接用该算法替换传统NMS算法,  因此, 在替换SoftNMS时, 无需更改模型的任何参数, 也无需重新训练模型, 就可以达到提升召回率的作用. (对mAP的提升大约为1%左右)</p><p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fwskrv3tdtj20rt0p61kx.jpg" alt=""></p><p><span id="SofterNMS"></span></p><h1 id="SofterNMS-Arxiv2018"><a href="#SofterNMS-Arxiv2018" class="headerlink" title="SofterNMS-Arxiv2018"></a><a href="../计算机视觉-Arxiv2018-SofterNMS">SofterNMS-Arxiv2018</a></h1><p><strong>提出了一种新的边框回归损失函数和NMS算法</strong><br>作者提出了一种 <strong>基于KL散度的边框回归损失函数</strong>, 可以同时学习到边框的形变量和位置变化量. 最终产生的位置变化量会与位置的精确度有很强的联系, 然后将其使用在本文提出的 <strong>新的NMS</strong> 算法上, 以此提高准确度.</p><h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><ul><li><a href="https://github.com/hoya012/deep_learning_object_detection" target="_blank" rel="noopener">https://github.com/hoya012/deep_learning_object_detection</a></li><li><a href="https://arxiv.org/pdf/1809.02165v1.pdf" target="_blank" rel="noopener">Deep Learning for Generic Object Detection: A Survey</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inception系列V1-V4</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-Inception%E7%B3%BB%E5%88%97V1-V4/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-Inception%E7%B3%BB%E5%88%97V1-V4/</url>
      
        <content type="html"><![CDATA[<h1 id="Inception-V1"><a href="#Inception-V1" class="headerlink" title="Inception V1"></a>Inception V1</h1><h2 id="论文概览"><a href="#论文概览" class="headerlink" title="论文概览"></a>论文概览</h2><p>Going Deeper with Convolutions</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>文章提出了一个深度卷积神经网络结构，并取名为Inception。该模型最主要的特点在于提高了网络内部计算资源的利用率。在保证计算负载不变的前提下，通过人工设计提升了网络的深度和宽度。该模型基于Hebbian原理和多尺度处理的intuition来提高性能。关于该模型的一个实例正是提交在ILSVRC14上的GoogLeNet，一个22层深的深度网络，主要针对分类和检测任务。</p><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>简要介绍了深度学习和神经网络技术近年来在图像分类和目标检测任务的发展。文章主要关注针对计算机视觉的高效深度神经网络，取名为Inception，名字来自于NIN。在文章中，“deep”具有两层含义：第一，指代文章新提出的Inception module，第二是指网络的深度。通常情况下，可以将Inception model视作NIN的“逻辑顶点”。</p><h3 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2.相关工作"></a>2.相关工作</h3><p>略</p><h3 id="3-动机和High-Level的考虑"><a href="#3-动机和High-Level的考虑" class="headerlink" title="3.动机和High Level的考虑"></a>3.动机和High Level的考虑</h3><p>提高深度卷积网络最直接的方式就是增加它们的size，包括网络的深度（层数）和宽度（每层的神经元个数），这对于高质量的网络结构来说是ok的，尤其是在拥有大量优质数据的情况下。但是，这种方法存在这两个主要的缺点：</p><ul><li>更大的size通常意味着更多的参数，这会使得网络更容易过拟合，尤其是在数据标签有限的情况下。由于获得大量优质数据具有一定难度，因此这往往会称为一个主要的瓶颈。</li><li>第二个缺点就是更大的size往往需要消耗更多的计算资源</li></ul><p>文章认为解决以上问题的一个经济可行的办法是将全连接层置换成稀疏连接结构，甚至是在卷积内。</p><p>目前的硬件结构在面对非均匀分布的稀疏数据结构时，计算效率很低。</p><p>为此，文章希望找到一个新的结构，可以更高效的处理稀疏矩阵的运算。</p><p>文章通过多个实验验证了Inception模型在面对图像分类和检测问题时，可以取得十分好的效果。但是，对于Inception model是否能够成为其他领域任务的指导原则，还尚未有定论，需要更多的验证和实验才能说明。</p><h3 id="4-框架细节"><a href="#4-框架细节" class="headerlink" title="4.框架细节"></a>4.框架细节</h3><p>Inception模型的一个核心思想在于找到 <strong>卷积网络中的最优局部稀疏结构可以在多大程度上被稠密组件近似和覆盖</strong> 。需要注意，由于假设了平移不变性，因此本文的模型将从卷积模块中开始建立，本文所需要做的就是找到一个局部最优结构，然后将这些结构在空间上组合起来。</p><p>为了避免path-alignment问题，现在滤波器大小设值为1×1,3×3,和5×5。</p><p>由于pooling层的重要性，本文才采用了pooling层。</p><p>将上面的Inception模块叠加起来，形成一个整体的模型。</p><p>但是直接叠加会使得向量维度剧增，因此，通过1×1卷积来控制维度。</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvn6do3nmnj20un08y75k.jpg" alt=""></p><p>当max pooling层的stride为1时，并不会缩小输出的feature map的size，只会影响depth的值。</p><p>关于此结构的一个好处在于它可以提高神经元的个数，同时避免网络不受控制的提升计算机复杂度。</p><h3 id="5-GooLeNet"><a href="#5-GooLeNet" class="headerlink" title="5. GooLeNet"></a>5. GooLeNet</h3><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvn6q3t8hfj20j01x2qcf.jpg" alt=""></p><p>GoogLeNet的网络结构图细节如下：</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvn98ano6mj20ps0f5778.jpg" alt=""></p><p>GoogLeNet网络结构明细表解析如下：</p><p>0、输入</p><p>原始输入图像为224x224x3，且都进行了零均值化的预处理操作（图像每个像素减去均值）。</p><p>1、第一层（卷积层）</p><p>使用7x7的卷积核（滑动步长2，padding为3），64通道，输出为112x112x64，卷积后进行ReLU操作<br>经过3x3的max pooling（步长为2），输出为((112 - 3+1)/2)+1=56，即56x56x64，再进行ReLU操作</p><p>2、第二层（卷积层）</p><p>使用3x3的卷积核（滑动步长为1，padding为1），192通道，输出为56x56x192，卷积后进行ReLU操作</p><p>经过3x3的max pooling（步长为2），输出为((56 - 3+1)/2)+1=28，即28x28x192，再进行ReLU操作</p><p>3a、第三层（Inception 3a层）</p><p>分为四个分支，采用不同尺度的卷积核来进行处理</p><p>（1）64个1x1的卷积核，然后RuLU，输出28x28x64</p><p>（2）96个1x1的卷积核，作为3x3卷积核之前的降维，变成28x28x96，然后进行ReLU计算，再进行128个3x3的卷积（padding为1），输出28x28x128</p><p>（3）16个1x1的卷积核，作为5x5卷积核之前的降维，变成28x28x16，进行ReLU计算后，再进行32个5x5的卷积（padding为2），输出28x28x32</p><p>（4）pool层，使用3x3的核（padding为1），输出28x28x192，然后进行32个1x1的卷积，输出28x28x32。<br>将四个结果进行连接，对这四部分输出结果的第三维并联，即64+128+32+32=256，最终输出28x28x256</p><p>3b、第三层（Inception 3b层）</p><p>（1）128个1x1的卷积核，然后RuLU，输出28x28x128</p><p>（2）128个1x1的卷积核，作为3x3卷积核之前的降维，变成28x28x128，进行ReLU，再进行192个3x3的卷积（padding为1），输出28x28x192</p><p>（3）32个1x1的卷积核，作为5x5卷积核之前的降维，变成28x28x32，进行ReLU计算后，再进行96个5x5的卷积（padding为2），输出28x28x96</p><p>（4）pool层，使用3x3的核（padding为1），输出28x28x256，然后进行64个1x1的卷积，输出28x28x64。</p><p>将四个结果进行连接，对这四部分输出结果的第三维并联，即128+192+96+64=480，最终输出输出为28x28x480</p><p>第四层（4a,4b,4c,4d,4e）、第五层（5a,5b）……，与3a、3b类似，在此就不再重复。</p><h2 id="要点整理"><a href="#要点整理" class="headerlink" title="要点整理"></a>要点整理</h2><h3 id="说明一下GoogLeNet采用多个卷积核的动机"><a href="#说明一下GoogLeNet采用多个卷积核的动机" class="headerlink" title="说明一下GoogLeNet采用多个卷积核的动机"></a>说明一下GoogLeNet采用多个卷积核的动机</h3><p>NIN网络和Inception Module这类结构非常看中模型在局部区域的拟合能力。它们认为：一张图像通常具有总体特征和细节特征这两类特征，一般小卷积核能够更好的捕捉一些细节特征，随着深层网络的小卷积不断计算下去，总体特征也会慢慢的被提炼出来，但是这样存在一个问题，那就是在如果只采用小卷积，那么网络结构的前段一般只有细节特征，后段才慢慢有一些总体特征，而我们希望这两方面的特征总是能够一起发挥作用，因此，上面的两种模型考虑采用更多不同尺寸的卷积核来提取特征，并把这些特征连接起来，一起送到后面的网络中去计算，使得网络可以获取到更多的特征信息。</p><p>Inception模块还采用了一个stride为1的max pooling层，它的主要功能是减少空间大小，降低过拟合风险（只选最大值，所以值的范围变少了）。</p><h3 id="Inception中为什么使用1×1卷积？1×1卷积的作用是什么？"><a href="#Inception中为什么使用1×1卷积？1×1卷积的作用是什么？" class="headerlink" title="Inception中为什么使用1×1卷积？1×1卷积的作用是什么？"></a>Inception中为什么使用1×1卷积？1×1卷积的作用是什么？</h3><p>关于Inception Module，有一种很直接的做法就是将1×1,3×3,5×5卷积和3×3 max pooling直接连接起来，如下面的左图所示，但是这样的话就有个问题，那就是计算量增长太快了。</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvn6do3nmnj20un08y75k.jpg" alt=""></p><p>为了解决这个问题，文章在3×3和5×5的卷积之前，3×3max pooling之后使用了1×1卷积，使其输出的feature map的depth降低了，从而达到了降维的效果，抑制的过快增长的计算量。</p><h4 id="1×1卷积核的作用："><a href="#1×1卷积核的作用：" class="headerlink" title="1×1卷积核的作用："></a>1×1卷积核的作用：</h4><p>1x1卷积的主要目的是为了减少维度，还用于修正线性激活（ReLU）。比如，上一层的输出为 100x100x128，经过具有256个通道的5x5卷积层之后(stride=1，pad=2)，输出数据为100x100x256，其中，卷积层的参数为128x5x5x256= 819200。而假如上一层输出先经过具有32个通道的1x1卷积层，再经过具有256个输出的5x5卷积层，那么输出数据仍为为100x100x256，但卷积参数量已经减少为128x1x1x32 + 32x5x5x256= 204800，大约减少了4倍</p><h4 id="1×1的卷积核，在一定程度上可以实现全连接层："><a href="#1×1的卷积核，在一定程度上可以实现全连接层：" class="headerlink" title="1×1的卷积核，在一定程度上可以实现全连接层："></a><strong>1×1的卷积核，在一定程度上可以实现全连接层：</strong></h4><p>具体的操作是，输入是224x224x3 的图像，假设经过变换之后最后一层是[7x7x512]的，那么传统的方法应该将其展平成为一个7x7x512长度的一层，然后做全连接层，假设全连接层为4096×1000层的（假设有1000个分类结果）。</p><p>那么用1×1卷积核怎么做呢，因为1×1卷积核相当于在不同channel之间做线性变换，所以：</p><ul><li>先选择7×7的卷积核，输出层特征层数为4096层，这样得到一个[1×1×4096]层的</li><li>然后再选择用1×1卷积核，输出层数为1000层，这样得到一个[1×1×1000]层的</li></ul><h4 id="用卷积层代替全连接层的好处："><a href="#用卷积层代替全连接层的好处：" class="headerlink" title="用卷积层代替全连接层的好处："></a><strong>用卷积层代替全连接层的好处：</strong></h4><p>这样做其实有非常多的好处，比如上面的例子中输入是224x224x3 的图像，如果此时图像变得更大了，变成384x384大小的了，那么一开始按照32作为步长来进行卷积操作，最后还按照这个网络结构能得到一个[6×6×1000]层的，那么前面那个[6×6]有什么用呢，这个代表每一个位置上，其属于1000个分类结果中的打分，所以这在图像分割等领域等领域有着非常重要的作用【之前一篇论文就是用的这种方法Fully Convolutional Networks for Semantic Segmentation】。</p><h3 id="Auxiliary-Classifier"><a href="#Auxiliary-Classifier" class="headerlink" title="Auxiliary Classifier"></a>Auxiliary Classifier</h3><p>当时Inception网络还是太深了，不好训练，因此网络中还加了两个侧枝，通过中间层的feature map，来得到预测结果（有了ResNet的shortcut以后，这种侧枝用的比较少了）。</p><h4 id="为什么使用侧枝？"><a href="#为什么使用侧枝？" class="headerlink" title="为什么使用侧枝？"></a>为什么使用侧枝？</h4><p>为了避免梯度消失，网络额外增加了2个辅助的softmax用于向前传导梯度（辅助分类器）。辅助分类器是将中间某一层的输出用作分类，并按一个较小的权重（0.3）加到最终分类结果中，这样相当于做了模型融合，同时给网络增加了反向传播的梯度信号，也提供了额外的正则化，对于整个网络的训练很有裨益。而在实际测试的时候，这两个额外的softmax会被去掉。也就是说在测试的时候，只会用最后的softmax结果作为分类依据。</p><h3 id="Inception-Model有没有使用全连接层？"><a href="#Inception-Model有没有使用全连接层？" class="headerlink" title="Inception Model有没有使用全连接层？"></a>Inception Model有没有使用全连接层？</h3><p>在两个侧枝使用了卷积+FC+FC+SoftmaxActivation的结构，在最后一层使用了全局平均池化+FC+SoftmaxActivation的结构。</p><h3 id="LRN：LocalRespNorm"><a href="#LRN：LocalRespNorm" class="headerlink" title="LRN：LocalRespNorm"></a>LRN：LocalRespNorm</h3><h1 id="Inception-V2"><a href="#Inception-V2" class="headerlink" title="Inception V2"></a>Inception V2</h1><h2 id="论文概览-1"><a href="#论文概览-1" class="headerlink" title="论文概览"></a>论文概览</h2><p>Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</p><h2 id="要点整理-1"><a href="#要点整理-1" class="headerlink" title="要点整理"></a>要点整理</h2><p>GoogLeNet设计的初衷就是要又准又快，而如果只是单纯的堆叠网络虽然可以提高准确率，但是会导致计算效率有明显的下降，所以如何在不增加过多计算量的同时提高网络的表达能力就成为了一个问题。</p><p>Inception V2版本的解决方案就是　<strong>修改Inception的内部计算逻辑，提出了比较特殊的“卷积”计算结构</strong>。</p><h3 id="卷积分解（Factorizing-Convolutions）"><a href="#卷积分解（Factorizing-Convolutions）" class="headerlink" title="卷积分解（Factorizing Convolutions）"></a>卷积分解（Factorizing Convolutions）</h3><p>主要受到VGG的启发</p><p>大尺寸的卷积核可以带来更大的感受野，但也意味着会产生更多的参数，比如5×5卷积核的参数就有25个（不算depth和filters的数量）。因此，GoogLeNet团队提出可以用2个连续的3×3卷积层组成的小网络来代替单个的5×5卷积层，即在 <strong>保持感受野范围的同时又减少了参数量</strong>，如下图：</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvna17nohlj209z09ydhb.jpg" alt=""></p><p>大量实验表明，这种分解并不会造成表达缺失，那么是否可以进一步分解，GoogLeNet团队尝试了n×1的卷积核，如下图所示，用3个3×1取代3×3卷积：</p><p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvna17muznj207c0a70th.jpg" alt=""></p><p>因此，任意nxn的卷积都可以通过1xn卷积后接nx1卷积来替代。GoogLeNet团队发现在网络的前期使用这种分解效果并不好，在中度大小的特征图（feature map）上使用效果才会更好（特征图大小建议在12到20之间）。</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvna17piozj20bu1a040a.jpg" alt=""></p><h3 id="降低特征图大小"><a href="#降低特征图大小" class="headerlink" title="降低特征图大小"></a>降低特征图大小</h3><p>一般情况下，如果想让图像缩小，可以有如下两种方式：</p><p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvna17my4gj20ep09haah.jpg" alt=""></p><p>前者先做pooling会导致在做卷积的时候缺少特征，后者是在卷积计算后，提取完特征以后进行的正常的图像缩小，但是计算量很大（卷积计算比pooling计算复杂）。为了同时保持特征表示且降低计算量，将网络结构改为下图，使用两个并行化的模块来降低计算量（卷积、池化并行执行，最后再进行合并）。</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvna17n33wj20fh08u759.jpg" alt=""></p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>使用Inception V2作改进版的GoogLeNet，网络结构图如下：</p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fvna17sdq6j20fh0f1djt.jpg" alt=""></p><p>注：上表中的Figure 5指没有进化的Inception，Figure 6是指小卷积版的Inception（用3x3卷积核代替5x5卷积核），Figure 7是指不对称版的Inception（用1xn、nx1卷积核代替nxn卷积核）。</p><h3 id="Batch-Normalizatin"><a href="#Batch-Normalizatin" class="headerlink" title="Batch Normalizatin"></a>Batch Normalizatin</h3><p>Batch Normalization, 批标准化, 和普通的数据标准化类似, 是将分散的数据统一的一种做法, 也是优化神经网络的一种方法.</p><p>详见:<img src="" alt="Batch-Normalization深入解析"></p><h1 id="Inception-V3"><a href="#Inception-V3" class="headerlink" title="Inception V3"></a>Inception V3</h1><h2 id="论文概览-2"><a href="#论文概览-2" class="headerlink" title="论文概览"></a>论文概览</h2><h2 id="要点整理-2"><a href="#要点整理-2" class="headerlink" title="要点整理"></a>要点整理</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
            <tag> 网络模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++创建对象时new与不new的区别</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6new%E4%B8%8E%E4%B8%8Dnew/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6new%E4%B8%8E%E4%B8%8Dnew/</url>
      
        <content type="html"><![CDATA[<p>C++在创建对象的时候可以采用两种方式：（例如类名为Test） <code>Test test</code>  或者 <code>Test* pTest = new Test()</code>。<br>这两种方法都可以实例化一个对象，但是这两种方法有很大的区别，区别在于对象内容所在的内存空间不同，众所周知，内存的分配方式有三种<br>（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。<br>（2）  在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束后在将这些局部变量的内存空间回收。在栈上分配内存空间效率很高，但是分配的内存容量有限。<br>（3） 从堆上分配的。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。<br>那么当使用Test test给对象分配内存空间的时候，是分配在堆中的还是栈中的呢？</p><p>在不使用new创建对象时，对象的内存空间是在栈中的，其作用范围只是在函数内部，函数执行完成后就会调用析构函数，删除该对象。</p><p>而使用new创建对象是创建在堆中的，必须要程序员手动的去管理该对象的内存空间。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VIM指令速查及常用技巧</title>
      <link href="/z_post/Linux-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-VIM%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/z_post/Linux-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-VIM%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="VIM-常用指令"><a href="#VIM-常用指令" class="headerlink" title="VIM 常用指令"></a>VIM 常用指令</h1><p>fa,i,r,o,A,I,R,O 进入编辑模式<br>h,backspace 左移动 l,space 右移动 j 下移动 k 上移动<br>0     移动到行首<br>$     移动到行末 1$表示当前行的行尾，2$表示当前行的下一行的行尾<br>b 按照单词向前移动 字首<br>e 按照单词向后移动 字尾<br>w 按照单词向后移至次一个字首<br>H 移动到屏幕最上 非空白字<br>M 移动到屏幕中央 非空白字<br>L 移动到屏幕最下 非空白字<br>G 移动到文档最后一行<br>gg 移动到文档第一行<br>v 进入光标模式，配合移动键选中多行<br>Ctrl+f 向下翻页<br>Ctrl+b 向上翻页<br>u 撤销上一次操作<br>.. 回到上次编辑的位置<br>dw 删除这个单词后面的内容<br>dd 删除光标当前行<br>dG 删除光标后的全部文字<br>d$ 删除本行光标后面的内容<br>d0 删除本行光标前面的内容<br>y 复制当前行，会复制换行符<br>yy 复制当前行的内容<br>yyp 复制当前行到下一行，此复制不会放到剪切板中<br>nyy 复制当前开始的n行</p><p>全选（高亮显示）：按esc后，然后ggvG或者ggVG</p><p>全部复制：按esc后，然后ggyG</p><p>全部删除：按esc后，然后dG</p><p>二、复制多行<br>任务：将第9行至第15行的数据，复制到第16行</p><p>方法1：（强烈推荐）<br>：9，15 copy 16  或 ：9，15 co 16<br>由此可有：<br>：9，15 move 16  或 :9,15 m 16 将第9行到第15行的文本内容到第16行的后面</p><p>ubuntu系统, 默认不支持系统剪切板与vim的交互, 需要先安装一个东西:</p><p><code>sudo apt-get install vim-gnome</code></p><p>再set clipboard=unnamed</p><p>然后就可以使用<code>ggyG</code>了</p><p>选中指定行：<br>方法3：<br>把光标移到第9行 shift + v<br>再把光标移动到第15行</p><p>Vim 有12个粘贴板依次编号为：0、1、2、…、9、a、”、+，其中 + 号为系统粘贴板，” 为临时粘贴板。系统剪切板中的内容可在其他程序中使用。上面的复制指令都可以配合剪切板进行操作。kj</p><p>“nyw 复制当前单词到 n 号剪切板（双引号开始）<br>“np 粘贴 n 号剪切板内容到当前位置后<br>“+Y 复制当前行到系统剪切板<br>“+nY 复制当前行往下 n 行到系统剪切板<br>“+p 粘贴系统剪切板内容到当前位置后</p><p>“+yy  // 复制当前行到剪切板<br>“+p   // 将剪切板内容粘贴到光标后面<br>“ayy  // 复制当前行到寄存器 a<br>“ap   // 将寄存器 a 中的内容粘贴到光标后面</p><p>p,P,. 粘贴<br>ddp 当前行和下一行互换位置<br>J 合并行<br>Ctrl+r 恢复刚才撤销（u）的动作<br>Ctrl+z 暂停并退出<br>ZZ 保存离开<br>xp 交换字符后面的交换到前面<br>~ 更换当前光标位置的大小写，并光标移动到本行右一个位置，直到无法移动</p><p>Ctrl+e     向下滚动<br>Ctrl+b     向上翻页<br>b 按照单词向前移动 字首<br>B 按照单词向前移动 字首 忽略一些标点符号<br>e按照单词向后移动 字尾<br>E 按照单词向后移动 忽略一些标点符号<br>w 按照单词向后移至次一个字首<br>W 按照单词向后移至次一个字首 忽略一些标点符号</p><p>H 移动到屏幕最上 非空白字<br>M 移动到屏幕中央 非空白字<br>L 移动到屏幕最下 非空白字</p><p>G 移动到文档最后一行<br>gg 移动到文档第一行<br>( 光标到句尾<br>) 光标到局首<br>{ 光标到段落开头<br>} 光标到段落结尾<br>nG 光标下移动到n行的首位<br>n$ 光标移动到n行尾部<br>n+ 光标下移动n行<br>n- 光标上移动n行</p><p>zz将当前行移到屏幕中部，zb移到底部,zt 顶部</p><p>* 向下查找同样光标的字符<br># 向上查找同样光标的字符<br>/code 查找 code 一样的内容，向后<br>?code 查找 code 一样的内容，向前<br>n 查找下一处<br>N 查找上一处<br>ma 在光标处做一个名叫a的标记 可用26个标记 (a~z)<br>`a 移动到一个标记a<br>d`a 删除当前位置到标记a之间的内容<br>:marks 查看所有标记</p><p>:q 一般退出<br>:q! 退出不保存<br>:wq 保存退出<br>:w filename 另存为 filename<br>:jumps 历史编辑文档记录</p><p>ctrl+i，ctrl+o跳转位置,</p><p>Ctrl+f    向文件尾翻一屏幕<br>Ctrl+b    向文件首翻一屏幕<br>Ctrl+d    向文件尾翻半屏幕<br>Ctrl+u    向文件首翻半屏幕</p><p>i 在光标前<br>I 在当前行首<br>a 在光标后<br>A 在当前行尾部<br>o 在当前行下新开一行<br>O 在当前行上新开一行<br>r 替换当前字符<br>R 替换当前行及后面的字符，直到按esc为止<br>s 从当前行开始，以输入的文本替代指定数目的字符<br>S 删除指定数目的行，并以输入的文本替代<br>ncw,nCW 修改指定数目n的字符<br>nCC 修改指定数目n的行</p><p>x 删除当前光标字符<br>X 删除光标前字符<br>nx<br>nX</p><p>dw            删除到下一个单词开头<br>de            删除到本单词末尾<br>dE            删除到本单词末尾包括标点在内<br>db            删除到前一个单词<br>dB            删除到前一个单词包括标点在内</p><p>ndw,nDW 删除光标开始及其后 n-1 个word<br>dw 删除这个单词后面的内容<br>dd 删除光标当前行<br>dG 删除光标后的全部文字<br>d$ 删除本行光标后面的内容<br>d0 删除本行光标前面的内容<br>ndd 删除当前行，以及其后的n-1行<br>x 删除一个字符，光标后<br>X 删除一个字符，光标前<br>Ctrl+u 删除输入模式下的输入的文本</p><p>:split    创建新窗口<br>Ctrl+w    切换窗口<br>Ctrl-w =    所有窗口一样高<br>Ctrl-w+方向键    多窗口视图切换</p><p>:args    列出当前编辑的文件名<br>:next    打开多文件，使用 n(Next) p(revious)    N(ext) 切换<br>:file    列出当前打开的所有文件</p><p>替換（substitute）</p><p>:[range]s/pattern/string/[c,e,g,i]</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《CUDA并行程序设计-GPU编程指南》</title>
      <link href="/z_post/CUDA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-CUDA%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_GPU%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
      <url>/z_post/CUDA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-CUDA%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_GPU%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><strong>前言部分——本书编排：</strong></p><ul><li>第一章：从宏观上介绍流处理器（streaming processor）的演变历史。</li><li>第二章：介绍并行编程的概念，建立基本认识。</li><li>第三章：详尽地讲解CUDA设备及与其紧密相关的硬件和架构。</li><li>第四章：介绍了如何在Windows、Mac和Linux等不同操作系统上安装和配置CUDA软件开发工具包。</li><li>第五章：介绍CUDA线程模型。</li><li>第六章：详细讲解了不同类型内存的工作机制。</li><li>第七章：详述了如何在若干任务中恰当地协同CPU和GPU。</li><li>第八章：介绍如何在应用程序中编写和使用多GPU。</li><li>第九章：对CUDA编程中限制性能的主要因素予以讲解。</li><li>第十章：介绍了CUDA软件开发工具包的示例和CUDA提供的库文件。</li><li>第十一章：关注构建自己的GPU服务器或者GPU集群时的几个问题。</li><li>第十二章：检视多数程序员在开发CUDA应用程序时易犯的错误类型。</li></ul><h1 id="第一章-超级计算机简史"><a href="#第一章-超级计算机简史" class="headerlink" title="第一章 超级计算机简史"></a>第一章 超级计算机简史</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>``</p>]]></content>
      
      
      <categories>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HelloCUDA</title>
      <link href="/z_post/CUDA-CUDA%E7%A4%BA%E4%BE%8B%E5%AD%A6%E4%B9%A0-HelloCUDA/"/>
      <url>/z_post/CUDA-CUDA%E7%A4%BA%E4%BE%8B%E5%AD%A6%E4%B9%A0-HelloCUDA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hellocuda.cu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">kernel</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, cvudakernel\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>,<span class="number">5</span>&gt;&gt;&gt;();</span><br><span class="line">    cudaDeviceReset();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>nvcc hellocuda.cu -o hellocuda</span><br><span class="line"><span class="meta">$</span>./hellocuda</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello, cvudakernel</span><br><span class="line">hello, cvudakernel</span><br><span class="line">hello, cvudakernel</span><br><span class="line">hello, cvudakernel</span><br><span class="line">hello, cvudakernel</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA示例学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中typeid实现原理和使用方法</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84typeid%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84typeid%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>先好好理解一下C++的typeid运算符到底是什么意思，再问“原理是什么”会比较好。先看这里学习typeid是什么意思：typeid operator针对题主给的例子：<code>int i = 1;const char* name = typeid(i).name();</code> 这里的typeid(i)根本不需要做任何运行时动作，而是纯编译时行为——它使用变量i的静态类型直接就知道这是对int类型做typeid运算，于是可以直接找出int对应的std::type_info对象返回出来。</p><p>If expression is not a glvalue expression of polymorphic type, typeid does not evaluate the expression, and the std::type_info object it identifies represents the static type of the expression. Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed.此时的typeid运算符就跟sizeof运算符的大部分情况一样，只需要编译器算出表达式的静态类型就足够了。算出表达式的静态类型是C++编译器的基本功能了，类型检查、类型推导等许多功能都依赖它。而当typeid运算符应用在一个指向多态类型对象的指针上的时候，typeid的实现才需要有运行时行为。<br>If expression is a glvalue expression that identifies an object of a polymorphic type (that is, a class that declares or inherits at least one virtual function), the typeid expression evaluates the expression and then refers to the std::type_info object that represents the dynamic type of the expression. If the glvalue expression is obtained by applying the unary <em> operator to a pointer and the pointer is a null pointer value, an exception of type std::bad_typeid or a type derived from std::bad_typeid is thrown.实际实现的时候，通常是在类的vtable里会有个slot保存着指向该类对应的std::type_info对象的指针。要形象的理解的话，请参考我在另一个回答里画的图：为什么bs虚函数表的地址（int</em>）(&amp;bs)与虚函数地址（int<em>）</em>(int*)(&amp;bs) 不是同一个？ - RednaxelaFX 的回答可以看到Clang++在LP64上用的vtable布局，不禁用RTTI时，在-8偏移量上的slot就是存typeinfo指针的。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Image-Generation-from-Scene-Graphs</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-Image_Generation_from_Scene_Graphs/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-Image_Generation_from_Scene_Graphs/</url>
      
        <content type="html"><![CDATA[<p>本篇论文解读的排版主要参见原文的格式，针对原文中的每一个小节进行展开，有的是对原文的一个提炼和简单概括，有的是对原文中一些要点的补充和说明。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>&emsp;&emsp;近几年来（至2018），针对某些特定目标（花，鸟等）的图片生成已经取得了令人激动的研究成果，但是当文本描述中包含多个物体和物体之间的关系时，仍然具有一些困难。 为了克服这一点，本文提出了从场景图来生成图片的方法，该方法可以推理出具体的物体和物体之间的关系。 本文的模型使用“图卷积层”（graph convolution）来处理输入的“图”（graph），通过预测物体的bounding boxes和segmentation masks来计算“场景布局”（scene layout），然后利用“级联精细化网络”（cascaded refinement network）将“场景布局”转换成一张图片输出。在训练网络时，通过对抗式的训练一对儿discriminators来确保生成图片的真实感。 本文在Visual Genome和COCO-Stuff数据集是验证了以上模型的有效性，结合高质量的生成图片、消融实验和人工调研的方法证明了本文提出的模型可以生成含有多个物体的复杂图片。</p><h1 id="介绍——Introduction"><a href="#介绍——Introduction" class="headerlink" title="介绍——Introduction"></a>介绍——Introduction</h1><p>What I cannot create，I do not understand —— Richar Feynman</p><p>&emsp;&emsp;要想让计算机生成图片，就需要令其对图片有更深刻的理解。</p><p>&emsp;&emsp;为了达到以上目标，目前在text to image synthesis领域已经有许多的工作成果。这些模型可以在limited domains内产生十分惊人的结果，但是当文本信息变得复杂起来时，其生成出来的图片就不尽人意了。</p><p><img src="https://s1.ax1x.com/2018/07/15/PMTISI.jpg" alt="图片显示失败，请联系博主进行维护" title="图1"></p><p>&emsp;&emsp;句子通常都是由一个单词接一个单词组成的线性结构，但是，一个复杂的句子，其内部携带的信息，通常需要由基于物体的“场景图”在具体表示，“场景图”中包含物体和物体之间的关系。“场景图”作为表征图片和文本的强有力的工具，常常被用于语义图片检测、提高和评价图片描述领域中。也有关于将自然语言或图片转换成“场景图”的研究。</p><p>22,1，31,47,32,36，57,58</p><p>&emsp;&emsp;本篇文章的主要研究目的是在“场景图”约束条件下，生成带有多个物体和物体之关系的复杂图片。这一任务也带来了许多新的挑战。首先，必须要找到可以处理场景图的输入方法，对此本文使用了“graph convalution network”，它可以沿着“场景图”的“边”将信息传递。处理完“图”以后，还必须建立图结构的输入与二维图片的输出之间的联系。为此 ，本文通过预测图中所有物体的bounding boxes和segmentation masks构建了“场景布局（scene layout）”。得到“布局”以后，就需要生成图片，本文使用了“cascaded refinement network（CRN）”，它可以不断增大空间尺寸，生成图片。 最后，我们必须确保生成的图片具有一定的真实感并且包含多个可辨识的物体，为此我们针对image patches和generated objects训练了一对儿discriminator网络。另外，所有的模型可以进行端到端的联合训练。</p><p>&emsp;&emsp;我们在2个数据集上进行了实验：Visual Genome（提供人工标注的场景图）和COCO-stuff（从真实的物体位置生成场景图）。两个数据集的生成结果都证明了本文提出的方法的可以生成包含多个物体并且反映它们之间关系的复杂图片。同时，还进行了综合的消融实验来验证本文提出的模型中每一部分的有效性。</p><h1 id="相关工作——Related-Work"><a href="#相关工作——Related-Work" class="headerlink" title="相关工作——Related Work"></a>相关工作——Related Work</h1><p>&emsp;&emsp;<strong>生成图片模型 Generative Image Models</strong> 目前，生成模型主要可分为三类：Generative Adversarial Networks（GANs）、Variational Autoencoders（VAE）和基于像素的似然法autoregressive approaches。</p><p>[12,40,24,38,53]</p><p>&emsp;&emsp;<strong>条件图片生成 Conditional Image Synthesis</strong> 通过在生成图片时向GAN网络添加条件的方式来控制最终输出图片的结果。由两种不同方法：一是将条件作为附加信息同时送入到generator和discriminator中，二是强制让discriminator去预测图片的label。本文选择后者。</p><p>[10,35,37,42,59,41,43,6,9,21,4,5,20,27,28,55,56,22]</p><p>&emsp;&emsp;<strong>场景图 Scene Graph</strong> 表现为有向图，它的结点是物体，边是物体之间的关系。场景图多倍用于图片检索、图片描述评价等，有些工作也场景从文本或图片中生成场景图</p><p>[1,47,32,36,57,58,26]</p><p>&emsp;&emsp;<strong>针对图的深度学习 Deep Learning on Graphs</strong> 有的工作是对图进行embedding学习，类似于word2vec，但这与本文的方法不同，因为本文在进行一次前向计算时，传过来的图都是新的。与本文方法更相关的是Graph Neural Networks，它可以对任意的图进行处理。</p><p>[39,51,14,34,11,13,46,8,49,48,7,19,29,54,2,15,25]</p><h1 id="方法——Methond"><a href="#方法——Methond" class="headerlink" title="方法——Methond"></a>方法——Methond</h1><p>&emsp;&emsp;我们的目标是得到一个模型，该模型的输入描述物体和它们之间关系的“场景图”，输出是基于该场景图的图片。主要的挑战和困难有三个方面：一、必须找到可以处理“场景图”输入的方法;二、确保生成的图片可以真实反映出场景图中缩描述的物体;三、确保生成的图片具有真实感。</p><p>&emsp;&emsp;如图2所示，本文通过“image generation network f”将场景图转换成图片。该网络的inputs是场景图 $G$ 噪声变量 $z$ ，ouputs是 $\hat I = f(G,z)$ 。</p><center><div style="color:orange;border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;">图2</div></center><p><img src="https://s1.ax1x.com/2018/07/15/PMT7Of.jpg" alt="图片显示失败，请联系博主进行维护" title="图2"></p><p>&emsp;&emsp;场景图经过“图卷积网络”后，会得到每个物体的embedding vectors，如图2和图3所示，每一层“图卷积层”都会沿着图的边将信息混合在一起。</p><center><div style="color:orange;border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;">图3</div></center><p><img src="https://s1.ax1x.com/2018/07/15/PMT4fA.jpg" alt="图片显示失败，请联系博主进行维护" title="图3"></p><p>&emsp;&emsp;本文利用从图卷积网络中得到的object embedding vectors来预测每个物体的bounding boxes和segmentation masks。将它们结合起来形成一个“场景图 scene layout”，如图2中心所示，场景布局相当于是场景图和图片中间媒介。</p><p>&emsp;&emsp;最终将布局送入到CRN中，生成图片，如图2右边所示，CRN中会不断将布局的尺寸放大，指定生成新的图片为止。本文训练的生成器是CRN网络 $f$ 和两个分辨器 $D_{img}$ 和 $D_{obj}$ ，它们可以确保图片的真实感以及图片中物体的可识别力。关于这部分的详细介绍可以查看后文以及附加材料中的内容。</p><p>&emsp;&emsp;<strong>场景图 Scene Graphs</strong> 给定一个物体类别集合 $C$ 和一个关系集合 $R$ 。一个场景图可以用一个元组 $(O,E)$ 表示，其中 $O \subseteq C$ ， $E \subseteq O \times R \times O$ 。在处理的第一阶段，使用学习好的embedding layer将场景图中的结点和边转换成一个dense vector，就像语言模型中的那样。</p><p>&emsp;&emsp;<strong>图卷积网络 Graph Convolution Network</strong> 为了实现端到端的处理，本文需要一个可以对场景图进行处理的神经网络模型，为此，采用了由若干图卷积层构成的图卷积网络。 本文的图卷积网络与传统的卷积网络的工作方式类似：给定一个input graph，它每个结点和边的vecotrs维度为 $D_{in}$ ，然后经过一层图卷积层以后，就会生成一个新的vector，其维度为 $D_{out}$ 。（输出结点的值是关输入结点周围像素的函数）。 具体来说，对于所有的 $o_i \in O , (o_i,r,o_j) \in E$ ，给定输入向量 $v_i,v_r \in R^{D_{in}}$ 都会计算出输出向量 $v_i^{‘} , v_r^{‘} \in R^{D_{out}}$ 。 对于所有的结点和边，都会使用3个函数： $g_s , g_p , g_o$ ，其接受的输入为一个向量的三元组 $(v_i, v_r, v_j)$。&emsp;计算边的输出向量时，直接使用 $v_r^{‘} = g_p(v_i, v_r, v_j)$ 。而更新结点的值时较为复杂，因为结点往往连接了很多条边。对于每条始于 $o_i$ 的结点，都利用 $g_s$ 去计算候选向量（candidate vector），收集到所有的候选向量以后，将其放置于集合 $V_i^s$ 中。用 $g_o$ 以同样的方式处理止于 $o_i$ 的边。公式表示如下：</p><script type="math/tex; mode=display">V_i^s = {g_s(v_i, v_r, v_j) : (o_i, r, o_j) \in E}</script><script type="math/tex; mode=display">V_i^o = {g_o(v_j, v_r, v_i) : (o_j, r, o_i) \in E}</script><p>然后再利用公式 $v_i^{‘} = h(V_i^s \cup V_i^o)$ 计算得到物体 $o_i$ 的输出向量 $v_i^{‘}$ （ $h$ 为池化操作）。有关计算的例子可以看图3。在本文中，函数 $g_s , g_p , g_o$ 的实现采用了一个单一网络，该网络会将输入向量连接起来，然后送到一个多层感知机（MLP）当中。pooling 函数 $h$ 会将输入结果进行平均值池化，然后送到MLP当中。</p><center><div style="color:orange;border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;">图4</div></center><p><img src="https://s1.ax1x.com/2018/07/15/PMTT6P.md.jpg" alt="图片显示失败，请联系博主进行维护" title="图4"></p><p>&emsp;&emsp;<strong>场景布局 Scene Layout</strong> 为了生成图片，本文利用object embedding vectors去计算场景布局，该布局给出了要生成的图片的2D结构。本文利用图4中的object layout network来预测每个物体的bounding boxes和 segmentation masks，进而生成场景布局。  object layout networks接受形状为 $D$ 的embedding vector $v_i$ ，并把它送入到一个 mask regression network中去预测形状为 $M \times M$ 的soft binary mask $\hat m_i$ ，同时也送到一个 box regression network中去预测bounding box $\hat b_i = (x_0, y_0, x_1, y_1)$ 。 我们将 embedding vectors $v_i$ 和 mask $\hat m_i$ 逐个元素相乘，得到一个masked embedding ， 其shape为 $D \times M \times M$ ，然后，再利用双线性插值法结合物体的bounding box得到一个object layout。将所有的object layout相加，最终得到scene layout。在训练阶段，我们使用ground-truth bounding boxes来计算scene layout，在测试阶段我们使用预先预测好的bounding boxes进行计算。</p><p>&emsp;&emsp;<strong>级联精细化网络 Cascaded Refinement Network</strong> 在给定场景布局以后，本文使用CRN来根据场景布局生成图片。一个CRN网络包含了一系列的convolutional refinement modules，modules之间的spatial resolutoin会不断变大（double），最终达到预定义的图片大小。 每个module都以scene layout（downsampling到当前module接受的大小）和前一层module的输出结果。 这两部分输入沿着channel连接在一起,送到2层3×3的卷积层里，然后利用最近邻插值对结果进行upsampling，之后继续传送到下一个module中。第一个module以scene layout和高斯噪声 $z \sim p_z$ 作为输入。把从最后一个module得到的结果再送到两个final convolution layers中去，生成最终的图片。</p><p>&emsp;&emsp;<strong>分辨器 Discriminators</strong> 本文训练了两个分辨器 $D_{img}$ 和 $D_{obj}$</p><ul><li>patch-based image discriminators $D_{img}$ ：确保生成图片的overall appearance是realistic的。利用全卷积网络实现。</li><li>object discriminator $D_{obj}$ ：确保图片中的每个物体都是recognizable并且realistic的。分别利用辅助分类器 auxiliary classifier和全卷积网络实现。</li></ul><p>&emsp;&emsp;<strong>训练 Training</strong> 本文将generation network $f$ 和 $D_{img} , D_{obj}$ 联合训练。generation network的训练目标是minimize下面的6个损失函数的权重和：</p><ul><li>$Box \ loss\ \ L_{box} = \sum_{i=1}^n ||b_i - \hat b_i||_1$ ：计算真实box和预测box之间的L1范式</li><li>$Mask\ loss\ \ L_{mask}$ ：计算真实mask和预测mask之间基于像素的交叉熵</li><li>$Pixel\ loss\ \ L_{pix} = ||I - \hat I||_1$ ：真实图片和生成图片之间的L范式</li><li>$Image\ adversarial\ loss\ \ L_{GAN}^{img}$ ：针对 $D_{img}$ 的损失函数</li><li>$Object\ adversarial\ loss\ \ L_{GAN}^{obj}$ ：针对 $D_{obj}$ 的损失函数，确保物体的realistic</li><li>$Auxiliarly\ classifier\ loss\ \ L_{AC}^{obj}$ ：针对 $D_{obj}$的损失函数，确保物体的recognizable</li></ul><p>&emsp;&emsp;<strong>实现细节 Implementation Details</strong> 本文对所有的scene graphs都进行了数据增强，并且添加了特殊的图片间的relationships，可以把每个真实物体与图片物体进行连接，确保所有的scene graphs都是连通的。我们使用Adam训练所有的模型，学习率设置为 $10^{-4}$ ， batch size 设置为32, 迭代次数为一百万次，使用单个Tesla P100训练了3天。 对于每一次minibatch，我们首先更新 $f$ ，而后更新 $D_{img}$ 和 $D_{obj}$ 。对于所有的graph convolution 本文使用ReLU作为激活函数，对于CRN和discriminators 使用Leaky ReLU作为激活函数，同时使用了batch normalization技术。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>&emsp;&emsp;在实验中，我们将证明本文提出的方法可以生成复杂的图片，并且正确反应场景图中的物体和物体之间的关系。</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>&emsp;&emsp;<strong>COCO</strong> 使用2017 COCO-Stuff 数据集，该数据集共有80个物体类别，40K的训练集和5K的验证集，所有的图片标注都具有bounding boxes和segmentation masks 。利用这些标注，本文建立了2D平面上的场景图，总共包含6中人工设定的关系：左边，右边，上边，下边，里面，外面。我们忽略了图片中占图片比例小于2%的物体，使用的图片包含3～8个物体。将COCO val分为val和test两部分。最终，我们得到了24972张训练图片，1024张val图片，2048张test图片。</p><p>&emsp;&emsp;<strong>Visual Genome</strong> 本文使用VG 1.4数据集，它包含108077张图片，并且具有标注好的场景图。将其中的80%用作训练集，10%分别用作val和test，本文仅仅使用在训练集中出现次数大于2000次的物体和大于500次的关系，最终，我们得到的训练集具有178种物体和45种关系类型。我们忽略图片中的小物体，并且使用图片中具有3～30个物体和至少一种关系类型的图片，最终我们得到了62565张图片作训练集，5506张val和5088张test，平均每张图片包含10个物体和5种关系类型。由于VG数据集没有提供segmentation masks标注，所以在使用VG数据集时，我们忽略mask loss 。</p><h2 id="定性结果——Qualitative-Results"><a href="#定性结果——Qualitative-Results" class="headerlink" title="定性结果——Qualitative Results"></a>定性结果——Qualitative Results</h2><p>&emsp;&emsp;由本文提出的模型生成的图片示例如图5,6所示</p><center><div style="color:orange;border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;">图5</div></center><p><img src="https://s1.ax1x.com/2018/07/15/PMThYd.jpg" alt="图片显示失败，请联系博主进行维护" title="图5"></p><center><div style="color:orange;border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;">图6</div></center><p><img src="https://s1.ax1x.com/2018/07/15/PMTolt.jpg" alt="图片显示失败，请联系博主进行维护" title="图6"></p><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><p>&emsp;&emsp;在消融实验中，如表1所示，我们验证了模型每一部分对最终图片质量的重要性和必要性。文本使用 $inception\ score^2$作为衡量生成图片好坏的标准。</p><center><div style="color:orange;display: inline-block;color: #999;">表1</div></center><center><div style="color:orange;border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;">表1</div></center><p><img src="https://s1.ax1x.com/2018/07/15/PMTbm8.jpg" alt="图片显示失败，请联系博主进行维护" title="表1"></p><p>我们测试了以下几种不同的消融模型：</p><p>&emsp;&emsp;<strong>无图卷积 no gconv</strong> ：去掉图卷积层，因此boxes和masks会直接从原始的object embedding vectors预测而来。</p><p>&emsp;&emsp;<strong>无关系 no relationships</strong> ：使用图卷积层，但是忽视场景图中的所有“边”，即关系信息。</p><p>&emsp;&emsp;<strong>无分辨器 no discriminators</strong> ：去掉分辨器 $D_{img}$ 和 $D_{pix}$ ，依靠像素回归损失函数 $L_{pix}$ 来引导图片的生成。</p><p>&emsp;&emsp;<strong>去掉一个分辨器 omit one of the Discriminators</strong> ：仅去掉其中一个分辨器</p><p>&emsp;&emsp;<strong>GT Layout</strong> ：除了消融实验外，本文还使用了GT layout来代替 $L_{box} 和 $L_{mask}$ 损失函数。</p><h2 id="物体定位-Object-Localization"><a href="#物体定位-Object-Localization" class="headerlink" title="物体定位 Object Localization"></a>物体定位 Object Localization</h2><p>&emsp;&emsp;除了关注生成图片的质量外，我们还对本文模型预测到的bounding boxes进行了分析。在表2中，我们展示了object的召回率和2种交并比的分值。另一个评价标准就是多样性。</p><center><div style="color:orange;border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;">表2</div></center><p><img src="https://s1.ax1x.com/2018/07/15/PMTXkQ.jpg" alt="图片显示失败，请联系博主进行维护" title="表2"></p><h2 id="用户调研-User-Studies"><a href="#用户调研-User-Studies" class="headerlink" title="用户调研 User Studies"></a>用户调研 User Studies</h2><p>&emsp;&emsp;作者找来了数名志愿者，让他们根据以下两个评价标准对本文模型的生成结果和StackGAN的结果进行评价。</p><ul><li>Caption Matching</li><li>Object Recall</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文解读 </tag>
            
            <tag> 图片生成 image generation </tag>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>卷积神经网络的复杂度分析</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/31575074" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31575074</a></p><p><a href="https://zhuanlan.zhihu.com/p/31575074" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31575074</a></p><p><a href="https://blog.csdn.net/dcrmg/article/details/79652521" target="_blank" rel="noopener">https://blog.csdn.net/dcrmg/article/details/79652521</a></p><p><a href="https://blog.csdn.net/laolu1573/article/details/79196160" target="_blank" rel="noopener">https://blog.csdn.net/laolu1573/article/details/79196160</a></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>时间复杂度即模型的浮点数运算次数, 可用 FLOPs (FLoating-point OPerations) 来衡量.</p><h2 id="单个卷积层的时间复杂度"><a href="#单个卷积层的时间复杂度" class="headerlink" title="单个卷积层的时间复杂度"></a>单个卷积层的时间复杂度</h2><script type="math/tex; mode=display">Time \sim O(M^2 K^2 C_{in} C_{out})</script><ul><li>$M$ : 每个卷积核输出的特征图谱的边长</li><li>$K$ : 每个卷积核的边长</li><li>$C_{in}$ : 每个卷积核的输入通道数</li><li>$C_{out}$ : 本卷积层具有的卷积核个数, 也即输出通道数</li></ul><p>注一: 为了简化表达式, 这里假设输入和输出的特征图谱都是正方形<br>注二: 同样为了简化表达式, 这里省略了偏置项.</p><h2 id="网络整体的时间复杂度"><a href="#网络整体的时间复杂度" class="headerlink" title="网络整体的时间复杂度"></a>网络整体的时间复杂度</h2><script type="math/tex; mode=display">Time \sim O \Big(\sum_{l=1}^D M^2K^2C_{l-1}C_l \Big)</script><ul><li>$D$ : 神经网络具有的卷积层层数, 也就是网络的深度</li><li>$l$ : 神经网络的第l层卷积层</li><li>$C_l$ : 神经网络第l层卷积层的输出通道数, 也就是该层的卷积核个数</li></ul><p>示例: 用Numpy实现简单二维卷积:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(img, kernel)</span>:</span></span><br><span class="line">    height, width, in_channels = img.shape</span><br><span class="line">    kernel_height, kernel_width, in_channels, out_channels = kernel.shape</span><br><span class="line">    out_height = height - kernel_height + <span class="number">1</span></span><br><span class="line">    out_width = width - kernel_width + <span class="number">1</span></span><br><span class="line">    feature_maps = np.zeros(shape=(out_height, out_width, out_channels))</span><br><span class="line">    <span class="keyword">for</span> oc <span class="keyword">in</span> range(out_channels):              <span class="comment"># Iterate out_channels (# of kernels)</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(out_height):             <span class="comment"># Iterate out_height</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(out_width):          <span class="comment"># Iterate out_width</span></span><br><span class="line">                <span class="keyword">for</span> ic <span class="keyword">in</span> range(in_channels):   <span class="comment"># Iterate in_channels</span></span><br><span class="line">                    patch = img[h: h + kernel_height, w: w + kernel_width, ic]</span><br><span class="line">                    feature_maps[h, w, oc] += np.sum(patch * kernel[:, :, ic, oc])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> feature_maps</span><br></pre></td></tr></table></figure><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>空间复杂度 (访存量) 包含两部分: 总参数量 + 各层的输出特征图谱</p><ul><li>参数复杂度: 模型所有带参数的层的参数总量: $O(K^2C_{l-1}C_{l})$</li><li>特征图谱复杂度: 实时运行过程的每层计算出的图谱大小: $O(M^2C_l)$</li></ul><script type="math/tex; mode=display">Space \sim O\Big( \sum_{l=1}^D K_l^2 C_{l-1} C_l + \sum_{l=1}^D M^2 C_l \Big)</script><p>注意, 上面的参数复杂度没有带偏置项, 因为这只是计算复杂度, 而不是精确的参数个数.</p><h1 id="复杂度对模型的影响"><a href="#复杂度对模型的影响" class="headerlink" title="复杂度对模型的影响"></a>复杂度对模型的影响</h1><h1 id="复杂度的优化"><a href="#复杂度的优化" class="headerlink" title="复杂度的优化"></a>复杂度的优化</h1><p>1×1 卷积降维同时优化时间复杂度和空间复杂度</p><p>用两个 3×3 卷积 (18个参数) 替代 5×5卷积 (25个参数)</p><p>使用 N×1 和 1×N 卷积级联替代 $N×N$ 卷积.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 卷积神经网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树结构知识点总结</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%A0%91%E7%BB%93%E6%9E%84/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-%E6%A0%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>注：本文的对各个概念的定义不一定采用常用的标准定义，原因有二：</p><ul><li>常用的定义描述在百度百科上即可查到</li><li>更多的是想通过自己的理解，用简短的几个关键词语或句子，来点明核心要点</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="基本概念和性质"><a href="#基本概念和性质" class="headerlink" title="基本概念和性质"></a>基本概念和性质</h2><p><strong>二叉树的定义</strong>：二叉树中的每个节点至多有2棵子树，并且子树有左右之分，其次序不能任意颠倒。</p><p><strong>二叉树的性质</strong>：</p><ol><li>对于非空二叉树：$N_0 = N_2 +1$</li><li>在于非空二叉树，第k层上的节点数不超过：$2^{k-1}$</li><li>高为h的二叉树，总节点数不超过：$2^h-1$</li><li>具有N个节点的<strong>完全二叉树</strong>，其高度为： $\lceil log_2(N+1) \rceil$ 或 $\lfloor log_2{N} \rfloor +1$</li><li>对于完全二叉树，如果各个节点按照顺序存储(从 1 开始)，则节点之间编号具有一定关系：<ul><li>节点 $i$ 的父节点为 $\lfloor \frac{i}{2} \rfloor (i&gt;1)$</li><li>$i$的左右子树分别为：$2i$ 和 $2i+1$ （如果$2i/2i+1 \geq N$，则无左/右子树</li></ul></li><li>给定N个节点，能够成$h(N)$ 种不同的二叉树：$h(N)=…$</li><li>设有$i$个枝点，$I$为所有枝点的道路长度总和，$J$为叶的道路长度总和$J=I+2i$</li></ol><p><strong>注意： 二叉树不是度为2的树。</strong> 度为2的树至少要有3个节点，而二叉树可以为空;度为2的树的左右子树是相对而言的，当只有一个孩子时，就无须分左右</p><h2 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h2><p><strong>满二叉树：</strong> 除叶子节点外的所有节点均有两个子节点</p><p><strong>完全二叉树：</strong> 最后一个不满的“满二叉树”，最后一层所有节点集中在左边</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="先根遍历：根节点、左子树、右子树"><a href="#先根遍历：根节点、左子树、右子树" class="headerlink" title="先根遍历：根节点、左子树、右子树"></a>先根遍历：根节点、左子树、右子树</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void preOrder(Tree t)&#123;</span><br><span class="line">  visit(t-&gt;value); //访问根节点</span><br><span class="line">  if (t-&gt;left)    preOrder(t-&gt;left); //访问左孩子</span><br><span class="line">  if (t-&gt;right)    preOrder(t-&gt;right); //访问右孩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><p>对于任一节点，其可看做是根节点，因此直接访问，访问后，若其左孩子不为空，则按相同规则访问其左子树，当访问完左子树之后，再访问其右子树：</p><p>对于任一节点P：</p><ol><li>访问节点P，并将P入栈</li><li>如果P的左孩子不为空，则令P = P-&gt;left，并转向第一步。若为空，则将P出栈，并令P = P-&gt;right，然后转向第一步。</li><li>直到P为nullptr并且栈为空时，结束循环</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; preOrder;</span><br><span class="line"><span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> preOrder;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; s_node;</span><br><span class="line">TreeNode* P = pRoot;</span><br><span class="line"><span class="keyword">while</span>(!s_node.empty() || P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    preOrder.push_back(P); <span class="comment">// visit P</span></span><br><span class="line">    s_node.push(P);</span><br><span class="line">    P = P-&gt;left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!s_node.empty())&#123;</span><br><span class="line">    P = s_node.top(); s_node.pop();</span><br><span class="line">    P = P-&gt;right; <span class="comment">// go to right child</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中根遍历：左子树、根节点、右子树"><a href="#中根遍历：左子树、根节点、右子树" class="headerlink" title="中根遍历：左子树、根节点、右子树"></a>中根遍历：左子树、根节点、右子树</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pRoot != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    in_order(pRoot-&gt;left);</span><br><span class="line">    visit(pRoot);</span><br><span class="line">    in_order(pRoot-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><p>对于任一节点，优先查看其左孩子，而左孩子节点又可以看作是一个根节点，则继续优先查看其左孩子，直到遇到左孩子节点为空的根节点才进行访问。然后再转向查看其右孩子，右孩子可看作是一个根节点，继续按上面的规则循环：</p><p>对于任一节点P：</p><ol><li>若其左孩子不为空，则就P入栈并将P的左孩子置为当前的P，然后继续查看当前P的左孩子，直到为空；</li><li>经过上一步后，P指向了空的左孩子，因此取栈顶元素并进行出栈操作，同时访问该栈顶节点，然后将P置为栈顶节点的右孩子（无需判断右孩子是否为空，若为空则下一次循环会自动继续取栈顶）</li><li>知道P为nullptr并且栈为空时循环结束</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; inOrder;</span><br><span class="line"><span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> inOrder;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; stack_node;</span><br><span class="line">TreeNode* P = pRoot;</span><br><span class="line"><span class="keyword">while</span>(!stack_node.empty() || P !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    stack_node.push(P);</span><br><span class="line">    P = P-&gt;left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!stack_node.empty())&#123;</span><br><span class="line">    P = stack_node.top(); stack_node.pop();</span><br><span class="line">    inOrder.push_back(P); <span class="comment">// visit P</span></span><br><span class="line">    P = P-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后根遍历：左子树、右子树、根节点"><a href="#后根遍历：左子树、右子树、根节点" class="headerlink" title="后根遍历：左子树、右子树、根节点"></a>后根遍历：左子树、右子树、根节点</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pRoot != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    in_order(pRoot-&gt;left);</span><br><span class="line">    in_order(pRoot-&gt;right);</span><br><span class="line">    visit(pRoot);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h4><p>后序遍历的非递归实现是最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问，并且左孩子在右孩子之间访问，最后才能访问根节点。有两种思路：</p><h5 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h5><h5 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h5><h1 id="二叉排序树（Binary-Sort-Tree-BST）"><a href="#二叉排序树（Binary-Sort-Tree-BST）" class="headerlink" title="二叉排序树（Binary Sort Tree, BST）"></a>二叉排序树（Binary Sort Tree, BST）</h1><h2 id="基本概念和性质-1"><a href="#基本概念和性质-1" class="headerlink" title="基本概念和性质"></a>基本概念和性质</h2><p><strong>定义：</strong> 也叫二叉查找树或有序二叉树。当树不为空时，该树具有如下性质：</p><ul><li>左子树上的所有节点值，均小于其根节点的值</li><li>右子树上的所有节点值，均大于其根节点的值</li><li>左、右子树也分别为二叉排序树</li><li>没有键值相等的节点</li></ul><p><strong>性质：</strong> 对二叉排序树进行中根遍历，即可得到一串有序数列（从小到大）</p><p><strong>时间复杂度：</strong> 插入与查找的复杂度均为$O(logn)$，但在最坏情况下为$O(n)$（原因在于树不一定是平衡的）</p><h1 id="平衡二叉书-AVL树-名字来源于其发明者-Adelson-Velsky-和-Landis"><a href="#平衡二叉书-AVL树-名字来源于其发明者-Adelson-Velsky-和-Landis" class="headerlink" title="平衡二叉书(AVL树, 名字来源于其发明者 Adelson-Velsky 和  Landis)"></a>平衡二叉书(AVL树, 名字来源于其发明者 Adelson-Velsky 和  Landis)</h1>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的封装、继承、多态、重载、重写基本概念解析</title>
      <link href="/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90/"/>
      <url>/z_post/Cpp-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-Cpp%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的三个基本特征"><a href="#面向对象的三个基本特征" class="headerlink" title="面向对象的三个基本特征"></a>面向对象的三个基本特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>实现多态具有两种方法：重载overload（利用参数列表）和覆盖override（利用virtual关键字）</p><h3 id="C-中的override关键字"><a href="#C-中的override关键字" class="headerlink" title="C++中的override关键字"></a>C++中的override关键字</h3><p>从C++11起，引入了新的关键字<code>override</code>，主要用于紧随成员函数声明或定义内成员函数的声明器之后使用。</p><p>在成员函数声明或定义中，override确保该函数为虚并覆写（overrride）来自基类的虚函数。<code>override</code>是在成员函数声明器后使用时才拥有特殊含义的标识符，其他情况下不是保留的关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> override</span>; <span class="comment">// 错误： B::foo 不覆写 A::foo（签名不匹配）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// OK ： B::foo 覆写 A::foo</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> override</span>; <span class="comment">// 错误： A::bar 非虚</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="C-中的final关键字"><a href="#C-中的final关键字" class="headerlink" title="C++中的final关键字"></a>C++中的final关键字</h3><p>指定派生类不能覆写虚函数，或类不能被继承。</p><p>在虚函数声明或定义中使用时，final确保函数为虚且不可被派生类覆写，否则程序生成编译时错误。</p><p>在类定义中使用时，final指定此类不可出现于另一类的定义的 base-specifier-list 中（换言之，不能从它派生出其他类），否则程序生成编译时错误。</p><p>final是在用于成员函数声明或类头部时有特殊含义的标识符，其他语境中它非保留关键字，可用于命名对象或函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> final</span>; <span class="comment">// A::foo 被覆写且是最终覆写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> final</span>; <span class="comment">// 错误：非虚函数不能被覆写或是 final</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">final</span> :</span> A <span class="comment">// struct B 为 final</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// 错误： foo 不能被覆写，因为它在 A 中是 final</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> B <span class="comment">// 错误： B 为 final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《深入理解TensorFlow架构设计与实现原理》</title>
      <link href="/z_post/TensorFlow-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TF/"/>
      <url>/z_post/TensorFlow-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TF/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-TensorFlow系统概述"><a href="#第一章-TensorFlow系统概述" class="headerlink" title="第一章 TensorFlow系统概述"></a>第一章 TensorFlow系统概述</h1><p>人工智能和深度学习的热潮将Tensoflow推向了很高的地位，本章主要是作为引子，来对TF进行一个概述</p><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><h3 id="1-1-1-产生背景"><a href="#1-1-1-产生背景" class="headerlink" title="1.1.1 产生背景"></a>1.1.1 产生背景</h3><p>近年来深度学习在图像、视觉和语音领域的突破，促使了各种深度学习框架的诞生</p><h3 id="1-1-2-独特价值"><a href="#1-1-2-独特价值" class="headerlink" title="1.1.2 独特价值"></a>1.1.2 独特价值</h3><p>TF能在众多开源框架中杀出重围，除了Google的背书以外，还少不了以下独特价值：</p><ul><li>运算性能强劲：TF1.0利用线性代数编译器XLA全方位的提升了计算性能，XLA帮助TF在CPU、GPU、TPU、嵌入式设备等平台上更快速的运行机器学习模型的训练与推理任务。同时，还提供了大量针对不同软硬件环境的优化配置参数</li><li>框架设计通用：TF既提供高层封装API（如Slim、Keras、TF Layers等），又提供底层原生API</li><li>支持生产环境部署</li><li>语言借口丰富：支持python、C、C++、java、Go等</li><li>端云协同计算：支持同时在云侧和端侧运行（移动设备等终端）</li></ul><h3 id="1-1-3-版本变迁"><a href="#1-1-3-版本变迁" class="headerlink" title="1.1.3 版本变迁"></a>1.1.3 版本变迁</h3><p>迭代更新非常快，慢慢走向成熟</p><h3 id="1-1-4-与其他主流深度学习框架对比"><a href="#1-1-4-与其他主流深度学习框架对比" class="headerlink" title="1.1.4 与其他主流深度学习框架对比"></a>1.1.4 与其他主流深度学习框架对比</h3><p>起初，TF的内存消耗和计算速度一直是短板。但是，随着XLA和RDMA等特性的发布，TF的性能在绝大多数情况下都不输于其他深度学习框架。</p><p>TF的灵活性导致了学习成本也相应较高，API过于丰富。（不过，可以使用Keras、TF Layers来解决此问题）</p><h2 id="1-2-设计目标"><a href="#1-2-设计目标" class="headerlink" title="1.2 设计目标"></a>1.2 设计目标</h2><p>TF的设计目标并非局限一套深度学习库，Google希望其成为一套面向多种应用场景和编程范式、支持异构计算平台、具备优异性能与可伸缩性的通用人工智能引擎。</p><h3 id="1-2-1-灵活通用的深度学习库"><a href="#1-2-1-灵活通用的深度学习库" class="headerlink" title="1.2.1 灵活通用的深度学习库"></a>1.2.1 灵活通用的深度学习库</h3><p>TF的灵活性主要体现在以下几个方面：</p><ul><li>算子定义：粒度更细，数量更多</li><li>编程范式：支持声明式编程，将模型的定义和执行解耦</li><li>runtime框架</li><li>多语言支持</li></ul><h3 id="1-2-2-端云结合的人工智能引擎"><a href="#1-2-2-端云结合的人工智能引擎" class="headerlink" title="1.2.2 端云结合的人工智能引擎"></a>1.2.2 端云结合的人工智能引擎</h3><p>TF对云计算场景的支持是其竞争力的基础，主要体现在以下方面：</p><ul><li>提供多种标准化的安装包、构建脚本和容器化封装，支持在不同Linux发行版以及Windows Server等服务器上部署</li><li>支持对接多种常见的公有云和私有云服务</li><li>兼容若干种常见的高性能计算与通信硬件</li><li>灵活的runtime框架设计，既提供标准且易用的PS-worker分布式模式，也允许用户自由开发针对特定环境需求的分布式框架</li></ul><p>TF在端侧方面也毫不逊色，主要体现在以下几个方面</p><ul><li>推理（预测）态代码能够运行于多种主流的终端平台</li><li>通过XLA AOT（ahead of time）编译技术及其他软硬件解耦设计，简化对接</li><li>提供量化参数和低精度代数等算法层机制</li><li>提供模型与框架一体化的精简版runtime平台</li></ul><h3 id="1-2-3-高性能的基础平台软件"><a href="#1-2-3-高性能的基础平台软件" class="headerlink" title="1.2.3 高性能的基础平台软件"></a>1.2.3 高性能的基础平台软件</h3><p>TF的高性能设计体现在它对高端和专用硬件的深入支持。</p><h2 id="1-3-基本架构"><a href="#1-3-基本架构" class="headerlink" title="1.3 基本架构"></a>1.3 基本架构</h2><h3 id="1-3-1-工作形态"><a href="#1-3-1-工作形态" class="headerlink" title="1.3.1 工作形态"></a>1.3.1 工作形态</h3><p>TF采用了库模式，其工作形态是有用户编写主程序代码，调用Python或其他语言函数库提供的借口以实现计算逻辑。</p><h3 id="1-3-2-组件结构"><a href="#1-3-2-组件结构" class="headerlink" title="1.3.2 组件结构"></a>1.3.2 组件结构</h3><p>结构示意图可查看书上p13</p><p>构成TF的主体使其运行时核心库。 对于普通的python应用层开发者而言，这个核心库就是值通过pip命令等方式安装TF之后，部署到<code>site-packages</code>或类似目录中的动态链接库文件。</p><p>生成这个库的C++源代码大致分为3个层次：分布式运行时、公共运行时和算子核函数。其中，公共运行时实现了数据流图计算的基本逻辑，分布式运行时在此基础上实现了数据流图的跨进程协同计算逻辑，算子核函数则包含图上具体操作节点的算法实现代码。</p><h1 id="第二章-TensorFlow环境准备"><a href="#第二章-TensorFlow环境准备" class="headerlink" title="第二章 TensorFlow环境准备"></a>第二章 TensorFlow环境准备</h1><h1 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h1><p>可查看官方文档</p><p>有一点需要注意：为了保证软件对操作系统和硬件平台的通用性，Google官方发布的TensorFlow whl包没有使用过多的编译优化选项，如 XLA、AVX、SSE等，如果想要打开这些编译优化选项来提升TF的计算性能，那么必须使用源代码编译安装的方式。</p><h1 id="2-2-依赖项"><a href="#2-2-依赖项" class="headerlink" title="2.2 依赖项"></a>2.2 依赖项</h1><h1 id="2-2-1-Bazel软件构建工具"><a href="#2-2-1-Bazel软件构建工具" class="headerlink" title="2.2.1 Bazel软件构建工具"></a>2.2.1 Bazel软件构建工具</h1><p>Bazel是Google开源的一套软件构建工具，功能定位与CMake、GNU Autotools和Apache Ant等类型，但具有一些独特的优势，如下所示：</p><ul><li>多语言支持：C++、Java、Python等</li><li>高级构建语言</li><li>多平台支持</li><li>可重现性</li><li>可伸缩性</li></ul><p>Bazel使用工作空间、包和目标三层抽象组织待构建的对象</p><ul><li>工作空间（workspce）：</li><li>包（package）：</li><li>目标（target）：</li></ul><h1 id="2-2-2-Protocal-Buffers-数据结构序列化工具"><a href="#2-2-2-Protocal-Buffers-数据结构序列化工具" class="headerlink" title="2.2.2 Protocal Buffers 数据结构序列化工具"></a>2.2.2 Protocal Buffers 数据结构序列化工具</h1><h1 id="2-2-3-Eigen线性代数计算库"><a href="#2-2-3-Eigen线性代数计算库" class="headerlink" title="2.2.3 Eigen线性代数计算库"></a>2.2.3 Eigen线性代数计算库</h1><h1 id="2-2-4-CUDA统一计算设备架构"><a href="#2-2-4-CUDA统一计算设备架构" class="headerlink" title="2.2.4 CUDA统一计算设备架构"></a>2.2.4 CUDA统一计算设备架构</h1><p>CUDA是NVIDIA公司退出的一种用于并行计算的软硬件架构，发布于2007年。该架构以通用计算图形处理器（GPGPU）作为主要的硬件平台，提供一组用于编写和执行通用计算任务的开发库与运行时环境。</p><p>CUDA作为软件依赖项提及时，往往指的是CUDA架构中的软件组件，即NVIDIA驱动程序和CUDA Toolkit。除了基本的CUDA开发库和编译器外，CUDA工具包还包括cuBLAS、cuFFT、cuSOLVER、cuDNN等高级算法库，以及IDE、调试器、可视化分析器等开发工具，其中部分组件需要独立安装。</p><p>在CUDA架构中，不同层次的软件组件均为开发者提供编程接口，以适应不同类型软件的开发需求：</p><ul><li>NVIDIA驱动层的开发接口（即cu开头的函数，也称为CUDA Driver API）较为底层，暴露了GPU的若干内部实现抽象。这种接口能够对GPU的运行时行为进行细粒度控制，有助于提升程序的运行时效率，但缺点在于开发过程烦琐。一般的GPU应用程序不会直接使用这一层接口，然而TF内部的GPU计算引擎——StreamExecutor为了追求性能，选择使用这一层接口实现GPU任务调度和内存管理等功能</li><li>CUDA开发库的API（即以cuda开头的函数，也称为CUDA Runtime API）是CUDA架构中使用最为广泛的接口，功能涵盖GPU设备管理，内存管理，时间管理以及图形处理相关的逻辑。</li><li>cuBLAS、cuDNN等高级算法库：提供了面向通用计算（如线性代数）或领域专用计算（如神经网络）需求的高层次接口。在这个层次，GPU设备的很多技术细节已被屏蔽，开发者可以专注于算法逻辑的设计与实现。TF面向NVIDIA GPU的计算类操作大多基于cuBLAS和cuDNN接口实现。</li></ul><p>对于TF而言，CUDA工具包是不受Bazel管理的外部依赖项，因此，用户如果想要使用NVIDIA GPU加速深度学习时，需要事先安装带有NVIDIA驱动程序的CUDA工具包即cuDNN库</p><h2 id="2-3-源代码结构"><a href="#2-3-源代码结构" class="headerlink" title="2.3 源代码结构"></a>2.3 源代码结构</h2><h3 id="2-3-1-根目录"><a href="#2-3-1-根目录" class="headerlink" title="2.3.1 根目录"></a>2.3.1 根目录</h3><p>TF源码的组织复合Bazel构建工具要求的规范。其根目录是一个Bazel项目的工作空间。</p><h3 id="2-3-2-tensorflow目录"><a href="#2-3-2-tensorflow目录" class="headerlink" title="2.3.2 tensorflow目录"></a>2.3.2 tensorflow目录</h3><p>TF项目的源码主体位于tensorflow目录，该目录下的源文件几乎实现了TF的全部功能，同时体现了TF的整体模块布局。</p><h3 id="2-3-3-tensorflow-core-目录"><a href="#2-3-3-tensorflow-core-目录" class="headerlink" title="2.3.3 tensorflow/core 目录"></a>2.3.3 tensorflow/core 目录</h3><p>TF核心运行时库的源代码位于tensorflow/core目录</p><h3 id="2-3-4-tensorflow-python-目录"><a href="#2-3-4-tensorflow-python-目录" class="headerlink" title="2.3.4 tensorflow/python 目录"></a>2.3.4 tensorflow/python 目录</h3><p>TF Python API的源码位于tensorflow/python目录</p><h3 id="2-3-5-安装目录"><a href="#2-3-5-安装目录" class="headerlink" title="2.3.5 安装目录"></a>2.3.5 安装目录</h3><p>pip命令会将TF运行时所需的Python文件、动态链接库以及必要的依赖项复制到当前Python环境的<code>site-packages</code>或<code>dist-packages</code>目录中，其中TF软件本身的的运行时代码会被部署到tensorflow子目录，这一目录具有与源码tensorflow目录相似的组织结构。二者的不同点在于以下几点：</p><ul><li>安装目录中只包含每个模块的Python语言接口文件，不再包含C++源码。所有使用到的C++源码已被编译到了python子目录下的动态链接库文件中（在Linux下为<code>_pywrap_tensorflow_internal.so</code>）。如果某个模块未提供Python API，那么相应的子目录不会在安装目录中出现</li><li>安装目录中的<code>python/ops</code>子目录比同名的源代码子目录增加了一系列名称有<code>gen_</code>开头的<code>Python</code>接口文件。这些文件是TensorFLow编译脚本自动创建的，旨在为C++核心库的一部分数据流图操作提供Python编程接口</li><li>安装目录比源代码目录多出一个include子目录。这个目录包含了TensorFLow本身以及Protocol Buffers、Eigen等依赖库的C++头文件，允许用户通过编程方式使用核心库的功能。</li></ul><h1 id="第三章-TensorFlow基础概念"><a href="#第三章-TensorFlow基础概念" class="headerlink" title="第三章 TensorFlow基础概念"></a>第三章 TensorFlow基础概念</h1><h2 id="3-1-编程范式：数据流图"><a href="#3-1-编程范式：数据流图" class="headerlink" title="3.1 编程范式：数据流图"></a>3.1 编程范式：数据流图</h2><p>TF采用了更适合描述深度神经网络模型的声明式编程范式，并以数据流图作为核心抽象。</p><p>优势（相比更广泛的命令式编程范式）：</p><ul><li>代码可读性强</li><li>支持引用透明</li><li>提供预编译优化能力</li></ul><h3 id="3-1-1-声明式编程与命令式编程"><a href="#3-1-1-声明式编程与命令式编程" class="headerlink" title="3.1.1 声明式编程与命令式编程"></a>3.1.1 声明式编程与命令式编程</h3><p>二者的最大区别在于：前者强调“做什么”， 后者强调“怎么做”。</p><p>声明式编程：结构化、抽象化，用户不必纠结每个步骤的具体实现，而是通过下定义的方式描述期望达到的状态。声明式编程比较接近人的思考模式；程序中的变量代表数学符号或抽象函数，而不是一块内存地址，程序的最终输出仅依赖于用户的输入数据，计算过程不受内部和外部状态影响。</p><p>命令式编程：过程化、具体化、用户告诉机器怎么做，机器按照用户的指示一步步执行命令，并转换到最终的停止状态。命令式编程起源于对汇编语言和机器指令的进一步抽象，本身带有明显的硬件结构特征。它通过修改存储器的值、产生副作用的方式实现计算。这里的副作用是值对外部环境产生的附加影响。</p><p>编程是一种输入到输出的转换机制，这两种范式提供了截然不同的解决方案：</p><ul><li>声明式编程：程序是一个数学模型，输入是自变量，输出是因变量，用户设计和组合一系列函数，通过表达式变换实现计算。</li><li>命令式编程：程序是一个有穷自动机，输入是起始状态，输出是结束状态，用户设计一系列指令，通过指令的执行完成状态转换。</li></ul><p>适用范围：</p><ul><li>声明式编程：DL、AI</li><li>命令式编程：交互式UI、OS</li></ul><h3 id="3-1-2-声明式编程在DL应用上的优势"><a href="#3-1-2-声明式编程在DL应用上的优势" class="headerlink" title="3.1.2 声明式编程在DL应用上的优势"></a>3.1.2 声明式编程在DL应用上的优势</h3><ol><li>代码可读性强</li></ol><p>&emsp;&emsp;以目标为导向，更接近于数学公式或人类的思维方式</p><ol><li>支持引用透明</li></ol><p>&emsp;&emsp;引用透明是指：如果一个函数的语义同他出现在程序中的上下文无关，则称它是引用透明的。关于引用透明的一个推论是：函数的调用语句可以被它的返回值取代，而不影响程序语义。因此，用户可以选择执行任意的模块组合（子图），以得到不同模型结构的输出结果。</p><ol><li>提供预编译优化能力</li></ol><p>&emsp;&emsp;TF需要实现编译得到完整的数据流图，然后根据用户选择的子图、输入数据进行计算。因此，声明式编程能够实现多种预编译优化，包括无依赖逻辑并行化、无效逻辑移除、公共逻辑提取、细粒度操作融合等。</p><h3 id="3-1-3-TensorFlow数据流图的基本概念"><a href="#3-1-3-TensorFlow数据流图的基本概念" class="headerlink" title="3.1.3 TensorFlow数据流图的基本概念"></a>3.1.3 TensorFlow数据流图的基本概念</h3><p>TF的数据流图是一个 <strong>有向无环图</strong> 。 图中的节点代表各类操作（opertion），具体包括数学运算、数据填充、结果输出和变量读写等操作，每个节点上的操作都需要分配到具体的物理设备（CPU、GPU）上执行。 图中的有向边描述了节点间的输入、输出关系（也就是各个操作的输入和输出），边上流动（flow）着代表高位数据的张量。</p><h4 id="1-节点"><a href="#1-节点" class="headerlink" title="1.节点"></a>1.节点</h4><p>前向图中的节点统一称为操作，它们根据功能可以分为以下3类：</p><ul><li>数学函数或表达式</li><li>存储模型参数的变量（variable）</li><li>占位符（placeholder）</li></ul><p>后向图中的节点同样分为三类：</p><ul><li>梯度值</li><li>更新模型参数的操作</li><li>更新后的模型参数</li></ul><h4 id="2-有向边"><a href="#2-有向边" class="headerlink" title="2.有向边"></a>2.有向边</h4><p>数据流图中的有向边用于定义操作之间的关系，它们分为两类：一类用来传输数据，绝大部分流动着的张量的变都是此类，简称数据边；另一类用来定义控制依赖，通过设定节点的前置依赖决定相关节点的执行顺序，简称控制边。</p><h4 id="3-执行原理"><a href="#3-执行原理" class="headerlink" title="3.执行原理"></a>3.执行原理</h4><p>声明式编程的特点决定了在深度神经网络模型的数据流图上，各个节点的执行顺序并不完全依赖于代码中定义的顺序，而是与节点之间的逻辑关系以及运行时库的实现机制相关。</p><p>抛开运行时库内部的复杂实现，数据流图上节点的执行顺序参考了拓扑排序的设计思想，其过程可以简述为以下4个步骤：</p><ol><li>以节点名称作为关键字、入度作为值，创建一张散列表，并将次数据流图上的所有节点放入散列表中。</li><li>为此数据流图创建一个可执行节点队列，将散列表中入度为0的节点加入到该队列，并从散列表中删除这些节点</li><li>依次执行该队列中的每一个节点，执行成功后将此节点输出指向的节点的入度值减1，更新散列表中对应节点的入度值</li><li>重复步骤2和步骤3，直到可执行节点队列变为空</li></ol><h2 id="3-2-数据载体：张量"><a href="#3-2-数据载体：张量" class="headerlink" title="3.2 数据载体：张量"></a>3.2 数据载体：张量</h2><p>TF提供Tensor和SparseTensor两种张量抽象，分别表示稠密数据和系数数据。后者旨在减少高维稀疏数据的内存占用。</p><h3 id="3-2-1-张量：Tensor"><a href="#3-2-1-张量：Tensor" class="headerlink" title="3.2.1 张量：Tensor"></a>3.2.1 张量：Tensor</h3><p>与数学和物理学中的张量不同，在NumPy或TF中，通常使用多维数组的形式描述一个张量，数组的维数表示对应张量的阶数。张量的阶数决定了其描述的数据所在高维空间的维数，在此基础上，定义每一阶的长度可以唯一确定一个张量的形状。</p><p>TF中的张量形状用python中的列表表示，列表中的每个值依次表示张量各阶的长度（如图片的张量：[128,128,3]）。</p><p>TF的张量在逻辑定义上是数据载体，但在物理实现时是一个句柄，它存储张量的元信息以及指向张量数据的内存缓冲区指针。这样设计是为了实现 <strong>内存复用</strong>。在某些前置操作（生产者）的输出值被输入到多个后置操作（消费者）的情况下，无须重复存储输出值。</p><h4 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h4><p>一般情况下，用户不需要使用Tensor类的构造方法直接创建张量，而是通过操作间接创建张量，如constant和add操作等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">b = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">c = tf.add(a,b)</span><br><span class="line">print([a,b,c])</span><br><span class="line"></span><br><span class="line">//output: [&lt;tf.Tensor....&gt;,&lt;...&gt;,&lt;...&gt;] 没有执行会话，所以不会输出值，而是输出abc的类型</span><br></pre></td></tr></table></figure><h4 id="2-求解"><a href="#2-求解" class="headerlink" title="2.求解"></a>2.求解</h4><h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><p>Tensor具有eval，get_shape等成员方法</p><h4 id="4-操作"><a href="#4-操作" class="headerlink" title="4.操作"></a>4.操作</h4><p>TF为Tensor提供了abs,add,reduce_mean等大量操作</p><h4 id="5-典型用例"><a href="#5-典型用例" class="headerlink" title="5.典型用例"></a>5.典型用例</h4><p>见书p44</p><h3 id="3-2-2-稀疏张量：SparseTensor"><a href="#3-2-2-稀疏张量：SparseTensor" class="headerlink" title="3.2.2 稀疏张量：SparseTensor"></a>3.2.2 稀疏张量：SparseTensor</h3><p>TF提供了专门用于处理高维稀疏数据的SparseTensor类。该类以键值对的形式表示高维稀疏数据，包含indices、values和dense_shape三个属性。</p><h4 id="1-创建-1"><a href="#1-创建-1" class="headerlink" title="1.创建"></a>1.创建</h4><p>在TF中创建稀疏张量时，一般可以直接用SparseTensor类的构造方法，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">sp = tf.SparseTensor(indices=[[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]], values=[<span class="number">1</span>,<span class="number">2</span>],dense_shape=[<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure></p><h4 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h4><p>TF为稀疏张量提供了一些专门的操作，方便用户处理。</p><h4 id="3-典型用例"><a href="#3-典型用例" class="headerlink" title="3.典型用例"></a>3.典型用例</h4><p>见书p46</p><h2 id="模型载体：操作"><a href="#模型载体：操作" class="headerlink" title="模型载体：操作"></a>模型载体：操作</h2><p>TF中每个节点均对应一个具体的操作。因此，操作是模型功能的实际载体，数据流图主要有以下三种节点：</p><ul><li>计算节点：对应的是无状态的计算或控制操作，主要负责算法逻辑表达式或流程控制</li><li>存储节点：对应的是有状态的变量操作，通常用来存储模型参数</li><li>数据节点：对应的是特殊的占位符操作，用于描述待输入数据的属性</li></ul><h3 id="3-3-1-计算节点：Operation"><a href="#3-3-1-计算节点：Operation" class="headerlink" title="3.3.1 计算节点：Operation"></a>3.3.1 计算节点：Operation</h3><p>Operation类定义在<code>tensorflow/python/framework/ops.py</code>文件中，提供了获取操作的名称、类型、输入张量、输出张量等基本属性的方法。</p><p>对于无状态节点，其输出有输入张量和节点操作共同决定</p><h3 id="3-3-2-存储节点：Variable"><a href="#3-3-2-存储节点：Variable" class="headerlink" title="3.3.2 存储节点：Variable"></a>3.3.2 存储节点：Variable</h3><p>存储节点作为数据流图中的有状态节点，其主要作用是在多次执行相同数据流图时存储特定的参数，如深度学习或机器学习的模型参数。</p><p>对于有状态的节点，其输出除了跟输入张量和节点操作有关之外，还会受到节点内部保存的状态值的影响。</p><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h4><p>TF中的存储节点抽象是Variable类</p><h4 id="2-变量操作"><a href="#2-变量操作" class="headerlink" title="2.变量操作"></a>2.变量操作</h4><p>每个变量对应的变量操作对象在变量初始化时构造，变量支持两种初始化方式：</p><ul><li>初始值。根据用户输入或采用缺省值初始化</li><li>VariableDef。使用Protocol Buffers定义的变量完成初始化</li></ul><h4 id="3-read节点"><a href="#3-read节点" class="headerlink" title="3.read节点"></a>3.read节点</h4><p>通过解释read节点的实现原理，加深对于变量、变量操作和变量值的理解。</p><h3 id="3-3-3-数据节点：Placeholder"><a href="#3-3-3-数据节点：Placeholder" class="headerlink" title="3.3.3 数据节点：Placeholder"></a>3.3.3 数据节点：Placeholder</h3><p>数据流图本身是一个具有计算拓扑和内部结构的“壳”。在用户向数据流图填充数据前，图中并没有真正执行任何计算。当数据流图执行时，TF会向数据节点填充（feed）用户提供的、复合定义的数据。</p><p>TF的数据节点有占位符操作（placeholder Operation）实现，其对应的操作函数是<code>tf.placeholder</code>。针对稀疏数据，TensorFlow也提供了稀疏占位符操作（sparse placeholder operatin），其操作函数是<code>tf.sparse_placeholde</code>。</p><h2 id="3-4-运行环境：会话"><a href="#3-4-运行环境：会话" class="headerlink" title="3.4 运行环境：会话"></a>3.4 运行环境：会话</h2>]]></content>
      
      
      <categories>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>报错module &#39;tensorflow&#39; has no attribute &#39;FIFOQueue&#39;</title>
      <link href="/z_post/TensorFlow-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-no_attribute_FIFOQueue/"/>
      <url>/z_post/TensorFlow-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-no_attribute_FIFOQueue/</url>
      
        <content type="html"><![CDATA[<p>报错原因可能是因为当前路径下存在有与tensorlfow官方库相冲突的文件名，解决办法有2个。</p><h1 id="1、更改掉有冲突性质的名字"><a href="#1、更改掉有冲突性质的名字" class="headerlink" title="1、更改掉有冲突性质的名字"></a>1、更改掉有冲突性质的名字</h1><p>这里如果你回忆一下在创建了哪个文件以后产生报错，然后将那个文件的名字更改一下就行了。<br>以我自己为例，我这里创建了一个queue.py的文件，然后运行时就报这个错误了，并且不只是这个文件，在当前路径下的其他py文件也不能正常运行，但是如果换一个文件夹路径，运行其他文件夹下的py文件是没有问题的。<br>所以这里我把queue.py改名成了q.py（其他名字也行），然后在运行，就不会报错了</p><h1 id="2、tensorlfow本身问题"><a href="#2、tensorlfow本身问题" class="headerlink" title="2、tensorlfow本身问题"></a>2、tensorlfow本身问题</h1><p>如果你不管在什么路径下运行任何还有tensorflow代码的文件，都会报错的话，建议使用指令重装TF：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 uninstall tensorflow-gpu#卸载</span><br><span class="line"></span><br><span class="line">pip3 install --upgrade tensorflow-gpu #安装</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>StackGAN---ICCV2017</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-StackGAN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-StackGAN/</url>
      
        <content type="html"><![CDATA[<p>本篇论文解读的排版主要参见原文的格式，针对原文中的每一个小节进行展开，有的是对原文的一个提炼和简单概括，有的是对原文中没有详细介绍的技术的补充和说明。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>&emsp;&emsp;要想从给定的文字描述中生成一幅高质量的图片，是一件十分具有挑战性的事情。而现有的方法（截止至2017年）生成的图片，虽然可以表现出文字中的一些关键信息，但是它们都缺少了很多局部细节。这篇文章提出了一个“堆叠式的生成式对抗神经网络——Stacked Generative Adversarial Networks（StackGAN）”。它可以在根据给定的文本信息，生成像素为256×256的高质量图片。具体的做法是利用“分治”的思想，将一个复杂的问题分解成更易解决的多个小问题。这篇文章将生成图片的过程分为了2个阶段：</p><ul><li>Stage-1：根据给定的文本信息，生成64×64大小的图片草图，着重于描绘图片中主要目标的轮廓和颜色</li><li>Stage-2：结合64×64的图片草图和文本信息，生成256×256的更高质量的图片，这个过程不仅修正了第一阶段中的错误信息，同时还反映了的图片中更多的细节。</li></ul><p>&emsp;&emsp;另外，为了提高训练时的稳定性和生成图片的多样性，本文还提出了一种新颖的“条件数据增强技术”，可以确保训练过程的平缓（ <strong>不懂</strong> ）</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;作者简要介绍了有关“图像生成”和“GAN”的研究现状和存在的困难，然后阐述了本文的3点主要贡献：</p><ul><li>提出了一个“堆叠式的生成式对抗神经网络——StackGAN”。该网络是<strong>第一个</strong>能够生成256×256图片大小的神经网络模型</li><li>提出了一个新颖的“条件数据增强技术”。以此来稳定网络训练过程，同时提高了生成图片的多样性</li><li>大量的实验和高质量的实验结果表明本文设计的模型框架是有效的，这对以后的研究和发展具有一定的帮助作用</li></ul><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><ul><li>VAE</li><li>PixelRNN</li><li>energy-based GAN</li><li>$S^2$-GAN</li><li>…</li></ul><h1 id="堆叠的生成式对抗神经网络——StackGAN"><a href="#堆叠的生成式对抗神经网络——StackGAN" class="headerlink" title="堆叠的生成式对抗神经网络——StackGAN"></a>堆叠的生成式对抗神经网络——StackGAN</h1><p>&emsp;&emsp;为了生成高质量的图片，本文提出了一个简单但是十分有效的网络模型，它将生成过程分成了两个阶段：</p><ul><li>Stage-1：根据给定的文本信息，生成64×64大小的图片草图，着重于描绘图片中主要目标的轮廓和颜色</li><li>Stage-2：结合64×64的图片草图和文本信息，生成256×256的更高质量的图片，这个过程不仅修正了第一阶段中的错误信息，同时还反映了的图片中更多的细节。</li></ul><h2 id="正文之前——Preliminaries"><a href="#正文之前——Preliminaries" class="headerlink" title="正文之前——Preliminaries"></a>正文之前——Preliminaries</h2><p>&emsp;&emsp;作者在这里简单介绍了GAN和Conditional GAN的核心原理。</p><ul><li>GAN：由两个“子模型”组成，这两个“子模型”不断交替训练，它们的训练目标恰好相反，仿佛实在彼此对抗一般。生成模型G的目标是习得能够代表真实数据分布 $p_{data}$ 的生成概率分布 $p_g$ ，而分辨模型D的目标则是要习得能够准确分辨出 $p_{data}$ 和 $p_g$ 的二分类器。它们之间的关系就像是一场“two-player min-max game”一样，其目标方程可以如下表示：</li></ul><script type="math/tex; mode=display">\min_G \max_D V(D,G) =  E_{x\sim p_{data}}[logD(x)] + E_{z\sim p_z}[log(1-D(G(z)))]</script><ul><li>Conditional GAN：是GAN的一种扩展，它令生成器和分辨器均接受一个条件向量 $c$ ，分别写成 $G(z,c)$ 和 $D(x,c)$ ，如此一来，生成器就可以根据不同的条件 $c$ 来限定生成的图片。（ $c$ 通常为图片标签或者图片描述）</li></ul><h2 id="条件增强技术——Conditioning-Augmentation"><a href="#条件增强技术——Conditioning-Augmentation" class="headerlink" title="条件增强技术——Conditioning Augmentation"></a>条件增强技术——Conditioning Augmentation</h2><p>&emsp;&emsp;如图1所示，文本描述信息 $t$ 首先会通过一个编码器进行编码，生成一个text embedding: $\phi_t$  。 在之前的工作中，会将text embedding非线性的传送到生成器当中去。但是，由于text embedding通常维度很高（100以上），所以当我们的数据十分有限时，text embedding表现出不连续，稀疏等特点，这对训练生成器来说是不利的。为了缓和这个问题，本文不再将text embedding直接送入的生成器中进行训练，而是随机的从一个独立高斯分布 $N(\mu(\phi_t), \Sigma(\phi_t))$ 当中进行采样，生成新的变量 $\hat{c}$ 。利用该技术，可以从一小部分数据中生成更多的训练数据（pairs）。</p><p>&emsp;&emsp;另外，为了更进一步的增强训练时的平滑性，同时为了抑制过拟合，本文还在目标函数中增加了下面的正则惩罚项(KL离散度——KL divergence)：</p><script type="math/tex; mode=display">D_{KL}(N(\mu(\phi_t), \Sigma(\phi_t)) || N(0,I))</script><p>（引入随机性变量 $\hat z$ 的原因，可以考虑是因为同样的特别描述往往可以对应到不同的图片）</p><h2 id="Stage-1-GAN"><a href="#Stage-1-GAN" class="headerlink" title="Stage-1 GAN"></a>Stage-1 GAN</h2><p>&emsp;&emsp;通过预训练好的编码器对给定的图片描述进行编码，生成text embedding: $\phi_t$ 。利用Conditioning Augmentation技术根据 $\phi_t$ 对 $N(\mu_0(\phi_t),\Sigma_0(\phi_t))$ 采样得到 $\hat c_0$ 。 最后，利用 $\hat c_0$ 和随机向量 $z$ 进行第一阶段的生成，得到 $G(z,\hat c_0)$ 。 在Stage-1的训练阶段，模型通过交替训练以下2个目标函数来分别优化生成器和分辨器：</p><ul><li>生成器， $min(L_{G_0})$ ：<script type="math/tex; mode=display">L_{G_0} = E_{z\sim p_z,t\sim p_{data}}[log\bigl(1-D_0(G_0(z,\hat c_0), \phi_t)\bigr)] + \lambda D_{KL}\bigl( N(\mu_0 (\phi_t), \Sigma_0(\phi_t)) || N(0,I_0) \bigr)</script></li><li>分辨器， $max(L_{D_0})$ ， $D(I,\phi_t)$ 代表图片 $I$ 在 $\phi_t$ 条件下是真实图片的概率：<script type="math/tex; mode=display">L_{D_0} =E_{(I_0,t)\sim p_{data}} [logD_0(I_0,\phi_t)] + E_{z\sim p_z,t\sim p_{data}}[log \bigl(1-D_0(G_0(z,\hat c_0), \phi_t) \bigr)]</script></li></ul><p>上面公式中：</p><ul><li>$I_0$ ：来自真实分布 $p_{data}$ 的图片</li><li>$t$ ：来自真实分布 $p_{data}$ 的图片描述</li><li>$\phi_t$ ：t经过预训练好的编码器编码后得到的text embedding</li><li>$z$ ：噪声，从 $p_z$ 分布中随机采样而来（本文用的是高斯分布）</li><li>$\lambda$ ：惩罚项的权重，本文采用 $\lambda = 1$</li><li>$N(\mu_0 (\phi_t), \Sigma_0(\phi_t))$ ：用于生成 $\hat c_0$ 的高斯分布，其期望值和方差都是通过神经网络学习出来的</li></ul><p><strong>模型架构</strong> ：</p><p>&emsp;&emsp;对于生成器 $G_0$ 来说，要想得到文本条件变量 $\hat c_0$ ，首先要将text embedding $\phi_t$ 送到一个全连接层中以此来生成 $\mu_0$ 和 $\sigma_0$ （ $\sigma_0$ 是 $\Sigma_0$ 对角线上的值），得到高斯分布 $N(\mu(\phi_t),\Sigma(\phi_t))$ 。然后从高斯分布中采样得到文本条件变量 $\hat c_0 = \mu_0 + \sigma_0 \cdot \epsilon$ ， $\hat c_0$ 的维度为 $N_g$ 。 这里，“ $\cdot$ ”代表点乘，$\epsilon \sim N(0,I)$ 。之后，将 $\hat c_0$ 和噪声向量 $z$ 连接起来，它们经过一些列“升维块”（upsampling block）之后，会生成大小为 $W_0 \times H_0$ 的图片。</p><p>&emsp;&emsp;对与分辨器 $D_0$ 来说，首先利用全连接层将 $\phi_t$ 压缩到 $N_d$ 维，然后，将其在空间上进行复制，形成一个 $M_d \times M_d \times N_d$ 的张量。  同时，将图片送到一系列“降维块”（downsampling block）中，使其具有 $M_d \times M_d \times N_{filter}$ 的空间结构，然后将图片的tensor和文本的tensor<br>沿着channel的维度连接的一起，然后将其送到 $1 \times 1$ 的卷积层当中，联合学习图片和文本之间的关系特征。最后，将特征传送到输出为一个节点的全连接层，得到当前图片与文本属于真实数据的概率。</p><h2 id="Stage-2-GAN"><a href="#Stage-2-GAN" class="headerlink" title="Stage-2 GAN"></a>Stage-2 GAN</h2><p>&emsp;&emsp;从Stage-1 GAN中得到的低分辨率图像通常会缺少一些局部细节，有时候还会造成主要目标物不同程度的形变。另一方面，有些存在于文本中的重要信息，也可能被忽视。  因此，本文的Stage-2 GAN在Stage-1的基础上进行构建。它将Stage-1返回的低分辨率图片和图片描述的text embedding作为GAN的条件，使之返回的结果不仅能修正Stage-1中的错误信息，同时还可以补充在Stage-1中没有捕捉到的信息。</p><p>&emsp;&emsp;当选取Stage-1低分辨率结果 $s_0 = G_0(z,\hat c_0)$ 和 高斯变量 $\hat c$ 作为GAN的条件时，生成器和分辨器的目标函数如下所示：</p><ul><li>生成器， $min(L_G)$ ：<script type="math/tex; mode=display">L_G = E_{z\sim p_z,t\sim p_{data}}[log\bigl(1-D(G(s_0,\hat c), \phi_t)\bigr)] + \lambda D_{KL}\bigl( N(\mu (\phi_t), \Sigma(\phi_t)) || N(0,I) \bigr)</script></li><li>分辨器， $max(L_D)$ ， $D(I,\phi_t)$ 代表图片 $I$ 在 $\phi_t$ 条件下是真实图片的概率：<script type="math/tex; mode=display">L_D =E_{(I,t)\sim p_{data}} [logD(I,\phi_t)] + E_{z\sim p_z,t\sim p_{data}}[log \bigl(1-D(G(s_0,\hat c), \phi_t) \bigr)]</script></li></ul><p>&emsp;&emsp;与第一阶段的GAN不同的是，在Stage-2中，本文提出了一个假设，那就是作为Stage-1条件之一的随机变量 $z$ ，可以确保Stage-1的生成结果具有多样性。在这样的假设下，本文在Stage-2阶段并不使用 $z$ 作为条件，而是采用Stage-1的生成结果 $s_0$ 作为条件。 高斯条件变量 $\hat c$ 和 $\hat c_0$ 分别作为Stage-2和Stage-1阶段的CA（Contioning Augmentation），它们共享同一个text embedding—— $\phi_t$ ， $\phi_t$ 由同一个预训练的编码器生成。 但是，Stage-1和Stage-2的CA会通过不同的全连接层，因此，它们生成的关于 $\phi_t$ 的均值和方差不同。 通过这种方式，Stage-2可以学习到被Stage-1所忽略的一些有用的信息。</p><p>  <strong>模型架构</strong>：</p><p>&emsp;&emsp;对于生成器，本文利用残差模块（residual blocks）将Stage-2的生成器设计成一个“编码-解码网络”（encoder-decoder network）。 首先，根据给定的text embedding $\phi_t$ 生成维度为 $N_g$ 的文本条件向量 $\hat c$ ，然后对其进行复制，使之形成形状为 $M_g \times M_g \times N_g$ 的张量。 同时，将Stage-1的结果 $s_0$ 送到若干个“降维模块”（downsampling block）中，直至其size变为 $M_g \times M_t$ 为止。然后将文本特征和图片特征沿着channels连接到一起，并将其送到若干个“残差模块”中去，目的是为了学习到图片和文本交织在一起的多模态表征。最终，通过一系列的“升维模块”（upsampling block），也就是解码器（decoder），生成size为 $W \times H$ 的高分辨率图片。</p><p>&emsp;&emsp;对于分辨器，它的结构与Stage-1中的结构相似，只不过由于接受的图片size变大了，所以需要更多的“降维模块”（downsampling block）。为了让分辨器更好的学到图片和文本之间的联系，本文采用了matching-aware discriminator，而非vanilla discriminator，具体可以参考才论文中的参考文献部分。 在训练阶段，正反例构成如下：</p><ul><li>正例：真实的图片和与之对应的文本描述</li><li>反例：1、真实的图片和不相匹配的文本描述&emsp; 2、生成器生成的图片和与之对应的文本描述</li></ul><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>&emsp;&emsp;“升维模块”由 $3 \times 3 stride 1$ 的卷积层后接最近邻upsampling组成。除了最后的卷积层外，其他卷积层都使用了Batch Normalization和ReLU激活函数。 “残差模块”由 $3 \times 3 stride 1$ 的卷积层、Batch Normalization和ReLU激活函数组成。 在 $128 \times 128$ 的StackGAN模型中，使用了2个“残差模块”，而在 $256 \times 256$ 的StackGAN模型中，使用了4个“残差模块”。 “降维模块”由 $4 \times 4 stride 2$ 的卷积层、Batch Normalization（除第一层）和LeakyReLU组成。<br>&emsp;&emsp;默认情况下，$N_g = 128$ , $N_z = 100$, $M_g = 16$, $M_d = 4$, $N_d = 128$, $W_0 = H_0 = 64$ , $W = H = 256$ 。在训练时，首先固定Stage-2 ，同时迭代训练Stage-1 GAN的 $D_0$ 和 $G_0$ 600 epochs。然后再固定Stage-1 ，同时迭代训练Stage-2 GAN的 $G$ 和 $D$ 600epochs。所有的网络训练时都使用ADAM优化算法，batch size为64,初始的学习率为0.0002 ，学习率每经过100epochs都会衰减成原来值的一半。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>&emsp;&emsp;为了验证上面提出的模型和方法的有效性，本文进行了大量的高质量实验。本文采用的对照方法是目前（2017）最有效的两个图片生成方法：GAN-INT-CLS和GAWWN 。 测试这两个方法时使用的代码来自于各自的作者。 除此以外，文本还设计了多个baseline models来验证模型整体的设计和每个部分对模型的重要程度。对于第一个baseline，本文直接训练Stage-1 GAN来生成64×64和256×256大小的图片，来探究本文提出的stack结构和CA技术是否对最终结果有帮助。然后修改本文的StackGAN，令其分别生成128×128和256×256大小的图片，来验证在生成更大的图片时，本文的模型是否可以生成取得更好的图片质量。另外，我们还验证了是否有必要在每个Stage都将图片描述作为约束条件之一。</p><h2 id="数据集和评价标准"><a href="#数据集和评价标准" class="headerlink" title="数据集和评价标准"></a>数据集和评价标准</h2><p>&emsp;&emsp;CUB数据集包含200种鸟类，共11788张图片。由于该数据集中80%的鸟的大小与图片大小的比例小于0.5,因此我们需要对其进行剪裁预处理，确保所有的图片中鸟占总大小的比例在0.75以上。Oxford-102数据集包含102种花类，共8189张图片。为了证实本文方法的有效性，同时还对一个更具挑战性的数据集——MS COCO数据集进行了实验， MS COCO数据集中的图片具有不同的背景，同时每张图片会有多个不同的物体， 它具有80k张图片作为训练集，40k张图片作为作为验证集。 COCO中的每张图片具有5条描述，CUB和Oxford-102中的每张图片具有10条描述。</p><p>&emsp;&emsp; <strong>评价标准：</strong> 目前，关于图片生成还没有很适合的权威的评价标准，在这里，本文采用的是最近比较流行的“inception score”来对生成图片的质量进行评价，公式如下：</p><script type="math/tex; mode=display">I = exp(E_x D_{KL}( p(y|x) || p(y)))</script><p>其中， $x$ 代表生成的图片， $y$ 代表Inception model预测的图片标签。该评价公式背后包含的隐层含义是： <strong>好的模型应该能生成多种多样并且有意义的图片</strong> 。因此，边缘分布 $p(y)$ 和条件分布 $p(y|x)$ 之间的KL散度应该越大越好。对于MC COCO数据集，本文直接使用预训练好的模型进行评价，而对于CUB和Oxfor-102数据集，本文先对其进行fine-tune迁移学习，训练出不同的模型，然后，再分别进行评价。评价时，对每个模型都需要大量的样本参与（随机挑选30k以上个生成模型产生的样本）。  </p><p>&emsp;&emsp;尽管inception score可以表现出类似于人的对“高质量图片”的感知能力，但是它却不能准确反应出生成的图片和图片描述信息之间的相关联系。因此，本文还进行人工评价。本文随机选取了CUB和Oxfor-102测试集中的50条图片描述信息，从MS COCO测试集中随机选取了4k条图片描述。 对于每条描述信息，对应的生成模型都会产生5张图片， 然后让10个用户通过不同的方法对这些图片进行排序。最后用平均排序结果作为最终的人工评价。</p><h2 id="定性-定量结果——Quantitative-and-qualitative-results"><a href="#定性-定量结果——Quantitative-and-qualitative-results" class="headerlink" title="定性/定量结果——Quantitative and qualitative results"></a>定性/定量结果——Quantitative and qualitative results</h2><p>&emsp;&emsp;本文在3个数据集上与现有的两种stage of art方法进行比较，inception scores和平均人工排序结果如下表所示。可以看出，本文的Stack GAN方法在三个数据集上全都取得了最好的结果。</p><p>&emsp;&emsp;从下面的图中，也可以看出本文提出的方法，可以生成更加生动的图片，同时生成的图片也具有多样性，而非单纯的“记忆”了训练集中的数据。</p><h2 id="成分分析——Component-analysis"><a href="#成分分析——Component-analysis" class="headerlink" title="成分分析——Component analysis"></a>成分分析——Component analysis</h2><p>&emsp;&emsp;在本小节中，我们会利用baseline mdoels来分析StackGAN每个成分的作用。下表展示了不同baseline models的inception socres</p><p><strong>StackGAN的设计：</strong> 如表中前四行所示，如果令Stage-1 GAN直接生成256×256的图片，inception scores会大大下降，并且在不使用CA的情况下，甚至无法生成合理的具有含义的图片。即使在使用CA的情况下可以生成含有一定意义的图片，它的图片质量也远不如Stack GAN生成的图片质量，详情如下图所示。这说明了本文提出了Stack结构是有效的。</p><p>另外，当把生成图片的分辨率降到128×128以后，inception socres的值从3.70降到了3.35。需要注意的是，inception model接受的图片大小为299×299,所以它在计算inception scores之前，会先将所有输入图片放缩到规定大小后再送入网络进行计算。因此，如果本文的模型仅仅是将128×128的图片放大到256×256，那么，最终计算出的inception scores就不会产生差异（多个线性放缩的叠加会退化成一个放缩计算），这就说明了本文的模型在生成256×256的图片时，相较于128×128的图片，确确实实生成了更多有效的信息。对于256×256的Stack GAN来说，如果仅仅只在Stage-1使用图片描述作为约束条件，inception scores的值会从3.70降到3.45，这说明将Stage-2阶段确实可以捕捉到Stage-1所忽略的文本信息，从而有助于生成高质量的图片。</p><p><strong>条件增强——Conditioning Augmentation：</strong> 本文同时还探究了CA技术的有效性，在不使用CA技术时，inception scores的值明显下降，并且，在训练时还容易崩溃，导致生成的图片难以识别。而在使用CA时，不仅能提成inception scores的值，还能生成更加多样的鸟（如姿态、脸的朝向等）。</p><p><strong>语句嵌入插值——Sentence embedding interpolation：</strong> 为了更进一步的证明我们的模型可以学习到更加光滑的潜在的数据信息，本文通过对text embedding线性插值的方式来进行验证。首先固定住噪声变量 $z$ ，这样一来生成的图片仅受图片text embedding约束的影响。下图中第一行的图片使用的text embedding是由我们自己可以制作的句子生成的，这些句子仅仅包含一些简单的颜色描述。结果显示，生成的图片可以根据不同的text embedding生成与之对应的鸟，可以反映出text embedding中描述的颜色，同时还能保持合理的外形。第二行展示了一些更加复杂句子生成的图片，这些句子包含更多的描述信息，用这些句子生成的图片中的鸟，它们的主要颜色会从红色慢慢变成蓝色，而翅膀的颜色会从黑色慢慢的变成棕色。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;在本篇文章中，作者提出了一个Stack GAN模型框架，同时结合CA技术，来生成具有照片真实度的图片。 该模型将text-to-image synthesis任务变成了一个“草图——细化”的过程。 Stage-1 GAN主要负责输出图片的“草图”，它侧重于输出图片的基本颜色搭配和主要目标的轮廓信息。 Stage-2 会修正Stage-1中的一些错误，同时很会再次根据图片描述来补充Stage-1中遗漏的信息，从而生成更高质量的图片。 大量的实验表明，本文提出的方法是有效的。 同时，与现有的最领先的方法进行比较后，本文的模型可以生成更高分辨率的图片，同时包含更多的信息和细节。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文解读 </tag>
            
            <tag> 图片生成 image generation </tag>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Linux命令行与shell脚本编程大全》</title>
      <link href="/z_post/Linux-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8/"/>
      <url>/z_post/Linux-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《深度学习与计算机视觉》</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>numpy和tensorflow中的关于参数axis的辅助理解方法</title>
      <link href="/z_post/Python-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-numpy%E5%92%8Ctensorflow%E4%B8%AD%E7%9A%84%E5%85%B3%E4%BA%8E%E5%8F%82%E6%95%B0axis%E7%9A%84%E8%BE%85%E5%8A%A9%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95/"/>
      <url>/z_post/Python-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-numpy%E5%92%8Ctensorflow%E4%B8%AD%E7%9A%84%E5%85%B3%E4%BA%8E%E5%8F%82%E6%95%B0axis%E7%9A%84%E8%BE%85%E5%8A%A9%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>一句话总结：固定除axis之外的其他维度，在axis指定的维度上进行函数操作，轴的计数按shape的形状从左往右为0轴，1轴，2轴…（详解请看下面的推导）</strong></p><p><strong>首先声明：axis的默认值不是0</strong>，这一点我发现很多博客文章都搞错了。所以一定要知道，<strong>axis的默认值不是0，0代表0轴，而默认值是将整个shape拉伸成一个一维向量，在整个向量上求解过</strong></p><h1 id="axis的默认值不是0"><a href="#axis的默认值不是0" class="headerlink" title="axis的默认值不是0"></a>axis的默认值不是0</h1><p>当给axis赋值为0时，和采取默认值时的表现是完全不同的，从下面的代码就可以看出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; z #大小为2×3×4的数组</span><br><span class="line">array([[[ 2,  3,  4,  8],</span><br><span class="line">        [ 3,  1,  4,  1],</span><br><span class="line">        [ 6,  3,  2,  6]],</span><br><span class="line"></span><br><span class="line">       [[10,  2, 45,  2],</span><br><span class="line">        [ 2,  4,  5, 10],</span><br><span class="line">        [22,  4,  4,  1]]])</span><br><span class="line">&gt;&gt;&gt; np.sum(z,axis=0)  # axis=0</span><br><span class="line">array([[12,  5, 49, 10],</span><br><span class="line">       [ 5,  5,  9, 11],</span><br><span class="line">       [28,  7,  6,  7]])</span><br><span class="line">&gt;&gt;&gt; np.sum(z)   #axis不指定，取默认值</span><br><span class="line">154</span><br></pre></td></tr></table></figure><h1 id="理解axis参数的作用"><a href="#理解axis参数的作用" class="headerlink" title="理解axis参数的作用"></a>理解axis参数的作用</h1><p>刚开始学习numpy和tensorflow的朋友经常遇到类似下面这样的一些函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#python</span><br><span class="line">x=[[1,2],[5,1]]</span><br><span class="line">x=np.array(x)</span><br><span class="line">z1=np.max(x,axis=0)</span><br><span class="line">z2=np.max(x,axis=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#tensorflow</span><br><span class="line">x=tf.constant([[1.,2.],[5.,2.]])  </span><br><span class="line">x=tf.shape(x)  </span><br><span class="line">z1=tf.reduce_max(x,axis=0)#沿axis=0操作  </span><br><span class="line">z2=tf.reduce_max(x,axis=1)#沿axis=1操作</span><br></pre></td></tr></table></figure><p>类似的还有argmax，sum等等函数，它们都含有一个名为axis的参数，那这个参数到底是什么意思呢？一句话总结就是：<strong>沿着axis指定的轴进行相应的函数操作</strong></p><p>直接看这句话可能看不懂，下面用一个最简单的例子来说明一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#首先，创建一个2×3维的numpy的array数组</span><br><span class="line">x=[[2,3,4],[1,2,5]]</span><br><span class="line">x=np.array(x)</span><br><span class="line">#然后，计算不同参数下np.max的输出</span><br><span class="line"></span><br><span class="line">print(np.max(x))</span><br><span class="line"># 5</span><br><span class="line">print(np.max(x,0))</span><br><span class="line"># [2,3,5]</span><br><span class="line">print(np.max(x,1))</span><br><span class="line"># [4,5]</span><br></pre></td></tr></table></figure><p>可以看到，如果不知道axis，那么默认就是取得整个数组的最大值，这相当于把多维数组展开成一维，然后找到这个一维数组里的最大值。<br>而当axis=0时，直观上来看就是取得每一列的最大值，源数组总共为2行3列，所以最终的输出包含3个元素。<br>当axis=1时，就相当与是取每一行的最大值。</p><p>上面的理解方式在二维数组还比较直观，但是如果数组达到3维4维甚至更高维时，就不能简单的从行列角度出发去理解了，这时应该考虑从“轴”的角度来看。首先，明确一点，“轴”是从外向里的，也就是说，最外层的是0轴，往内一次是1轴，2轴… 。 具体可以看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; z</span><br><span class="line">array([[[ 2,  3,  4,  8],</span><br><span class="line">        [ 3,  1,  4,  1],</span><br><span class="line">        [ 6,  3,  2,  6]],</span><br><span class="line"></span><br><span class="line">       [[10,  2, 45,  2],</span><br><span class="line">        [ 2,  4,  5, 10],</span><br><span class="line">        [22,  4,  4,  1]]])</span><br><span class="line">&gt;&gt;&gt; z.shape</span><br><span class="line">(2, 3, 4)</span><br></pre></td></tr></table></figure><p>可以看到，这是一个2×3×4的三位数组，其中0轴对应第一维（2），1轴对应第二维（3），2轴对应第三维（4）。当我们指定了函数按某一轴来计算时，函数的输出数组的shape就是去掉当前轴的shape，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; np.max(z,axis=0).shape</span><br><span class="line">(3, 4)</span><br><span class="line">&gt;&gt;&gt; np.max(z,axis=1).shape</span><br><span class="line">(2, 4)</span><br><span class="line">&gt;&gt;&gt; np.max(z,axis=2).shape</span><br><span class="line">(2, 3)</span><br></pre></td></tr></table></figure><p>而对于输出数组的每一个元素<code>output[i][j]</code>的值，实际上就是<code>z[i][...][j]</code>集合中的最大值，如下面的代码所示。其中当axis=0时，输出数组output的shape为3×4，其中<code>output.[2][3]</code>的值，实际上就是<code>z[0][2][3],z[1][2][3]</code>的最大值，也就是（6，1）中的最大值，即为<code>output.[2][3]=6</code>。</p><p>再如axis=1时，输出数组output的shape为2×4，其中<code>output.[1][2]</code>的值，实际上就<code>是z[1][0][2],z[1][1][2],z[1][2][2]</code>中的最大值，也就是（45，5，4）中的最大值，即为<code>output.[1][2]=45]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; np.max(z,axis=0)</span><br><span class="line">array([[10,  3, 45,  8],</span><br><span class="line">       [ 3,  4,  5, 10],</span><br><span class="line">       [22,  4,  4,  6]])</span><br><span class="line">&gt;&gt;&gt; np.max(z,axis=1)</span><br><span class="line">array([[ 6,  3,  4,  8],</span><br><span class="line">       [22,  4, 45, 10]])</span><br><span class="line">&gt;&gt;&gt; np.max(z,axis=2)</span><br><span class="line">array([[ 8,  4,  6],</span><br><span class="line">       [45, 10, 22]])</span><br></pre></td></tr></table></figure><h1 id="数学公式总结"><a href="#数学公式总结" class="headerlink" title="数学公式总结"></a>数学公式总结</h1><p>用形式化的数学语言总结上面的过程就是：<br>对于大小为[i,j,k]的输入数组z，假设axis=0，那么输出矩阵output的大小就为[j,k]，并且output的每一个元素的计算方式如下：</p><script type="math/tex; mode=display">x^{y^z}=(1+{\rm e}^x)^{-2xy^w}</script><script type="math/tex; mode=display">output[j,k]=\max_{i}(z[i,j,k])</script><p>如果axis=1，那么输出矩阵output的大小就为[i,k]，并且output的每一个元素的计算方式如下：</p><script type="math/tex; mode=display">output[i,k]=\max_{j}(z[i,j,k])</script><p>对于4维，5维甚至无限维的情况，计算方法是一样的，你不妨自己推导一下，如果有任何问题，欢迎可以在评论中留言。</p><p>另外，对于其他的sum，argmax等等函数中的计算方法也是一样的，只需要把函数max换成对应的函数即可，如下所示：</p><p>sum：</p><script type="math/tex; mode=display">output[j,k]=\sum_{i}(z[i,j,k])</script><p>argmax:</p><script type="math/tex; mode=display">output[j,k]=argmax_{i}(z[i,j,k])</script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Github源码：DenseCap</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-DenseCap%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-DenseCap%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本篇博文是对论文DenseCap的源码实现，作者是斯坦福的Justin Johnson<br>项目地址：<a href="https://cs.stanford.edu/people/karpathy/densecap/" target="_blank" rel="noopener">https://cs.stanford.edu/people/karpathy/densecap/</a><br>源码地址：<a href="https://github.com/jcjohnson/densecap" target="_blank" rel="noopener">https://github.com/jcjohnson/densecap</a><br>论文地址：<a href="http://arxiv.org/abs/1511.07571" target="_blank" rel="noopener">http://arxiv.org/abs/1511.07571</a></p><p>注意事项：源码是15年写的，所以使用的是比较老版本的cuda和cudnn（8.0  v5.1），并且作者也没有在继续更新代码了，所以如果你想成功运行起来的话，尽量不要用太高版本的cuda，否则可能会出现文件丢失错误（libcudnn (R5) not found in library path.）</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装以下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$luarocks install torch</span><br><span class="line">$luarocks install nn</span><br><span class="line">$luarocks install image</span><br><span class="line">$luarocks install lua-cjson</span><br><span class="line">$luarocks install https://raw.githubusercontent.com/qassemoquab/stnbhwd/master/stnbhwd-scm-1$.rockspec</span><br><span class="line">$luarocks install https://raw.githubusercontent.com/jcjohnson/torch-rnn/master/torch-rnn-scm-1.rockspec</span><br></pre></td></tr></table></figure><p>（可选）安装GPU相关依赖（如果你不使用GPU跑代码，可以不装这里）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$luarocks install cutorch</span><br><span class="line">$luarocks install cunn</span><br><span class="line">$luarocks install cudnn</span><br></pre></td></tr></table></figure><h1 id="下载预训练模型"><a href="#下载预训练模型" class="headerlink" title="下载预训练模型"></a>下载预训练模型</h1><p>在命令行中键入下面的指令，运行脚本下载预训练模型（注意，下面的脚本文件在github上的项目代码里，所以你要先把github上的源代码下载下来，然后进入到项目目录里面）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sh scripts/download_pretrained_model.sh</span><br></pre></td></tr></table></figure></p><h1 id="用图片来测试模型"><a href="#用图片来测试模型" class="headerlink" title="用图片来测试模型"></a>用图片来测试模型</h1><p>源码中自带了一张大象的图片，你可以用下面的指令来对大象图片进行测试，如果你想测试自己的图片，把图片放到项目中的<code>imgs</code>文件里，然后修改指令后面的图片名称为你自己图片的名称就可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$th run_model.lua -input_image imgs/elephant.jpg</span><br></pre></td></tr></table></figure></p><p>如果你没有GPU，记得要加上-gpu -1指令来告诉模型在cpu上指令（CPU上的指令速度较慢，我自己的执行情况是：GTX980Ti：0.3s   酷睿i5/7：5～10min）</p><p>以上指令会生成vis/data文件夹，这就是模型的运行结果，可以用下面的方式查看结果，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cd vis</span><br><span class="line">$python -m SimpleHTTPServer 8181（或者python -m http.server 8181)</span><br></pre></td></tr></table></figure><p>然后，在浏览器中打开<a href="http://localhost:8181/view_results.html" target="_blank" rel="noopener">http://localhost:8181/view_results.html</a>.</p><p>当然，如果你想一次运行数张图片，可以使用下面的指令，该指令会将指定路径下的图片全部执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$th run_model.lua -input_dir /path/to/my/image/folder</span><br></pre></td></tr></table></figure></p><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>我遇到了以下问题，这里列出我自己的解决方法，如果你还遇到了其他不同的问题，可以留言，我会尽快答复你</p><p>问题1：cutorch问题<br>提示找不到cutorch，或者其他什么相关的错误</p><p>解决办法：重新安装cutorch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$luarocks install cutorch</span><br></pre></td></tr></table></figure></p><p>不幸的是，这个解决方法对我并没有用，我最后发现是因为代码运行的cutorch版本是5.1，而由于此时我安装了高版本的cuda（9），所以在使用上面的指令安装时，安装的是cutorch 5.2，所以提示找不多5.1的cutorch，最后，我重新换回了的cuda8.0，并重新安装cutorch，解决了问题，切换cuda版本的方法可以看这里：<a href="https://blog.csdn.net/ksws0292756/article/details/80120561" target="_blank" rel="noopener">https://blog.csdn.net/ksws0292756/article/details/80120561</a></p><p>问题2：libcudd.5.so.5 找不到<br>主要原因还是cuda和cudnn的版本问题，我切换了cuda和cudnn的相关版本，换到cuda8.0和cudnn_v5.1以后， 解决了问题</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片描述 image captioning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FasterRCNN-NIPS2015</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-NIPS2015-FasterRCNN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-NIPS2015-FasterRCNN/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong><br><strong>作者:</strong></p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="Region-Proposals-Networks"><a href="#Region-Proposals-Networks" class="headerlink" title="Region Proposals Networks"></a>Region Proposals Networks</h2><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw9s61fiidj20nc0e579t.jpg" alt=""></p><p>原文中, 作者用ZF model为例对RPN网络进行讲解, ZF model的最后一层卷积层Conv5具有256个卷积核, 也就是说它生成的特征图谱的shape为 $W\times H\times 256$, RPN网络的第一层可以认为是一个卷积层, 卷积核的尺寸为 $n\times n$ (文中使用的是 3×3), 卷积核的个数为 256 (维持通道数不变). 利用该层的卷积层对Conv5的特征图谱操作, 最终生成的特征图谱大小仍然为 $W\times H\times 256$ (只不过此时,图谱中的每个点都会原图谱中的 $n\timesn$ 个点相关联). 对于这个图谱中的每个点, 我们认为它是一个anchor, 可以将它看做是一个元素个数为256的1维向量 (因为通道数为256).</p><p>然后, 对于每一个anchor, 都会分配 $k$ 个anchor boxes. 每个anchor box都要分前景后景, 也就是分是否包含物体, 同时, 每一个anchor box还要输出预测物体相对于anchor的偏移坐标量.</p><p>训练的时候会选择128个postive anchor boxes 和128个negative anchor boxes.</p><p><img src="https://wx2.sinaimg.cn/mw1024/d7b90c85ly1fw9tvpr5doj20xz0lk1kx.jpg" alt=""></p><p>实际上, RPN网络由两部分构成: 一个卷积层, 一对全连接层分别输出分类结果(cls layer)以及坐标回归结果(reg layer).</p><p>实现上: 利用了一个卷积核大小为 $n\times n$ 的卷积层, 后接两个 $1\times 1$ 的卷积层.(分别用于回归和分类)</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数:"></a>损失函数:</h2><script type="math/tex; mode=display">L(\{p_i\}, \{t_i\}) = \frac{1}{N_{cls}} \sum_i L_{cls}(p_i, p_i^* ) + \lambda \frac{1}{N_{reg}} \sum_i p_i^* L_{reg}(t_i, t_i^* )</script><h2 id="RPN和FastRCNN共享卷积参数"><a href="#RPN和FastRCNN共享卷积参数" class="headerlink" title="RPN和FastRCNN共享卷积参数"></a>RPN和FastRCNN共享卷积参数</h2><p>原文为了使RPN和FastRCNN共享卷积参数, 讨论了三种不同的训练策略:</p><ul><li>Alternating training: 先训练RPN, 然后用RPN产生的候选区域来训练Fast RCNN, 之后, FastRCNN更新参数以后, 继续用来训练RPN. 该策略是本篇paper所有的实验使用的训练方法</li><li>Approximate joint training:</li></ul><h2 id="如果anchor-box有两个物体重叠了-怎么处理"><a href="#如果anchor-box有两个物体重叠了-怎么处理" class="headerlink" title="如果anchor box有两个物体重叠了?  怎么处理????"></a>如果anchor box有两个物体重叠了?  怎么处理????</h2><h2 id="bounding-box-回归的时候-为什么不直接对坐标回归-而是采用偏移量和缩放度"><a href="#bounding-box-回归的时候-为什么不直接对坐标回归-而是采用偏移量和缩放度" class="headerlink" title="bounding box 回归的时候, 为什么不直接对坐标回归, 而是采用偏移量和缩放度?"></a>bounding box 回归的时候, 为什么不直接对坐标回归, 而是采用偏移量和缩放度?</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《TensorFlow实战》</title>
      <link href="/z_post/TensorFlow-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-TF%E5%AE%9E%E6%88%98/"/>
      <url>/z_post/TensorFlow-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-TF%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从RCNN到FasterRCNN</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-MaskRCNN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2017-MaskRCNN/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong></p><p><strong>作者:</strong></p><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><h2 id="RoI-Align"><a href="#RoI-Align" class="headerlink" title="RoI Align"></a>RoI Align</h2><p>RoI Pooling存在两次量化过程:</p><ul><li>将候选框边界量化为整数坐标值</li><li>将量化后的边界区域分割成 $k\times k$ 个bins, 并对每一个单元的边界量化</li></ul><p>可以看出, 上面的量化操作是一种很粗糙的Pooling方式, 由于feature map可以看做是对原图特征的高度概括信息, 所以feature map上的细微差别映射回原图时, 往往会导致产生很大的像素位移差. 故此, 提出了RoI Align的解决思路: 取消量化操作, 使用双线性内插的方法获得坐标为浮点数的像素点上的图像数值, 从而将整个特征聚集过程转换为一个连续的操作. 其具体流程如下:</p><ul><li>遍历每一个候选区域, 保持浮点数边界不做量化</li><li>将候选区域分割成 $k\times k$ 个bins, 每个bins的边界也不做量化</li><li>在每个bins中计算固定四个坐标的位置, 使用双线性内插的方法计算出这四个位置的值, 然后进行最大化操作哦.</li></ul><h1 id="论文细节-1"><a href="#论文细节-1" class="headerlink" title="论文细节"></a>论文细节</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FastRCNN-ICCV2015</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2015-FastRCNN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-ICCV2015-FastRCNN/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong><br><strong>作者:</strong></p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="RoI-Pooling"><a href="#RoI-Pooling" class="headerlink" title="RoI Pooling"></a>RoI Pooling</h2><p>RoI Pooling的前向传播过程如下:</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw9pzrhzpjj20ny078747.jpg" alt=""></p><p>对于任意给定的feature map的候选区域框, 将其划分成指定的网格大小, 然后执行max pooling操作. 这样, 对于任意size的输入, 都可以获得固定长度的输出.</p><p>RoI Pooling 在反向传播计算梯度时, 可以看做是分别对每个候选区域框计算max pooling 的梯度, 然后将所有候选区域框的梯度累加, 其过程及公式如下:</p><p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw9pzrhzpjj20ny078747.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/mw690/d7b90c85ly1fw9pzwf08rj208h05u0si.jpg" alt=""></p><script type="math/tex; mode=display">\frac{\partial L}{\partial x_i} = \sum_r \sum_j [i = i^*(r,j)]\frac{\partial L}{\partial y_{rj}}</script><p>式中, $x_i$ 代表RoI Pooling前特征图上的像素点, $y_{rj}$ 代表pooling后的第 $r$ 个候选区域的第 $j$ 个点, $i^<em>(r,j)$ 代表点 $y_{rj}$ 像素值的来源(最大池化的时候选出的最大像素值所在点的坐标). 由此可以看出, 只有当池化后某个点的像素值在池化过程中采用了当前点 $x_i$ 的像素值 (即满足 $i = i^</em> (r,j)) 时, 才在 $x_i$ 处回传梯度.</p><h2 id="为什么RoI-Pooling比SPP效果好"><a href="#为什么RoI-Pooling比SPP效果好" class="headerlink" title="为什么RoI Pooling比SPP效果好?"></a>为什么RoI Pooling比SPP效果好?</h2><p>SPP的Pooling方式是组合不同划分粒度下feature map的max pooling. 这种方式就会导致网络在反向传播的时候, 不容易通过SPP层反向传播. 所以SPPNet的作者就没有设计对应的传播规则 (这里与Inceptin不同, Inception是卷积核连接, 梯度更新是互相独立的, 按照正常计算即可) , 而是直接在最后两个全连接层上进行fine-tune, 虽然最后也取得了不错的成果, 但是Roos认为, 虽然离输入层较劲的前几层卷积层是比较generic和task independent的, 但是靠近输出层的卷积层还是很有必要进行fine-tune的, 他也通过实验证实了这种必要性, 于是他简化了SPP的Pooling策略, 用一种更简单粗暴的Pooling方式来获得固定长度的输出向量, 同时也设计了相应的RoI Pooling的反向传播规则, 并对较深的基层卷积层进行了fine-tune, 最终取得了不错的效果.</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>分类损失, 对于真实类别 $u$ 的损失函数如下:</p><script type="math/tex; mode=display">L_{cls}(p,u) = -log p_u</script><p>bounding box回归:</p><script type="math/tex; mode=display">L_{loc}(t^u,v) = \sum_{i\in \{x,y,w,h\}} smooth_{L_1}(t_i^u - v_i)</script><script type="math/tex; mode=display">smooth_{L_1}(x) = \begin{cases} 0.5x^2 & \text{if } |x| < 1 \\ |x| - 0.5 & \text{otherwise} \end{cases}</script><p>相比于 $L_2$ 损失, $L_1$ 损失对于离异值更加鲁棒, 当预测值与目标值相差很大时, 梯度很容易爆炸, 因为梯度里面包含了 $(t_i^u - v_i)$ 这一项, 而smooth L1 在值相差很大是, 其梯度为 $\pm 1$ ( $L_1$ 在 $x$ 绝对值较大时, 是线性的, 而 $L_2$ 是指数的, 很容易爆炸)</p><p>联合任务损失函数:</p><script type="math/tex; mode=display">L(p,u,t^u,v) = L_{cls}(p,u) + \lambda[u\ge 1]L_{loc}(t^u,v)</script><h2 id="Truncated-SVD-截断式奇异矩阵分解"><a href="#Truncated-SVD-截断式奇异矩阵分解" class="headerlink" title="Truncated SVD 截断式奇异矩阵分解"></a>Truncated SVD 截断式奇异矩阵分解</h2><p>对于整张图片的分类问题来说, 花费在全连接上的计算时间相比于在卷积层上的计算时间来说, 要小很多. 但是, 与之相反的, 对于目标检测问题来说, 需要处理的RoI数量很大, 并且前向计算的时间有几乎一半都花费在了全连接层的计算上, 因此, 使用truncated SVD技术来进行加速.</p><p>对于一个权重矩阵为 $u\times v$ 的全连接层来说, 该矩阵可以被近似的因式分解为:</p><script type="math/tex; mode=display">W \approx U \sum_t V^T</script><p>式中, $U$ 是一个 $u\times t$ 的矩阵, $\sum_t$ 是一个 $t\times t$ 的对角矩阵, 包含着矩阵 $W$ 的值最大的 $t$ 个奇异值</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rich Feature Hierarchies for Accurate Object Detection and Semantic Segmentation</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2014-RCNN/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-CVPR2014-RCNN/</url>
      
        <content type="html"><![CDATA[<p><strong>文章:</strong></p><p><strong>作者:</strong></p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h1 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h1><h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><h1 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h1><h2 id="Selective-Search-算法"><a href="#Selective-Search-算法" class="headerlink" title="Selective Search 算法"></a>Selective Search 算法</h2><p>基本思路如下:</p><ol><li>使用一个分割手段, 将图像分割成小区域</li><li>查看现有小区域, 合并可能性最高的两个区域, 重复知道整张图像合并成一个区域位置. 优先合并以下区域:<ul><li>颜色(颜色直方图)相近的</li><li>纹理(梯度直方图)相近的</li><li>合并后总面积小的</li><li>合并后, 总面积在其BBox中所占比例大的</li></ul></li><li>输出所有存在过的区域, 即所谓的候选区域</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文解读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《C++ PrimerPlus》 第十二章～第十三章</title>
      <link href="/z_post/Cpp-Book-CppPrimerPlusChapter12_13/"/>
      <url>/z_post/Cpp-Book-CppPrimerPlusChapter12_13/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章 预备知识"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">第一章 预备知识</a></h1><h1 id="第二章-开始学习C"><a href="#第二章-开始学习C" class="headerlink" title="第二章 开始学习C++"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C">第二章 开始学习C++</a></h1><h1 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章 处理数据"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE">第三章 处理数据</a></h1><h1 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B">第四章 复合类型</a></h1><h1 id="第五章-循环和关系表达式"><a href="#第五章-循环和关系表达式" class="headerlink" title="第五章 循环和关系表达式"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F">第五章 循环和关系表达式</a></h1><h1 id="第六章-分支语句和逻辑运算符"><a href="#第六章-分支语句和逻辑运算符" class="headerlink" title="第六章 分支语句和逻辑运算符"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">第六章 分支语句和逻辑运算符</a></h1><h1 id="第七章-函数——C-的编程模块"><a href="#第七章-函数——C-的编程模块" class="headerlink" title="第七章 函数——C++的编程模块"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C-%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97">第七章 函数——C++的编程模块</a></h1><h1 id="第八章-函数探幽"><a href="#第八章-函数探幽" class="headerlink" title="第八章 函数探幽"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD">第八章 函数探幽</a></h1><h1 id="第八章-函数探幽-1"><a href="#第八章-函数探幽-1" class="headerlink" title="第八章 函数探幽"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD">第八章 函数探幽</a></h1><h1 id="第八章-函数探幽-2"><a href="#第八章-函数探幽-2" class="headerlink" title="第八章 函数探幽"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD">第八章 函数探幽</a></h1><h1 id="第八章-函数探幽-3"><a href="#第八章-函数探幽-3" class="headerlink" title="第八章 函数探幽"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD">第八章 函数探幽</a></h1><h1 id="第十二章-类和动态内存分配"><a href="#第十二章-类和动态内存分配" class="headerlink" title="第十二章 类和动态内存分配"></a>第十二章 类和动态内存分配</h1><h2 id="动态内存和类"><a href="#动态内存和类" class="headerlink" title="动态内存和类"></a>动态内存和类</h2><h3 id="复习示例和静态成员"><a href="#复习示例和静态成员" class="headerlink" title="复习示例和静态成员"></a>复习示例和静态成员</h3><ul><li>所有的对象都共用一个静态成员副本。 <strong>不能在类声明中初始化静态成员变量</strong> ，这是因为声明描述了如何分配内存，但并不分配内存。p428</li><li><p>对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。注意下面的初始化语句，指出了类型，并使用了作用域运算符，但没有使用关键字static。p428</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int StringBad::num_strings = 0;</span><br></pre></td></tr></table></figure></li><li><p>在构造函数中使用new来分配内存时，必须在相应的析构函数中使用delete来释放内存。如果使用new[]来分配内存，则应使用delete[]来释放内存。p429</p></li></ul><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><ul><li>C++提供了一些特殊的成员函数，它们会在一定条件下自动创建。p432<ul><li>默认构造函数，如果没有定义构造函数;</li><li>默认析构函数，如果没有定义;</li><li>复制构造函数，如果没有定义;</li><li>赋值运算符，如果没有定义;</li><li>地址运算符，如果没有定义。</li><li>C++11提供了另外两种特殊成员函数：移动构造函数和移动赋值运算符。这将在第十八章讨论。</li></ul></li><li>其中，隐式地址运算符返回调用对象的地址（即this指针的值），这与我们的初衷一致。主要引起问题的是复制构造函数和赋值运算符。p432<ul><li><strong>复制构造函数</strong> 用于将一个对象复制到 <strong>新创键</strong> 的对象中。也就是说，它用于初始化过程中，而不是常规的复制过程中。类的复制构造函数原型通常如下：<code>Class_name(const Class_name&amp;);</code> p433<ul><li><strong>何时调用复制构造函数</strong>：每当程序产生了对象副本时，都将使用复制构造函数，如用赋值语句初始化，函数按值传递等。具体地说，当函数按值传递对象或者函数按值返回对象时，都将使用复制构造函数。因此，进行传递时，多用引用，可以减少调用复制构造函数的时间和存储新对象的空间。</li><li><strong>默认复制构造函数的功能</strong>：默认的复制构造函数逐个复制非静态成员，复制的是成员的值（按值复制，浅复制），如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态函数不受影响，因为它们属于整个类。</li></ul></li></ul></li></ul><h3 id="复制构造函数容易引起的问题"><a href="#复制构造函数容易引起的问题" class="headerlink" title="复制构造函数容易引起的问题"></a>复制构造函数容易引起的问题</h3><ul><li>如果常规构造函数中设置了一个静态变量用于计录创建对象的个数，那么就应在复制构造函数中显示写出该逻辑，否则会导致计数结果不准确。p434</li><li>由于隐式复制构造函数是按值进行复制的。在这成员变量中含有指针时是十分危险的，因为这样依赖两个对象中的成员指针就会指向同一块内存，如果其中一个对象被释放后，其指针指向的内存块可能会导致不确定的错误。另外，程序有可能会因为两次释放同一块内存而导致程序终止。具体的错误取决于系统和相关实现。p435</li><li><strong>深度复制</strong>。深度复制可解决上述的问题。复制时应当复制指针指向内容的副本，并将副本的地址赋给新的对象，这样一来，两个对象就是完全独立的。必须自定义复制构造函数的原因就在于，一些类成员是使用new初始化的、指向数据的指针，而不是数据本身。p435</li></ul><h3 id="赋值运算符容易引起的问题"><a href="#赋值运算符容易引起的问题" class="headerlink" title="赋值运算符容易引起的问题"></a>赋值运算符容易引起的问题</h3><ul><li>赋值运算符的完整函数原型如下：<code>Class_name &amp; Class_name::operator = (const Class_name&amp;);</code>。它接受并返回一个指向类对象的引用。</li><li>赋值运算符的功能以及何时使用：将已有的对象赋给另一个对象时，将使用重载的复制运算符。（注意，初始化赋值时，不会调用赋值运算符重载，而是调用复制构造函数）。p436</li><li><strong>赋值的问题</strong>：主要是由于浅复制造成的数据问题，由于赋值时是按值赋值的，导致指针变量会指向相同的地址。解决的方法是提供赋值运算符（进行深度复制）的定义，其实现与复制构造函数相似，但也有一些差别。p436<ul><li>由于目标对象是已经存在的对象，所以它可能引用了以前分配的数据，因此函数应使用delete[]来释放这些数据。</li><li>函数应当避免将对象赋给自身，否则，给对象重新赋值前，释放内存操作就已经删除了对象内容。这一点可以通过程序逻辑实现：<code>if(this == &amp;s) return *this;</code></li><li>函数应返回一个指向调用对象的引用。通过返回一个对象，函数可以想常规赋值操作那样，连续进行赋值。</li></ul></li></ul><h2 id="改进后的新String类"><a href="#改进后的新String类" class="headerlink" title="改进后的新String类"></a>改进后的新String类</h2><ul><li><p>下面两种方式分配的内存量相同，区别在于前者与类析构函数兼容，而后者不兼容。p438</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = new char[1];  //与析构函数中的delete []str; 兼容</span><br><span class="line">str = new char;</span><br></pre></td></tr></table></figure></li><li><p><strong>C++11空指针：</strong> 在C++98中，字面值0有两个含义：可以表示数字值零，也可以表示空指针，这使得阅读程序的人和编译器难以区分。C++11提供了更好的解决方案，引入新关键字nullptr，用于表示空指针。原来的表示依然合法，但建议使用nullptr。 p438</p></li><li><strong>静态成员函数：</strong> 不能通过对象调用静态成员函数，也不能使用this指针。如果静态成员函数是在公有部分声明，则可以使用类名和作用域解析符来调用它。 其次，由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员，不能访问其他成员数据。p441</li><li>较早的<code>get(char *, int)</code>版本在读取空行后，字符串中第一个字符将是一个空字符。较新的C++标准则会返回false。p446</li></ul><h2 id="在构造函数中使用new时应注意的事项"><a href="#在构造函数中使用new时应注意的事项" class="headerlink" title="在构造函数中使用new时应注意的事项"></a>在构造函数中使用new时应注意的事项</h2><ul><li>使用new初始化对象的指针成员时，必须注意下面几项：p446<ul><li>如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。</li><li>new和delete必须相互兼容。new对应于delete，new[]对应于delete[]。</li><li>如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空（0或C++11中的nullptr），这是因为delete（无论是否带[]）可以用于空指针。</li><li>应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。它应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址。另外，还应该更新所有受影响的静态类成员。</li><li>应定义一个赋值运算符，通过深度复制将一个对象赋值给另一个对象。它应该检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用。</li></ul></li></ul><h2 id="有关返回对象的说明"><a href="#有关返回对象的说明" class="headerlink" title="有关返回对象的说明"></a>有关返回对象的说明</h2><h3 id="返回指向const对象的引用"><a href="#返回指向const对象的引用" class="headerlink" title="返回指向const对象的引用"></a>返回指向const对象的引用</h3><ul><li>返回的对象应该是函数参数传递进来的对象，并且是const的，所以需要返回const引用。p449</li></ul><h3 id="返回指向非const对象的引用"><a href="#返回指向非const对象的引用" class="headerlink" title="返回指向非const对象的引用"></a>返回指向非const对象的引用</h3><ul><li>返回的对象应该是函数参数传递进来的对象，但是由于参数不是const的，所以返回非const（当然也可以返回const）。常见的两种情况是重载赋值运算符以及重载与count一起使用的&lt;&lt;运算符。p449</li></ul><h3 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h3><ul><li>如果返回的对象是被调用函数中的局部变量，则不应该按引用方式返回它，因为在调用函数执行完毕时，局部对象将调用其析构函数。p450</li></ul><h3 id="返回const对象"><a href="#返回const对象" class="headerlink" title="返回const对象"></a>返回const对象</h3><ul><li>返回const对象，该对象将不能作为右值，此时可以避免一些不必要的错误。p450</li></ul><h2 id="使用指向对象的指针"><a href="#使用指向对象的指针" class="headerlink" title="使用指向对象的指针"></a>使用指向对象的指针</h2><ul><li><p>利用new创建一个对象并令指针指向它，该对象会被分配到堆内存中，直到使用delete为止，该对象一直存在。p453</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String * favorite = new String;</span><br></pre></td></tr></table></figure></li><li><p>使用对象指针时，需要注意几点：p454</p><ul><li>使用常规表示法来声明指向对象的指针：<code>String * glamour;</code></li><li>可以将指针初始化为指向已有的对象：<code>String * second = &amp;string_first;</code></li><li>想要将创建一个新的对象，可以使用new来初始化指针：<code>String * glamour = new String</code></li><li>可以通过间接访问运算符<code>-&gt;</code>来调用类的方法。</li><li>可以通过解除引用运算符（ * ）来活得对象。</li></ul></li><li><strong>定位new运算符：</strong> 定位new运算符可以在分配内存时指定内存的位置：<code>Sting * p1 = new (buffer) String;</code> 。但是在使用时要注意以下几点：p457<ul><li>确保定义不同的对象时，二者使用的内存地址是不同的，且内存单元之间没有重叠</li><li>delete可以与常规new运算符配合使用，但不能与定位new运算符配合使用。有时需要通过显示调用析构函数来释放对象的内存。</li><li>对于使用定位new运算符创建的对象，应以与创建顺序相反的顺序进行删除。原因在于，晚创建的对象可能依赖于早创建的对象。另外，仅当所有对象（定位new创建的）都被销毁后，才能释放用于存储这些对象的缓冲区。</li></ul></li></ul><h2 id="复习各种技术"><a href="#复习各种技术" class="headerlink" title="复习各种技术"></a>复习各种技术</h2><ul><li>p459</li></ul><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><ul><li>如果Classy是一个类，而mem1、mem2和mem3都是这个类的数据成员，则类构造函数可以使用如下的语法来初始化数据成员。该语法需要注意以下几点：p464<ul><li>这种格式只能由于构造函数;</li><li>必须用这种格式来初始化非静态const数据成员（C++11之前）;</li><li>必须用这种格式来初始化引用数据成员。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Classy:Classy(int n, int m) :mem1(n), mem2(0), mem3(n*m+2)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="第十三章-类继承"><a href="#第十三章-类继承" class="headerlink" title="第十三章 类继承"></a>第十三章 类继承</h1><h2 id="13-1-一个简单的基类"><a href="#13-1-一个简单的基类" class="headerlink" title="13.1 一个简单的基类"></a>13.1 一个简单的基类</h2><ul><li>从一个类派生出另一个类时,原始类称为基类,继承类称为派生类。p481</li></ul><h3 id="13-1-1-派生一个类"><a href="#13-1-1-派生一个类" class="headerlink" title="13.1.1 派生一个类"></a>13.1.1 派生一个类</h3><ul><li>使用公有派生，基类的公有成员将成为派生类的公有成员。基类的私有部分只能通过基类的公有和 <strong>保护</strong> 方法访问。 <code>class A : public B //A继承自B，且是公有继承</code> p483</li></ul><h3 id="13-1-2-构造函数：访问权限的考虑"><a href="#13-1-2-构造函数：访问权限的考虑" class="headerlink" title="13.1.2 构造函数：访问权限的考虑"></a>13.1.2 构造函数：访问权限的考虑</h3><p>创建派生类对象时，程序首先会创建基类对象，这意味着 <strong>基类对象应该在程序进入派生类构造函数之前被创建</strong> 。C++<br>使用成员初始化列表语法来完成这种工作。</p><p>派生类构造函数必须调用基类的构造函数，利用成员初始化列表语法来显式调用基类构造函数，如果没有显式调用，那么就会调用默认的基类构造函数。p484<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">derived::derived(type1 x, type2 y) : base(x,y)&#123;  //显式调用基类B的构造函数</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">derived::derived(type1 x, type2 y)&#123; //该代码与下面的等效</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">derived::derived(type1 x, type2 y) : base()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>有关派生类构造函数的要点如下：<ul><li>首先创建基类对象（在进入派生类构造函数之前就被创建）</li><li>派生类构造函数应通过 <strong>成员初始化列表</strong> 将基类信息传递给基类构造函数</li><li>派生类构造函数应初始化派生类新增的数据成员</li></ul></li><li>释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。p485</li><li>如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数，成员初始化列表只能用于构造函数。p486</li></ul><h3 id="派生类与基类之间的特殊关系"><a href="#派生类与基类之间的特殊关系" class="headerlink" title="派生类与基类之间的特殊关系"></a>派生类与基类之间的特殊关系</h3><ul><li>当基类的方法不是私有的（可以是公有或保护），派生类可以使用基类的方法。p488</li><li>基类指针/引用可以在不进行显式类型转换的情况下指向/引用派生类对象（反之不行）。但是只能调用基类方法。p488</li></ul><h2 id="继承：is-a关系"><a href="#继承：is-a关系" class="headerlink" title="继承：is-a关系"></a>继承：is-a关系</h2><ul><li>公有继承是最常用的方式（另外还有私有和保护继承），它建立一种is-a-kind-of（是一种）的关系，术语简称is-a。is-a关系的派生类对象也是一种基类对象，凡是可以对基类执行的操作，都可以对派生类执行。p489</li></ul><h2 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h2><ul><li>实现多态公有继承的方式有以下两种：p490<ul><li>在派生类中重新定义基类的方法</li><li>使用虚方法（关键字virtual只用与类声明的方法原型中，不用于方法定义）</li></ul></li><li>如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。p493</li><li>在派生类方法中，标准技术是使用作用域解析符来调用基类方法。p496</li></ul><h2 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h2><ul><li>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。但是有时候，无法在编译时确定使用哪个函数块（如虚函数），所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被成为动态联编（dynamic binding），又称为晚期联编（late binding）。p502</li></ul><h3 id="指针和引用类型的兼容性"><a href="#指针和引用类型的兼容性" class="headerlink" title="指针和引用类型的兼容性"></a>指针和引用类型的兼容性</h3><ul><li>将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting）。如果不使用显式类型转换，则向下强制转换是不允许的。p502</li><li>隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。p503</li></ul><h3 id="虚成员函数和动态联编"><a href="#虚成员函数和动态联编" class="headerlink" title="虚成员函数和动态联编"></a>虚成员函数和动态联编</h3><ul><li>编译器对非虚方法使用静态联编，对虚方法使用动态联编。因为虚方法是根据对象类型来选择的，而对象类型只有在运行时才能确定。非虚方法则是根据引用或指针的类型来选择方法，它们可以在编译时确定。p503</li><li><strong>为什么有两种联编类型以及为什么默认为静态联编：</strong> 动态联编的好处是可以重新定义类方法，但是在运行阶段跟踪对象类型会产生一定的开销，这使得动态联编没有静态联编效率高，这也是选择静态联编为默认方式的原因。p503</li><li><strong>虚函数的工作原理：</strong> C++规定了虚函数的行为，但将实现方法留给了编译器作者。通常，编译器处理虚函数的方法是，给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组成为虚函数表（virtual function table，vtbl）。虚函数表中存储了为类对象进行声明的虚函数的地址。 派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址;如果没有重新定义虚函数，则保存函数原始版本的地址。调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。p504</li><li>根据工作原理可以得出，使用虚函数时，在内存和执行速度方面有一定的成本（虽然非虚函数效率高，但不具备动态联编功能），包括：p505<ul><li>每个对象都将增大，增大量为存储地址的空间;</li><li>对于每个类，编译器都将创建一个虚函数地址表（数组）;</li><li>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。</li></ul></li></ul><h3 id="有关虚函数注意事项"><a href="#有关虚函数注意事项" class="headerlink" title="有关虚函数注意事项"></a>有关虚函数注意事项</h3><ul><li>虚函数的一些要点：p505<ul><li>在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括儿子的儿子）中是虚的。</li><li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。</li></ul></li><li>构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数会使用基类的构造函数，这种顺序不同于继承机制。因此，派生类不急成基类的构造函数。p505</li><li>除非类不是基类，否则应该将析构函数声明为虚函数。p505</li><li>友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。p505</li><li>如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本。p506</li><li>重新定义继承的方法并不是重载，而是将基类的方法隐藏，也可以看作是重写。由此，得出两条经验规则：第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。第二，如果基类声明被重载了，则应在派生类中重新定义所在的基类版本。如果只定义类部分版本，则其他版本将被隐藏。另外，如果不需要修改，则新定义直接调用基类版本即可，如<code>void derived::show() { const(base::show()); }</code></li></ul><h2 id="访问控制：protected"><a href="#访问控制：protected" class="headerlink" title="访问控制：protected"></a>访问控制：protected</h2><ul><li>对于外部世界来说，保护成员的行为与私有成员相似，但对于派生类来说，保护成员的行为与公有成员相似。p507</li><li>对于数据成员最好采用私有访问控制，同时通过基类方法使派生类能够访问基类数据。对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。</li></ul><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><ul><li><p>从多个类中抽象出它们的共性，将这些共性放在一个抽象基类（abstract base class，ABC）中，然后再从该ABC派生出这些类。ABC中有些方法不能直接实现，C++通过纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为<code>=0</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual double Area() const = 0; // a pure virtual function</span><br></pre></td></tr></table></figure></li><li><p>当类声明中包含纯虚函数时，则不能创建该类的对象，而只能作为基类使用。要成为真正的ABC，必须至少包含一个纯虚函数，原型声明中的<code>=0</code>是虚函数成为纯虚函数，一般纯虚函数没有定义，但C++允许纯虚函数有定义，即可以把所有派生类的某个共同操作作为纯虚函数的定义，然后在派生类重写该纯虚函数时调用。p509</p></li></ul><h2 id="13-7-继承和动态内存分配"><a href="#13-7-继承和动态内存分配" class="headerlink" title="13.7 继承和动态内存分配"></a>13.7 继承和动态内存分配</h2><p>如果基类使用动态内存分配，并重新定义赋值和复制构造函数，那么将怎么影响派生类的实现呢？有以下几种情况：</p><h3 id="13-7-1-派生类不使用new"><a href="#13-7-1-派生类不使用new" class="headerlink" title="13.7.1 派生类不使用new"></a>13.7.1 派生类不使用new</h3><ul><li>如果基类使用了动态内存分配，而派生类未使用，那么就不需要为派生类定义显式析构函数、赋值和复制构造函数。 p516</li></ul><h3 id="13-7-2-派生类使用new"><a href="#13-7-2-派生类使用new" class="headerlink" title="13.7.2 派生类使用new"></a>13.7.2 派生类使用new</h3><ul><li>如果派生类使用了new，就必须为派生类定义显示析构函数、赋值和复制构造函数。p517</li></ul><h2 id="13-8-类设计回顾"><a href="#13-8-类设计回顾" class="headerlink" title="13.8 类设计回顾"></a>13.8 类设计回顾</h2><h3 id="13-8-1-编译器生成的成员函数"><a href="#13-8-1-编译器生成的成员函数" class="headerlink" title="13.8.1 编译器生成的成员函数"></a>13.8.1 编译器生成的成员函数</h3><ol><li>默认构造函数</li></ol><p>&emsp;&emsp;如果没有定义任何构造函数，编译器将定义默认构造函数。</p><ol><li><p>复制构造函数<br>&emsp;&emsp;如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义。</p></li><li><p>复制运算符<br>&emsp;&emsp;默认的赋值运算符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。如果语句创建新的对象，则是用初始化。如果语句修改已有对象的值，则是赋值。</p></li></ol><h3 id="13-8-2-其他的类方法"><a href="#13-8-2-其他的类方法" class="headerlink" title="13.8.2 其他的类方法"></a>13.8.2 其他的类方法</h3><ol><li>构造函数</li></ol><p>构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一，继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不存在。</p><ol><li>析构函数</li></ol><p>一定要定义显式析构函数来世放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。对于基类，即使它不需要析构函数，也应提供一个虚析构函数。</p><ol><li>转换</li></ol><p>使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。</p><ol><li><p>按值传递对象引用传递</p></li><li><p>返回对象和返回引用</p></li></ol><p>有些类方法返回对象，有些返回引用，返回对象涉及生成返回对象的临时副本。优先返回引用，但函数不能返回在函数中创建的临时对象的引用。</p><ol><li>使用const<br>可以是用const来确保方法不修改参数。</li></ol><p>注意，如果函数将参数声明为指向const的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。</p><h3 id="13-8-3-公有继承的考虑因素"><a href="#13-8-3-公有继承的考虑因素" class="headerlink" title="13.8.3 公有继承的考虑因素"></a>13.8.3 公有继承的考虑因素</h3><ol><li>is-a关系</li></ol><p>要遵循is-a关系。如果派生类不是一个特殊的基类，则不用使用公有派生。</p><ol><li>什么不能被继承</li></ol><p>构造函数是不能继承的，也就是说，创建派生类对象时，必须调用派生类的构造函数。 <strong>C++11新增了一种能够继承构造函数的机制，但默认是不能继承构造函数。</strong></p><p>析构函数也是不能继承的。</p><p>赋值运算符是不能继承的。</p><ol><li><p>赋值运算符</p></li><li><p>私有成员与保护成员</p></li><li><p>虚方法</p></li></ol><ol><li>析构函数</li></ol><ol><li>友元函数</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DenseCap---CVPR2016</title>
      <link href="/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-DenseCap/"/>
      <url>/z_post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB-DenseCap/</url>
      
        <content type="html"><![CDATA[<p>本篇论文解读的排版主要参见原文的格式，针对原文中的每一个小节进行展开，有的是对原文的一个提炼和简单概括，有的是对原文中涉及但是又没有详细介绍的技术的补充和说明。<br>原文连接：<a href="https://cs.stanford.edu/people/karpathy/densecap/" target="_blank" rel="noopener">https://cs.stanford.edu/people/karpathy/densecap/</a><br>作者个人主页：<a href="https://cs.stanford.edu/people/jcjohns/" target="_blank" rel="noopener">https://cs.stanford.edu/people/jcjohns/</a><br><strong>PS：本篇博文不是对原文的简单翻译，论文中每一处涉及到的知识点以及论文中没有提及的技术细节，本文都会做一定的补充说明，如果还有什么看不懂的地方的话，可以留言一起讨论，我会尽量在24小时内回复。</strong></p><p>(正文所有图片中的ksws0292756水印是我的CSDN博客)</p><p><img src="https://img-blog.csdn.net/20180329150203861?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图1" title="heheheheh"></p><center><div style="color:orange;border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;">这里输入题注</div></center><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>&emsp;&emsp;这篇文章的主要工作是对图像的dense captioning。所谓dense captioning，就是要描述的对象不再是一幅简单的图片，而是要将图片中的许多局部细节都都用自然语言描述出来。这篇文章所做的工作可以说是object detection和image captioning的一般化，即当描述的语言是一个单词的时候，就可以看作是object detection，当描述的对象是整幅图片的时候，就成了普通的image captioning。<br>这篇文章的主要贡献在于提出了一个Fully Convolutional Localization Network（FCLN）网络结构，该网络结构可以进行端到端式的训练，无需额外的候选区域生成模型（以及整合到网络内部），只需要进行一轮优化和前馈计算就可以得到输出结果。<br>网络模型有三部分组成：卷积网络（Convolutional Network）、<strong>密集定位层（dense localization layer）</strong> 和RNN语言模型。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;本小节主要介绍了dense cationing任务的定义，以及相对应的object detection和image caotioning方面的研究。大家可以自己看一下原文</p><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>&emsp;&emsp;这里只给出重要的2篇论文（作者主要是在这两篇论文的几处上进行模型构建的），其他的可以参见原文</p><p><strong>Faster R-CNN</strong><br><a href="http://papers.nips.cc/paper/5638-faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks" target="_blank" rel="noopener">http://papers.nips.cc/paper/5638-faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks</a><br><strong>Deep Visual-Semantic Alignments for Generating Image Descriptions</strong><br><a href="https://cs.stanford.edu/people/karpathy/deepimagesent/" target="_blank" rel="noopener">https://cs.stanford.edu/people/karpathy/deepimagesent/</a></p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><strong>目标</strong>：设计一个可以标定出感兴趣区域并且用自然语言描述其中内容的网络框架模型<br><strong>挑战与难点</strong>：在兼顾高效性和有效性的前提下，开发出一个可以支持端到端训练并且只需一次优化的模型</p><h2 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h2><p><img src="https://img-blog.csdn.net/20180329204903491?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="卷积网络（Convalutional-Network）"><a href="#卷积网络（Convalutional-Network）" class="headerlink" title="卷积网络（Convalutional Network）"></a>卷积网络（Convalutional Network）</h3><p>&emsp;&emsp;作者采用了基于VGG-16的网络结构，包含13层卷积核为3×3的卷积层和4层池化核为2×2的最大池化层（<strong>原本的VGG是5层池化层，这里作者做了一些小改动，改为4层</strong>），因此，对于大小为$3×W×H$的图片，经过卷积网络后，输出结果是$C×W’×H’$的特征图谱，这里$C=512$，$W’=\lfloor\frac{W}{16}\rfloor$，$H’=\lfloor\frac{H}{16}\rfloor$，该特征图谱就是下一层Fully Convolutional Localization Layer的输入。</p><h3 id="全卷积定位层（Fully-Convolutional-Localization-Layer）"><a href="#全卷积定位层（Fully-Convolutional-Localization-Layer）" class="headerlink" title="全卷积定位层（Fully Convolutional Localization Layer）"></a>全卷积定位层（Fully Convolutional Localization Layer）</h3><p><strong>输入和输出</strong></p><p><strong>输入</strong><br> : 来自卷积网络的特征图谱$C×W’×H’$（size任意）</p><p><strong>输出</strong><br> : 输出B个候选区域的表征向量（定长），每个特征向量都包含下面三个关键信息：</p><ul><li>候选区域的<strong>坐标</strong>：输出形式是一个$B×4$的矩阵，每行代表一个候选区域的坐标</li><li>候选区域的<strong>置信分数</strong>：一个长度为$B$的一维列向量，向量内每个元素都给出了候选区域的得分。得分越高说明越可能是真实区域</li><li>候选区域的<strong>特征</strong>：输出形式为$B×C×X×Y$的特征集合，这里B代表区域个数，$X×Y$表示特征图谱的大小（注意，这里的size已经是固定的），$C$代表特征的维度</li></ul><p>&emsp;&emsp;这里额外说明一下，在CNN阶段我们不需要指定输入图片的大小（传统CNN分类任务由于FC全连接层的限制，使得输入图片的大小是固定的），因为这里我们关心的是图片的特征，而卷积层和池化层根本不care输出尺寸的多少，它们只负责拿到前一层的特征图谱（feature map）。<br>&emsp;&emsp;但是为什么这里的输出必须是定长的向量呢？主要是因为后面RNN模型的制约，由于RNN模型接受的数据必须的定长的，所以在全卷积定位层（FCL）阶段的最后一步，我们需要使用双线性插值的方法来使输出成为定长的特征向量。</p><p><strong>卷积锚点（Convolutional Anchors）</strong><br>&emsp;&emsp;这里的工作主要参考自Faster R-CNN。主要思想是借助一系列具有平移不变性的锚点（anchors）来预测候选区域的位置和大小，具体做法如下：<br>&emsp;&emsp;对于大小为$W’×H’$的特征图谱来说，将图谱中的每一个像素点都做为一个锚点（anchor）（锚点数量为$W’×H’$个），将该点反向映射会原始图像$W*H$中，然后基于该锚点，画出不同宽高比和大小的若干个“锚箱”（anchor box）。下图所示是3个具有相同大小但是不同宽高比的锚箱示例（分别为1:1，1:2，2:1）。</p><p><img src="https://img-blog.csdn.net/20180329153116993?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>&emsp;&emsp;如果采用Faster R-CNN的设置，即每个锚点对应3个不同的size取值（$128^2，256^2，512^2$）和3个不同的宽高比取值（1:1，1:2，2:1），因此，每个锚点对应的锚箱数量为$k=9$，在本文中采用的是$k=12$，具体对应多少个size和宽高比文中并没有给出。对于这$k$个锚箱，定位层（localization layer）会通过回归模型来预测相应的置信分数（score）和位置信息（scalars）。具体的计算过程是将特征图片作为输入，经过一个卷积核为$3×3$的卷积层（filter个数为256)，然后再经过一个卷积核为$1×1$卷积层（filter个数为$5k$，这里$k$代表anchor box的数量）,所以这一层的<strong>最终输出是$5k×W’×H’$的张量</strong>，包含了所有锚点对应的置信分数和位置信息。</p><p><strong>边界回归（Box Regression）</strong><br>&emsp;&emsp;边界回归主要是对刚刚预测的候选区域的一次精修，进行边界回归的原因主要是当前的候选区域可能与真实区域并不是特别匹配，如下图所示：</p><p><img src="https://img-blog.csdn.net/20180329161316503?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>&emsp;&emsp;图中，绿色框代表真实区域，红色框代表目前的候选区域，我们可以看到，候选区域虽然可以判断出区域内存在物体（飞机），但是它的定位并不是很准取，这时候就可以利用box regression来对边框进行微调。核心思想是利用线性回归得到关于边框的四个位移参数$（t_x,t_y,t_w,t_h）$，然后通过下面的式子对候选区域的中点$（x,y）$和size$（w，h）$进行更新</p><script type="math/tex; mode=display">x=x_a+t_xw_a$$$$ y=y_a+t_yh_a$$$$ w=w_aexp(t_w) $$$$h=h_aexp(h_w)</script><p>有关box regression的详细讲解可以参考这篇论文：<br><a href="https://blog.csdn.net/zijin0802034/article/details/77685438" target="_blank" rel="noopener">https://blog.csdn.net/zijin0802034/article/details/77685438</a><br>（PS：这篇论文的讲解是基于R-CNN的，其中的符号表示与本文有些出入，如$t_x,t_y$在R-CNN中代表的是真实区域的中心坐标，看的时候注意一下各个符号都表达了什么，不要搞混了）</p><p><strong>区域采样</strong><br>&emsp;&emsp;以图像大小为$W=720，H=540$，锚箱（anchor box）数量为$k=12$的情况为例，得到的候选区域的个数应该为$\lfloor\frac{720}{16}\rfloor×\lfloor\frac{540}{16}\rfloor×12=17820$（文章中写的是17280，我感觉应该是写错了）。<br>为了降低成本，我们只取这些候选区域的子集来参与训练过程和测试过程，具体选取原则如下：</p><p><strong>在训练阶段</strong><br>: 采用Faster R-CNN的方法，采集一个大小为$B=256$的minibatch来进行训练，在这$B$个候选区域中，有至多$B/2$个正样本，其余均为负样本。采集时，如果所有的候选区域中（这里为17280个）正样本的数量不足$B/2$个，那么就由负样本补充，所以，最终的minibatch中正样本的数量$B_P\le B/2$，而负样本的数量$B_N=B-B_P$。正样本和负样本的定义如下：</p><ul><li>正样本：候选区域与<strong>一个或多个</strong>真实区域的面积相交部分大于70%</li><li>负样本： 候选区域与<strong>所有</strong>真实区域的面积相交部分小于30%</li></ul><p><strong>在测试阶段</strong><br>: 基于每个候选区域的置信分数，采用非极大抑制选取$B=300$个置信分数最高的候选区域</p><p>&emsp;&emsp;非极大抑制：这里的抑制就是忽略的意思，非极大抑制的意思就是忽略那些与具有最高score值的候选区域的相交面积大于设定阈值的其他候选区域。这样做的目的主要是为了减少重叠区域的输出，从而更精细化的定位目标位置。</p><p>&emsp;&emsp;经过以上操作，最终我们可以得到关于这B个候选区域的位置坐标和置信分数，表示为<strong>B×4和B×1的张量</strong>，这就是定位层（localization layer）的<strong>输出</strong>。</p><p><strong>双线性插值（Bilinear Interpolaion）</strong></p><p>&emsp;&emsp;在经过采样后，我们得到的各个候选区域是具有不同大小和宽高比的矩形框。为了与全连接层（主要进行识别分类）和RNN语言模型的进行建立连接，我们必须将候选区域提取成<strong>固定大小</strong>的特征表示向量。对于这一问题，Faster R-CNN提出了感兴趣区域池化层（RoI pooling layer），具体方法是大小为$W’×H’$的卷积特征图谱进行划分，得到具有$X×Y$个小网格的网格图，然后根据最大池化的原理，将小网格内的像素最大值作为代表该网格的特征像素，最终可以得到定长为$X×Y$的特征向量。划分示意图如下所示。</p><p><img src="https://img-blog.csdn.net/20180331113328854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>&emsp;&emsp;RoI pooling layer需要两个输入：卷积特征图谱和候选区域坐标。但是在应用梯度下降时，该方法只能对特征图谱采用反向传播（BP）算法，而不能对候选区域坐标使用BP算法，为了克服这个缺点，在本文中，作者采用了双线性插值。<br>&emsp;&emsp;具体来说，就是对于任意的特征图谱$U（C×W’×H’）$和候选区域，我们要将其放缩成大小为$（C×X×Y）$的特征图谱$V$，放缩过程按照如下步骤进行：</p><ol><li>计算$V$到 $U$的反向投影坐标值，例如对于特征图谱$V$中的任意一点坐标$(x_{i,j}^V,y_{i,j}^V)$，投影到$U$中的坐标值为<script type="math/tex">x_{i,j}=x_{i,j}^V*\frac{W'}{X}，y_{i,j}=y_{i,j}^V*\frac{H'}{Y}</script>很容易看出，这里$x_{i,j}和y_{i,j}$的值均为浮点数，然而图像的像素坐标在计算机中必须为整数，所以这里坐标$(x_{i,j},y_{i,j})$对应的像素点是虚拟像素点，并不是$U$中实际存在的点。</li><li>按照双线性插值法，得到$U$中$(x_{i,j}^U,y_{i,j}^U)$坐标点的像素值，该像素值就是$V$中对应点的像素值$V_{c,i,j}$，计算公式如下<script type="math/tex">V_{c,i,j}=\sum_{i'=1}^{W’}\sum_{j'=1}^{H'}U_{c,j',j'}k(i'-x_{i,j})k(j'-y_{i,j})，其中 ，k(d)=max(0,1-|d|)</script></li><li>利用上面的方法，计算$V$中所有像素点的坐标值，得到$C×X×Y$的特征图谱</li></ol><p>&emsp;&emsp;对于上面的步骤可能理解起来不太直观，下面我们利用一个例子来帮助理解，我们假定源图谱U的大小为4×4，目的图谱V的大小为3×3，如下图所示</p><p><img src="https://img-blog.csdn.net/20180407104939387?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>如果我们想要知道V中某点的坐标值，以V的中心点为例，我们先计算出V反向投影到U的坐标值$(x_{i,j},y_{i,j})$</p><p><img src="https://img-blog.csdn.net/20180407105124903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><script type="math/tex; mode=display">x_{i,j}=1*\frac{4}{3}=1.333，y_{i,j}=1*\frac{4}{3}=1.333</script><p>然后，利用上面的公式计算$V_{c,i,j}$的值</p><script type="math/tex; mode=display">V_{c,i,j}=95*0.667*0.667+32*0.667*0.333+156*0.333*0.667+84*0.333*0.333=93.336\approx 93</script><p><img src="https://img-blog.csdn.net/20180407110041733?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>最终，对于$B$个候选区域，我们会得到形式为$B×C×X×Y$的一个张量，这就是localization layer的最终输出。</p><h3 id="识别网络（Recognition-Network）"><a href="#识别网络（Recognition-Network）" class="headerlink" title="识别网络（Recognition Network）"></a>识别网络（Recognition Network）</h3><p>&emsp;&emsp;识别网络以一个全连接的神经网络，它接受的是来自定位层的候选区域的特征矩阵（定长）。将每个候选区域的特征拉伸成一个一维列向量，令其经过两层全连接层，每次都使用ReLU激活函数和Dropout优化原则。最终，对于每一个候选区域，都会生成一个长度为$D=4096$的一维向量。<br>&emsp;&emsp;将所有的正样本的存储起来，形成一个$B×D$形状的矩阵，将该矩阵传送到RNN语言模型中。<br>另外，我们允许识别网络对候选区域的置信分数和位置信息进行二次精修，从而生成每个候选区域最终的置信分数和位置信息，这一次的精修与之前的box regression基本是一样的，只不过是针对这个长度$D$的向量又进行了一次box regression而已（在R-CNN论文中已经指出，理论上是可以通过迭代使用box regression来不断让候选区域无限逼近真实区域的，不过实现表明，对最终的结果提升并不大）。</p><h3 id="RNN语言模型（RNN-Language-Model）"><a href="#RNN语言模型（RNN-Language-Model）" class="headerlink" title="RNN语言模型（RNN Language Model）"></a>RNN语言模型（RNN Language Model）</h3><p>&emsp;&emsp;将图片的特征图谱输入到RNN语言模型当中，从而获得基于图片内容的自然语言序列。基本方法是将识别网络的输出结果进行编码（每一个候选区域到对应一个编码），记为$x_{-1}=CNN（I）$，然后将该区域对应的真实描述$s_1,…,s_T$也进行编码，记为$x_1,…x_T$，这里，$x_i$就是对应的$s_i$的向量编码。于是，我们就得到了长度为T+2的单词向量序列$x_{-1},x_0,x_1,…,x_T$，其中$x_{-1}$代表这候选区域的图像信息，$x_0$是特殊的开始标志，$x_1,…x_T$代表每一个单词的向量编码，将这T+2长度的向量序列feed到RNN中，训练出一个预测模型。<br>接着，在预测阶段，训练好的RNN语言模型的 <strong>输入是$x_{-1}$和$x_0$</strong> （START token），然后根据公式$h_t,y_t=f(h_{t-1},x_t)$分别计算出隐藏状态$h_0$和单词向量$y_0$。这里，$y_t$是一个长度为$|V|+1$的向量，$V$代表词库的size，多出来的1是一个特殊的END标志，根据$y_0$预测出第一个word，然后将该word再作为下一层LSTM网络（RNN中的语言模型网络）的输入，预测出第二个word，一直 <strong>递归</strong> 的重复这个过程，直到输出的word是END标志为止。该预测过程可以用下面的公式和两张示意图表示。</p><script type="math/tex; mode=display">x_{-1}=CNN(I)$$$$x_t=W_eS_t，t\in \{ 0...N-1 \} $$$$p_{t+1}=LSTM(x_t)，t\in \{ 0...N-1\}</script><p>&emsp;&emsp;上式中，$x_{-1}$代表$CNN$生成的$D$维图像特征向量，并且它将作为整个$RNN$语言模型的初始输入，$S_t$代表RNN模型生成的一个个单词（word），其中$S_0$是一个特殊的开始标志，$p_{t+1}$代表第$t+1$个单词在整个单词表中的分布率，它是$p(S_{t+1}|I,S_0,…,S_t)$的简写形式，之后，选取$p_t$概率最大的元素作为句子中第$t$个单词的输出，如果概率最大的元素对应的是$END$标识符，则句子生成结束，迭代终止。</p><p><img src="https://img-blog.csdn.net/20180331141915321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180331141925286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>有关RNN模型生成图片描述的详细介绍可以参考下面两篇论文：<br><strong>Show and Tell: A Neural Image Caption Generator</strong><br><a href="https://arxiv.org/abs/1411.4555" target="_blank" rel="noopener">https://arxiv.org/abs/1411.4555</a><br><strong>Deep Visual-Semantic Alignments for Generating Image Descriptions</strong><br><a href="https://arxiv.org/abs/1412.2306" target="_blank" rel="noopener">https://arxiv.org/abs/1412.2306</a></p><h2 id="损失函数（Loss-function）"><a href="#损失函数（Loss-function）" class="headerlink" title="损失函数（Loss function）"></a>损失函数（Loss function）</h2><p>&emsp;&emsp;这篇文章训练时的损失函数有五个，如下图所示，首先是lacalization layer定位层的边框位置回归和置信分数两处损失函数，前者使用<strong>smooth L1 loss</strong>，后者使用<strong>binary logistic loss</strong>。损失函数的数学定义可以参考Fast R-CNN和Faster R-CNN里面的损失函数。<br>&emsp;&emsp;接下来是Recognition Network的两处损失函数，该层和localization layer一样，也是边框位置和置信分数两个损失函数，最后是语言模型的损失函数，采用的取交叉熵（cross-entropy）损失函数。<br>&emsp;&emsp;作者利用bathch size和sequence length对所有的损失函数都进行了归一化。经过不断测试，作者发现将后续区域边框的初始权重设为0.1，将图片描述的置信权重设为1.0，是比较高效率的初始化设置。<br>文中并没有对损失函数给出详细定义，通过查阅相关论文后，得到了各个损失函数的详细定义如下：</p><p><strong>置信度损失函数（binary logistic loss）</strong><br>  : <script type="math/tex">l(w,b)=-\sum_{i=1}^{m}lnP(y_i|x_i;w,b)$$$$P(y=1|x)=\frac{e^{w^Tx+b}}{1+e^{w^Tx+b}}$$$$P(y=0|x)=\frac{1}{1+e^{w^Tx+b}}</script>这里，$w$为矩阵，$b$为向量，$x_i$是输入的图像区域的特征图谱，$y_i$为期望的真实输出（is or not object）</p><p><strong>边框位置回归损失函数（smooth L1 loss）</strong><br>: <script type="math/tex">L_{loc}(t^u,v)=\sum_{i\in \{x,y,w,h\}}smooth_{L_1}(t_i^u-v_i)</script></p><script type="math/tex; mode=display">smooth_{L_1}(x)=\begin{cases} 0.5x^2& \text{if |x|<1} \\|x|-0.5& \text{otherwise} \end{cases}</script><p>公式中，$t^u=(t_x^u,t_y^u,t_w^u,t_h^u)$代表了预测边框的位置信息，$v=(v_x,v_y,v_w,v_h)$代表了真实边框的位置信息</p><p><strong>交叉熵损失函数</strong><br>: <script type="math/tex">L(I,S)=-\frac {1}{T} \sum_{t=1}^{T}logp_t(x_t)</script>这里，$I$代表image，$S$代表sentence，$S_t$代表sentence中的第$t$个word，$p_t$代表第$t$个word的预测分布，因为要使损失函数最小，所以每次我们都选择概率最大的word。注意到这里的交叉熵损失函数比起完整的定义来说，缺少了真实分布P，这是因为在自然语言模型中，我们无法获取语句的真实分布，因此，需要用交叉熵的估计值进行代替。</p><p><img src="https://img-blog.csdn.net/20180331142156199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="训练和优化"><a href="#训练和优化" class="headerlink" title="训练和优化"></a>训练和优化</h2><p>&emsp;&emsp;我们用预训练ImageNet的权重来初始化CNN，其他权重的取值来源于标准差为0.01的高斯分布。CNN中权重的训练使用了momentum为0.9的SGD，其他的权重使用了Adam算法。学习速率分别为$\beta_1=0.9$和$\beta_2=0.99$。CNN的fune-tuning在迭代一轮后就开始了，但是不包含CNN中的前四个卷积层的微调。<br>&emsp;&emsp;训练时的batches由一张长边为720像素的图片构成（在该图片中选取B个候选区域组成mini-batch）。源码实现采用的是Torch7，在Titan X GPU上面一次mini batch的运行时间是300ms。训练模型直到收敛的运行时间总共花费了3天<br>源码地址：<a href="https://github.com/jcjohnson/densecap" target="_blank" rel="noopener">https://github.com/jcjohnson/densecap</a><br>源码实现教程（中文）：<a href="https://github.com/jcjohnson/densecap" target="_blank" rel="noopener">https://github.com/jcjohnson/densecap</a></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>程序运行示例：</p><p><img src="https://img-blog.csdn.net/20180331144328891?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>图片描述精确度以及程序运行时间</p><p><img src="https://img-blog.csdn.net/20180331144407700?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>bonus task：根据语言图片检索图片</p><p><img src="https://img-blog.csdn.net/20180331144427786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzd3MwMjkyNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇论文的亮点在于提出了一个FCLN结构，并且利用双线性插值使得localization layer可导，从而可以支持从图片区域到自然语言描述之间的端到端训练，并且实验结果表现，当前的网络结构相较于以前的网络结构，不论是在生成的图片描述的质量上，还是在生成速度上，都有一定的提升。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文解读 </tag>
            
            <tag> 图片描述 image captioning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《TensorFlow实战Google深度学习框架》</title>
      <link href="/z_post/TensorFLow-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-TF%E5%AE%9E%E6%88%98Google%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
      <url>/z_post/TensorFLow-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-TF%E5%AE%9E%E6%88%98Google%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《C++ PrimerPlus》 第九章～第十一章</title>
      <link href="/z_post/Cpp-Book-CppPrimerPlusChapter9_11/"/>
      <url>/z_post/Cpp-Book-CppPrimerPlusChapter9_11/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章 预备知识"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">第一章 预备知识</a></h1><h1 id="第二章-开始学习C"><a href="#第二章-开始学习C" class="headerlink" title="第二章 开始学习C++"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C">第二章 开始学习C++</a></h1><h1 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章 处理数据"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE">第三章 处理数据</a></h1><h1 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B">第四章 复合类型</a></h1><h1 id="第五章-循环和关系表达式"><a href="#第五章-循环和关系表达式" class="headerlink" title="第五章 循环和关系表达式"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F">第五章 循环和关系表达式</a></h1><h1 id="第六章-分支语句和逻辑运算符"><a href="#第六章-分支语句和逻辑运算符" class="headerlink" title="第六章 分支语句和逻辑运算符"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">第六章 分支语句和逻辑运算符</a></h1><h1 id="第七章-函数——C-的编程模块"><a href="#第七章-函数——C-的编程模块" class="headerlink" title="第七章 函数——C++的编程模块"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C-%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97">第七章 函数——C++的编程模块</a></h1><h1 id="第八章-函数探幽"><a href="#第八章-函数探幽" class="headerlink" title="第八章 函数探幽"></a><a href="https://hellozhaozheng.github.io/z_post/2017-11-08-CppPrimerPlus/#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD">第八章 函数探幽</a></h1><h1 id="第九章-内存模型和名称空间"><a href="#第九章-内存模型和名称空间" class="headerlink" title="第九章 内存模型和名称空间"></a>第九章 内存模型和名称空间</h1><h2 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h2><ul><li><strong>头文件中常包含的内容：</strong> （不能将函数定义放在头文件中，容易出现重定义错误）  p301<ul><li>函数原型</li><li>使用#define或const定义的符号常量</li><li>结构声明 （结构声明不创建变量，只是告诉编译器如果创建该结构变量）</li><li>类声明</li><li>模板声明</li><li>内联函数</li></ul></li><li><p>在同一个文件中只能将同一个头文件包含一次，利用下述C/C++技术可以避免多次包含同一个头文件。p302</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef COORDIN_H_</span><br><span class="line">#define COORDIN_H_</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p><strong>多个库的链接：</strong> 不同的编译器可能会为同一个函数生成不同的修饰名称（取决于编译器设计人员），名称的不同将使链接器无法将一个编译器生成的函数调用与另一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有对象文件或库都是由同一个编译器生成的。（如果有源代码，通常可以用自己的编译器重新编译源代码来消除链接错误）。p304</p></li></ul><h2 id="存储持续性、作用域和链接性"><a href="#存储持续性、作用域和链接性" class="headerlink" title="存储持续性、作用域和链接性"></a>存储持续性、作用域和链接性</h2><ul><li>C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间：p304<ul><li>自动存储持续性</li><li>静态存储持续性</li><li>线程存储持续性（C++11）</li><li>动态存储持续性</li></ul></li></ul><h3 id="作用域和链接"><a href="#作用域和链接" class="headerlink" title="作用域和链接"></a>作用域和链接</h3><ul><li>作用域（scope）描述了名称在文件（翻译单元）的多大范围可见。链接性（linkage）描述了名称如何在不同单元间共享。 自动变量的名称没有链接性，因为它们不能共享。p305</li><li>全局作用域是名称空间作用域的特例。 p305</li></ul><h3 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h3><ul><li><strong>C++11中的auto：</strong> 在C++11中，auto关键字用于自动类型推断。但在C语言和以前的C++版本中，auto用于显式的指出变量为自动存储（实际中很少很使用，因为默认就是自动存储类型）。在C++11中，这种用法不再合法。p307</li><li>函数及其中的变量存放于“栈”中——这是专门流出来的一段内存，栈的长度由具体的实现决定。p308</li><li>寄存器变量：在C++11中，关键字register的作用只是显示地指出变量是自动的。鉴于它只能用于原本就是自动的变量，使用它的唯一原因是，指出程序员想使用一个自动变量。保留该关键字的原因是避免使用了该关键字的现有代码非法。p309</li></ul><h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><ul><li>和C语言一样，C++也为 <strong>静态</strong> 存储持续性变量提供了3种链接性，这三种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。p309<ul><li>外部链接性（可在其他文件中访问）</li><li>内部链接性（只能在当前文件中访问）</li><li>无链接性（只能在当前函数或代码块中访问，与自动变量不同的是，就算不在函数中，变量也存在，只是不能访问）</li></ul></li><li>由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地初始化静态变量，编译器将把它设置为0。在默认情况下，<strong>静态</strong> 数组和结构将每个元素或成员的所有位都设置为0。p309</li><li><p>创建三种链接性的静态持续变量：p309</p><ul><li>外部链接性：必须在代码块的外面声明</li><li>内部链接性：必须在代码块的外面声明，并使用static限定符</li><li>无链接性：必须在代码块内部声明，并使用static限定符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int global = 1000; //静态持续变量，外部链接性，作用域为整个文件</span><br><span class="line">static int one_file = 50; //静态持续变量，内部链接性，作用域为整个文件</span><br><span class="line">int main()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">void funct1(int n)&#123;</span><br><span class="line">  static int count = 0; //静态持续变量，无链接性，作用域为局部</span><br><span class="line">  int llama = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>五种变量存储方式：p310</p><ul><li>自动</li><li>寄存器</li><li>静态，无链接</li><li>静态，外部链接</li><li>静态，内部链接</li></ul></li><li><strong>关键字重载：</strong> 关键字的含义取决于上下文，static用于局部声明，以指出变量是无链接性的静态变量时，表示的是存储持续性。而用于代码块外的声明时，static表示内部链接性，因为位于代码块外的变量已经是静态持续性了。p310</li><li><strong>静态变量的初始化：</strong> 静态变量有三种初始化方式：零初始化（变量设为零）、常量表达式初始化和动态初始化。 零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件时初始化变量，动态初始化意味着变量将在编译后初始化。p310</li><li><strong>静态变量的初始化过程：</strong> 首先，所有静态变量都被零初始化，而不管程序员是否显式地初始化了它。接下来，如果使用常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可计算表达式，编译器将执行常量表达式初始化。必要时，编译器将执行简单计算。最后，剩下的变量将被动态初始化。 常量表达式并非只能是使用字面常量的算术表达式。（sizeof运算符也可以）p310</li><li>链接性为外部的变量通常简称为外部变量，也称全局变量，它们的存储持续性为静态，作用域为整个文件。p310</li></ul><h3 id="静态持续性、外部链接性"><a href="#静态持续性、外部链接性" class="headerlink" title="静态持续性、外部链接性"></a>静态持续性、外部链接性</h3><ul><li><p><strong>单定义规则（One Definition Rule，ODR）：</strong> 变量只能定义一次。为满足这种需求，C++提供了两种变量声明：p311</p><ul><li>定义声明（简称定义）：为变量分配存储空间。</li><li>引用声明（简称声明）：不给变量分配存储空间，引用已有的变量。使用关键字extern<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double up; //定义声明</span><br><span class="line">exterm int blem; //blem在别处定义</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字extern声明它。p311</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//file01.cpp</span><br><span class="line">extern int cats = 20; // 由于初始化，所以这里是定义而非声明</span><br><span class="line">int dogs = 22;  //定义</span><br><span class="line">//即使去掉file01.cpp文件中的extern也无妨，效果相同。</span><br><span class="line">//file02.cpp</span><br><span class="line">extern int cats;  //使用extern且无初始化，说明使用的是其他文件的cats</span><br><span class="line">extern int dogs;  //同上</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态持续性、内部链接性"><a href="#静态持续性、内部链接性" class="headerlink" title="静态持续性、内部链接性"></a>静态持续性、内部链接性</h3><ul><li>将作用域为整个文件的变量声明为静态外部变量（内部链接性），就不必担心其名称与其他文件中的外部变量发生冲突<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//file1</span><br><span class="line">int errors = 20;</span><br><span class="line"></span><br><span class="line">//file2</span><br><span class="line">int errors = 5;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cout&lt;&lt;errors; //报错，errors与file1中的外部变量重定义</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解决方法：file2</span><br><span class="line">static int errors = 5;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cout&lt;&lt;errors; // 输出5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态存储持续性、无链接性"><a href="#静态存储持续性、无链接性" class="headerlink" title="静态存储持续性、无链接性"></a>静态存储持续性、无链接性</h3><ul><li>局部静态变量：虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。因此在两次函数调用之间，静态局部变量的值将 <strong>保持不变</strong> 。另外，如果初始化了静态局部变量，则程序 <strong>只在启动时进行一次初始化</strong> 。以后再调用函数时，将不会被再次初始化。p315</li></ul><h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><ul><li>存储说明符（storage class specifier）：p317<ul><li>auto（在C++11中不再是说明符）</li><li>register</li><li>static</li><li>extern</li><li>thread_local（C++11新增的）</li><li>mutable：即使结构（或类）变量为const，其某个成员也可以被修改</li></ul></li><li>cv-限定符（cv-qualifer）：p317<ul><li>const：内存被初始化后，程序便不能再对它进行修改</li><li>volatile：即使程序代码没有对内存单元进行修改，其值也可能发生变化</li></ul></li><li>在默认情况下全局变量的链接性为外部，但const全局变量的链接性为内部。因此，将一组常量放在头文件中，其他引用该头文件的文件都相当于自己定义了私有的常量，这就是能够将常量定义放在头文件中而不会重定义的原因。p318</li><li>如果处于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性，<code>extern const int states = 50;</code>，在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它。p318</li></ul><h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><ul><li>C++不允许在一个函数中定义另一个函数，因此所有函数的存储持续性都自动为静态，即在整个程序执行期间都一直存在。p318</li><li>在默认情况下，函数的链接性为外部。即可以在文件间共享，使用extern来指出函数实在另一个文件中定义的（可选）。p318</li><li>可以使用关键字static将函数的链接性设置为内部，使之只能在一个文件中使用，必须同时在原型和函数定义中使用该关键字。p318</li><li><strong>内联函数不受单定义规则的约束，这允许程序员能够将内联函数的定义放在头文件中。但是C++要求同一个函数的所有内联定义都必须相同。</strong> p319</li><li>C++查找函数顺序：静态（在本文件中找）——外部（在所有的程序文件中找）——在库函数中找。因此如果定义了一个与库函数同名的函数，编译器优先使用程序员定义的版本（C++不推荐这样做）。p319</li></ul><h3 id="语言链接性"><a href="#语言链接性" class="headerlink" title="语言链接性"></a>语言链接性</h3><ul><li>不同的语言采用了不同的链接性，为了解决这种问题，需要特别指定函数采用的链接性（默认为C++链接性）。p319</li></ul><h3 id="存储方案和动态分配"><a href="#存储方案和动态分配" class="headerlink" title="存储方案和动态分配"></a>存储方案和动态分配</h3><ul><li>前面介绍的分配内存的5种方案（线程内存除外），它们不适用于C++运算符new分配的内存，这种内存被称为动态内存。动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。 p320</li><li><p>使用new运算符初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//如果要为内置的标量类型分配存储空间并初始化，可在类型名后面加上括号和初始值</span><br><span class="line">int *pi = new int(6);</span><br><span class="line">double *pd = new double(99.99);</span><br><span class="line"></span><br><span class="line">//如果要初始化常规结构或数组，需要用大括号的列表初始化，这要求编译器支持C++11.</span><br><span class="line">struct where &#123;double x; double y; double z;&#125;;</span><br><span class="line">where *one = new where&#123;2.5, 5.3, 6.2&#125;;</span><br><span class="line">int *ar = new int [4]&#123;2,4,6,8&#125;;</span><br><span class="line">//列表初始化也可以用于单值变量</span><br><span class="line">int *pin = new int&#123;6&#125;;</span><br><span class="line">double *pdo = new doubel&#123;99.99&#125;;</span><br></pre></td></tr></table></figure></li><li><p>new失败时，在最初的10年中，C++在这种情况下让new返回空指针，但现在将引发异常std::bad_alloc。p320</p></li><li><p>运算符new和new[]分别调用函数1和2，同样delete和delete[]调用3和4。p320</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void * operator new(std::size_t);</span><br><span class="line">void * operator new[](std::size_t);</span><br><span class="line">void * operator delete(void *);</span><br><span class="line">void * operator delete[](void *);</span><br><span class="line"></span><br><span class="line">//std::size_t是一个typedef，对应于合适的整型</span><br><span class="line">int *pi = new int;//该式会被转换为下式</span><br><span class="line">int *pi = new(sizeof(int));</span><br><span class="line">int *pa = new int[40];//同样，转换为下式</span><br><span class="line">int *pa = new(40*sizeof(int));</span><br><span class="line">delete pi;//同样，转换为下式</span><br><span class="line">delete(pi);</span><br></pre></td></tr></table></figure></li><li><p>定位new运算符。p321</p></li></ul><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><h3 id="传统的C-名称空间"><a href="#传统的C-名称空间" class="headerlink" title="传统的C++名称空间"></a>传统的C++名称空间</h3><ul><li>一些基本术语：p324<ul><li>声名区域：变量可以进行声明的区域。对于全局变量，其声明区域为所在的文件，对于局部变量，其声明区域为所在的代码块。</li><li>潜在作用域：变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声名区域小。</li><li>作用域：变量对程序而言可见的范围。变量并非在其潜在作用域内的任何位置都可见，如被另一个嵌套声明区域中的同名变量隐藏。作用域小于潜在作用域。</li></ul></li></ul><h3 id="新的名称空间特性"><a href="#新的名称空间特性" class="headerlink" title="新的名称空间特性"></a>新的名称空间特性</h3><ul><li><p>一个名称空间中的名称不会和另一个名称空间的相同名称发生冲突，利用新的关键字namespace可以创建名称空间：p325</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespce Jack&#123;</span><br><span class="line">  double pail;</span><br><span class="line">  void fetch();</span><br><span class="line">&#125;</span><br><span class="line">namespace Jill&#123;</span><br><span class="line">  double fetch;</span><br><span class="line">  int pal;</span><br><span class="line">&#125;</span><br><span class="line">//名称空间是开放的，可以重复使用namespace来将名称添加到名称空间中</span><br><span class="line">namespace Jack&#123;</span><br><span class="line">  char * goose(const char*); //将goose添加到Jack名称空间（已有pail和fetch）</span><br><span class="line">&#125;</span><br><span class="line">//可以在另一个文件中使用namespce为函数原型写出定义</span><br><span class="line">namespace Jack&#123;</span><br><span class="line">  void fetch()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用作用域解析运算符来使用名称空间</span><br><span class="line">Jack::pail = 12.35;</span><br><span class="line">Jill::pal = 1;</span><br><span class="line">Jack::fetch();</span><br></pre></td></tr></table></figure></li><li><p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。保持，在默认情况下，在名称空间中声明的名称的链接性是外部的（除非使用了const）。p326</p></li><li><strong>using声明和using编译指令：</strong> p326<ul><li>using声明：<code>using Jack::fetch</code> 使特定的标识符可用（可以用在代码块中）。</li><li>using编译指令：<code>using namespace Jack</code> 使整个名称空间可用（可以用在代码块中，放在代码块中时，虽然它只在该代码块中可见，但是其作用域不是布局的）。p328</li></ul></li><li>使用using编译指令和使用多个using声明是不一样的。假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，则这两个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。p328</li><li>推荐使用using声明而不是using编译指令，因为前者更安全。在引入的名称有相同局部名称时，前者会发出错误提示，后者只会隐藏名称空间版本而不进行提示。p329</li><li>名称空间可以嵌套：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">namespce elements&#123;</span><br><span class="line">  namespce fire&#123;</span><br><span class="line">    int flame;</span><br><span class="line">  &#125;</span><br><span class="line">  using Jill::fetch;</span><br><span class="line">  using namepace Jack;</span><br><span class="line">  float water;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace elements;</span><br><span class="line">using namespace elements::fire;</span><br><span class="line">//访问Jill::fetch，由于在elements中声明了Jill::fetch，所以以下两种名称空间都可用</span><br><span class="line">Jill::fetch;</span><br><span class="line">elements::fetch;</span><br><span class="line"></span><br><span class="line">using namespace elements;//这条编译指令与下面两条编译指令等价</span><br><span class="line">using namespace elements;</span><br><span class="line">using namespace Jack;</span><br><span class="line"></span><br><span class="line">namespace ele = elements; //给elements创建别名</span><br></pre></td></tr></table></figure></li></ul><h3 id="名称空间示例"><a href="#名称空间示例" class="headerlink" title="名称空间示例"></a>名称空间示例</h3><h3 id="名称空间及其用途"><a href="#名称空间及其用途" class="headerlink" title="名称空间及其用途"></a>名称空间及其用途</h3><ul><li>指导原则：p334<ul><li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li><li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li><li>如果开发了一个函数库或类库，将其放在一个名称空间中。</li><li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权益之计。</li><li>不要在头文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用，另外，包含头文件的顺序可能影响程序的行为。</li><li>导入名称时，首选使用作用域解析运算符或using声明的办法。</li><li>对于using声明，首选将其作用域设置为局部而不是全局。</li></ul></li></ul><h1 id="第十章-对象和类"><a href="#第十章-对象和类" class="headerlink" title="第十章 对象和类"></a>第十章 对象和类</h1><h2 id="过程性编程和面向对象编程"><a href="#过程性编程和面向对象编程" class="headerlink" title="过程性编程和面向对象编程"></a>过程性编程和面向对象编程</h2><ul><li>面向对象变成（OOP），首先从用户的角度考虑对象——描述对象所需的数据以及描述用户与数据交互所需的操作。p341</li></ul><h2 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h2><h3 id="类型是什么"><a href="#类型是什么" class="headerlink" title="类型是什么"></a>类型是什么</h3><ul><li>指定基本类型完成了三项工作：p342<ul><li>决定数据对象需要的内存数量</li><li>决定如何解释内存中的位（long与float位数相同，但含义不同）</li><li>决定可使用数据对象执行的操作或方法</li></ul></li></ul><h3 id="10-2-2-C-中的类"><a href="#10-2-2-C-中的类" class="headerlink" title="10.2.2 C++中的类"></a>10.2.2 C++中的类</h3><ul><li>类规范由两个部分组成：p342<ul><li>类声明：以数据成员的方式描述数据部分，以成员函数（方法）的方式描述公有接口——提供了类的蓝图。</li><li>类方法定义：描述如何实现类成员函数——提供了类的实现细节。</li></ul></li><li>类对象成员访问类型默认为私有private。结构体成员访问类型默认为公有public。p345</li></ul><p><strong>类和结构的区别：</strong> 实际上，在C++中，对结构进行了扩展，使之具有与类相同的特性。它们之间唯一的区别是，结构的默认访问类型是public，而类的默认访问类型是private。C++程序员通常使用类来实现类描述，而把结构限制为只表示纯碎的数据对象。（看上去类可以完美替代结构体，事实上也是这样，C++保留结构体的主要原因是为了向C兼容）。</p><h3 id="实现类成员函数"><a href="#实现类成员函数" class="headerlink" title="实现类成员函数"></a>实现类成员函数</h3><ul><li><p>定义成员函数时，使用作用域解析符（::）来标识函数所属的类。类方法可以直接访问类的组件（private和public均可，并且无需使用作用域解析符）。 p345</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//无需使用public，因为在声明函数原型时已经指明了访问类型</span><br><span class="line">void Stock::update(double price)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>内联方法：</strong> 方法定义位于类声明处的函数都将自动成为内联函数。类声明常常将短小的成员函数作为内联函数。内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义，因此通常将内联定义放在定义类的头文件中。p347</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Stock&#123;</span><br><span class="line">  private:</span><br><span class="line">    int shares;</span><br><span class="line">    double share_val;</span><br><span class="line">    void set_tot() &#123;total_val = shares*share_val;&#125; //自动成为内联函数</span><br><span class="line">  public:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的每个新对象都有自己的存储空间，用于存储其内部变量和类成员。但是同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。p348</p></li></ul><h3 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h3><ul><li>要创建类对象，可以像基本类型一样声明类对象<code>Stock kate，joe; //声明了2个对象kate和joe</code>，也可以使用new为类对象分配存储空间。p349</li></ul><h3 id="修改实现"><a href="#修改实现" class="headerlink" title="修改实现"></a>修改实现</h3><ul><li>利用<code>setf()</code>控制输出格式，并将修改限定在实现文件中，以免影响程序的其他方面。p351</li></ul><h2 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h2><h3 id="声明和定义构造函数"><a href="#声明和定义构造函数" class="headerlink" title="声明和定义构造函数"></a>声明和定义构造函数</h3><ul><li>构造函数没有返回类型。并且，构造函数的形参名称不能与类成员变量的形参名称完全相同，一种常见做法是在数据成员中使用<code>m_</code>前缀，或者用this指针<code>this-&gt;company = company</code>。p353<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Stock&#123;</span><br><span class="line">  private:</span><br><span class="line">    string m_company;</span><br><span class="line">    ...</span><br><span class="line">  public:</span><br><span class="line">    Stock(const string &amp;company);更</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::Stock(const string &amp;company)&#123;</span><br><span class="line">  m_company = company;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h3><ul><li>C++提供了两种使用构造函数来初始化对象的方式。p354<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock garment = Stock(&quot;Furry&quot;);  //显示调用构造函数</span><br><span class="line">Stock garment(&quot;Furry&quot;);  //隐式调用构造函数，二者等价</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><ul><li><p>当且进党没有定义任何构造函数时，编译器会提供一个默认构造函数，它不接受任何参数，也不做任何操作。它可以使得下述语句正常运行：p354</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock cat; //隐式地调用了默认构造函数</span><br></pre></td></tr></table></figure></li><li><p>如果为类定义了构造函数，程序员就必须为它显式提供默认构造函数，除非不使用无参数的对象声明<code>Stock cat;</code>，否则会报错。定义默认构造函数的方式有两种：p354</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock(const string &amp; company = &quot;default_company&quot;); //为所有参数提供默认值</span><br><span class="line">Stock(); //函数重载定义无参数的构造函数</span><br></pre></td></tr></table></figure></li><li><p>隐式地调用默认构造函数时，不要使用圆括号：p355</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stock first(&quot;Furry&quot;); //隐式调用非默认构造函数</span><br><span class="line">Stock second(); //这是一条声明语句，指出second()是一个返回Stock对象的函数</span><br><span class="line">Stock third; //隐式调用默认构造参数</span><br><span class="line">Stock third = Stock(); //显式调用默认构造参数</span><br></pre></td></tr></table></figure></li><li><p>接受一个参数的构造函数（或者其它的参数提供了默认值）允许使用赋值语法将对象初始化为一个值。p362</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classname object = value;</span><br></pre></td></tr></table></figure></li><li><p>带参数的构造函数也可以是默认的构造函数，只要所有参数都有默认值。但是只能有一个默认构造参数，也就是说，一旦所有参数都提供了默认值，就不能再声明无参数的构造函数，否则会产生二义性错误。 p433</p></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li><p>如果程序员没有提供析构函数，编译器将隐式的声明一个析构函数，析构函数没有返回类型，也没有参数，在声明时，需要在类型前加上波浪号：p355</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Stock&#123;</span><br><span class="line">  public:</span><br><span class="line">    ~Stock(); //声明  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::~Stock()&#123; //定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译器调用析构函数的时机：p356</p><ul><li>静态存储类对象：在程序结束时自动被调用</li><li>自动存储类对象：在程序执行完代码块时自动被调用</li><li>new创建的对象：当使用delete来释放对象内存时自动被调用</li></ul></li><li><p>构造函数的另一种用法——赋值。语句1为初始化语句，语句2为赋值语句，构造函数会创建一个 <strong>临时</strong> 的对象，然后将该对象的值赋给已经存在的对象stock1，之后编译器会自动调用析构函数 <strong>删除该临时对象</strong> 。p361</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stock stock1 = Stock(&quot;test1&quot;);</span><br><span class="line">stock1 = Stock(&quot;test2&quot;);</span><br><span class="line">//如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式，通常这种方式的效率更高。</span><br></pre></td></tr></table></figure></li><li><p>可以使用C++11的列表初始化方式来作用于类，前提是提供了相应的构造函数。p361</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock hot_tip = &#123;&quot;Plus&quot; ,100, 45.0&#125;;</span><br><span class="line">Stock jock&#123;&quot;Sport&quot;&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>以上两个声明中，用大括号括起的列表与下面的构造函数匹配：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock::Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; co,  <span class="keyword">long</span> n =<span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure></p><p>另外，C++11还提供了名为<code>std::initialize_list</code>的类，可将其用作函数参数或方法参数的类型。这个类可表示任意长度的列表，只要所有的列表项的类型都相同或可转换为相同的类型。（在16章介绍）。</p><ul><li>C++的成员函数如果不修改调用对象，则应将其声明为const，将const关键字放在函数的括号后面。（放在前面就变成了返回类型为const double了）p362<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Stock&#123;</span><br><span class="line">    public:</span><br><span class="line">      double show() const; //const成员函数声明</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Stock::show() const&#123; //const成员函数定义</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ul><li>this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。一定要注意this是一个指向对象的指针，所以在使用时要按照指针的方式。p364<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;shares; //用间接成员运算符-&gt;引用对象的成员</span><br><span class="line">return *this; //返回this指向的对象</span><br></pre></td></tr></table></figure></li></ul><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><ul><li><p>利用对象数组可以创建同一个类的多个对象。p368</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stock mystuff[4]; //调用默认构造函数</span><br><span class="line">Stock stocks[4]=&#123;  //为每个元素调用指定的构造函数</span><br><span class="line">  Stock(&quot;NanoSmar&quot;);</span><br><span class="line">  Stock();  //显示调用默认构造函数</span><br><span class="line">  //stocks[2]和stock[3]未指明构造函数，将调用默认构成函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。p369</p></li></ul><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><ul><li>C++类引入了一种新的作用域：类作用域。在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。要调用公有成员函数，必须通过对象访问。同样，在定义成员函数时，必须使用作用域解析符。</li></ul><h3 id="作用域为类的常量"><a href="#作用域为类的常量" class="headerlink" title="作用域为类的常量"></a>作用域为类的常量</h3><ul><li>直接在类中声明const常量是非法的，因为声明类只是描述了对象的形式，并没有创建对象。因此，在创建对象前，将没有用于储存值的空间。p371</li><li>实现“类的常量”的两种方式：<ul><li>方式1：使用枚举，在类中声明一个枚举，用枚举为 <strong>整型常量</strong> 提供作用域为整个类的符号名称。</li><li>方式2：使用static，这将创建一个常量，该常量将于其他静态变量存储在一起，而不是存储在对象中。该常量被所有的类对象共享。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Bakery&#123;</span><br><span class="line">  private:</span><br><span class="line">    const int Months = 12; //非法，无法编译</span><br><span class="line">    enum &#123;Months = 12&#125;; //未提供枚举名，这种方式声明枚举并不会创建类数据成员，Months只是一个符号名称，在编译时，将用12来替换它。</span><br><span class="line">    static const int Months = 12; //C++98中，不能存储double常量，C++11消除了这种限制</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="作用域内枚举"><a href="#作用域内枚举" class="headerlink" title="作用域内枚举"></a>作用域内枚举</h3><ul><li><p>传统的枚举如果两个枚举定义中的枚举量名称相同，则会发生冲突，C++利用类作用域的方法消除了这种冲突。p372</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//传统枚举量，产生冲突</span><br><span class="line">enum egg &#123;Small, Medium, Large, Jumbo&#125;;</span><br><span class="line">enum t_shirt &#123;Small, Medium, Large, Xlarge&#125;;</span><br><span class="line">//类作用域，不冲突。 也可以利用关键字struct代替class。</span><br><span class="line">enum class egg &#123;Small, Medium, Large, Jumbo&#125;;</span><br><span class="line">enum class t_shirt &#123;Small, Medium, Large, Xlarge&#125;;</span><br><span class="line">//使用时用枚举名和作用域解析符来限定枚举量：</span><br><span class="line">egg choice = egg::Large;</span><br><span class="line">t_shirt t_choice = t_shirt::Large;</span><br></pre></td></tr></table></figure></li><li><p>C++11还提高了作用域内枚举的类型安全，在有些情况下，常规枚举将自动转换为整型，如将其赋给int变量或用于比较表达式时，但作用域内枚举不能隐式地转换为整型。p372</p></li><li>枚举有某种底层整型类型表示，在C++98中，如何选择取决于实现，因此包含枚举的结构的长度可能随系统而异。对于作用域内枚举，C++11消除了这种依赖性。默认情况下，C++11作用域内枚举的底层类型为int。而常规枚举的底层类型依然随实现而异。另外，C++11提供了指定底层类型的语法。p372<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum class :short pizza &#123;Small,Medium,Large,XLarge&#125;; //:short将底层类型指定为short</span><br></pre></td></tr></table></figure></li></ul><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ul><li>类很适合描述ADT。公有成员函数接口提供了ADT描述的服务，类的私有部分和类方法的代码提供了实现，这些实现对类的客户隐藏。p373</li></ul><h1 id="第十一章-使用类"><a href="#第十一章-使用类" class="headerlink" title="第十一章 使用类"></a>第十一章 使用类</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ul><li>要重载运算符，需使用被成为运算符函数的特殊函数形式。<code>op</code>必须是有效的C++运算符，不能虚构一个新的符号。p381<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">operatorop(argument-list)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Stock::operator+(...)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Stock::operator*(...)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//当编译器发现了运算符的操作数是对应的对象是，会自动替换运算符为重载函数</span><br><span class="line">stock3 = stock1 + stock2; //左侧的操作数为调用对象，右侧为重载函数的参数</span><br><span class="line">stock3 = stock1.operator+(stock2); //用operaotr+重载函数替换“+”</span><br></pre></td></tr></table></figure></li></ul><h2 id="计算时间：一个运算符重载示例"><a href="#计算时间：一个运算符重载示例" class="headerlink" title="计算时间：一个运算符重载示例"></a>计算时间：一个运算符重载示例</h2><h3 id="添加加法运算符"><a href="#添加加法运算符" class="headerlink" title="添加加法运算符"></a>添加加法运算符</h3><ul><li>对于连加或连乘，需要函数返回的是正确的对象类型。p387<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t4 = t1 + t2 + t3;</span><br><span class="line">t4 = t1.operator+(t2.opertor+(t3)); //当operator+返回的函数类型复合其参数列表要求时，合法。</span><br></pre></td></tr></table></figure></li></ul><h3 id="重载限制"><a href="#重载限制" class="headerlink" title="重载限制"></a>重载限制</h3><ul><li>重载的运算符不必是成员函数，但必须至少有一个操作数是用户定义的类型，这是为了防止用户为标准类型重载运算符。p387</li><li>使用运算符时不能违反运算符原来的语法规则，如双目不能重载成单目，同时，重载不会修改运算符的优先级。p387</li><li>不能创建新的运算符。p387</li><li>不能重载下面的运算符： p387<ul><li>“sizeof”运算符</li><li>“.”成员运算符</li><li>“.* ”成员指针运算符</li><li>“::” 作用域解析运算符</li><li>“? :” 三目条件运算符</li><li>“typeid” 一个RTTI运算符</li><li>“const_cast” 强制类型转换运算符</li><li>“dynamic_cast” 强制类型转换运算符</li><li>“reinterpret_cast” 强制类型转换运算符。</li><li>“static_cast” 强制类型转换运算符</li></ul></li><li>大多数运算符都可以通过成员或非成员函数进行重载，但下面 的运算符只能通过成员函数进行重载： p387<ul><li>“=” 赋值运算符</li><li>“()” 函数调用运算符</li><li>“[]” 下标运算符</li><li>“-&gt;” 通过指针访问类成员的运算符</li></ul></li></ul><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul><li>除了private，public和protect控制的类访问权限外，C++提供了另外一种形式的方式权限：友元。通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。友元有3种： p391<ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul></li></ul><h3 id="创建友元"><a href="#创建友元" class="headerlink" title="创建友元"></a>创建友元</h3><ul><li><p>创建友元的第一步是将其原型 <strong>放在类声明中</strong> ，并在原型声明前加上关键字friend：p391</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">friend Time operator*(double m, const Time &amp; t);</span><br><span class="line">//可以解决2.85*time的乘法重载的问题，2.85不是Time对象，因此无法调用成员重载函数，需要借助友元非成员函数实现。</span><br><span class="line">//该声明意味着：1、虽然该函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用; 2、虽然该函数不是成员函数，但它与成员函数的访问权限相同。</span><br></pre></td></tr></table></figure></li><li><p>编写友元函数的定义。因为它不是成员函数，所以无需使用<code>类名::</code>限定符，另外，定义时不要在函数头使用关键字<code>friend</code>。p392</p></li></ul><h3 id="常用的友元：重载-lt-lt-运算符"><a href="#常用的友元：重载-lt-lt-运算符" class="headerlink" title="常用的友元：重载&lt;&lt;运算符"></a>常用的友元：重载&lt;&lt;运算符</h3><ul><li>cout是一个ostream对象，对于每种基本类型ostream类声明中都包含了相应的重载的operator&lt;&lt;()定义。因此，对于不同的基本类型，&lt;&lt;运算符在cout对象中可以表现出不同行为。p392</li><li><p><strong>&lt;&lt;的第一种重载版本</strong>  如果直接通过类声明来重载<code>operator&lt;&lt;()</code>函数，那么在使用时就会像这样，<code>time&lt;&lt;cout;</code>，其中，time是Time类的实例，而cout是Time类重载函数的参数，为了看起来不那么迷惑，利用友元函数，使其第一个参数为ostream对象，这样一来，就可以使用<code>cout&lt;&lt;time</code>的形式（运算符左侧操作数是第一个参数）。p393</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void operator&lt;&lt;(ostream &amp;os, const Time &amp;t)&#123;</span><br><span class="line">  os&lt;&lt;t.hours&lt;&lt;t.minutes;  //os是cout的引用，别名，省去了拷贝副本的时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;time1; //等价于下式</span><br><span class="line">operator&lt;&lt;(cout,time1);</span><br></pre></td></tr></table></figure></li><li><p><strong>&lt;&lt;的第二种重载版本</strong> 上面的重载方法有一些问题，那就是无法使用<code>cout&lt;&lt;time1&lt;&lt;time2&lt;&lt;endl;</code>这样的形式，解决方法如下：p394</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp; os, const Time &amp; t)&#123;</span><br><span class="line">  os&lt;&lt;t.hours&lt;&lt;t.minutes;</span><br><span class="line">  return os; //返回os的引用，以便实现连续使用&lt;&lt;的操作。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="重载运算符：作为成员函数还是非成员函数"><a href="#重载运算符：作为成员函数还是非成员函数" class="headerlink" title="重载运算符：作为成员函数还是非成员函数"></a>重载运算符：作为成员函数还是非成员函数</h2><ul><li>成员函数和非成员函数的实现方法二者均可，但不能都实现，否则会产生二义性错误。p398</li></ul><h2 id="再谈重载：一个矢量类"><a href="#再谈重载：一个矢量类" class="headerlink" title="再谈重载：一个矢量类"></a>再谈重载：一个矢量类</h2><ul><li>一个应用了运算符重载和友元设计的例子——矢量类。p398</li></ul><h2 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h2><ul><li>只有一个参数的构造函数可以作为转换函数。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则也可以用于隐式转换。p413</li></ul><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><ul><li><p>转进行从对象到基本类型的转换，必须使用特殊的C++运算符——转换函数<code>operator typeName()</code>。创建转换函数时，需要注意以下几点：p415</p><ul><li>转换函数必须是类方法</li><li>转换函数不能指定返回类型</li><li>转换函数不能有参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">operator double() const; //转换为double类型的函数原型。</span><br><span class="line"></span><br><span class="line">Stonewt::operator double() const&#123;  // 转换函数的定义</span><br><span class="line">  return pounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double d = stonewt; //隐式调用转换函数</span><br><span class="line">double d = double(stonewt); //显式调用转换函数</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在进行类型转换时，一定要注意是否有二义性，如果有，编译器将产生错误。p418</p></li><li>提供执行自动、隐式的转换函数存在的问题是，在用户不希望进行转换时，转换函数也可能进行转换。消除这种隐患的方式是在转换函数原型前加上关键字<code>explicit</code>。（C++98不能将explicit用于转换函数，C++11可以）。另一种方法是使用功能相同的非转换函数，在进行转换时显式调用该函数即可。p419</li><li>总之，C++为类提供了下面的类型转换：p419<ul><li>只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。在构造函数声明中使用explicit可防止隐式转换。</li><li>被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。没有返回类型、没有参数，名为operator typeName()。</li></ul></li><li>将加法等二元运算符定义为友元可以让程序更容易适应自动类型转换。因为这会可以自动将对象类型转换成基本类型，或者将基本类型转换为对象类型进行运算。p420</li><li>将double变量与对象相加，由两种选择。一种是借助类型转换，另一种是在重载函数中显式接受double参数而不进行类型转换。 前者定义简单，但需要类型转换，增加了内存和时间开销。后面定义麻烦，需要写更多逻辑，但运行速度快。p421</li></ul>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux-Ubuntu个人必装软件</title>
      <link href="/z_post/Linux-Ubuntu%E4%B8%AA%E4%BA%BA%E5%BF%85%E8%A3%85%E8%BD%AF%E4%BB%B6/"/>
      <url>/z_post/Linux-Ubuntu%E4%B8%AA%E4%BA%BA%E5%BF%85%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h1 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h1><h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><h1 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h1><h1 id="Guake-Terminal"><a href="#Guake-Terminal" class="headerlink" title="Guake Terminal"></a>Guake Terminal</h1><h1 id="EverNote"><a href="#EverNote" class="headerlink" title="EverNote"></a>EverNote</h1><h1 id="Foxit-Reader"><a href="#Foxit-Reader" class="headerlink" title="Foxit Reader"></a>Foxit Reader</h1><h1 id="TeamViewer"><a href="#TeamViewer" class="headerlink" title="TeamViewer"></a>TeamViewer</h1><h1 id="Sogouinput"><a href="#Sogouinput" class="headerlink" title="Sogouinput"></a>Sogouinput</h1><h1 id="VMware-Workstation"><a href="#VMware-Workstation" class="headerlink" title="VMware Workstation"></a>VMware Workstation</h1><h1 id="Gparted"><a href="#Gparted" class="headerlink" title="Gparted"></a>Gparted</h1><h1 id="VCL"><a href="#VCL" class="headerlink" title="VCL"></a>VCL</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《C++ PrimerPlus》 第一章～第八章</title>
      <link href="/z_post/Cpp-Book-CppPrimerPlusChapter1_8/"/>
      <url>/z_post/Cpp-Book-CppPrimerPlusChapter1_8/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章 预备知识"></a>第一章 预备知识</h1><h2 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h2><ul><li>C++融合了三种不同的变成方式：1、C语言代表的过程性语言 2、带有类的面向对象语言 3、C++模板支持的泛型编程</li></ul><h2 id="C-简史"><a href="#C-简史" class="headerlink" title="C++简史"></a>C++简史</h2><p>20世纪70年代早期，贝尔实验室的Dennis Ritchie开发了C语言。</p><p>20世纪80年代，贝尔实验室的Bjarne Stroustrup开发了C++语言。</p><h2 id="可移植性和标准"><a href="#可移植性和标准" class="headerlink" title="可移植性和标准"></a>可移植性和标准</h2><p>C++98</p><p>C++11</p><h2 id="程序创建的技巧"><a href="#程序创建的技巧" class="headerlink" title="程序创建的技巧"></a>程序创建的技巧</h2><p>编译和链接</p><h1 id="第二章-开始学习C"><a href="#第二章-开始学习C" class="headerlink" title="第二章 开始学习C++"></a>第二章 开始学习C++</h1><h2 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h2><p>输入输出：C++能在使用printf()、scanf()和其他所有标准的C输入输出函数，只需要包含常规的C语言的stdio.h文件即可</p><p><strong>main函数：</strong></p><ul><li>main函数是被操作系统调用的，他是程序与操作系统之间的接口。p14</li><li>int main( void ) 在括号中用void明确指出，函数不接受任何参数，在CPP中，让括号空着与使用void完全等效。但是在C中，让括号空着意味着对于是否接受参数保持沉默。p15</li><li>许多程序员喜欢使用下面的函数头，并省略返回语句：<code>void main()</code>。这在逻辑上是可以理解的，大部分系统也适用，但由于它不是当前标准的内容，因此在有些系统上不能工作。新的标准中对这一点作出了让步，如果编译器到达main()函数末尾时没有遇到返回语句，则自动添加return 0语句 （只对main函数有效，对其他函数不会隐含return 0）。p15 <strong>（疑问：在测试的时候报错说main函数必须是int返回类型？同时，非main函数也可以不写明return语句，但是返回的值是6295680？？）</strong></li><li>有一些非标准函数，他们使用_tmain() 形式，这种情况下，有一个隐藏的main（）调用它，但是常规的独立程序都需要main()。p15</li></ul><p><strong>头文件名，名称空间：</strong></p><ul><li>新标准的CPP不适用头文件的.h扩展名，而利用命名空间机制。</li><li>新的cout，cin为了避免产生函数名冲突，需要使用std::cout，std::cin来使用</li><li>如果使用using namespace std； 则表示std名称空间中的所要名称都可用，但这是一个隐患，推荐使用using std::cout的方式（为了方便，大多会使用using namespace std）</li><li>p33：using namespace std可以放在main中，表示只有main可以访问其命名空间，也可以放在iostream下面，表示文件中的所有函数都能访问</li></ul><p><strong>使用cout进行输出：</strong></p><ul><li>cout是一个预定义的对象，是某个类的特定实例，&lt;&lt;符号表示它将后面的字符串发送给cout：cout&lt;&lt;string</li><li>从概念上看，输出是一个流，即从程序流出的一系列字符。cout对象表示这种流，其属性定义在iostream文件中，&lt;&lt;是cout对象的一个属性，它表示将其右侧的信息插入到流中，该符号与按位左移运算符实际上是重载关系</li><li>打印的时候，cout会将整数形式的数字自动转换成字符串形式，注意整数25与字符串25有天壤之别</li><li>endl确保程序继续运行前刷新输出？<br>控制符：诸如endl等对于cout来说有特殊含义的符号（manipulator）<br>传统Cpp不能把回车放在字符串中间，但是C++11新增的原始字符串可以包含回车</li></ul><h2 id="C-语句"><a href="#C-语句" class="headerlink" title="C++语句"></a>C++语句</h2><h2 id="其他C-语句"><a href="#其他C-语句" class="headerlink" title="其他C++语句"></a>其他C++语句</h2><ul><li>cin.get（） 一般需要两条，一条用于接受多余的换行，有一条用于让程序暂停。cin使用&gt;&gt;运算符才输入流中抽取字符。p24</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>C++函数和C一样，不允许嵌套定义。p30</li><li>main不是关键字，因为它不是语言的组成部分，可以做关键字，但最好别这样，会引起其他错误。cout也不是关键字，而是一个对象名，所以可以在不适用cout的程序中，将cout用作变量名。p31</li></ul><h1 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章 处理数据"></a>第三章 处理数据</h1><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><p><strong>变量名，符号类型：</strong></p><ul><li>CPP命名规则：以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）。p38</li><li>CPP的字节位数根据字符集的大小而定，对于基本字符集ASCII和EBCDIC来说，一字节为8为，而对于国际编程Unicode来说，一字节可能为16为或32位，int在老式机器中一般为16位，而在现在多为32位。p39</li><li>预编译指令#define是c遗留下来的，cpp中多用const关键字p42。</li><li>cpp中有一种c没有的初始化赋值语法：int a（42）。C++11具有新的初始化方式。p42</li><li>常数后缀，ul，lu，uL，LU等等都可以，均表示unsigned long常量。在cpp中，对十进制整数采用的长度规则，与16进制和8进制略有不同。p47</li><li>通用字符名，以/u开头 Unicode与ISO 10646。p52</li><li>char默认情况下既不是无符号，也不是有符号。    wcha_t 与 underlying（底层类型）  cin和cout将输入和输出看做是char流，因此不适合用来处理wchar_t类型，以l或L为前缀应用wcin和wcout。cpp11新增的char16_t  char32_t分别以u和U为前缀。p53</li></ul><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><ul><li>p54：const比#define更好，1.它可以明确指定类型，2.cpp的作用于规则将定义限制在特定的函数或头文件中，3.const可用于复杂类型，如数组和结构体</li></ul><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h2 id="C-算术运算符"><a href="#C-算术运算符" class="headerlink" title="C++算术运算符"></a>C++算术运算符</h2><ul><li>求模运算符只能用于整形。p59</li><li>对于float类型，11.17+50.25=61.419998  具体愿意是float的精度限制所导致的（将操作数转化成二进制即可理解）。p60</li><li>数值类型转换，对于精度丢失的情况，最终结果会根据系统的不同而不同。p63</li><li>c++11中的{}初始化赋值法不允许narrowing缩窄，即只能小赋给大，不能大赋给小（但是const可以，只要能hold住要赋的值即可）。p64<br>整型提升：c++在计算表达式时自动将bool char unsigned char signed char short转换为int。如果shot比int短，则unsigned short类型将被转化为int，如果长度相同，则unsigned short将被转化为unsigned int，以此确保在对unsigned short进行提升时不会损失数据。wchar_t被提升为下列类型中第一个宽度足够的类型：int，unsigned int，long，unsigned long。更多转化规则可以查看校验表p64</li><li>强制类型转化通用格式：（typeName）value；typeName（value）第一种格式来自C语法，第二种是纯粹C++语法。p65</li><li>c++11中新增了auto类型声明的用法，让编译器根据初始值的类型推断变量的类型。主要用于复杂类型。p66</li></ul><h1 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>c++中数组的arraySize只能是常量，const，或常量表达式，不能是变量。p71</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>c++11初始化数组时，可以省略等号。c++标准模板库（STL）提供了一种数组替代品模板类vector，c++11新增了模板类array。p74</li><li>‘s’表示83  “s”表示的是某块内存的地址。 cout会默认自动拼接两段字符串，并且可以不在同一行。p75</li><li>c++使用空白（空格，制表，换行）来确定字符串的结束位置。为了读取空白可以采用cin的成员函数面向行的输入：cin.getline（）和cin.get（）。二者以换行为结束，前者会舍弃换行符，后者会将其保留在输入队列中（注意是输入队列，这相当于输入缓冲区，下面读取函数有可能会读到这个换行符）。二者的返回值为cin对象，可以继续调用函数。getline（）使用起来更简单方便，但get（）更能检查出错误。另外要注意二者读取空行时的区别。p78</li></ul><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><ul><li>string对象和字符数组之间的主要区别是string对象可以声明为简单变量，类设计让程序能够自动处理string的大小。p83</li><li>原始字符串 raw。p87</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>p89：C++允许在声明结构变量时省略关键字struct。但是C不允许</li><li>p92：c++的结构特性比C更多。 位字段，共用体（长度为其最大成员长度）</li></ul><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li><p>对于枚举变量，只有赋值运算符，枚举创建的是符号常量，可以代替const。枚举量的值可以重复。p96</p></li><li><p>指针：*运算符称为间接值（indirect value）或解除引用（dereferencing）。p101：不管是指向何种类型的指针，其指针变量本身的长度是一定的。p99<br>17.10.19</p></li></ul><h2 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h2><ul><li>C++利用new关键字代替了malloc（）来分配内存：int* p=new int; 用指针和new进行的内存分配是在程序运行时进行的（只有运行时，指针才知道它指向的是哪一块地址）。p102</li><li>delete关键字只能释放new的内存，不能用于一般变量，同时，不可以重复释放，否则结果未知。 不能用sizeof运算符确定动态数组包含的字节数。p104</li></ul><h2 id="指针、数组和指针算术"><a href="#指针、数组和指针算术" class="headerlink" title="指针、数组和指针算术"></a>指针、数组和指针算术</h2><ul><li>指向数组的指针和数组名基本等价，区别是：1，指针值可以变，而数组名的值不能变。2，sizeof用在数组名上返回数组长度，用在指针上放回指针的长度。注意short tell[10];  中tell与&amp;tell的关系。p109</li><li>cout打印字符数组的关键不在于变量是一个数组名，而在于它是一个char的地址！在cout和多数c++表达式中，char数组名，char指针和双引号下的字符串常量都被解释为字符串第一个字符的地址。p109</li></ul><h1 id="第五章-循环和关系表达式"><a href="#第五章-循环和关系表达式" class="headerlink" title="第五章 循环和关系表达式"></a>第五章 循环和关系表达式</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><h2 id="基于范围的for循环（C-11"><a href="#基于范围的for循环（C-11" class="headerlink" title="基于范围的for循环（C++11)"></a>基于范围的for循环（C++11)</h2><ul><li>c++11新增了一种基于范围的for循环，它简化了一种常见的循环任务：对数组或容器类的循环for（int x：arr）和for（int &amp;x：arr），前者不可以改变x的值，后者可以。5.5节详解cin.get（）函数。p152</li></ul><h2 id="循环和文本输入"><a href="#循环和文本输入" class="headerlink" title="循环和文本输入"></a>循环和文本输入</h2><ul><li>cin在获取用户输入的字符时，将忽略空格和换行符，并且，发送给cin的输入会被缓冲，只有在用户按下回车键后，他输入的内容才会被发送给程序，为了读取空格和换行符，可以利用cin.get（char）进行补救，char的函数声明是引用，所以，可以改变char的值。p154</li></ul><h1 id="第六章-分支语句和逻辑运算符"><a href="#第六章-分支语句和逻辑运算符" class="headerlink" title="第六章 分支语句和逻辑运算符"></a>第六章 分支语句和逻辑运算符</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><h2 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a>字符函数库cctype</h2><h2 id="运算符"><a href="#运算符" class="headerlink" title="?:运算符"></a>?:运算符</h2><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><ul><li>p181 ：c++的switch语句中必须是整数表达式，一般为int或char或枚举</li></ul><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><h2 id="读取数字的循环"><a href="#读取数字的循环" class="headerlink" title="读取数字的循环"></a>读取数字的循环</h2><h2 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入/输出"></a>简单文件输入/输出</h2><ul><li>打开已经存在的文件，接受输出时，默认将它的长度截断为零，文件原来的内容会丢失。p194</li><li>函数exit（）的原型是在头文件cstdlib中定义的，在该头文件中，还定义了一个用于操作系统通信的参数值EXIT_FAILURE。p195</li><li>windows系统中的文本文件每行都已回车字符和换行符两个字符结尾，在通常情况下，C++在读取文件时将这两个字符转换为换行符，并在写入文件时执行相反的转换。有些文本编辑器不会自动在文件的最后一行加上换行符，因此，需要手动按下回车键再保存文件。p196</li></ul><h1 id="第七章-函数——C-的编程模块"><a href="#第七章-函数——C-的编程模块" class="headerlink" title="第七章 函数——C++的编程模块"></a>第七章 函数——C++的编程模块</h1><h2 id="复习函数的基本知识"><a href="#复习函数的基本知识" class="headerlink" title="复习函数的基本知识"></a>复习函数的基本知识</h2><ul><li>在C++中不能将数组作为函数返回值 （但是可以将数组作为结构或这对象的组成部分返回）。p204</li><li>函数定义必须提供标识符，而函数原型不要求，有类型列表就足够了：void cheers（int），通常，在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。但是，好的变量名可以帮助理解程序功能，所以一般建议加上。p206</li><li>C++与接受可变参数的C函数交互时可能用到：void say（…）的形式。p206</li><li>通常，函数原型会自动将被传递的参数强制转换为期望的类型。（但函数重载可以导致二义性，因此不允许某些自动强制类型转换）</li></ul><h2 id="函数参数和按值传递"><a href="#函数参数和按值传递" class="headerlink" title="函数参数和按值传递"></a>函数参数和按值传递</h2><ul><li>C++通常按值传递参数，这会让函数在自身的作用域内保持实参的副本，这种方式在一定程度上可以确保数据的完整性和安全性。</li></ul><h2 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h2><ul><li>在C++中，当且仅当用于函数头或函数原型中，int *arr和int arr[]的含义才是相同的。在其他的环境下，二者的含义并不同，前者代表指向int类型的指针，后者代表数组名。p213</li><li><p>以下程序说明了数组函数一些有趣的地方，首先，cookies和arr指向同一个地址，但sizeof cookies的值是32，而sizeof arr的值是4。sizeof cookies是整个数组的长度，sizeof arr只是指针变量的长度。这也是必须显示传递数组长度，而不能在函数中使用sizeof arr的原因，因为指针本身并没有指出数组的长度。p215</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int cookies[size]=&#123;1,2,3,4,5,6,7,8&#125;;</span><br><span class="line">int *arr = cookies</span><br></pre></td></tr></table></figure></li><li><p>由为防止函数中无意中修改数组的内容，可以在声明形参的时候使用关键字const，但应注意，这并不是意味着原始数组必须是常量而只意味着不能在函数中修改数组中的值。（对于普通变量来说，由于C++默认按值传递的特性，这种保护会自动实现）p217</p></li><li><strong>使用数组区间（range）的函数</strong> ：对于处理数组的函数，必须将数组的数据种类、起始位置和元素个数传递给它，传统的方法是传递数组名和数组个数n。另一种方法是传递两个指针，分别标识数组的开头和结尾，即数组区间。STL方法使用“超尾”的概念来指定区间，即end指针的是最后一个元素后面的指针。p220</li><li><strong>指针和const：</strong><ul><li>情况1，pt指向一个const int，因此不能使用pt来修改这个值，但是这并不意味着age是一个常量，而只是说对于pt来说这是一个常量，我们依然可以直接通过age来修改age的值，但不能通过pt来修改它。同时，我们可以修改pt的值，即pt可以重新指向另一个地址。</li><li>情况2，finger只能指向age，但是允许使用<em>finger来修改age。简而言之，finger和</em>ps都是const，而*finger和ps不是。</li><li>情况3，stick只能指向age，并且不能通过stick修改age的值。p221<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age=30；</span><br><span class="line">const int *pt=&amp;age；</span><br><span class="line">int *const finger=&amp;age;</span><br><span class="line">const int * const stick=&amp;age；</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="函数和二维数组"><a href="#函数和二维数组" class="headerlink" title="函数和二维数组"></a>函数和二维数组</h2><ul><li>数组作参数的函数，必须牢记，数组名被视为地址，因此，相应的形参是一个指针，正确的函数原型如下所示，二者含义完全相同，后者可读性更强。注意，前者的括号是必不可少的，式子3代表的是指针数组，而不是指向二维数组的指针。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum (int (*arr)[4])</span><br><span class="line">int sum (int arr[][4])</span><br><span class="line">int *arr[4]</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数和C-风格字符串"><a href="#函数和C-风格字符串" class="headerlink" title="函数和C-风格字符串"></a>函数和C-风格字符串</h2><ul><li>C-风格字符串与常规char数组之间的区别：字符串有内置的结束字符’\0’。p225</li><li>空字符’\0’值等于0，因此可以直接用于while（）里的循环判定。p227</li><li>函数无法返回一个字符串，但是可以返回字符串的地址。p227</li></ul><h2 id="函数和结构"><a href="#函数和结构" class="headerlink" title="函数和结构"></a>函数和结构</h2><ul><li>在涉及到函数时，结构变量的行为更接近与基本的单值变量，默认情况下是按值传递的，函数将使用原始结构的副本。当结构非常大时，这会增加内存要求，因此更推荐使用指针来传递结构体。指针传递时使用间接成员运算符’-&gt;’访问，值传递时使用成员运算符’.’访问。p228</li><li>当程序在输入循环以后还需要进行输入时，可以使用 <code>cin.clear()</code> 重置输入。p233</li></ul><h2 id="函数和string对象"><a href="#函数和string对象" class="headerlink" title="函数和string对象"></a>函数和string对象</h2><ul><li>虽然C-风格字符串和string对象的用途几乎相同，但与char数组相比，string对象更像是一个单一变量，可以将string直接复制，也可以直接在函数中传递。</li></ul><h2 id="函数和array对象"><a href="#函数和array对象" class="headerlink" title="函数和array对象"></a>函数和array对象</h2><ul><li>在C++中，类对象是基于结构的，因此结构变成方面的考虑因素也适用于类，所以可以按值将对象传递给函数。p236</li><li>array模板并非只能存储基本类型数据，它还可以存储类对象。p237</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>C++函数允许自己调用自己（然而，与C语言不同，C++不允许main()调用自己）</li></ul><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li>与数据项类似，函数也有地址，函数名即为函数的地址，它是存储其机器语言代码的内存的开始地址。p241</li><li>使用场景：要在当前函数中使用不同的算法来实现灵活的功能，可以将算法的函数地址作为参数进行传递，这就是函数指针。p241</li><li><p>注意以下代码的区别。p242</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int think ();</span><br><span class="line">process(think);  //传递了函数的地址，process函数能够在其内部调用think函数</span><br><span class="line">thought(think()); //传递了函数的返回值</span><br></pre></td></tr></table></figure></li><li><p>声明函数指针，最简单的方法就是，先写出该函数的原型，然后用<code>(*pf)</code>替换函数名即可，如下所示,pf即为函数指针。注意，括号的优先级比星号高，所以这里括号不可少。p242</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double pam(int,double);</span><br><span class="line">double (*pf)(int,double); //pf是一个指针，指向doubel （int，double）类型的函数</span><br><span class="line">double *pf(int,double); //pf是一个函数，返回double *类型的数据</span><br><span class="line">pf = pam; //正确声明函数指针后，便可以将相应的函数赋给它</span><br></pre></td></tr></table></figure></li><li><p>在使用函数指针时，下面两种方法等价！这很神奇！前者的好处是强调当前正在使用函数指针，后者的好处是使用起来很方便。至于为什么会这样，主要是因为有两种流派的声音，C++对这两种流派进行了折衷，认为二者都正确。p243</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double pam(int);</span><br><span class="line">double (*pf)(int);</span><br><span class="line">pf = pam;</span><br><span class="line">double y;</span><br><span class="line">y = pam(5);</span><br><span class="line">//下面两种方法等价</span><br><span class="line">y = (*pf)(5);</span><br><span class="line">y = pf(5);</span><br></pre></td></tr></table></figure></li><li><p>C++11的自动类型推断功能在函数指针声明并初始化时十分方便，以下两种声明初始化方式等价。p245</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const double *f1(const double ar[], int n);</span><br><span class="line">const bouble *(*pf)(const double ar[], int n) = f1;</span><br><span class="line">auto pf = f1;</span><br></pre></td></tr></table></figure></li><li><p>函数指针数组,[]的优先级高级星号，所以先指明了这是一个包含3个元素的数组，声明的其他部分指出了元素的类型。所以pa是一个包含三个指针的数组，每个指针都指向一个函数，该函数返回指向double类型的指针。p245</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const double *(*pa[3])(const double *,int) = &#123;f1,f2,f3&#125;;</span><br><span class="line">auto pb = &#123;f1,f2,f3&#125; //非法！ auto只能用于单值初始化，不能用于初始化列表。</span><br><span class="line">auto pb=pa  //但可以利用声明好的pa数组，来声明同样类型的数组。</span><br><span class="line"></span><br><span class="line">//使用时，想使用数组一样即可</span><br><span class="line">const double *px = pa[0](av,3);</span><br><span class="line">const double *py = (*pb[0])(av,3); //前面的括号必不可少</span><br></pre></td></tr></table></figure></li><li><p>下面的声明，表示pd首先是一个指针，它指向一个包含三个元素的数组，数组中的元素是函数指针。这里pd其实就是指向pa的地址，pa是上面声明的函数指针数组的名字，也就是函数指针数组的首地址。p245</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const double* (*(*pd)[3])(const double*,int) = &amp;pa;</span><br><span class="line">//调用方法，用``(*pd)``代替``pa``即可</span><br><span class="line">(*pd)[i](av,3);  //返回指针</span><br><span class="line">(*(*pd)[i])(av,3);  //与上面等价， 返回指针</span><br><span class="line">*(*pd)[i](av,3); //注意如果不带括号，先返回指针，然和用星号得到指针指向的值</span><br><span class="line">*(*(*pd)[i])(av,3) //与上一条等价，先返回指针，然和用星号得到指针指向的值</span><br></pre></td></tr></table></figure></li><li><p>函数指针的声明有时候会很长，此时可使用auto（C++11）或typedef来对代码进行简化，方便编程。p248</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//下面两条语句等价，前者使用方便，缺点就是无法直观看出pc的类型，后续程序可能会不小心产生类型赋值错误</span><br><span class="line">auto pc = &amp;pa;</span><br><span class="line">const double* (*(*pd)[3])(const double*,int) = &amp;pa;</span><br><span class="line"></span><br><span class="line">// 可以用typedef简化声明</span><br><span class="line">typedef double real; //正常声明变量，前面加上typedef，即可用后者代替前者</span><br><span class="line"></span><br><span class="line">typedef const double* (*p_fun)(const double*, int);</span><br><span class="line">p_fun pa[3] = &#123;f1,f2,f3&#125;;</span><br><span class="line">p_fun (*pa)[3] = &amp;pa;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第八章-函数探幽"><a href="#第八章-函数探幽" class="headerlink" title="第八章 函数探幽"></a>第八章 函数探幽</h1><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><ul><li>常规函数与内敛函数之间的主要区别在于C++编译器如何将它们组合到程序中。<ul><li>传统函数在被调用后，会立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到函数起点的内存单元，然后执行函数的机器代码，之后再跳回到地址被保存的指令处。 <strong>来回跳跃并记录跳跃位置需要一定的开销</strong>。p253</li><li>内联函数的编译代码与其他程序的代码“内联”起来了，即编译器会使用相应的函数代码来替换函数调用（这就省去了来回跳跃的时间开销和内存开销）。 内联函数无需跳跃时间，因此加快了运行速度，但同时增加了存储内联函数的内存开销，如果程序在10个不同的地方调用同一个内联函数，就需要存储10个副本。</li></ul></li><li>当函数的代码执行时间很短（函数很小），则内联调用可以省去调用时间。但是由于这个过程相当快，因此尽管接伸了该调用过程的大部分时间，但节省的时间绝对值并不大，除非该函数被经常调用。p253</li><li><p>使用内联时，在函数声明或定义前加上关键字<code>inline</code>。通常的做法是省略原型，将整个定义放在原型处，并加上内联关键字。p254</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline double square(double x) &#123; return x*x&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>inline</code>工具是C++新增的特性，原始的C语言使用<code>#define</code>来实现内联（文本替换）p255</p></li></ul><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><ul><li>引用变量，是 <strong>已定义的变量的别名</strong> ，他的主要作用是用作函数的形参，如此一来，函数将使用原始数据，而不是其副本。</li><li><code>&amp;</code>符号在变量前（右值）是代表“取地址”，在类型附近时（左值）代表“引用”</li><li><p>引用和指针的区别（引用看上去很像伪装的指针 “&amp;rodents=prats”）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int rats = 101;</span><br><span class="line">int &amp; rodents = rats; //rodents是rats的别名，二者指向同一块内存地址</span><br><span class="line">int * prats = &amp;rats;  //prats指向rats的内存地址</span><br></pre></td></tr></table></figure><ul><li><strong>引用在声明的同时必须进行初始化（做函数参数时，在函数调用时使用实参初始化），而不能像指针那样，先声明，在赋值</strong> 。引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。p256<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int rats = 101;</span><br><span class="line">int &amp; rodents = rats;</span><br><span class="line">int * const pr = &amp;rats; //上式是该式的伪装表示</span><br><span class="line">int bunnies = 50;</span><br><span class="line">rodents = bunnies; //试图将rodents变成bunnies的别名</span><br><span class="line">cout&lt;&lt;rodents&lt;&lt;endl; //输出50,和rodents值一样</span><br><span class="line">count&lt;&lt;rats&lt;&lt;endl;  //但同时rats的值也变成了50</span><br><span class="line">cout&lt;&lt;&amp;rodents&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;bunnies&lt;&lt;endl; //二者的内存地址并不相同</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>const double &amp;ra</code>用作函数参数时，在函数内不能修改ra的值（会报错），这在行为上与按值传递类似，但是当ra内存占用比较大时（结构或对象），就会很省内存（按值传递会生成副本，内存消耗大）。p261</p></li><li><p>对于基本类型，使用按值传递兼容性更好，因为按值传递可以自动强制类型转换，而const引用的限制更严格，因为它是别名，所以不能将表达式赋给引用。p261</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//现代C++中会报错，但早期C++只会警告，会创建一个临时变量，并将其初始化为x+3.0的值</span><br><span class="line">double &amp; ra = x + 1.0;</span><br></pre></td></tr></table></figure></li><li><p><strong>临时变量、引用参数和const：</strong> 当前，如果实参与引用参数不匹配，仅当引用参数为const引用时，C++将生成临时变量。创建临时变量的两种情况：p262</p><ul><li>实参的类型正确，但不是左值。（字面常量，表达式）</li><li>实参的类型不正确，但可以转换为正确的类型。（int转double）</li></ul></li><li>左值：左值参数是可以被引用的数据对象，例如，变量、数组元素、结构成员、引用和接触引用的指针都是左值。 非左值：字面常量（用引号扩起的字符串除外，它们由其地址表示）和包含多项的表达式。 （C语言中，左值最初指的是可出现在赋值语句左边的实体，引入const关键字后，const变量，虽然一般不出现在左边，但是可以通过地址访问它们）</li><li><strong>非const引用无法生成临时变量</strong>，这是因为如果接受引用参数的函数的意图是修改作为参数传递的变量，临时变量将无法实现修改，所以现在的C++标准禁止创建临时变量（老的编译器只会发出警告”Warning: Temporary used for parameter ‘ra’ in call to refcube(double &amp;)”，遇到这种警告，一定要排除）。p263</li><li><strong>将引用参数声明为const引用的理由有三个：</strong> p263<ul><li>使用const可以避免无意中修改数据的变成错误;</li><li>使用const使函数能够处理cnost和非const实参，否则只能接受非const数据;</li><li>使用const引用能使函数能够正确生成并使用临时变量。</li></ul></li><li><p>C++11新增了另一种引用—— <strong>右值引用（rvalue reference）</strong> 。这种引用可指向右值，是使用&amp;&amp;声明的。新增右值引用的主要目的是，让库设计人员能够提供有些操作的更有效实现，实例见18章。&amp;声明的叫左值引用。：p263</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double &amp;&amp; rref = std::sqrt(36.00); // not allowed for double &amp;</span><br><span class="line">double j = 15.0;</span><br><span class="line">double &amp;&amp; jref = 2.0*j + 15.6;  //not allowed for double &amp;</span><br></pre></td></tr></table></figure></li><li><p><strong>返回引用与传统返回机制的区别：</strong> 传统返回机制是按值传递函数参数类似，计算关键字return后面的表达式，并将结果返回给调用参数。而返回引用是返回return后面的变量的别名，并不会生成新的副本。p267</p></li><li><p><strong>返回引用需要注意的问题：</strong> 最重要的是要避免返回函数终止时不再存在的内存单元的引用。（同样，也应避免返回指向临时变量的指针）。如下面的情况：p267</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const double &amp; clone(double &amp; dref)&#123;</span><br><span class="line">  double newguy;</span><br><span class="line">  newguy = dref;</span><br><span class="line">  return newguy; //返回newguy的引用，但是newguy在函数结束时会释放内存,会报错</span><br><span class="line">  return dref; //返回dref的引用，可行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前者可以编译，后者不可以。因为前者是指针，指向x，而后者是变量，是独立于x的副本。指针和副本都会在函数结束时释放，但是x并不会释放。p268</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int &amp; clone(int &amp; x)&#123;  //可以编译</span><br><span class="line">    int *y = &amp;x;</span><br><span class="line">    return *y;</span><br><span class="line">&#125;</span><br><span class="line">const int &amp; clone(int &amp; x)&#123;  //不可以编译</span><br><span class="line">    int y = x;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>将C-风格字符串用作string对象引用参数</strong>，形参类型为<code>const string &amp;</code>时，实参类型可以为<code>char*, const char*, string</code>等（<code>“abc”</code>类型为<code>const char*</code>）。原因如下：p270</p><ul><li>string类定义了一种<code>char*</code>到<code>string</code>的转换功能，这使得可以使用C-风格字符串来初始化string对象</li><li>const引用形参具有创建临时变量的属性。因此，当类型不符合时，会创建临时变量</li></ul></li><li><strong>对象、继承和引用：</strong> 除了可以使用父类的方法外，继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。这种特征的实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为实参，也可以将派生类对象作为实参。p271</li><li><strong>使用引用参数两个主要原因：</strong> p274<ul><li>程序员能够修改调用函数中的数据对象;</li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</li></ul></li><li><strong>指导原则：</strong> p274<ul><li>对于使用传递的值而不作修改的函数<ul><li>如果数据对象很小，如内置数据类型或小型结构，则按值传递;</li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针;</li><li>如果数据对象是较大的结构，则是用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间;</li><li>如果数据对象是类对象，则是用const引用。传递类对象参数的标准方式是按引用传递。</li></ul></li><li>对于修改调用函数中的数据的函数<ul><li>如果数据对象是内置数据类型，则是用指针;</li><li>如果数据对象是数组，则只能使用指针;</li><li>如果数据对象是结构，则使用引用或指针;</li><li>如果数据对象是类，则使用引用。</li></ul></li></ul></li></ul><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><ul><li><p>对于带参数列表的函数，必须从右向左添加默认值。（即带默认值的参数的右边所有参数都要有默认值）。p275</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int harpo(int n, int m=4, int j=5); //valid</span><br><span class="line">int chico(int n, int m=6, int j); //invalid</span><br></pre></td></tr></table></figure></li><li><p>实参按从左到右的顺序一次被赋给相应的形参，而不能跳过任何参数。（这点与python不同） p275</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beeps = harpo(2);  //same as harpo(2,4,5)</span><br><span class="line">beeps = harpo(1,8);  //same as harpo(1,8,5)</span><br><span class="line">beeps = harpo(3, ,8); /invalid</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><ul><li>“多态”指的是函数有多种形式，“重载”指的是可以有多个同名的函数。<strong>二者指的是一回事</strong> 。p276</li><li>函数重载的关键是函数的参数列表——函数特征标（function signature）。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而 <strong>参数变量名是无关紧要的</strong> 。p277</li><li><p>编译器在检查函数特征标时，将把 <strong>类型引用和类型本身视为同一个特征标</strong> 。如以下两个看起来不同的特征标是不能共存的(它们都接受同一个参数x，会使得程序具有二义性)：p277</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double cube(double x);</span><br><span class="line">double cube(double &amp;x);</span><br></pre></td></tr></table></figure></li><li><p>函数重载只看特征标是否相同，不关心函数返回类型。p278</p></li><li><p>当传入参数类型可以被强制转换时，将调用最匹配的版本：p278</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void staff(double &amp; rs); // matches modifiable lvalue</span><br><span class="line">void staff(const double &amp; rcs); //matches rvalue, const lvalue</span><br><span class="line"></span><br><span class="line">void stove(double &amp; r1); // matches modifiable lvalue</span><br><span class="line">void stove(const double &amp; r2); //matches const lvalue</span><br><span class="line">void stove(double &amp;&amp; r3); //matches rvalue</span><br></pre></td></tr></table></figure></li><li><p><strong>名称修饰：</strong> C++通过名称修饰（name decoration）或名称矫正（name mangling）来区分重载函数，它会根据函数原型中指定的形参类型对每个函数名进行加密。p289</p></li></ul><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul><li><p>函数模板是通用的函数描述，它们使用泛型来定义函数。模板并不创建任何函数，而只是告诉编译器如何定义函数。在标准C++98添加关键字typename之前，C++使用关键字class来创建模板。p281</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//如果需要多个将同一种算法用于不同类型的函数，可以使用模板</span><br><span class="line">template &lt;typename AnyType&gt;  //注意没有分号;</span><br><span class="line">void Swap(AnyType &amp;a, AnyType &amp;b)&#123; //可以交换多种类型</span><br><span class="line">  AnyType temp;</span><br><span class="line">  temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数模板不能缩短可执行程序。对于以不同类型多次调用模板的程序来说，最终仍然会生成多个独立的函数定义，就像以手工方式定义一样。 <strong>最终的代码不包含任何模板，而只包含了为程序生成的实际函数</strong>。p283</p></li><li><p><strong>重载的模板：</strong> 被重载的模板的函数特征标必须不同：p283</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b);</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Swap(T *a, T *b, int n);</span><br></pre></td></tr></table></figure></li><li><p><strong>显式具体化：</strong> （具体机制随着C++的演变而不断变化，下面是ISO/ANSI C++标准）p286</p><ul><li>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。</li><li>显式具体化的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型。</li><li>具体化优先于常规模板，而非模板函数优先于具体化和常规模板。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct job&#123;...&#125;;</span><br><span class="line">void Swap(job &amp;, job &amp;); //非模板函数</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;, T &amp;); //模板函数</span><br><span class="line">template &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;); //显式具体化</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>实例化和具体化：</strong> 在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例（instantiation）。也就是说，模板并非函数定义，模板实例才是函数定义。p288</p></li><li><p><strong>隐式实例化和显式实例化：</strong> p288</p><ul><li>隐式(implicit)：通过函数调用导致编译器生成模板实例（大多数情况下都是隐式）</li><li>显示(explicit)：直接命令编译器创建特定的实例，方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template void Swap&lt;int&gt;(int, int); //explicit instantiation</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>显式实例化和显式具体化的区别：</strong> p288</p><ul><li><p>显式实例化：使用<code>Swap()</code>模板来生成int类型的函数定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template void Swap&lt;int&gt;(int, int); //explicit instantiation</span><br></pre></td></tr></table></figure></li><li><p>显式具体化(explicit specialization)：不要使用<code>Swap()</code>模板来生成函数定义，而应使用专门为int类型显式定义的函数定义。这些原型必须有自己的函数定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt; void Swap&lt;int&gt;(int &amp;, int &amp;);</span><br><span class="line">template &lt;&gt; void Swap(int &amp;, int &amp;); //这两句声明等价，任选其一</span><br></pre></td></tr></table></figure></li><li><p><strong>警告：</strong> 试图在同一个文件（或转换单元）中使用同一种类型的显式实例化和显式具体化将出错。</p></li></ul></li><li><strong>隐式实例化、显式实例化和显式具体化统称为具体化（specialization）。</strong> 它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。p289</li><li><strong>重载解析（overloading resolution）：</strong> 对于函数重载、函数模板和函数模板重载，C++需要（且有）一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时。该策略大概过程如下：p289<ul><li>第一步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。</li><li>第二步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。</li><li>第三步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。</li></ul></li><li><strong>匹配顺序：</strong> p290<ul><li>完全匹配，但常规函数优先于模板。</li><li>提升转换（如，char和shorts自动转换为int，float自动转换为double）。</li><li>标准转换（如，int转换为char，long转换为double）。</li><li>用户自定义的转换（如，类声明中定义的转换）。</li></ul></li><li><p><strong>完全匹配与最佳匹配</strong> 完全匹配不等于最佳匹配，通常，有两个函数完全匹配是一种错误，但这一规则有两个例外。即有时候，即使两个函数都完全匹配，仍可完成重载解析。p290</p><ul><li><p>指向非const数据的指针和引用，优先与非const指针和引用参数匹配。 下面两个式子都是完全匹配，但程序会选择前者，而不是报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void recycle(blot &amp;);  //#1</span><br><span class="line">void recycle(const blot &amp;);  //#2</span><br><span class="line"></span><br><span class="line">struct blot &#123;int a; char b[10];&#125;;</span><br><span class="line">blot ink = &#123;25,&quot;spots&quot;&#125;;</span><br><span class="line">recycle(ink);  //选择#1，因为ink没有被声明为const</span><br><span class="line"></span><br><span class="line">//然而，const和非const之间的区别只适用于指针和引用指向的数据</span><br><span class="line">//即，如果是如下定义，则将出现二义性错误</span><br><span class="line">void recycle(blot);</span><br><span class="line">void recycle(const blot);</span><br></pre></td></tr></table></figure></li><li><p>两个完全匹配的函数，一个是非模板函数，另一个不是。此时，非模板函数将优先于模板函数（包括显式具体化）。如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。 C++98新增的特性—— <strong>部分排序规则（partial ordering rules）</strong> 可以找出最具体的模板。</p></li></ul></li><li><strong>8.5小节涵盖的知识点很多，并且由于篇幅原因，没有详细展开，需要多看。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《深度学习》</title>
      <link href="/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Book-%E8%8A%B1%E4%B9%A6/"/>
      <url>/z_post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Book-%E8%8A%B1%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h1 id="第二章-线性代数"><a href="#第二章-线性代数" class="headerlink" title="第二章 线性代数"></a>第二章 线性代数</h1><h2 id="2-1-标量-向量-矩阵和张量"><a href="#2-1-标量-向量-矩阵和张量" class="headerlink" title="2.1 标量, 向量, 矩阵和张量"></a>2.1 标量, 向量, 矩阵和张量</h2><ul><li>标量(scalar): 一个单独的数字</li><li>向量(vector): 一般默认是列向量, 为一列数字</li><li>矩阵(matrix): 多个列向量组成, 可看做是二维数组</li><li>张量(tensor): 超过两维的数组</li></ul><h2 id="2-2-矩阵和向量相乘"><a href="#2-2-矩阵和向量相乘" class="headerlink" title="2.2 矩阵和向量相乘"></a>2.2 矩阵和向量相乘</h2><h2 id="2-3-单位矩阵和逆矩阵"><a href="#2-3-单位矩阵和逆矩阵" class="headerlink" title="2.3 单位矩阵和逆矩阵"></a>2.3 单位矩阵和逆矩阵</h2><h2 id="2-4-线性相关性和生成子空间"><a href="#2-4-线性相关性和生成子空间" class="headerlink" title="2.4 线性相关性和生成子空间"></a>2.4 线性相关性和生成子空间</h2><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>计算机视觉面试总结</title>
      <link href="/z_post/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/z_post/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="在Faster-RCNN中-如果两个物体重合度很高-会怎么样"><a href="#在Faster-RCNN中-如果两个物体重合度很高-会怎么样" class="headerlink" title="在Faster RCNN中, 如果两个物体重合度很高, 会怎么样"></a>在Faster RCNN中, 如果两个物体重合度很高, 会怎么样</h1><h1 id="卷积神经网络复杂度分析"><a href="#卷积神经网络复杂度分析" class="headerlink" title="卷积神经网络复杂度分析"></a>卷积神经网络复杂度分析</h1><p><a href="../深度学习-卷积神经网络复杂度分析">卷积神经网络复杂度分析</a></p><h1 id="卷积计算-卷积层特参数个数及征图谱尺寸计算"><a href="#卷积计算-卷积层特参数个数及征图谱尺寸计算" class="headerlink" title="卷积计算,卷积层特参数个数及征图谱尺寸计算"></a>卷积计算,卷积层特参数个数及征图谱尺寸计算</h1><p>卷积层输入图谱大小为 $D_in \times D_{in} \times depth_{in}$ , 卷积核尺寸为 $F \times F \times depth_{in}$, 步长为 $stride$ ,结合padding,输出的图谱size是多少</p><script type="math/tex; mode=display">D_{out} = \frac{D_{in} - F + 2*Padding}{stride} + 1</script><p>输出的特征图谱的深度为卷积核的个数: $depth_{out} = Num_{filters}$</p><p>本层的偏置参数数量: $Num_{bias} = Num_{filters}$, 注意只与卷积核的个数有关, 与输入的特征图谱的深度无关</p><p>该层的参数个数 = 卷积核参数个数 + 偏置项参数个数:</p><script type="math/tex; mode=display">Num_{params} = F \times F \times depth_{in} \times depth_{out} + Num_{bias}</script><h1 id="L2正则化和L2规范化-归一化-的不同"><a href="#L2正则化和L2规范化-归一化-的不同" class="headerlink" title="L2正则化和L2规范化(归一化)的不同"></a>L2正则化和L2规范化(归一化)的不同</h1><p>正则化是指正则项, 计算完以后是一个矢量. 归一化是将向量中每个元素进行归一化, 计算完以后还是同size的向量, L2归一化实际上就是对每一个元素除以L2正则项.</p><h1 id="从-rcnn-到-faster"><a href="#从-rcnn-到-faster" class="headerlink" title="从 rcnn 到 faster"></a>从 rcnn 到 faster</h1><p><a href="https://blog.csdn.net/xiaoye5606/article/details/71191429" target="_blank" rel="noopener">https://blog.csdn.net/xiaoye5606/article/details/71191429</a></p><h1 id="为什么fast-rcnn的roi-pooling比spp的-spatial-pooling效果好"><a href="#为什么fast-rcnn的roi-pooling比spp的-spatial-pooling效果好" class="headerlink" title="为什么fast rcnn的roi pooling比spp的 spatial pooling效果好???"></a>为什么fast rcnn的roi pooling比spp的 spatial pooling效果好???</h1><h1 id="神经网络参数初始化"><a href="#神经网络参数初始化" class="headerlink" title="神经网络参数初始化"></a>神经网络参数初始化</h1><h1 id="分类问题为什么用交叉熵"><a href="#分类问题为什么用交叉熵" class="headerlink" title="分类问题为什么用交叉熵"></a>分类问题为什么用交叉熵</h1><p><strong>典型错误答案1:</strong> 如果用交叉熵，能保证神经网络训练时是一个凸优化问题</p><p>错误原因: 凸函数的复合并不一定是凸函数</p><p><strong>典型错误答案2:</strong> 如果当前值与目标值相差很远，则梯度下降法迭代时收敛的更快一些</p><p>错误原因: 欧式距离(平方损失)也能起到这个作用, 为什么不用?</p><p><strong>正确答案:</strong></p><p>Cross-Entropy vs. Squared Error Training: a Theoretical and Experimental Comparison.</p><h1 id="Relu和Dropout都具有正则化作用-它们在正则化方面的区别是什么"><a href="#Relu和Dropout都具有正则化作用-它们在正则化方面的区别是什么" class="headerlink" title="Relu和Dropout都具有正则化作用, 它们在正则化方面的区别是什么?"></a>Relu和Dropout都具有正则化作用, 它们在正则化方面的区别是什么?</h1><p>Relu是强制正则化(所有神经元的输出值, 只要小于0, 就置为0)</p><p>Dropout是随机正则化(随机让一些神经元的不起作用)</p><h1 id="介绍一下-hard-negative-mining-难样例挖掘"><a href="#介绍一下-hard-negative-mining-难样例挖掘" class="headerlink" title="介绍一下 hard negative mining(难样例挖掘)"></a>介绍一下 hard negative mining(难样例挖掘)</h1><h1 id="dropout内部是怎么实现的"><a href="#dropout内部是怎么实现的" class="headerlink" title="dropout内部是怎么实现的"></a>dropout内部是怎么实现的</h1><p>在 <strong>训练阶段</strong> 给每个神经元的参数都会乘以 $\frac{1}{\alpha_{dropout}}$, 这样一来, 在训练阶段可以随时更改dropout的参数值, 而对于测试阶段来说, 无需对神经元进行任何额外处理, 所有的神经元都相当于适配了训练过程中dropout对参数带来的影响.</p><h1 id="简述一下BN"><a href="#简述一下BN" class="headerlink" title="简述一下BN"></a>简述一下BN</h1><p>首先标准化就是将数据归一到一个希望的区间内, 一般都是归一化到激活函数敏感区域内, 而BN和传统标准标准化的区别主要有两点:</p><ul><li>BN是在每一个batch上做标准化的, 并且不仅仅只对输入层数据做标准化, 对网络内部的隐藏层输入也会进行标准话</li><li>第二就是BN并不是在标准的减均值初标准差之后, 还会进行一个线性变换,<strong>其本质就是改变数据分布的方差和均值</strong>. 对应的两个参数是通过学习学出来的. 其主要思想是考虑到数据可能本身就具有一定的不对称性, 并且激活函数也不一定就在面对标准数据时才有最好的表现, 因此</li></ul><p>关于BN的详细解析可以看:<br><img src="Batch-Normalization深入解析" alt=""></p><h1 id="各种初始化方式，及公式各个参数对训练的影响"><a href="#各种初始化方式，及公式各个参数对训练的影响" class="headerlink" title="各种初始化方式，及公式各个参数对训练的影响"></a>各种初始化方式，及公式各个参数对训练的影响</h1><h1 id="目标检测，数据不平衡问题怎么解决"><a href="#目标检测，数据不平衡问题怎么解决" class="headerlink" title="目标检测，数据不平衡问题怎么解决"></a>目标检测，数据不平衡问题怎么解决</h1><p>对于目标物的不平衡问题, 通过采样方法来缓解.</p><p>对于前后景样本数的不平衡问题, 尝试使用FocalLoss来解决</p><script type="math/tex; mode=display">L = -(1-p_t)^\gamma log(p_t)</script><h1 id="你的zerotensor和TF比性能上有优势吗"><a href="#你的zerotensor和TF比性能上有优势吗" class="headerlink" title="你的zerotensor和TF比性能上有优势吗"></a>你的zerotensor和TF比性能上有优势吗</h1><h1 id="常用的数据增强技术"><a href="#常用的数据增强技术" class="headerlink" title="常用的数据增强技术"></a>常用的数据增强技术</h1><p>水平或垂直翻转图像、裁剪、色彩变换、扩展和旋转</p><h1 id="有哪些可以避免过拟合的办法"><a href="#有哪些可以避免过拟合的办法" class="headerlink" title="有哪些可以避免过拟合的办法"></a>有哪些可以避免过拟合的办法</h1><p>数据增强, 正则化, 模型融合(其中dropout是模型融合方法中最高效和常用的技巧)</p><p>为了防止过拟合，增加训练样本是一个好的解决方案。此外，还可使用数据增强、L1 正则化、L2 正则化、Dropout、DropConnect 和早停（Early stopping）法等</p><h1 id="正则化L1和L2的区别"><a href="#正则化L1和L2的区别" class="headerlink" title="正则化L1和L2的区别"></a>正则化L1和L2的区别</h1><h2 id="rcnn。。"><a href="#rcnn。。" class="headerlink" title="rcnn。。"></a>rcnn。。</h2><h1 id="推导svm"><a href="#推导svm" class="headerlink" title="推导svm"></a>推导svm</h1><h1 id="卷积层的参数个数计算公式是："><a href="#卷积层的参数个数计算公式是：" class="headerlink" title="卷积层的参数个数计算公式是："></a>卷积层的参数个数计算公式是：</h1><p>输入的filers×kernerl size ×输出的filters。如：</p><p>（3×3×256）×512   括号前面是每一个卷积核的大小，后面的是总共有512个卷积核</p><h1 id="梯度消失和梯度爆炸的概念，引用这两个现象的原因及其解决办法"><a href="#梯度消失和梯度爆炸的概念，引用这两个现象的原因及其解决办法" class="headerlink" title="梯度消失和梯度爆炸的概念，引用这两个现象的原因及其解决办法"></a>梯度消失和梯度爆炸的概念，引用这两个现象的原因及其解决办法</h1><p>详见<a href="">梯度消失和梯度爆炸问题深入解析</a></p><p><span id="activation"> </span></p><h1 id="关于各种激活函数的解析与讨论"><a href="#关于各种激活函数的解析与讨论" class="headerlink" title="关于各种激活函数的解析与讨论"></a>关于各种激活函数的解析与讨论</h1><h1 id="简述ResNet"><a href="#简述ResNet" class="headerlink" title="简述ResNet"></a>简述ResNet</h1><h1 id="嵌入式开发很底层-一般还是倾向于做一些上层的东西"><a href="#嵌入式开发很底层-一般还是倾向于做一些上层的东西" class="headerlink" title="嵌入式开发很底层   一般还是倾向于做一些上层的东西"></a>嵌入式开发很底层   一般还是倾向于做一些上层的东西</h1><h1 id="推导SVM"><a href="#推导SVM" class="headerlink" title="推导SVM"></a>推导SVM</h1><h1 id="比较Boosting和Bagging的异同"><a href="#比较Boosting和Bagging的异同" class="headerlink" title="比较Boosting和Bagging的异同"></a>比较Boosting和Bagging的异同</h1><p>二者都是集成学习方法, 都是将多个弱学习器组合成强学习器的方法, 它们的区别在于:</p><p>Boosting: 每一轮根据上一轮的分类结果动态调整每个样本在分类器中的权重, 训练得到k个弱分类器, 他们都有各自的权重, 通过加权组合的方式得到最终的分类结果</p><p>Bagging: 从原始数据集中每一轮又放回地抽取训练集(抽取的训练集小于原始数据集), 训练得到k个弱学习器, 然后将这k个软学习器的分类结果结合, 得到最终的分类结果.</p><h1 id="无监督学习中存在过拟合吗"><a href="#无监督学习中存在过拟合吗" class="headerlink" title="无监督学习中存在过拟合吗?"></a>无监督学习中存在过拟合吗?</h1><p>存在.<br>//TODO 补充  什么情况下会产生无监督的过拟合</p><h1 id="什么是K折交叉验证"><a href="#什么是K折交叉验证" class="headerlink" title="什么是K折交叉验证?"></a>什么是K折交叉验证?</h1><p>将原始数据集划分为k个子集, 将其中一个子集作为验证集, 其余k-1个子集作为训练集, 如此训练和验证一轮成为一次交叉验证. 交叉验证重复k此, 每个子集都会做一次验证, 最终得到k个模型, 然后可以对这k个模型的结果加权平均, 以作为评估整体模型的依据</p><h1 id="关于k折交叉验证-需要注意什么"><a href="#关于k折交叉验证-需要注意什么" class="headerlink" title="关于k折交叉验证, 需要注意什么?"></a>关于k折交叉验证, 需要注意什么?</h1><p>k越大, 不一定效果越好, 而且越大的k会加大训练时间;</p><p>在选择k时, 需要考虑最小化数据集之间的方差, 比如对于2分类任务, 如果采用2折交叉验证, 即对原始数据集二分,若此时训练集中都是A类别, 验证集中都是B类别, 则交叉验证效果会非常差</p><h1 id="对于一个二分类问题-我们定义超过阈值t的判定为正例-否则判定为负例-现在若将t增大-则准确率和召回率会如何变化"><a href="#对于一个二分类问题-我们定义超过阈值t的判定为正例-否则判定为负例-现在若将t增大-则准确率和召回率会如何变化" class="headerlink" title="对于一个二分类问题, 我们定义超过阈值t的判定为正例, 否则判定为负例. 现在若将t增大, 则准确率和召回率会如何变化?"></a>对于一个二分类问题, 我们定义超过阈值t的判定为正例, 否则判定为负例. 现在若将t增大, 则准确率和召回率会如何变化?</h1><p>准确率 = TP / (TP + FP), 召回率 = TP / (TP, FN)</p><p>若增大阈值t, 则更多不确定的样本将会被分为负例, 剩余确定样本的所占比例会增大, 那么准确率就会提升(或不变); 同时, 由于那些不确定的样本中还可能包含有正例, 引起, 阈值调大后, 这些正例就会被认为是负例, 所以召回率减小(或不变)</p><h1 id="增加网络层数-是否总能减小训练集错误率"><a href="#增加网络层数-是否总能减小训练集错误率" class="headerlink" title="增加网络层数, 是否总能减小训练集错误率?"></a>增加网络层数, 是否总能减小训练集错误率?</h1><p>不能, 有时候网络层数过深, 还会因为梯度消失导致模型退化, 使得模型性能降低</p><h1 id="在目标检测问题上-如何做数据增广"><a href="#在目标检测问题上-如何做数据增广" class="headerlink" title="在目标检测问题上, 如何做数据增广?"></a>在目标检测问题上, 如何做数据增广?</h1><h1 id="softmax怎么跟交叉熵损失函数结合"><a href="#softmax怎么跟交叉熵损失函数结合" class="headerlink" title="softmax怎么跟交叉熵损失函数结合?"></a>softmax怎么跟交叉熵损失函数结合?</h1><h1 id="用梯度下降训练神经网络的参数-为什么参数有时候会被训练为nan值"><a href="#用梯度下降训练神经网络的参数-为什么参数有时候会被训练为nan值" class="headerlink" title="用梯度下降训练神经网络的参数, 为什么参数有时候会被训练为nan值?"></a>用梯度下降训练神经网络的参数, 为什么参数有时候会被训练为nan值?</h1><p>输入数据本身存在nan值, 或者考虑是否梯度爆炸了(可以试着降低学习率, 或者利用截断法先知梯度的值)</p><h1 id="有没有自己试过更改模型的框架"><a href="#有没有自己试过更改模型的框架" class="headerlink" title="有没有自己试过更改模型的框架."></a>有没有自己试过更改模型的框架.</h1><p>有时候读paper会遇到一些好的点子或者方法, 自己会去加到现有的网络中去验证一下是不是能够提升模型的性能, 一般情况下, 比较经典且认可度较高的一些算法, 由于在网上都能找到相应的源码, 加上去的时候性能往往会有一点提升, 但是有时候有的方法比较偏, 我加完了以后有时候是没作用, 有时候是性能降低了, 我不知道到底是我实现的和paper有出入, 还是这个东西不适合当前框架</p><h1 id="说一下你所有的提高精度的方法-并且说明它们带来了多少的精度提升"><a href="#说一下你所有的提高精度的方法-并且说明它们带来了多少的精度提升" class="headerlink" title="说一下你所有的提高精度的方法, 并且说明它们带来了多少的精度提升!"></a>说一下你所有的提高精度的方法, 并且说明它们带来了多少的精度提升!</h1><p>OHEM ~3%</p><h1 id="SSD已经使用了难样例挖掘的技巧-Focal-Loss-相比之下为什么能够提高"><a href="#SSD已经使用了难样例挖掘的技巧-Focal-Loss-相比之下为什么能够提高" class="headerlink" title="SSD已经使用了难样例挖掘的技巧, Focal Loss 相比之下为什么能够提高"></a>SSD已经使用了难样例挖掘的技巧, Focal Loss 相比之下为什么能够提高</h1><h1 id="池化的优点-优化的缺点"><a href="#池化的优点-优化的缺点" class="headerlink" title="池化的优点, 优化的缺点"></a>池化的优点, 优化的缺点</h1><p>优点:</p><ul><li>显著减少参数数量, 降低过拟合</li><li>池化单元具有平移不变性</li></ul><p>缺点:<br>pooling能够增大感受野, 让后续的卷积看到更多的信息, 但是它在降维的过程中丢失了一些信息, 这对segmentation要求的精确location有一定的影响, 所以pooling层跟segmentation有一定的冲突, 但是感受野的增大有可以特征检测实例的准确率, 还可以降低计算量, 增强泛化能力. 所以这个是实例分割问题需要解决的一个关键点之一.</p><h1 id="待定"><a href="#待定" class="headerlink" title="待定"></a>待定</h1><p><a href="https://blog.csdn.net/comway_Li/article/details/82532573" target="_blank" rel="noopener">https://blog.csdn.net/comway_Li/article/details/82532573</a></p><h1 id="完善bisai待看"><a href="#完善bisai待看" class="headerlink" title="完善bisai待看"></a>完善bisai待看</h1><p><a href="https://www.kaggle.com/c/google-ai-open-images-object-detection-track/discussion/64986" target="_blank" rel="noopener">https://www.kaggle.com/c/google-ai-open-images-object-detection-track/discussion/64986</a></p><p><a href="https://arxiv.org/abs/1809.00778" target="_blank" rel="noopener">https://arxiv.org/abs/1809.00778</a></p><p><a href="https://www.kaggle.com/c/google-ai-open-images-object-detection-track/discussion" target="_blank" rel="noopener">https://www.kaggle.com/c/google-ai-open-images-object-detection-track/discussion</a></p><h1 id="谈谈你参加的比赛"><a href="#谈谈你参加的比赛" class="headerlink" title="谈谈你参加的比赛"></a>谈谈你参加的比赛</h1><p>对于一个比赛任务, 我会首先进行预处理,  之后, 会根据数据集的数据分布来对参数进行调整, 比如, 先只训练顶层, 然后逐步放开, 最后再训练所有层的参数.  在训练的时候,我一般都会采用bagging的思想, 将训练集随机28分, 分成3份, 然后训练, 最后进行模型融合,  融合的时候我一般都是对训练结果进行融合.</p><p>如果是目标检测累任务, 那么就:…</p><p>如果是实力分割类任务, 那么就:</p><h1 id="对于一个新任务-你一般都会使用那些数据预处理方法"><a href="#对于一个新任务-你一般都会使用那些数据预处理方法" class="headerlink" title="(对于一个新任务,) 你一般都会使用那些数据预处理方法"></a>(对于一个新任务,) 你一般都会使用那些数据预处理方法</h1><ol><li>训练数据可视化</li></ol><p>首先, 不论是什么样的数据集, 我都会先随机挑选 20 到 100张 的训练数据, 然后根据标签, 将图片数据可视化出来, 比如说如果是目标检测的任务, 我就会用opencv 的<code>cv2.rectangle()</code> 函数和 <code>cv2.putText()</code> 函数将标签里面的bbox标签和类别标签画到图片上去, 并且建立一个字典结构, 将不同的class-id对应到不同的颜色,  如果是实力分割任务, 我就会将mask标签反应到图片上去, 一般就是先将单通道的mask扩展成多通道的, 同时根据不同的class-id赋予不同的颜色, 最后利用numpy的where方法和原始图片进行叠加.  一般对于这种几十张的smaple图片, 我都是直接保存, 这样以后想再看的时候也不用重新跑脚本了.</p><p>之后, 我就会先简单浏览一下这些数据, 对整个数据集有一个初步的把握, 大概知道哪些物体被标注了, 有时候也能发现很多标注存在问题, 不过这也没有办法,  毕竟标注是一个很费时费力的工作, 错误在所难免.</p><ol><li>计算数据分布信息</li></ol><p>然后我就会写个脚本对整个数据集和标签进行遍历, 统计一些信息, 通常我会检测这么几个信息:</p><p>图像的平均尺寸, 整个数据集的像素平均值, 每张图片平均包含的目标个数, 每个类别的目标个数以及目标的平均大小,</p><p>同时, 因为平均值有时候往往反应不出来太多信息, 所以我还会用matplotlib把每种信息的直方图画出来, 然后看一下数据的整体分布是什么样子的, 比如图片size的分布, 目标大小的分布等等, 我主要就是根据这些分布信息来决定我最开始的参数设置.  主要调的参数就是imagesize,anchors相关的参数, 其他的还有就非极大抑制和置信度的阈值, 有时候还会试一下BN的作用(默认是关闭的)</p><p>然后一般情况下我都会对数据集做增广</p><p>常用的就是裁剪, 反转, 虚化, 颜色变换等等, 增广我不会做太多, 一般就用一些常用的增广方法</p><h1 id="比赛中用到的模型融合方法"><a href="#比赛中用到的模型融合方法" class="headerlink" title="比赛中用到的模型融合方法:"></a>比赛中用到的模型融合方法:</h1><p>对于目标检测任务:</p><p>我用的融合策略就是先以一个结果文件为基准, 然后用另一个结果文件里面的某张图片的框去跟前一个结果文件对应图片的所有框作比较, 因为之间会对框的面积做排序, 所以只与面积相似的框作比较, 看看框的位置是不是也相似, 如果相似, 就认为检测的是同一个物体, 然后就看他们的类别是否相同, 这里我一般会使用三个结果文件(来自于三个不同模型)进行投票选择.</p><p>对于有的框不在另一个文件的,  我就会根据框的置信度来设置一个阈值, 大于阈值的我就直接把框加进去, 如果有票数相同的, 就按置信度来区分.</p><h1 id="你的方法与其他人方法的区别是什么-为什么比别人的方法差"><a href="#你的方法与其他人方法的区别是什么-为什么比别人的方法差" class="headerlink" title="你的方法与其他人方法的区别是什么? 为什么比别人的方法差?"></a>你的方法与其他人方法的区别是什么? 为什么比别人的方法差?</h1><h1 id="对于faster-rcnn-你都调了哪些参数"><a href="#对于faster-rcnn-你都调了哪些参数" class="headerlink" title="对于faster rcnn 你都调了哪些参数?"></a>对于faster rcnn 你都调了哪些参数?</h1><p>首先调的是anchor相关参数, 比如anchor size 和 anchor ratio</p><p>然后是学习率, 前景后景的样本比例, 非极大抑制的阈值, 候选区域块的生成个数, 图片的缩放尺度等等</p><h1 id="BN具体是什么实现的"><a href="#BN具体是什么实现的" class="headerlink" title="BN具体是什么实现的"></a>BN具体是什么实现的</h1><h1 id="对于平均移动了解吗"><a href="#对于平均移动了解吗" class="headerlink" title="对于平均移动了解吗"></a>对于平均移动了解吗</h1><h1 id="积分图-快速求矩阵的核"><a href="#积分图-快速求矩阵的核" class="headerlink" title="积分图, 快速求矩阵的核"></a>积分图, 快速求矩阵的核</h1><h1 id="样本不均衡问题怎么解决"><a href="#样本不均衡问题怎么解决" class="headerlink" title="样本不均衡问题怎么解决"></a>样本不均衡问题怎么解决</h1><h1 id="详细说一下Focal-Loss"><a href="#详细说一下Focal-Loss" class="headerlink" title="详细说一下Focal Loss"></a>详细说一下Focal Loss</h1><h1 id="说一下为什么Faster-比YOLO和SSD更准确"><a href="#说一下为什么Faster-比YOLO和SSD更准确" class="headerlink" title="说一下为什么Faster 比YOLO和SSD更准确"></a>说一下为什么Faster 比YOLO和SSD更准确</h1><h1 id="样本采样的理论化值是"><a href="#样本采样的理论化值是" class="headerlink" title="样本采样的理论化值是"></a>样本采样的理论化值是</h1><h1 id="anchor的参数设值怎么选的？-为什么这么设置"><a href="#anchor的参数设值怎么选的？-为什么这么设置" class="headerlink" title="anchor的参数设值怎么选的？  为什么这么设置"></a>anchor的参数设值怎么选的？  为什么这么设置</h1><h1 id="在调试RPN网络时有没有遇到什么问题？"><a href="#在调试RPN网络时有没有遇到什么问题？" class="headerlink" title="在调试RPN网络时有没有遇到什么问题？"></a>在调试RPN网络时有没有遇到什么问题？</h1><h1 id="简述一下faster-rcnn模型"><a href="#简述一下faster-rcnn模型" class="headerlink" title="简述一下faster rcnn模型"></a>简述一下faster rcnn模型</h1><h1 id="简述一下ResNet模型及它解决的问题"><a href="#简述一下ResNet模型及它解决的问题" class="headerlink" title="简述一下ResNet模型及它解决的问题"></a>简述一下ResNet模型及它解决的问题</h1>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点梳理 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
